<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>语义化版本管理 | Programming Wiki</title>
  <meta name="author" content="cn.printf">
  
  <meta name="description" content="background如果不是在一个非常规范的公司,有时候甚至没有软件发布包版本管理这件事,对于很多语言来说,并没有提供包管理的相关特性,比如PHP,从事PHP多年,但是我们再发布的时候流程并不是非常规范。版本之间的依赖也比较混乱,于是有人提出了语义化版本管理的规范
搬运 http://semver.">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="语义化版本管理"/>
  <meta property="og:site_name" content="Programming Wiki"/>

  
    <meta property="og:image" content="undefined"/>
  

  
    <link rel="alternative" href="/atom.xml" title="Programming Wiki" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/css/sidenav.css" media="screen" type="text/css">  
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  

</head>

<body id="body" data-spy="scroll" data-target=".toc">
  <div class="container" id="container">
	<div class="content">
	  <div class="page-header">		
  <h1><a class="brand" href="/">Programming Wiki</a><span class="split"></span><span class="title">语义化版本管理</span><span class="date" id="title-date"><i class="fa fa-clock-o"></i> 2017-07-28</span></h1>
</div>		

<div class="row page">
  <!-- cols -->	
  
  <div class="col-xs-12 col-sm-3 col-md-3 toc"> 
	<!-- toc -->
<script type="text/javascript">
		jQuery(document).ready(function() {
 		   generateWikiTOC('.note', '.toc',  2 , 2 );
		});
</script>
  </div><!-- col-md-3 -->
  
  

  
  <div class="col-xs-12 col-sm-9 col-md-9 note">
	

	  <!-- content -->
	  <h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><p>如果不是在一个非常规范的公司,有时候甚至没有软件发布包版本管理这件事,对于很多语言来说,并没有提供包管理的相关特性,比如PHP,从事PHP多年,但是我们再发布的时候流程并不是非常规范。版本之间的依赖也比较混乱,于是有人提出了语义化版本管理的规范</p>
<p>搬运 <a href="http://semver.org/lang/zh-CN/" target="_blank" rel="external">http://semver.org/lang/zh-CN/</a> 网站上的一些资料</p>
<p>github: <a href="https://github.com/mojombo/semver" target="_blank" rel="external">https://github.com/mojombo/semver</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Given a version number MAJOR.MINOR.PATCH, increment the:</p>
<ol>
<li>MAJOR version when you make incompatible API changes,</li>
<li>MINOR version when you add functionality in a backwards-compatible<br>manner, and</li>
<li>PATCH version when you make backwards-compatible bug fixes.</li>
</ol>
<p>Additional labels for pre-release and build metadata are available as extensions<br>to the MAJOR.MINOR.PATCH format.</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>In the world of software management there exists a dreaded place called<br>“dependency hell.” The bigger your system grows and the more packages you<br>integrate into your software, the more likely you are to find yourself, one<br>day, in this pit of despair.</p>
<p>In systems with many dependencies, releasing new package versions can quickly<br>become a nightmare. If the dependency specifications are too tight, you are in<br>danger of version lock (the inability to upgrade a package without having to<br>release new versions of every dependent package). If dependencies are<br>specified too loosely, you will inevitably be bitten by version promiscuity<br>(assuming compatibility with more future versions than is reasonable).<br>Dependency hell is where you are when version lock and/or version promiscuity<br>prevent you from easily and safely moving your project forward.</p>
<p>As a solution to this problem, I propose a simple set of rules and<br>requirements that dictate how version numbers are assigned and incremented.<br>These rules are based on but not necessarily limited to pre-existing<br>widespread common practices in use in both closed and open-source software.<br>For this system to work, you first need to declare a public API. This may<br>consist of documentation or be enforced by the code itself. Regardless, it is<br>important that this API be clear and precise. Once you identify your public<br>API, you communicate changes to it with specific increments to your version<br>number. Consider a version format of X.Y.Z (Major.Minor.Patch). Bug fixes not<br>affecting the API increment the patch version, backwards compatible API<br>additions/changes increment the minor version, and backwards incompatible API<br>changes increment the major version.</p>
<p>I call this system “Semantic Versioning.” Under this scheme, version numbers<br>and the way they change convey meaning about the underlying code and what has<br>been modified from one version to the next.</p>
<h2 id="Semantic-Versioning-Specification-SemVer"><a href="#Semantic-Versioning-Specification-SemVer" class="headerlink" title="Semantic Versioning Specification (SemVer)"></a>Semantic Versioning Specification (SemVer)</h2><p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”,<br>“SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be<br>interpreted as described in <a href="http://tools.ietf.org/html/rfc2119" target="_blank" rel="external">RFC 2119</a>.</p>
<ol>
<li><p>Software using Semantic Versioning MUST declare a public API. This API<br>could be declared in the code itself or exist strictly in documentation.<br>However it is done, it SHOULD be precise and comprehensive.</p>
</li>
<li><p>A normal version number MUST take the form X.Y.Z where X, Y, and Z are<br>non-negative integers, and MUST NOT contain leading zeroes. X is the<br>major version, Y is the minor version, and Z is the patch version.<br>Each element MUST increase numerically. For instance: 1.9.0 -&gt; 1.10.0 -&gt; 1.11.0.</p>
</li>
<li><p>Once a versioned package has been released, the contents of that version<br>MUST NOT be modified. Any modifications MUST be released as a new version.</p>
</li>
<li><p>Major version zero (0.y.z) is for initial development. Anything MAY change<br>at any time. The public API SHOULD NOT be considered stable.</p>
</li>
<li><p>Version 1.0.0 defines the public API. The way in which the version number<br>is incremented after this release is dependent on this public API and how it<br>changes.</p>
</li>
<li><p>Patch version Z (x.y.Z | x &gt; 0) MUST be incremented if only backwards<br>compatible bug fixes are introduced. A bug fix is defined as an internal<br>change that fixes incorrect behavior.</p>
</li>
<li><p>Minor version Y (x.Y.z | x &gt; 0) MUST be incremented if new, backwards<br>compatible functionality is introduced to the public API. It MUST be<br>incremented if any public API functionality is marked as deprecated. It MAY be<br>incremented if substantial new functionality or improvements are introduced<br>within the private code. It MAY include patch level changes. Patch version<br>MUST be reset to 0 when minor version is incremented.</p>
</li>
<li><p>Major version X (X.y.z | X &gt; 0) MUST be incremented if any backwards<br>incompatible changes are introduced to the public API. It MAY also include minor<br>and patch level changes. Patch and minor version MUST be reset to 0 when major<br>version is incremented.</p>
</li>
<li><p>A pre-release version MAY be denoted by appending a hyphen and a<br>series of dot separated identifiers immediately following the patch<br>version. Identifiers MUST comprise only ASCII alphanumerics and hyphen<br>[0-9A-Za-z-]. Identifiers MUST NOT be empty. Numeric identifiers MUST<br>NOT include leading zeroes. Pre-release versions have a lower<br>precedence than the associated normal version. A pre-release version<br>indicates that the version is unstable and might not satisfy the<br>intended compatibility requirements as denoted by its associated<br>normal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,<br>1.0.0-x.7.z.92.</p>
</li>
<li><p>Build metadata MAY be denoted by appending a plus sign and a series of dot<br>separated identifiers immediately following the patch or pre-release version.<br>Identifiers MUST comprise only ASCII alphanumerics and hyphen [0-9A-Za-z-].<br>Identifiers MUST NOT be empty. Build metadata MUST be ignored when determining<br>version precedence. Thus two versions that differ only in the build metadata,<br>have the same precedence. Examples: 1.0.0-alpha+001, 1.0.0+20130313144700,<br>1.0.0-beta+exp.sha.5114f85.</p>
</li>
<li><p>Precedence refers to how versions are compared to each other when ordered.<br>Precedence MUST be calculated by separating the version into major, minor, patch<br>and pre-release identifiers in that order (Build metadata does not figure<br>into precedence). Precedence is determined by the first difference when<br>comparing each of these identifiers from left to right as follows: Major, minor,<br>and patch versions are always compared numerically. Example: 1.0.0 &lt; 2.0.0 &lt;<br>2.1.0 &lt; 2.1.1. When major, minor, and patch are equal, a pre-release version has<br>lower precedence than a normal version. Example: 1.0.0-alpha &lt; 1.0.0. Precedence<br>for two pre-release versions with the same major, minor, and patch version MUST<br>be determined by comparing each dot separated identifier from left to right<br>until a difference is found as follows: identifiers consisting of only digits<br>are compared numerically and identifiers with letters or hyphens are compared<br>lexically in ASCII sort order. Numeric identifiers always have lower precedence<br>than non-numeric identifiers. A larger set of pre-release fields has a higher<br>precedence than a smaller set, if all of the preceding identifiers are equal.<br>Example: 1.0.0-alpha &lt; 1.0.0-alpha.1 &lt; 1.0.0-alpha.beta &lt; 1.0.0-beta &lt;<br>1.0.0-beta.2 &lt; 1.0.0-beta.11 &lt; 1.0.0-rc.1 &lt; 1.0.0.</p>
</li>
</ol>
<h2 id="Backus–Naur-Form-Grammar-for-Valid-SemVer-Versions"><a href="#Backus–Naur-Form-Grammar-for-Valid-SemVer-Versions" class="headerlink" title="Backus–Naur Form Grammar for Valid SemVer Versions"></a>Backus–Naur Form Grammar for Valid SemVer Versions</h2><pre><code>&lt;valid semver&gt; ::= &lt;version core&gt;
                 | &lt;version core&gt; &quot;-&quot; &lt;pre-release&gt;
                 | &lt;version core&gt; &quot;+&quot; &lt;build&gt;
                 | &lt;version core&gt; &quot;-&quot; &lt;pre-release&gt; &quot;+&quot; &lt;build&gt;

&lt;version core&gt; ::= &lt;major&gt; &quot;.&quot; &lt;minor&gt; &quot;.&quot; &lt;patch&gt;

&lt;major&gt; ::= &lt;numeric identifier&gt;

&lt;minor&gt; ::= &lt;numeric identifier&gt;

&lt;patch&gt; ::= &lt;numeric identifier&gt;

&lt;pre-release&gt; ::= &lt;dot-separated pre-release identifiers&gt;

&lt;dot-separated pre-release identifiers&gt; ::= &lt;pre-release identifier&gt;
                                          | &lt;pre-release identifier&gt; &quot;.&quot; &lt;dot-separated pre-release identifiers&gt;

&lt;build&gt; ::= &lt;dot-separated build identifiers&gt;

&lt;dot-separated build identifiers&gt; ::= &lt;build identifier&gt;
                                    | &lt;build identifier&gt; &quot;.&quot; &lt;dot-separated build identifiers&gt;

&lt;pre-release identifier&gt; ::= &lt;alphanumeric identifier&gt;
                           | &lt;numeric identifier&gt;

&lt;build identifier&gt; ::= &lt;alphanumeric identifier&gt;
                     | &lt;digits&gt;

&lt;alphanumeric identifier&gt; ::= &lt;non-digit&gt;
                            | &lt;non-digit&gt; &lt;identifier characters&gt;
                            | &lt;identifier characters&gt; &lt;non-digit&gt;
                            | &lt;identifier characters&gt; &lt;non-digit&gt; &lt;identifier characters&gt;

&lt;numeric identifier&gt; ::= &quot;0&quot;
                       | &lt;positive digit&gt;
                       | &lt;positive digit&gt; &lt;digits&gt;

&lt;identifier characters&gt; ::= &lt;identifier character&gt;
                          | &lt;identifier character&gt; &lt;identifier characters&gt;

&lt;identifier character&gt; ::= &lt;digit&gt;
                         | &lt;non-digit&gt;

&lt;non-digit&gt; ::= &lt;letter&gt;
              | &quot;-&quot;

&lt;digits&gt; ::= &lt;digit&gt;
           | &lt;digit&gt; &lt;digits&gt;

&lt;digit&gt; ::= &quot;0&quot;
          | &lt;positive digit&gt;

&lt;positive digit&gt; ::= &quot;1&quot; | &quot;2&quot; | &quot;3&quot; | &quot;4&quot; | &quot;5&quot; | &quot;6&quot; | &quot;7&quot; | &quot;8&quot; | &quot;9&quot;

&lt;letter&gt; ::= &quot;A&quot; | &quot;B&quot; | &quot;C&quot; | &quot;D&quot; | &quot;E&quot; | &quot;F&quot; | &quot;G&quot; | &quot;H&quot; | &quot;I&quot; | &quot;J&quot;
           | &quot;K&quot; | &quot;L&quot; | &quot;M&quot; | &quot;N&quot; | &quot;O&quot; | &quot;P&quot; | &quot;Q&quot; | &quot;R&quot; | &quot;S&quot; | &quot;T&quot;
           | &quot;U&quot; | &quot;V&quot; | &quot;W&quot; | &quot;X&quot; | &quot;Y&quot; | &quot;Z&quot; | &quot;a&quot; | &quot;b&quot; | &quot;c&quot; | &quot;d&quot;
           | &quot;e&quot; | &quot;f&quot; | &quot;g&quot; | &quot;h&quot; | &quot;i&quot; | &quot;j&quot; | &quot;k&quot; | &quot;l&quot; | &quot;m&quot; | &quot;n&quot;
           | &quot;o&quot; | &quot;p&quot; | &quot;q&quot; | &quot;r&quot; | &quot;s&quot; | &quot;t&quot; | &quot;u&quot; | &quot;v&quot; | &quot;w&quot; | &quot;x&quot;
           | &quot;y&quot; | &quot;z&quot;
</code></pre><h2 id="Why-Use-Semantic-Versioning"><a href="#Why-Use-Semantic-Versioning" class="headerlink" title="Why Use Semantic Versioning?"></a>Why Use Semantic Versioning?</h2><p>This is not a new or revolutionary idea. In fact, you probably do something<br>close to this already. The problem is that “close” isn’t good enough. Without<br>compliance to some sort of formal specification, version numbers are<br>essentially useless for dependency management. By giving a name and clear<br>definition to the above ideas, it becomes easy to communicate your intentions<br>to the users of your software. Once these intentions are clear, flexible (but<br>not too flexible) dependency specifications can finally be made.</p>
<p>A simple example will demonstrate how Semantic Versioning can make dependency<br>hell a thing of the past. Consider a library called “Firetruck.” It requires a<br>Semantically Versioned package named “Ladder.” At the time that Firetruck is<br>created, Ladder is at version 3.1.0. Since Firetruck uses some functionality<br>that was first introduced in 3.1.0, you can safely specify the Ladder<br>dependency as greater than or equal to 3.1.0 but less than 4.0.0. Now, when<br>Ladder version 3.1.1 and 3.2.0 become available, you can release them to your<br>package management system and know that they will be compatible with existing<br>dependent software.</p>
<p>As a responsible developer you will, of course, want to verify that any<br>package upgrades function as advertised. The real world is a messy place;<br>there’s nothing we can do about that but be vigilant. What you can do is let<br>Semantic Versioning provide you with a sane way to release and upgrade<br>packages without having to roll new versions of dependent packages, saving you<br>time and hassle.</p>
<p>If all of this sounds desirable, all you need to do to start using Semantic<br>Versioning is to declare that you are doing so and then follow the rules. Link<br>to this website from your README so others know the rules and can benefit from<br>them.</p>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="How-should-I-deal-with-revisions-in-the-0-y-z-initial-development-phase"><a href="#How-should-I-deal-with-revisions-in-the-0-y-z-initial-development-phase" class="headerlink" title="How should I deal with revisions in the 0.y.z initial development phase?"></a>How should I deal with revisions in the 0.y.z initial development phase?</h3><p>The simplest thing to do is start your initial development release at 0.1.0<br>and then increment the minor version for each subsequent release.</p>
<h3 id="How-do-I-know-when-to-release-1-0-0"><a href="#How-do-I-know-when-to-release-1-0-0" class="headerlink" title="How do I know when to release 1.0.0?"></a>How do I know when to release 1.0.0?</h3><p>If your software is being used in production, it should probably already be<br>1.0.0. If you have a stable API on which users have come to depend, you should<br>be 1.0.0. If you’re worrying a lot about backwards compatibility, you should<br>probably already be 1.0.0.</p>
<h3 id="Doesn’t-this-discourage-rapid-development-and-fast-iteration"><a href="#Doesn’t-this-discourage-rapid-development-and-fast-iteration" class="headerlink" title="Doesn’t this discourage rapid development and fast iteration?"></a>Doesn’t this discourage rapid development and fast iteration?</h3><p>Major version zero is all about rapid development. If you’re changing the API<br>every day you should either still be in version 0.y.z or on a separate<br>development branch working on the next major version.</p>
<h3 id="If-even-the-tiniest-backwards-incompatible-changes-to-the-public-API-require-a-major-version-bump-won’t-I-end-up-at-version-42-0-0-very-rapidly"><a href="#If-even-the-tiniest-backwards-incompatible-changes-to-the-public-API-require-a-major-version-bump-won’t-I-end-up-at-version-42-0-0-very-rapidly" class="headerlink" title="If even the tiniest backwards incompatible changes to the public API require a major version bump, won’t I end up at version 42.0.0 very rapidly?"></a>If even the tiniest backwards incompatible changes to the public API require a major version bump, won’t I end up at version 42.0.0 very rapidly?</h3><p>This is a question of responsible development and foresight. Incompatible<br>changes should not be introduced lightly to software that has a lot of<br>dependent code. The cost that must be incurred to upgrade can be significant.<br>Having to bump major versions to release incompatible changes means you’ll<br>think through the impact of your changes, and evaluate the cost/benefit ratio<br>involved.</p>
<h3 id="Documenting-the-entire-public-API-is-too-much-work"><a href="#Documenting-the-entire-public-API-is-too-much-work" class="headerlink" title="Documenting the entire public API is too much work!"></a>Documenting the entire public API is too much work!</h3><p>It is your responsibility as a professional developer to properly document<br>software that is intended for use by others. Managing software complexity is a<br>hugely important part of keeping a project efficient, and that’s hard to do if<br>nobody knows how to use your software, or what methods are safe to call. In<br>the long run, Semantic Versioning, and the insistence on a well defined public<br>API can keep everyone and everything running smoothly.</p>
<h3 id="What-do-I-do-if-I-accidentally-release-a-backwards-incompatible-change-as-a-minor-version"><a href="#What-do-I-do-if-I-accidentally-release-a-backwards-incompatible-change-as-a-minor-version" class="headerlink" title="What do I do if I accidentally release a backwards incompatible change as a minor version?"></a>What do I do if I accidentally release a backwards incompatible change as a minor version?</h3><p>As soon as you realize that you’ve broken the Semantic Versioning spec, fix<br>the problem and release a new minor version that corrects the problem and<br>restores backwards compatibility. Even under this circumstance, it is<br>unacceptable to modify versioned releases. If it’s appropriate,<br>document the offending version and inform your users of the problem so that<br>they are aware of the offending version.</p>
<h3 id="What-should-I-do-if-I-update-my-own-dependencies-without-changing-the-public-API"><a href="#What-should-I-do-if-I-update-my-own-dependencies-without-changing-the-public-API" class="headerlink" title="What should I do if I update my own dependencies without changing the public API?"></a>What should I do if I update my own dependencies without changing the public API?</h3><p>That would be considered compatible since it does not affect the public API.<br>Software that explicitly depends on the same dependencies as your package<br>should have their own dependency specifications and the author will notice any<br>conflicts. Determining whether the change is a patch level or minor level<br>modification depends on whether you updated your dependencies in order to fix<br>a bug or introduce new functionality. I would usually expect additional code<br>for the latter instance, in which case it’s obviously a minor level increment.</p>
<h3 id="What-if-I-inadvertently-alter-the-public-API-in-a-way-that-is-not-compliant-with-the-version-number-change-i-e-the-code-incorrectly-introduces-a-major-breaking-change-in-a-patch-release"><a href="#What-if-I-inadvertently-alter-the-public-API-in-a-way-that-is-not-compliant-with-the-version-number-change-i-e-the-code-incorrectly-introduces-a-major-breaking-change-in-a-patch-release" class="headerlink" title="What if I inadvertently alter the public API in a way that is not compliant with the version number change (i.e. the code incorrectly introduces a major breaking change in a patch release)?"></a>What if I inadvertently alter the public API in a way that is not compliant with the version number change (i.e. the code incorrectly introduces a major breaking change in a patch release)?</h3><p>Use your best judgment. If you have a huge audience that will be drastically<br>impacted by changing the behavior back to what the public API intended, then<br>it may be best to perform a major version release, even though the fix could<br>strictly be considered a patch release. Remember, Semantic Versioning is all<br>about conveying meaning by how the version number changes. If these changes<br>are important to your users, use the version number to inform them.</p>
<h3 id="How-should-I-handle-deprecating-functionality"><a href="#How-should-I-handle-deprecating-functionality" class="headerlink" title="How should I handle deprecating functionality?"></a>How should I handle deprecating functionality?</h3><p>Deprecating existing functionality is a normal part of software development and<br>is often required to make forward progress. When you deprecate part of your<br>public API, you should do two things: (1) update your documentation to let<br>users know about the change, (2) issue a new minor release with the deprecation<br>in place. Before you completely remove the functionality in a new major release<br>there should be at least one minor release that contains the deprecation so<br>that users can smoothly transition to the new API.</p>
<h3 id="Does-SemVer-have-a-size-limit-on-the-version-string"><a href="#Does-SemVer-have-a-size-limit-on-the-version-string" class="headerlink" title="Does SemVer have a size limit on the version string?"></a>Does SemVer have a size limit on the version string?</h3><p>No, but use good judgment. A 255 character version string is probably overkill,<br>for example. Also, specific systems may impose their own limits on the size of<br>the string.</p>
<h3 id="Is-“v1-2-3”-a-semantic-version"><a href="#Is-“v1-2-3”-a-semantic-version" class="headerlink" title="Is “v1.2.3” a semantic version?"></a>Is “v1.2.3” a semantic version?</h3><p>No, “v1.2.3” is not a semantic version. However, prefixing a semantic version<br>with a “v” is a common way (in English) to indicate it is a version number.<br>Abbreviating “version” as “v” is often seen with version control. Example:<br><code>git tag v1.2.3 -m &quot;Release version 1.2.3&quot;</code>, in which case “v1.2.3” is a tag<br>name and the semantic version is “1.2.3”.</p>
<h2 id="About"><a href="#About" class="headerlink" title="About"></a>About</h2><p>The Semantic Versioning specification is authored by <a href="http://tom.preston-werner.com" target="_blank" rel="external">Tom<br>Preston-Werner</a>, inventor of Gravatar and<br>cofounder of GitHub.</p>
<p>If you’d like to leave feedback, please <a href="https://github.com/mojombo/semver/issues" target="_blank" rel="external">open an issue on<br>GitHub</a>.</p>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>Creative Commons - CC BY 3.0<br><a href="http://creativecommons.org/licenses/by/3.0/" target="_blank" rel="external">http://creativecommons.org/licenses/by/3.0/</a></p>
	  

	  <div>
  		<center>
		  <div class="pagination">
<ul class="pagination">
	
	
	
	
	
	
		
			
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	
	
		<li class="prev disabled"><a><i class="fa fa-arrow-circle-o-left"></i>prev</a></li>
	
	<li><a href="/"><i class="fa fa-archive"></i>Home</a></li>
	
		<li class="next disabled"><a>next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

		</center>
	  </div>
	  
	</div> <!-- col-md-9/col-md-12 -->
	
  </div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
	<footer> <p>
    
      &copy; 2017 cn.printf
      
      <a href="http://www.printf.cn" target="_blank">www.printf.cn</a>
</p> </footer>
  </div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/jquery.tableofcontents.min.js"></script>
<script src="/js/tocgenerator.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


</body>
</html>
