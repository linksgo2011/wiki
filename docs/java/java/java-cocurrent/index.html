<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Java 并发和多线程 | 架构师知识系统</title>
  <meta name="author" content="少个分号">
  
  <meta name="description" content="Java 多线程的几种实现方式通过实现 Runnable 接口；
class RunnableDemo implements Runnable {
   private Thread t;
   private String threadName;

   RunnableDemo( String ">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Java 并发和多线程">
  <meta property="og:site_name" content="架构师知识系统">

  
    <meta property="og:image" content="undefined">
  

  
    <link rel="alternative" href="/atom.xml" title="架构师知识系统" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/css/sidenav.css" media="screen" type="text/css">  
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  

</head>
</html>
<body id="body" data-spy="scroll" data-target=".toc">
  <div class="container" id="container">
	<div class="content">
	  <div class="page-header">		
  <h1><a class="brand" href="/">架构师知识系统</a><span class="split"></span><span class="title">Java 并发和多线程</span><span class="date" id="title-date"><i class="fa fa-clock-o"></i> 2019-01-24</span></h1>
</div>		

<div class="row page">
  <!-- cols -->	
  
  

  
	<div class="col-md-12">
	  

	  <!-- content -->
	  <h2 id="Java-多线程的几种实现方式"><a href="#Java-多线程的几种实现方式" class="headerlink" title="Java 多线程的几种实现方式"></a>Java 多线程的几种实现方式</h2><h3 id="通过实现-Runnable-接口；"><a href="#通过实现-Runnable-接口；" class="headerlink" title="通过实现 Runnable 接口；"></a>通过实现 Runnable 接口；</h3><pre><code class="java">
class RunnableDemo implements Runnable {
   private Thread t;
   private String threadName;

   RunnableDemo( String name) {
      threadName = name;
      System.out.println(&quot;Creating &quot; +  threadName );
   }

   public void run() {
      System.out.println(&quot;Running &quot; +  threadName );
      try {
         for(int i = 4; i &gt; 0; i--) {
            System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i);
            // 让线程睡眠一会
            Thread.sleep(50);
         }
      }catch (InterruptedException e) {
         System.out.println(&quot;Thread &quot; +  threadName + &quot; interrupted.&quot;);
      }
      System.out.println(&quot;Thread &quot; +  threadName + &quot; exiting.&quot;);
   }

   public void start () {
      System.out.println(&quot;Starting &quot; +  threadName );
      if (t == null) {
         t = new Thread (this, threadName);
         t.start ();
      }
   }
}

public class TestThread {

   public static void main(String args[]) {
      RunnableDemo R1 = new RunnableDemo( &quot;Thread-1&quot;);
      R1.start();

      RunnableDemo R2 = new RunnableDemo( &quot;Thread-2&quot;);
      R2.start();
   }   
}

</code></pre>
<h3 id="通过继承Thread来创建线程"><a href="#通过继承Thread来创建线程" class="headerlink" title="通过继承Thread来创建线程"></a>通过继承Thread来创建线程</h3><pre><code class="java">
class ThreadDemo extends Thread {
   private Thread t;
   private String threadName;

   ThreadDemo( String name) {
      threadName = name;
      System.out.println(&quot;Creating &quot; +  threadName );
   }

   public void run() {
      System.out.println(&quot;Running &quot; +  threadName );
      try {
         for(int i = 4; i &gt; 0; i--) {
            System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i);
            // 让线程睡眠一会
            Thread.sleep(50);
         }
      }catch (InterruptedException e) {
         System.out.println(&quot;Thread &quot; +  threadName + &quot; interrupted.&quot;);
      }
      System.out.println(&quot;Thread &quot; +  threadName + &quot; exiting.&quot;);
   }

   public void start () {
      System.out.println(&quot;Starting &quot; +  threadName );
      if (t == null) {
         t = new Thread (this, threadName);
         t.start ();
      }
   }
}

public class TestThread {

   public static void main(String args[]) {
      ThreadDemo T1 = new ThreadDemo( &quot;Thread-1&quot;);
      T1.start();

      ThreadDemo T2 = new ThreadDemo( &quot;Thread-2&quot;);
      T2.start();
   }   
}
</code></pre>
<h3 id="通过-Callable-和-Future-创建线程"><a href="#通过-Callable-和-Future-创建线程" class="headerlink" title="通过 Callable 和 Future 创建线程"></a>通过 Callable 和 Future 创建线程</h3><pre><code class="java">
public class CallableThreadTest implements Callable&lt;Integer&gt; {
    public static void main(String[] args)  
    {  
        CallableThreadTest ctt = new CallableThreadTest();  
        FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(ctt);  
        for(int i = 0;i &lt; 100;i++)  
        {  
            System.out.println(Thread.currentThread().getName()+&quot; 的循环变量i的值&quot;+i);  
            if(i==20)  
            {  
                new Thread(ft,&quot;有返回值的线程&quot;).start();  
            }  
        }  
        try  
        {  
            System.out.println(&quot;子线程的返回值：&quot;+ft.get());  
        } catch (InterruptedException e)  
        {  
            e.printStackTrace();  
        } catch (ExecutionException e)  
        {  
            e.printStackTrace();  
        }  

    }
    @Override  
    public Integer call() throws Exception  
    {  
        int i = 0;  
        for(;i&lt;100;i++)  
        {  
            System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);  
        }  
        return i;  
    }  
}
</code></pre>
<h3 id="创建线程的三种方式的对比"><a href="#创建线程的三种方式的对比" class="headerlink" title="创建线程的三种方式的对比"></a>创建线程的三种方式的对比</h3><ol>
<li>采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</li>
<li>使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</li>
<li>推荐使用 Callbale 方式，因为可以得到线程中的返回值和异常</li>
</ol>
<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>多线程代码中，变量会存在共享，但是如果操作不是原子性的，会造成一致性的问题。 在保证线程安全中Java提供了一些措施。</p>
<h3 id="同步操作和只读操作"><a href="#同步操作和只读操作" class="headerlink" title="同步操作和只读操作"></a>同步操作和只读操作</h3><p>1.方法的调用是在栈中完成的，因此方法的调用不会造成线程安全的问题。这也是为什么Spring 中使用Bean管理对象，每一次请求的操作可以视为同步行为，可以避免多线程问题。</p>
<p>2.Java中一些对象是线程安全的，是通过使用了只读操作完成的，例如每一个String都是新的对象，在解决线程安全问题的同时需要注意性能问题。</p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。</p>
<p>volatile 并不能解决线程安全问题，但是需要注意，赋值操作不是原子性的，因此需要使用volatile来保证变量的可见性。</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>synchronized 有两种使用方法同步代码块和同步方法，同步代码块可以传入一个需要锁定的对象，通常是this，而同步方法可以用来修饰方法</p>
<pre><code class="java">

synchronized void f() { /* body */ }

void f() { synchronized(this) { /* body */ } }

</code></pre>
<p>需要注意的是如果是类当中的静态变量 synchronized 并不会锁住</p>
<p>需要使用类名来锁</p>
<pre><code class="java">
synchronized void f() { /* body */ }

void f() { synchronized(this) { /* body */ } }

</code></pre>
	  

	  <div>
  		<center>
		  <div class="pagination">
<ul class="pagination">
	
	
	
	
	
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
			
		
	
		
	
		
			
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
			
		
	
		
			
			
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	
	
		<li class="prev"><a href="/java/java/unmodifiableMap/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>prev</a></li>
	
	<li><a href="/"><i class="fa fa-archive"></i>Home</a></li>
	
		<li class="next"><a href="/java/java/java-performance/" class="alignright next">next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

		</center>
	  </div>
	  
	</div> <!-- col-md-9/col-md-12 -->
	
  </div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
	<footer> <p>
  
  &copy; 2019 少个分号
  
  <a href="/about" target="_blank">关于本站</a> |
  <a href="https://github.com/linksgo2011/wiki" target="_blank">github |</a>
  <a href="http://www.printf.cn" target="_blank">我的博客</a>
</p> </footer>
  </div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/jquery.tableofcontents.min.js"></script>
<script src="/js/tocgenerator.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


</body>
</html>
