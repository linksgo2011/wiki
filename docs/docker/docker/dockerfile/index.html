<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Dockerfile 详解 | web 工程师知识系统</title>
  <meta name="author" content="少个分号">
  
  <meta name="description" content="Dockerfile 编写基础我们可以通过编写 Dockerfile 构建出 Docker 镜像，Dockerfile 可以看作为一个用于构建镜像的 Linux 命令集。Docker 在构建镜像的过程中，执行这个命令集，安装必要的软件以及一些基本的配置。
一个基本的 Dockerfle
FROM d">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Dockerfile 详解">
  <meta property="og:site_name" content="web 工程师知识系统">

  
    <meta property="og:image" content="undefined">
  

  
    <link rel="alternative" href="/atom.xml" title="web 工程师知识系统" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/css/sidenav.css" media="screen" type="text/css">  
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  

</head>
</html>
<body id="body" data-spy="scroll" data-target=".toc">
  <div class="container" id="container">
	<div class="content">
	  <div class="page-header">		
  <h1><a class="brand" href="/">web 工程师知识系统</a><span class="split"></span><span class="title">Dockerfile 详解</span><span class="date" id="title-date"><i class="fa fa-clock-o"></i> 2019-12-13</span></h1>
</div>		

<div class="row page">
  <!-- cols -->	
  
  <div class="col-xs-12 col-sm-3 col-md-3 toc"> 
	<!-- toc -->
<script type="text/javascript">
		jQuery(document).ready(function() {
 		   generateWikiTOC('.note', '.toc',  2 , 2 );
		});
</script>
  </div><!-- col-md-3 -->
  
  

  
  <div class="col-xs-12 col-sm-9 col-md-9 note">
	

	  <!-- content -->
	  <h2 id="Dockerfile-编写基础"><a href="#Dockerfile-编写基础" class="headerlink" title="Dockerfile 编写基础"></a>Dockerfile 编写基础</h2><p>我们可以通过编写 Dockerfile 构建出 Docker 镜像，Dockerfile 可以看作为一个用于构建镜像的 Linux 命令集。Docker 在构建镜像的过程中，执行这个命令集，安装必要的软件以及一些基本的配置。</p>
<p>一个基本的 Dockerfle</p>
<pre><code>FROM docker.io/nginx

COPY ./test.html /usr/share/nginx/htm/index.html
COPY nginx.conf /etc/nginx/conf.d/default.conf

CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]

</code></pre><ul>
<li>FROM 指明基础镜像，COPY 为复制资源文件命令， CMD 为容器启动时的命令。</li>
</ul>
<p>“Dockerfile” 是 Docker 默认的的文件名，也可使用 -f 参数进行指定其他文件名。</p>
<blockquote>
<p>docker build -t user/image:tag .<br>docker build -t user/image:new -f Dockerfile.new</p>
</blockquote>
<h3 id="Dockerfile-编写的注意事项"><a href="#Dockerfile-编写的注意事项" class="headerlink" title="Dockerfile 编写的注意事项"></a>Dockerfile 编写的注意事项</h3><p>尽可能自动化，避免 Y/n 提示导致构建失败。</p>
<p>考虑命令的顺序,后面的命令会依赖前面的结果。</p>
<p>如果很长的命令可以使用 \&amp;&amp; 来进行连接,例如</p>
<pre><code>RUN echo &#39;this is a long message&#39; \
&amp;&amp; echo &#39;hello&#39;
</code></pre><p>如果 Dockerfile 存放的目录还有其他文件，例如 node_modules 等超大型文件集合，Docker 也会发送到 Daemon 去构建，因此可以使用 .dockerignore 来排除文件，加快构建速度。.dockerignore 文件的语法类似于 .gitignore。</p>
<p>另外，一个容器最好只做一件事情，如果将数据库、前端静态页面、后端网站等都放到一个容器中，这样就失去了容器的意义。如果需要编排各种应用，可以使用 docker-compose 进行编排。</p>
<h2 id="Dockerfile-命令"><a href="#Dockerfile-命令" class="headerlink" title="Dockerfile 命令"></a>Dockerfile 命令</h2><h3 id="解析器命令"><a href="#解析器命令" class="headerlink" title="解析器命令"></a>解析器命令</h3><p>解析器命令是可选的，它影响 Dockerfile 后续的处理方式。解析器命令告诉 Docker 如何处理后续的命令，使用注释的形式，写下 FROM 命令之前，否则会被作为注释处理。</p>
<p>目前只有一个解析命令，escape </p>
<pre><code># escape=`
FROM ...
COPY testfile.txt c:\\
</code></pre><p>因为在 windows 下转义字符为 \ 因此 c:\ 会被解析成 c:\</p>
<h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p>FORM 命令用来表明，使用那个镜像作为基础构建，一般情况下都有基础镜像。FROM 必须是 Dockerfile 的第一句命令。</p>
<blockquote>
<p>FROM <a href="imageName:tag" target="_blank" rel="noopener">imageName:tag</a></p>
</blockquote>
<p>可以编写多个 FROM 会以最后一个镜像为准。</p>
<h3 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h3><p>指定维护者，方便其他人联系作者，这个命令已经弃用，可以使用 LABEL 命令。</p>
<blockquote>
<p>MAINTAINER NAME <email></email></p>
</blockquote>
<h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>指定在编译阶段的命令， RUN 会在 shell 环境下执行命令，用于安装软件或者做配置使用。</p>
<blockquote>
<p>RUN echo Hi</p>
</blockquote>
<p>RUN 命令会在当前的镜像的顶层执行命令，然后 commit 一个中间镜像，提交的镜像会在下一个 RUN 中使用。 Docker 构建完成后会删除中间镜像。</p>
<p>使用 RUN 的格式为 </p>
<blockquote>
<p>RUN [“程序名”,”参数1”,”参数2”]</p>
</blockquote>
<h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>ENV 命令用来执行 docker run 命令时设置的环境变量，这个环境变量可以在后续的命令中使用。</p>
<blockquote>
<p>ENV <key> <value></value></key></p>
</blockquote>
<p>定义的变量可以通过另种方式在 Dockerfile 中使用</p>
<ul>
<li>$variable</li>
<li>#{variable}</li>
</ul>
<p>尽量把 ENV 命令写成一个命令，因为每一个命令都是一个镜像层，合并之后的机构会变得更加简单和直观。</p>
<blockquote>
<p>ENV var1=value \<br>    var2=value2</p>
</blockquote>
<p>这些变量可以通过 docker run –env <key> = <value> 在运行更改，也可以使用 docker inspect 查看镜像或者容器中的变量。</value></key></p>
<h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>ARG 定义的参数用法和 ENV 一样，但是构建结束后会消失。</p>
<blockquote>
<p>ARG test=true</p>
</blockquote>
<h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>作用和 COPY 类似，可以添加文件到容器中。同时支持从 URL 中下载文件到容器中，不过 ADD 会比 COPY 构建出来的镜像文件更大。</p>
<p>ADD 不能使用当前目录之外的文件，例如不能使用 add ../ 等路径。</p>
<h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>用于标明这个镜像的应用会监听某个端口，并且能将这个端口映射到主机的网络界面上。</p>
<p>EXPOSE 只负责处理容器内部的监听端口，如果 Docker 不在 RUN 的时候给容器分配端口映射，则外部无法访问容器 EXPOSE 设置的端口。</p>
<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>CMD 提供了容器启动时默认执行命令，例如 java -jar app.jar 启动 Spring boot 项目。CMD 与 ENTRYPOINT 的功能机位相似，区别在于 CMD 只能使用一次，后面的会覆盖前面的。ENTRYPOINT 可以定义多次。</p>
<p>同时 Docker run 也会覆盖 CMD 命令。</p>
<pre><code>FROM ubuntu

CMD [&quot;echo&quot;,&quot;Hi&quot;]
</code></pre><p>构建后运行，会输出 Hi，如果使用如下命令</p>
<blockquote>
<p>docker run 10d628b340ea echo “test”</p>
</blockquote>
<p>结果会输出 test，RUN 的时候会覆盖 RUN 的命令。</p>
<h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>ENTRYPOINT 相当于固化了 CMD 命令无法被修改，也无法被 RUN 覆盖。</p>
<p>当使用 ENTRYPONT 的时候，CMD 以及 RUN 命令都会作为参数传递给 ENTRYPOINT</p>
<pre><code>FROM ubuntu

ENTRYPOINT [&quot;echo&quot;]
</code></pre><p>当我们构建并运行时，需要给一个参数 </p>
<blockquote>
<p>docker run 46e76bb0a870 “result”</p>
</blockquote>
<h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p>用于指明一个数据卷，Docker 容器最好的是无状态的，数据以及状态由数据卷提供。</p>
<pre><code>FROM ubuntu
RUN mkdir /app &amp;&amp; echo &quot;Hello&quot; &gt; /app/test.txt
VOLUME [&quot;/Users/nlin/www/deployment-automation/app-examples/docker-test/local&quot;,&quot;/app&quot;]

CMD [&quot;cat&quot;,&quot;/app/test.txt&quot;]
</code></pre><p>在运行时候可以使用 -v 参数映射 （推荐这种做法）</p>
<blockquote>
<p>docker run  –rm -v /Users/nlin/www/deployment-automation/app-examples/docker-test/local:/app  521522ce40f6 </p>
</blockquote>
<h2 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h2><p>USER 命令用于指定运行容器时，使用的用户，默认为 ROOT</p>
<pre><code>USER mysql
</code></pre><p>在运行时候可以使用 -u 动态指定。</p>
<h2 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h2><p>WORKDIR 用于指定 RUN、CMD 等命令的工作目录，相当于 cd，多个 WORKDIR会产生连续的效果。</p>
<pre><code>WORKDIR /a
WORKDIR b
WORKDIR c
</code></pre><p>相当于 cd /a/b/c</p>
<h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>ONBUILD 用于在子镜像的 FROM 之前运行，相当于子镜像中的一个钩子。这个命令不会在当前命令中执行。</p>
<h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p>给镜像打上标签，尽量写在一起，减少构建过程的时间</p>
<pre><code>LABEL label1=xxx label2=xxx
</code></pre><h3 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h3><p>用于容器停止时的信号</p>
<pre><code>STOPSIGNAL SIGKILL 
</code></pre><p>这样写可以在容器停止时，发送一个信号给运行的程序。</p>
<h3 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h3><p>定期发送一个 HEALTHCHECK 信号</p>
<pre><code>HEALTHCHECK --interval=10s --timeout=3s \
    CMD curl -f http://localhost/ || exit 1
</code></pre><p>这样在容器运行时检查系统是否正常，然后退出。</p>
	  

	  <div>
  		<center>
		  <div class="pagination">
<ul class="pagination">
	
	
	
	
	
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
			
		
	
		
			
			
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	
	
		<li class="prev"><a href="/docker/docker/docker-export/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>prev</a></li>
	
	<li><a href="/"><i class="fa fa-archive"></i>Home</a></li>
	
		<li class="next"><a href="/docker/docker/docker-basic/" class="alignright next">next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

		</center>
	  </div>
	  
	</div> <!-- col-md-9/col-md-12 -->
	
  </div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
	<footer> <p>
  
  &copy; 2020 少个分号
  
  <a href="/about" target="_blank">关于本站</a> |
  <a href="https://github.com/linksgo2011/wiki" target="_blank">github |</a>
  <a href="http://www.printf.cn" target="_blank">我的博客</a>
</p> </footer>
  </div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/jquery.tableofcontents.min.js"></script>
<script src="/js/tocgenerator.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


</body>
</html>
