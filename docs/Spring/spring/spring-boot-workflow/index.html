<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Spring boot 源码分析 | web 工程师知识系统</title>
  <meta name="author" content="少个分号">
  
  <meta name="description" content="前置知识
要求对 Spring 有一定了解知道 Spring 和 spring boot 之间的关系
对 Servlet 有一定了解
对类加载器有一定了解

spring 预习spring 本质上就是一个帮你加载类，管理类的库，所以被称作 IOC 容器。

spring-core spring 核心">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Spring boot 源码分析">
  <meta property="og:site_name" content="web 工程师知识系统">

  
    <meta property="og:image" content="undefined">
  

  
    <link rel="alternative" href="/atom.xml" title="web 工程师知识系统" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/css/sidenav.css" media="screen" type="text/css">  
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  

</head>
</html>
<body id="body" data-spy="scroll" data-target=".toc">
  <div class="container" id="container">
	<div class="content">
	  <div class="page-header">		
  <h1><a class="brand" href="/">web 工程师知识系统</a><span class="split"></span><span class="title">Spring boot 源码分析</span><span class="date" id="title-date"><i class="fa fa-clock-o"></i> 2020-04-04</span></h1>
</div>		

<div class="row page">
  <!-- cols -->	
  
  <div class="col-xs-12 col-sm-3 col-md-3 toc"> 
	<!-- toc -->
<script type="text/javascript">
		jQuery(document).ready(function() {
 		   generateWikiTOC('.note', '.toc',  2 , 2 );
		});
</script>
  </div><!-- col-md-3 -->
  
  

  
  <div class="col-xs-12 col-sm-9 col-md-9 note">
	

	  <!-- content -->
	  <h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><ul>
<li>要求对 Spring 有一定了解知道 Spring 和 spring boot 之间的关系</li>
<li>对 Servlet 有一定了解</li>
<li>对类加载器有一定了解</li>
</ul>
<h3 id="spring-预习"><a href="#spring-预习" class="headerlink" title="spring 预习"></a>spring 预习</h3><p>spring 本质上就是一个帮你加载类，管理类的库，所以被称作 IOC 容器。</p>
<ul>
<li>spring-core spring 核心基础能力：<ul>
<li>动态代理 cglib</li>
<li>类解析 asm</li>
<li>类实例化 objenesis</li>
<li>基础注解  core.annotation</li>
<li>编解码 core.codec</li>
<li>类型转换器 core.convert</li>
<li>配置文件解析 core.env</li>
<li>资源读取 core.io</li>
<li>日志 core.log</li>
<li>序列化 core.serializer</li>
<li>格式化输出 core.style</li>
<li>多线程任务 core.task</li>
<li>注解处理 core.type</li>
<li>工具包<ul>
<li>退避算法 util.backoff</li>
<li>比较器 util.comparator</li>
<li>并发工具 util.concurrent</li>
<li>单位 util.unit</li>
<li>函数式工具 util.function</li>
<li>xml 处理工具 util.xml</li>
</ul>
</li>
<li>其他常用的工具类<ul>
<li>TODO </li>
</ul>
</li>
</ul>
</li>
<li>spring-beans 对 bean 各种操作<ul>
<li>bean 工厂 factory</li>
<li>bean 的属性编辑器</li>
<li>bean 工具</li>
</ul>
</li>
<li>spring-aop 实现切片编程的逻辑</li>
<li>spring-expression  EL 表达式，基本实现了一个 DSL</li>
<li>spring-context 整合上面的组件，提供给应用程序一个上下文容器<ul>
<li>cache 缓存相关</li>
<li>context  应用上下文相关<ul>
<li>annotation</li>
<li>config</li>
<li>event</li>
<li>expression</li>
<li>i18n</li>
<li>index</li>
<li>support</li>
<li>weaving</li>
</ul>
</li>
<li>format</li>
<li>scheduling 计划任务</li>
<li>scripting</li>
<li>stereotype  模板类型，例如 Controller </li>
<li>validation 数据验证</li>
</ul>
</li>
</ul>
<h3 id="spring-boot、-spring、spring-mvc-的关系"><a href="#spring-boot、-spring、spring-mvc-的关系" class="headerlink" title="spring boot、 spring、spring mvc 的关系"></a>spring boot、 spring、spring mvc 的关系</h3><p>spring 是一个 IOC 容器，负责初始化对象，以及管理对象。可以看做一个库，无法作为一个应用启动。spring 实际上与 web 应用无关，但是也提供了很多 web 应用的支持。</p>
<p>spring boot 是一个整合了 spring 等其他技术的应用框架，开发者需要根据 spring boot 的逻辑来进行开发，spring boot 帮忙做了很多默认配置。</p>
<p>spring mvc  是一个响应 servlet 请求并完成请求路由映射、模型加载、视图渲染等经典 MVC 框架。</p>
<h1 id="Spring-boot-启动过程"><a href="#Spring-boot-启动过程" class="headerlink" title="Spring boot 启动过程"></a>Spring boot 启动过程</h1><h2 id="1-执行入口方法"><a href="#1-执行入口方法" class="headerlink" title="1 执行入口方法"></a>1 执行入口方法</h2><pre><code class="java">@SpringBootApplication
public class SpringBootBestPracticeApplication {
    public static void main(String[] args) {
        SpringApplication.run(SpringBootBestPracticeApplication.class, args);
    }
}
</code></pre>
<h2 id="2-构造应用实例-new-SpringApplication"><a href="#2-构造应用实例-new-SpringApplication" class="headerlink" title="2 构造应用实例 new SpringApplication()"></a>2 构造应用实例 new SpringApplication()</h2><p>实例化 SpringApplication 对象</p>
<pre><code class="java">public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources,
      String[] args) {
   // 2. 构建应用实例
   SpringApplication app = new SpringApplication(primarySources);
   // 3. 运行应用实例
   return app.run(args);
}
</code></pre>
<pre><code class="java">public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) {
   // 2.1 资源初始化资源加载器为 null
   this.resourceLoader = resourceLoader;
   Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);
   this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));
   // 2.2 推断当前 WEB 应用类型,判断是一个 webflux 还是普通 servlet 项目，或者不是 web 项目
   this.webApplicationType = WebApplicationType.deduceFromClasspath();
   // 2.3 设置应用上下文初始化器 ,ApplicationContextInitializer 接口负责在项目启动时候初始话各种资源，这里支持不同的初始化器，例如加载配置文件、注册属性资源、激活 Profiles 
  setInitializers((Collection) getSpringFactoriesInstances(
         ApplicationContextInitializer.class));
   // 2.4 设置监听器
   setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
   // 2.5 推断主入口应用类
   this.mainApplicationClass = deduceMainApplicationClass();
}
</code></pre>
<h3 id="2-1-资源初始化资源加载器为-null"><a href="#2-1-资源初始化资源加载器为-null" class="headerlink" title="2.1 资源初始化资源加载器为 null"></a>2.1 资源初始化资源加载器为 null</h3><h3 id="2-2-推断应用类型"><a href="#2-2-推断应用类型" class="headerlink" title="2.2 推断应用类型"></a>2.2 推断应用类型</h3><pre><code class="java">static WebApplicationType deduceFromClasspath() {
   if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null)
         &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null)
         &amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) {
      return WebApplicationType.REACTIVE;
   }
   for (String className : SERVLET_INDICATOR_CLASSES) {
      if (!ClassUtils.isPresent(className, null)) {
         return WebApplicationType.NONE;
      }
   }
   return WebApplicationType.SERVLET;
}
</code></pre>
<p>ClassUtils.isPresent 检测 org.springframework.web.reactive.DispatcherHandler 这个类是否存在，并且没有加载 Spring mvc 以及 Jersey 可以判定为 REACTIVE 模式。</p>
<p>如果没有加载任何 ConfigurableWebApplicationContext 相关的类，判定为非 web 项目。</p>
<h3 id="2-3-构造-SpringApplication-的上下文初始化器"><a href="#2-3-构造-SpringApplication-的上下文初始化器" class="headerlink" title="2.3 构造 SpringApplication  的上下文初始化器"></a>2.3 构造 SpringApplication  的上下文初始化器</h3><p>获取初始化器的实例</p>
<pre><code class="java">private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type,
      Class&lt;?&gt;[] parameterTypes, Object... args) {
   // 2.3.1 通过 SpringFactoriesLoader.loadFactoryNames 加载该接口的所有实现
   ClassLoader classLoader = getClassLoader();
   // 2.3.2 通过 SpringFactoriesLoader.loadFactoryNames 加载该接口的所有实现
   Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(
         SpringFactoriesLoader.loadFactoryNames(type, classLoader));
   // 2.3.3 使用 BeanUtils.instantiateClass 实例化所有的类
   List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes,
         classLoader, args, names);
   // 2.3.4 使用 BeanUtils.instantiateClass 使用注解比较器进行排序
   AnnotationAwareOrderComparator.sort(instances);
   return instances;
}
</code></pre>
<h4 id="2-3-1-获取-class-loader"><a href="#2-3-1-获取-class-loader" class="headerlink" title="2.3.1 获取 class loader"></a>2.3.1 获取 class loader</h4><pre><code class="java">if (this.resourceLoader != null) {
   return this.resourceLoader.getClassLoader();
}
return ClassUtils.getDefaultClassLoader();
</code></pre>
<p>ClassUtils 的实现原理为 Thread.currentThread().getContextClassLoader();  并做了回退处理</p>
<ul>
<li>Thread.currentThread().getContextClassLoader(); </li>
<li>ClassUtils.class.getClassLoader();</li>
<li>ClassLoader.getSystemClassLoader();</li>
</ul>
<h4 id="2-3-2-加载初始化类名"><a href="#2-3-2-加载初始化类名" class="headerlink" title="2.3.2 加载初始化类名"></a>2.3.2 加载初始化类名</h4><pre><code class="java">        public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) {
        String factoryClassName = factoryClass.getName();
        return loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());
    }
</code></pre>
<pre><code class="java">private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) {
   MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);
   if (result != null) {
      return result;
   }

   try {
      Enumeration&lt;URL&gt; urls = (classLoader != null ?
            classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :
            ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));
      result = new LinkedMultiValueMap&lt;&gt;();
      while (urls.hasMoreElements()) {
         URL url = urls.nextElement();
         UrlResource resource = new UrlResource(url);
         Properties properties = PropertiesLoaderUtils.loadProperties(resource);
         for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) {
            String factoryClassName = ((String) entry.getKey()).trim();
            for (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) {
               result.add(factoryClassName, factoryName.trim());
            }
         }
      }
      cache.put(classLoader, result);
      return result;
   }
   catch (IOException ex) {
      throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; +
            FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex);
   }
}
</code></pre>
<p>基本原理是通过 class loader 找到 META-INF/spring.factories 文件解析并获取 <code>ApplicationContextInitializer</code> 接口的所有配置的类路径名称。</p>
<p>这里非常关键，spring boot 通过加载不同的 ApplicationContextInitializer 对上下文进行初始化，这是 spring boot 应用具有大量特性的同时也能保持灵活性的重要手段。</p>
<p>urls 是类加载器以及双亲委派模式下的类加载器加载出来的所有资源，然后遍历获取需要的类。</p>
<p>ApplicationContextInitializer 的类定义有几个潜在来源：</p>
<ul>
<li>spring boot 本身提供了4 个类</li>
<li>devtools 提供了1个用于热加载后刷新上下文的类</li>
<li>autoconfigure 提供了2个用于自动配置的类</li>
</ul>
<p>我加载了 devtools 因此加载了7个上下文初始化类。</p>
<pre><code>0 = &quot;org.springframework.boot.devtools.restart.RestartScopeInitializer&quot;
1 = &quot;org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer&quot;
2 = &quot;org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener&quot;
3 = &quot;org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer&quot;
4 = &quot;org.springframework.boot.context.ContextIdApplicationContextInitializer&quot;
5 = &quot;org.springframework.boot.context.config.DelegatingApplicationContextInitializer&quot;
6 = &quot;org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer&quot;
</code></pre><p>这里使用了一个 LinkedMultiValueMap 数据结构，可以为一个 key 存储多个值，构建出一个树类似的结构，便于解析 properties 文件。</p>
<p>可以把从不同的 spring.factories 中的代码块汇集到一个对象中，一个 spring.factories 数据结构如下</p>
<pre><code># Error Reporters
org.springframework.boot.SpringBootExceptionReporter=\
org.springframework.boot.diagnostics.FailureAnalyzers

# Application Context Initializers
org.springframework.context.ApplicationContextInitializer=\
org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\
org.springframework.boot.context.ContextIdApplicationContextInitializer,\
org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\
org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer
</code></pre><p>如果有多个 jar 包中都有 ApplicationContextInitializer配置块，通过LinkedMultiValueMap 可以很方便的合并同样key的集合。</p>
<h4 id="2-3-3-实例化初始化器类"><a href="#2-3-3-实例化初始化器类" class="headerlink" title="2.3.3 实例化初始化器类"></a>2.3.3 实例化初始化器类</h4><pre><code class="java">@SuppressWarnings(&quot;unchecked&quot;)
private &lt;T&gt; List&lt;T&gt; createSpringFactoriesInstances(Class&lt;T&gt; type,
      Class&lt;?&gt;[] parameterTypes, ClassLoader classLoader, Object[] args,
      Set&lt;String&gt; names) {
   List&lt;T&gt; instances = new ArrayList&lt;&gt;(names.size());
   for (String name : names) {
      try {
         Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader);
         Assert.isAssignable(type, instanceClass);
         Constructor&lt;?&gt; constructor = instanceClass
               .getDeclaredConstructor(parameterTypes);
         T instance = (T) BeanUtils.instantiateClass(constructor, args);
         instances.add(instance);
      }
      catch (Throwable ex) {
         throw new IllegalArgumentException(
               &quot;Cannot instantiate &quot; + type + &quot; : &quot; + name, ex);
      }
   }
   return instances;
}
</code></pre>
<h4 id="2-3-4-使用注解比较器进行排序"><a href="#2-3-4-使用注解比较器进行排序" class="headerlink" title="2.3.4 使用注解比较器进行排序"></a>2.3.4 使用注解比较器进行排序</h4><pre><code class="java">public static void sort(List&lt;?&gt; list) {
   if (list.size() &gt; 1) {
      list.sort(INSTANCE);
   }
}
</code></pre>
<p>INSTANCE 是 AnnotationAwareOrderComparator 的一个单例，继承 OrderComparator 实现通过顺序进行比较。AnnotationAwareOrderComparator 的职责是通过找到 Order 注解进行排序。</p>
<h3 id="2-4-设置监听器"><a href="#2-4-设置监听器" class="headerlink" title="2.4 设置监听器"></a>2.4 设置监听器</h3><p>获取监听器的原理和上下文初始化器一样，不过类型换成了 ApplicationListener。</p>
<pre><code class="properties"># Application Listeners
org.springframework.context.ApplicationListener=\
org.springframework.boot.ClearCachesApplicationListener,\
org.springframework.boot.builder.ParentContextCloserApplicationListener,\
org.springframework.boot.context.FileEncodingApplicationListener,\
org.springframework.boot.context.config.AnsiOutputApplicationListener,\
org.springframework.boot.context.config.ConfigFileApplicationListener,\
org.springframework.boot.context.config.DelegatingApplicationListener,\
org.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\
org.springframework.boot.context.logging.LoggingApplicationListener,\
org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener
</code></pre>
<h3 id="2-5-推断主入口应用类"><a href="#2-5-推断主入口应用类" class="headerlink" title="2.5 推断主入口应用类"></a>2.5 推断主入口应用类</h3><pre><code class="java">private Class&lt;?&gt; deduceMainApplicationClass() {
   try {
      StackTraceElement[] stackTrace = new RuntimeException().getStackTrace();
      for (StackTraceElement stackTraceElement : stackTrace) {
         if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) {
            return Class.forName(stackTraceElement.getClassName());
         }
      }
   }
   catch (ClassNotFoundException ex) {
      // Swallow and continue
   }
   return null;
}
</code></pre>
<p>通过构造一个运行时异常，再遍历异常栈中的方法名，获取方法名为 main 的栈帧，从来得到入口类的名字再返回该类。</p>
<p>应用程序的主入口 Spring boot 并不知道，通过模拟一个异常栈，根据异常栈中的元素找出 main 方法，通过这种方式获取入口应用类。</p>
<h2 id="3-运行应用实例"><a href="#3-运行应用实例" class="headerlink" title="3 运行应用实例"></a>3 运行应用实例</h2><p>上面分析了创建 SpringApplication 实例的过程，下面分析实例创建后是如何被启动的。</p>
<pre><code class="java">public ConfigurableApplicationContext run(String... args) {
   // 3.1 创建并启动计时监控类
   StopWatch stopWatch = new StopWatch();
   stopWatch.start();
   // 初始化应用上下文和异常报告集合
   ConfigurableApplicationContext context = null;
   Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;();
   // 3.2 设置系统属性 `java.awt.headless` 的值，默认值为：true
   configureHeadlessProperty();
   // 3.3 创建所有 Spring 运行监听器并发布应用启动事件
   SpringApplicationRunListeners listeners = getRunListeners(args);
   listeners.starting();

   try {
      // 3.4 初始化默认应用参数类
      ApplicationArguments applicationArguments = new DefaultApplicationArguments(
            args);
      // 3.5 根据运行监听器和应用参数来准备 Spring 环境
      ConfigurableEnvironment environment = prepareEnvironment(listeners,
            applicationArguments);
      // 根据 spring.beaninfo.ignore 配置忽略 bean
      configureIgnoreBeanInfo(environment);
      // 3.6 创建 Banner 打印类 
      Banner printedBanner = printBanner(environment);

      // 3.7 创建应用上下文
      context = createApplicationContext();

      // 准备异常报告器
      exceptionReporters = getSpringFactoriesInstances(
            SpringBootExceptionReporter.class,
            new Class[] { ConfigurableApplicationContext.class }, context);

      // 3.8 准备应用上下文
      prepareContext(context, environment, listeners, applicationArguments,
            printedBanner);
      // 3.9 刷新应用上下文
      refreshContext(context);

      // 3.10 应用上下文刷新后置处理
      afterRefresh(context, applicationArguments);

         // 3.11 停止计时监控类
      stopWatch.stop();
      // 3.12 输出日志记录执行主类名、时间信息
      if (this.logStartupInfo) {
         new StartupInfoLogger(this.mainApplicationClass)
               .logStarted(getApplicationLog(), stopWatch);
      }

      // 3.13 发布应用上下文启动完成事件
      listeners.started(context);

      // 3.14 执行所有 Runner 运行器
      callRunners(context, applicationArguments);
   }
   catch (Throwable ex) {
      handleRunFailure(context, ex, exceptionReporters, listeners);
      throw new IllegalStateException(ex);
   }

   try {
      // 3.15 发布应用上下文就绪事件
      listeners.running(context);
   }
   catch (Throwable ex) {
      // 3.16 处理运行异常
      handleRunFailure(context, ex, exceptionReporters, null);
      throw new IllegalStateException(ex);
   }
   return context;
}
</code></pre>
<h3 id="3-1-创建并启动计时监控类"><a href="#3-1-创建并启动计时监控类" class="headerlink" title="3.1 创建并启动计时监控类"></a>3.1 创建并启动计时监控类</h3><pre><code class="java">StopWatch stopWatch = new StopWatch();
stopWatch.start();
</code></pre>
<p>StopWatch 的源码</p>
<pre><code class="java">public void start() throws IllegalStateException {
    start(&quot;&quot;);
}

public void start(String taskName) throws IllegalStateException {
    if (this.currentTaskName != null) {
        throw new IllegalStateException(&quot;Can&#39;t start StopWatch: it&#39;s already running&quot;);
    }
    this.currentTaskName = taskName;
    this.startTimeMillis = System.currentTimeMillis();
}
</code></pre>
<p>首先记录了当前任务的名称，默认为空字符串，然后记录当前 Spring Boot 应用启动的开始时间。</p>
<h3 id="3-2-设置系统属性-java-awt-headless"><a href="#3-2-设置系统属性-java-awt-headless" class="headerlink" title="3.2 设置系统属性 java.awt.headless"></a>3.2 设置系统属性 <code>java.awt.headless</code></h3><pre><code class="java">private void configureHeadlessProperty() {
   System.setProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, System.getProperty(
         SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, Boolean.toString(this.headless)));
}
</code></pre>
<p>设置变量 <code>Java.awt.headless = true</code> </p>
<blockquote>
<p>Java包含很多类，这些类假设有某种显示和一个附加的键盘。有时，你写的代码运行在一个没有这些的服务器上，这被称为无头模式。有时，你写的代码运行在一个没有这些的服务器上，这被称为无头模式。从Java 1.4开始，您就可以明确地告诉Java以Headless模式运行。</p>
<p><a href="https://stackoverflow.com/questions/2552371/setting-java-awt-headless-true-programmatically" target="_blank" rel="noopener">https://stackoverflow.com/questions/2552371/setting-java-awt-headless-true-programmatically</a></p>
</blockquote>
<h3 id="3-3-创建所有-Spring-运行监听器并发布应用启动事件"><a href="#3-3-创建所有-Spring-运行监听器并发布应用启动事件" class="headerlink" title="3.3 创建所有 Spring 运行监听器并发布应用启动事件"></a>3.3 创建所有 Spring 运行监听器并发布应用启动事件</h3><pre><code class="java">private SpringApplicationRunListeners getRunListeners(String[] args) {
   Class&lt;?&gt;[] types = new Class&lt;?&gt;[] { SpringApplication.class, String[].class };
   return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances(
         SpringApplicationRunListener.class, types, this, args));
}
</code></pre>
<p>创建逻辑和之前实例化初始化器和监听器的一样，一样调用的是 <code>getSpringFactoriesInstances</code> 方法来获取配置的监听器名称并实例化所有的类。</p>
<pre><code class="properties"># Run Listeners
org.springframework.boot.SpringApplicationRunListener=\
org.springframework.boot.context.event.EventPublishingRunListener
</code></pre>
<h3 id="3-4-初始化默认应用参数类"><a href="#3-4-初始化默认应用参数类" class="headerlink" title="3.4 初始化默认应用参数类"></a>3.4 初始化默认应用参数类</h3><pre><code class="java">ApplicationArguments applicationArguments = new DefaultApplicationArguments(
      args);
</code></pre>
<p>只是用一个类 DefaultApplicationArguments  包装了一下参数输入。</p>
<h3 id="3-5-根据应用参数来准备环境"><a href="#3-5-根据应用参数来准备环境" class="headerlink" title="3.5 根据应用参数来准备环境"></a>3.5 根据应用参数来准备环境</h3><pre><code class="java">ConfigurableEnvironment environment = prepareEnvironment(listeners,
      applicationArguments);
</code></pre>
<pre><code class="java">private ConfigurableEnvironment prepareEnvironment(
      SpringApplicationRunListeners listeners,
      ApplicationArguments applicationArguments) {
   // Create and configure the environment
   // 3.5.1 获取或者创建应用环境
   ConfigurableEnvironment environment = getOrCreateEnvironment();
   // 3.5.2 配置应用环境
   configureEnvironment(environment, applicationArguments.getSourceArgs());
   // 发布事件
   listeners.environmentPrepared(environment);
   // 3.5.3 绑定环境
   bindToSpringApplication(environment);
   if (!this.isCustomEnvironment) {
     // 3.5.4 自定义环境转换
      environment = new EnvironmentConverter(getClassLoader())
            .convertEnvironmentIfNecessary(environment, deduceEnvironmentClass());
   }
   // 3.5.5 附加配置属性
   ConfigurationPropertySources.attach(environment);
   return environment;
}
</code></pre>
<h4 id="3-5-1-获取或者创建应用环境"><a href="#3-5-1-获取或者创建应用环境" class="headerlink" title="3.5.1 获取或者创建应用环境"></a>3.5.1 获取或者创建应用环境</h4><pre><code class="java">private ConfigurableEnvironment getOrCreateEnvironment() {
   if (this.environment != null) {
      return this.environment;
   }
   switch (this.webApplicationType) {
   case SERVLET:
      return new StandardServletEnvironment();
   case REACTIVE:
      return new StandardReactiveWebEnvironment();
   default:
      return new StandardEnvironment();
   }
}
</code></pre>
<p>根据应用类型的不同，存在3种实现:</p>
<ul>
<li>StandardServletEnvironment</li>
<li>StandardReactiveWebEnvironment </li>
<li>StandardEnvironment </li>
</ul>
<p>StandardServletEnvironment、StandardReactiveWebEnvironment 都是继承于 StandardEnvironment，用于管理系统环境变量以及配置文件。</p>
<p>Environment 对象就是存放我们设置的 profile 信息，默认为 default。</p>
<h4 id="3-5-2-配置应用环境"><a href="#3-5-2-配置应用环境" class="headerlink" title="3.5.2 配置应用环境"></a>3.5.2 配置应用环境</h4><pre><code class="java">configureEnvironment(environment, applicationArguments.getSourceArgs());
</code></pre>
<p>使用刚刚创建的环境对象管理环境参数。</p>
<pre><code class="java">protected void configureEnvironment(ConfigurableEnvironment environment,
      String[] args) {
   // 3.5.2.1 配置转换服务
   if (this.addConversionService) {
      ConversionService conversionService = ApplicationConversionService
            .getSharedInstance();
      environment.setConversionService(
            (ConfigurableConversionService) conversionService);
   }
   // 3.5.2.2 配置属性资源
   configurePropertySources(environment, args);
   // 3.5.2.3 配置 profiles
   configureProfiles(environment, args);
}
</code></pre>
<h5 id="3-5-2-1-配置转换服务"><a href="#3-5-2-1-配置转换服务" class="headerlink" title="3.5.2.1 配置转换服务"></a>3.5.2.1 配置转换服务</h5><p>addConversionService 默认为 true，提供一个数据类型转换服务。在配置文件中大多是使用字符串，帮我们转换成容易使用的数据类型，例如 duration 这类的配置可以被转换成数值。</p>
<p>getSharedInstance() 是一个单例实现，用于组合各种数据类型的转换器、文本解析器，可以学习一下。</p>
<pre><code class="java">public static ConversionService getSharedInstance() {
   ApplicationConversionService sharedInstance = ApplicationConversionService.sharedInstance;
   if (sharedInstance == null) {
      synchronized (ApplicationConversionService.class) {
         sharedInstance = ApplicationConversionService.sharedInstance;
         if (sharedInstance == null) {
            sharedInstance = new ApplicationConversionService();
            ApplicationConversionService.sharedInstance = sharedInstance;
         }
      }
   }
   return sharedInstance;
}
</code></pre>
<p>ApplicationConversionService 注册了大量的转换器，确保配置被合理的转换成特定的数据类型。</p>
<pre><code class="java">public static void addApplicationConverters(ConverterRegistry registry) {
   addDelimitedStringConverters(registry);
   registry.addConverter(new StringToDurationConverter());
   registry.addConverter(new DurationToStringConverter());
   registry.addConverter(new NumberToDurationConverter());
   registry.addConverter(new DurationToNumberConverter());
   registry.addConverter(new StringToDataSizeConverter());
   registry.addConverter(new NumberToDataSizeConverter());
   registry.addConverterFactory(new StringToEnumIgnoringCaseConverterFactory());
}
</code></pre>
<p>addDelimitedStringConverters 中包含了大量逗号分隔符的转换器，用于将逗号分隔的字符串转换成集合。</p>
<pre><code class="java">public static void addDelimitedStringConverters(ConverterRegistry registry) {
   ConversionService service = (ConversionService) registry;
   registry.addConverter(new ArrayToDelimitedStringConverter(service));
   registry.addConverter(new CollectionToDelimitedStringConverter(service));
   registry.addConverter(new DelimitedStringToArrayConverter(service));
   registry.addConverter(new DelimitedStringToCollectionConverter(service));
}

</code></pre>
<p>有一些专门的解析和生成字符串类的格式化器，具有格式化成字符串、解析字符串的能力。</p>
<pre><code class="java">public static void addApplicationFormatters(FormatterRegistry registry) {
   registry.addFormatter(new CharArrayFormatter());
   registry.addFormatter(new InetAddressFormatter());
   registry.addFormatter(new IsoOffsetFormatter());
}
</code></pre>
<p>转换器和格式化器继承的父类和实现的接口不太一样。</p>
<p><img src="/Spring/spring/spring-boot-workflow/image-20200405145057079.png" alt="image-20200405145057079"></p>
<center>（转换器）<center><br><img src="/Spring/spring/spring-boot-workflow/image-20200405145258465.png" alt="image-20200405145258465"><br><br><center>(格式化器)</center>

<h5 id="3-5-2-2-配置属性资源"><a href="#3-5-2-2-配置属性资源" class="headerlink" title="3.5.2.2 配置属性资源"></a>3.5.2.2 配置属性资源</h5><pre><code class="java">protected void configurePropertySources(ConfigurableEnvironment environment,
      String[] args) {
   MutablePropertySources sources = environment.getPropertySources();
   if (this.defaultProperties != null &amp;&amp; !this.defaultProperties.isEmpty()) {
      sources.addLast(
            new MapPropertySource(&quot;defaultProperties&quot;, this.defaultProperties));
   }
   if (this.addCommandLineProperties &amp;&amp; args.length &gt; 0) {
      String name = CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME;
      if (sources.contains(name)) {
         PropertySource&lt;?&gt; source = sources.get(name);
         CompositePropertySource composite = new CompositePropertySource(name);
         composite.addPropertySource(new SimpleCommandLinePropertySource(
               &quot;springApplicationCommandLineArgs&quot;, args));
         composite.addPropertySource(source);
         sources.replace(name, composite);
      }
      else {
         sources.addFirst(new SimpleCommandLinePropertySource(args));
      }
   }
}
</code></pre>
<p>这里将命令行中的配置添加到，配置列表中，因为 spring boot 支持各种各样的配置来源，因此需要做大量类似的工作。这里根据命令行参数添加了 <code>SimpleCommandLinePropertySource</code>配置来源。</p>
<p>参考 <a href="https://docs.spring.io/spring-boot/docs/2.2.6.RELEASE/reference/htmlsingle/#boot-features-external-config" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.2.6.RELEASE/reference/htmlsingle/#boot-features-external-config</a></p>
<h5 id="3-5-2-3-配置-profiles"><a href="#3-5-2-3-配置-profiles" class="headerlink" title="3.5.2.3 配置 profiles"></a>3.5.2.3 配置 profiles</h5><pre><code class="java">protected void configureProfiles(ConfigurableEnvironment environment, String[] args) {
   environment.getActiveProfiles(); // ensure they are initialized
   // But these ones should go first (last wins in a property key clash)
   Set&lt;String&gt; profiles = new LinkedHashSet&lt;&gt;(this.additionalProfiles);
   profiles.addAll(Arrays.asList(environment.getActiveProfiles()));
   environment.setActiveProfiles(StringUtils.toStringArray(profiles));
}
</code></pre>
<p>通过获取到的 profiles 信息，设置当前激活的 profiles。</p>
<h4 id="3-5-3-绑定配置信息到对象上"><a href="#3-5-3-绑定配置信息到对象上" class="headerlink" title="3.5.3 绑定配置信息到对象上"></a>3.5.3 绑定配置信息到对象上</h4><pre><code class="java">protected void bindToSpringApplication(ConfigurableEnvironment environment) {
   try {
      Binder.get(environment).bind(&quot;spring.main&quot;, Bindable.ofInstance(this));
   }
   catch (Exception ex) {
      throw new IllegalStateException(&quot;Cannot bind to SpringApplication&quot;, ex);
   }
}
</code></pre>
<p>pringboot 2.x新引入的类，负责处理对象与多个 ConfigurationPropertySource（属性）之间的绑定，可以将多个配置属性绑定到类的属性上，这里面的内容比较复杂，不再过深入展开。</p>
<h4 id="3-5-4-自定义环境转换"><a href="#3-5-4-自定义环境转换" class="headerlink" title="3.5.4 自定义环境转换"></a>3.5.4 自定义环境转换</h4><pre><code class="java">if (!this.isCustomEnvironment) {
   environment = new EnvironmentConverter(getClassLoader())
         .convertEnvironmentIfNecessary(environment, deduceEnvironmentClass());
}
</code></pre>
<p>如果在最开始传入的 environment 对象不是 deduceEnvironmentClass() 中的三种之一，那么需要转换，默认为关闭状态。</p>
<pre><code class="java">private Class&lt;? extends StandardEnvironment&gt; deduceEnvironmentClass() {
   switch (this.webApplicationType) {
   case SERVLET:
      return StandardServletEnvironment.class;
   case REACTIVE:
      return StandardReactiveWebEnvironment.class;
   default:
      return StandardEnvironment.class;
   }
}
</code></pre>
<h4 id="3-5-5-附加配置属性"><a href="#3-5-5-附加配置属性" class="headerlink" title="3.5.5 附加配置属性"></a>3.5.5 附加配置属性</h4><pre><code class="java">public static void attach(Environment environment) {
   Assert.isInstanceOf(ConfigurableEnvironment.class, environment);
   MutablePropertySources sources = ((ConfigurableEnvironment) environment)
         .getPropertySources();
   PropertySource&lt;?&gt; attached = sources.get(ATTACHED_PROPERTY_SOURCE_NAME);
   if (attached != null &amp;&amp; attached.getSource() != sources) {
      sources.remove(ATTACHED_PROPERTY_SOURCE_NAME);
      attached = null;
   }
   if (attached == null) {
      sources.addFirst(new ConfigurationPropertySourcesPropertySource(
            ATTACHED_PROPERTY_SOURCE_NAME,
            new SpringConfigurationPropertySources(sources)));
   }
}
</code></pre>
<p>TODO 这段代码还不知道干嘛用的，尤其是 SpringConfigurationPropertySources 这个类</p>
<h3 id="3-6-创建-Banner-打印类"><a href="#3-6-创建-Banner-打印类" class="headerlink" title="3.6 创建 Banner 打印类"></a>3.6 创建 Banner 打印类</h3><pre><code class="java">private Banner printBanner(ConfigurableEnvironment environment) {
   if (this.bannerMode == Banner.Mode.OFF) {
      return null;
   }
   ResourceLoader resourceLoader = (this.resourceLoader != null)
         ? this.resourceLoader : new DefaultResourceLoader(getClassLoader());
   SpringApplicationBannerPrinter bannerPrinter = new SpringApplicationBannerPrinter(
         resourceLoader, this.banner);
   if (this.bannerMode == Mode.LOG) {
      return bannerPrinter.print(environment, this.mainApplicationClass, logger);
   }
   return bannerPrinter.print(environment, this.mainApplicationClass, System.out);
}
</code></pre>
<p>打印一个 banner 信息，基本的逻辑就是 SpringApplicationBannerPrinter 类根据配置文件在指定的位置打印出 banner，根据 banner 输出的模式分为日志、控制台、不打印。</p>
<h3 id="3-7-创建应用上下文-核心点"><a href="#3-7-创建应用上下文-核心点" class="headerlink" title="3.7 创建应用上下文 [核心点]"></a>3.7 创建应用上下文 [核心点]</h3><pre><code class="java">protected ConfigurableApplicationContext createApplicationContext() {
   Class&lt;?&gt; contextClass = this.applicationContextClass;
   if (contextClass == null) {
      try {
         switch (this.webApplicationType) {
         case SERVLET:
            contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);
            break;
         case REACTIVE:
            contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);
            break;
         default:
            contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);
         }
      }
      catch (ClassNotFoundException ex) {
         throw new IllegalStateException(
               &quot;Unable create a default ApplicationContext, &quot;
                     + &quot;please specify an ApplicationContextClass&quot;,
               ex);
      }
   }
   return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);
}
</code></pre>
<p>非常关键的一个环节，初始化一个 Spring boot 上下文，在这个上下文中会启动 Spring 上下文，实际上在这之前还没有启动 Spring 。根据不同的应用类型初始不同的上下文，如果是一个普通 web 应用，默认初始化的是  <code>AnnotationConfigServletWebServerApplicationContext</code> 。</p>
<p>使用 BeanUtils.instantiateClass 来初始化一个类，这种初始化方法能使用 Spring 类的生命周期注解。这里默认构造了一个上下文，通过这个上下文在后面利用 spring 初始化 bean 的时候非常重要。</p>
<p>基本上这个类是 Spring boot 继承于 Spring 中的 ServletWebServerApplicationContext，ServletWebServerApplicationContext 有继承于 GenericApplicationContext。GenericApplicationContext 是一个抽象程度非常高的上下文。实现了大量与应用类型无关的 bean 操作，后面的 bean 初始化会靠它，另外一个很重要的是 这里默认初始花了一个 DefaultListableBeanFactory 作为 bean 工厂。</p>
<p><img src="/Spring/spring/spring-boot-workflow/image-20200405225010409.png" alt="image-20200405225010409"></p>
<h3 id="3-8-准备应用上下文"><a href="#3-8-准备应用上下文" class="headerlink" title="3.8 准备应用上下文"></a>3.8 准备应用上下文</h3><pre><code class="java">private void prepareContext(ConfigurableApplicationContext context,
      ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,
      ApplicationArguments applicationArguments, Banner printedBanner) {
   // 设置环境信息
   context.setEnvironment(environment);
   // 3.8.1 配置 bean 生成器和资源加载器
   postProcessApplicationContext(context);
   // 3.8.2 应用所有的初始化器 
   applyInitializers(context);
   // 上下文准备完成通知
   listeners.contextPrepared(context);
   // 3.8.3 记录启动日志
   if (this.logStartupInfo) {
      logStartupInfo(context.getParent() == null);
      logStartupProfileInfo(context);
   }
   // 3.8.4 注册两个特殊的 bean 
   ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
   beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments);
   if (printedBanner != null) {
      beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner);
   }
   if (beanFactory instanceof DefaultListableBeanFactory) {
      ((DefaultListableBeanFactory) beanFactory)
            .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);
   }
   // 3.8.5 加载所有的资源 
   Set&lt;Object&gt; sources = getAllSources();
   Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);
   load(context, sources.toArray(new Object[0]));
   // 通知上下文加载完成
   listeners.contextLoaded(context);
}
</code></pre>
<h4 id="3-8-1-配置-bean-生成器和资源加载器"><a href="#3-8-1-配置-bean-生成器和资源加载器" class="headerlink" title="3.8.1 配置 bean 生成器和资源加载器"></a>3.8.1 配置 bean 生成器和资源加载器</h4><pre><code class="java">protected void postProcessApplicationContext(ConfigurableApplicationContext context) {
   if (this.beanNameGenerator != null) {
      context.getBeanFactory().registerSingleton(
            AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR,
            this.beanNameGenerator);
   }
   if (this.resourceLoader != null) {
      if (context instanceof GenericApplicationContext) {
         ((GenericApplicationContext) context)
               .setResourceLoader(this.resourceLoader);
      }
      if (context instanceof DefaultResourceLoader) {
         ((DefaultResourceLoader) context)
               .setClassLoader(this.resourceLoader.getClassLoader());
      }
   }
   if (this.addConversionService) {
      context.getBeanFactory().setConversionService(
            ApplicationConversionService.getSharedInstance());
   }
}
</code></pre>
<h4 id="3-8-2-应用所有的初始化器"><a href="#3-8-2-应用所有的初始化器" class="headerlink" title="3.8.2 应用所有的初始化器"></a>3.8.2 应用所有的初始化器</h4><pre><code class="java">protected void applyInitializers(ConfigurableApplicationContext context) {
   for (ApplicationContextInitializer initializer : getInitializers()) {
      Class&lt;?&gt; requiredType = GenericTypeResolver.resolveTypeArgument(
            initializer.getClass(), ApplicationContextInitializer.class);
      Assert.isInstanceOf(requiredType, context, &quot;Unable to call initializer.&quot;);
      initializer.initialize(context);
   }
}
</code></pre>
<p>这一步会把所有符合条件的 ApplicationContextInitializer 应用一遍，实际上 spring boot 的主要启动过程都在这几个 ApplicationContextInitializer 中。</p>
<p>前面讲过，spring boot 是如何将需要的类加载进来，这里需要说明下几个主要的初始化器的功能。</p>
<p>我在调试时主要有这几个：</p>
<pre><code>org.springframework.boot.devtools.restart.RestartScopeInitializer
org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer
org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener
org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer
org.springframework.boot.context.ContextIdApplicationContextInitializer
org.springframework.boot.context.config.DelegatingApplicationContextInitializer
org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer
</code></pre><p><strong>RestartScopeInitializer</strong></p>
<p>主要是注册了一个 restart 的 bean scope 用热重载。</p>
<pre><code class="java">public void initialize(ConfigurableApplicationContext applicationContext) {
   applicationContext.getBeanFactory().registerScope(&quot;restart&quot;, new RestartScope());
}
</code></pre>
<p>在 RestartScope 中使用了 Restarter 来刷新应用。</p>
<p>TODO </p>
<h4 id="3-8-3-记录启动日志"><a href="#3-8-3-记录启动日志" class="headerlink" title="3.8.3 记录启动日志"></a>3.8.3 记录启动日志</h4><p>创建了一个日志类，将日志打出</p>
<pre><code class="java">new StartupInfoLogger(this.mainApplicationClass)
      .logStarting(getApplicationLog());
</code></pre>
<pre><code class="java">public void logStarting(Log log) {
   Assert.notNull(log, &quot;Log must not be null&quot;);
   if (log.isInfoEnabled()) {
      log.info(getStartupMessage());
   }
   if (log.isDebugEnabled()) {
      log.debug(getRunningMessage());
   }
}
</code></pre>
<p> 先判断日志是否开启 <code>log.isInfoEnabled</code>() 是为了提高性能，如果开启 info 会打出启动信息。只有开启 debug 级别的日志，才会打出运行时信息。</p>
<pre><code>logStartupProfileInfo(context);
</code></pre><p>接下来打印 profile 的日志信息，如果没有设置 profile，也就是会显示我们平时看到的 </p>
<blockquote>
<p>No active profile set, falling back to default profiles: default</p>
</blockquote>
<h4 id="3-8-4-注册两个特殊的-bean"><a href="#3-8-4-注册两个特殊的-bean" class="headerlink" title="3.8.4 注册两个特殊的 bean"></a>3.8.4 注册两个特殊的 bean</h4><pre><code class="java">ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments);
if (printedBanner != null) {
   beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner);
}
if (beanFactory instanceof DefaultListableBeanFactory) {
   ((DefaultListableBeanFactory) beanFactory)
         .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);
}
</code></pre>
<p>这里将当前使用到的  <code>applicationArguments</code> 和 <code>springBootBanner</code>  注册成单例，用于后面需要的时候获取。通过这种方式附加到上下文中。</p>
<h4 id="3-8-5-加载所有的资源-包扫描-补充点"><a href="#3-8-5-加载所有的资源-包扫描-补充点" class="headerlink" title="3.8.5 加载所有的资源 (包扫描) [补充点]"></a>3.8.5 加载所有的资源 (包扫描) [补充点]</h4><pre><code class="java">        // 3.8.5.1 加载包扫描资源类
    Set&lt;Object&gt; sources = getAllSources();
        Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);
    // 3.8.5.2 包扫描
        load(context, sources.toArray(new Object[0]));
        listeners.contextLoaded(context);
</code></pre>
<h5 id="3-8-5-1-加载包扫描资源类"><a href="#3-8-5-1-加载包扫描资源类" class="headerlink" title="3.8.5.1 加载包扫描资源类"></a>3.8.5.1 加载包扫描资源类</h5><pre><code class="java">public Set&lt;Object&gt; getAllSources() {
   Set&lt;Object&gt; allSources = new LinkedHashSet&lt;&gt;();
   if (!CollectionUtils.isEmpty(this.primarySources)) {
      allSources.addAll(this.primarySources);
   }
   if (!CollectionUtils.isEmpty(this.sources)) {
      allSources.addAll(this.sources);
   }
   return Collections.unmodifiableSet(allSources);
}
</code></pre>
<p>˙这里的 primarySources 就是指的 run 方法传入的类，spring boot 会根据资源类所在的包进行扫描。加载各种业务对象。因此可以在入口类中，可以做一些拓展，主动加载其他资源，甚至远程资源。</p>
<h5 id="3-8-5-2-包扫描"><a href="#3-8-5-2-包扫描" class="headerlink" title="3.8.5.2 包扫描"></a>3.8.5.2 包扫描</h5><pre><code class="java">protected void load(ApplicationContext context, Object[] sources) {
   if (logger.isDebugEnabled()) {
      logger.debug(
            &quot;Loading source &quot; + StringUtils.arrayToCommaDelimitedString(sources));
   }
   // 初始化 bean 加载器
   BeanDefinitionLoader loader = createBeanDefinitionLoader(
         getBeanDefinitionRegistry(context), sources);
   if (this.beanNameGenerator != null) {
      loader.setBeanNameGenerator(this.beanNameGenerator);
   }
   if (this.resourceLoader != null) {
      loader.setResourceLoader(this.resourceLoader);
   }
   if (this.environment != null) {
      loader.setEnvironment(this.environment);
   }
   // 最终的初始化类的地方
   loader.load();
}

// 下面调用了 BeanDefinitionLoader 的构造方法
protected BeanDefinitionLoader createBeanDefinitionLoader(
      BeanDefinitionRegistry registry, Object[] sources) {
   return new BeanDefinitionLoader(registry, sources);
}
</code></pre>
<pre><code class="java"> // BeanDefinitionLoader 实际上是一个简单的外观模式，包装了 Spring 中初始化 bean 的常用方法
 BeanDefinitionLoader(BeanDefinitionRegistry registry, Object... sources) {
        Assert.notNull(registry, &quot;Registry must not be null&quot;);
        Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);
        this.sources = sources;
    // 基于注解的 bean 阅读器
        this.annotatedReader = new AnnotatedBeanDefinitionReader(registry);
        this.xmlReader = new XmlBeanDefinitionReader(registry);
        if (isGroovyPresent()) {
            this.groovyReader = new GroovyBeanDefinitionReader(registry);
        }
    // 类扫描器
        this.scanner = new ClassPathBeanDefinitionScanner(registry);
        this.scanner.addExcludeFilter(new ClassExcludeFilter(sources));
    }
</code></pre>
<p>这里就是 spring boot 利用 spring 初始化各种类的核心了。通过 BeanDefinitionLoader 包装 spring 中的 bean 实例化工具，初始化各种对象。</p>
<p>当所有的准备工作做完后，通过调用 loader.load(); 初始化各种 bean 。</p>
<pre><code class="java">// 多资源加载
public int load() {
   int count = 0;
   for (Object source : this.sources) {
      count += load(source);
   }
   return count;
}

// 某个资源，一般这个资源是根目录下的一个类，例如 Application.class 但是 Spring 也是支持各种加载方式。
private int load(Object source) {
   Assert.notNull(source, &quot;Source must not be null&quot;);
   // 一般都会走这里
   if (source instanceof Class&lt;?&gt;) {
      return load((Class&lt;?&gt;) source);
   }
   if (source instanceof Resource) {
      return load((Resource) source);
   }
   if (source instanceof Package) {
      return load((Package) source);
   }
   if (source instanceof CharSequence) {
      return load((CharSequence) source);
   }
   throw new IllegalArgumentException(&quot;Invalid source type &quot; + source.getClass());
}


private int load(Class&lt;?&gt; source) {
        if (isGroovyPresent()
                &amp;&amp; GroovyBeanDefinitionSource.class.isAssignableFrom(source)) {
            // Any GroovyLoaders added in beans{} DSL can contribute beans here
            GroovyBeanDefinitionSource loader = BeanUtils.instantiateClass(source,
                    GroovyBeanDefinitionSource.class);
            load(loader);
        }
        if (isComponent(source)) {
            this.annotatedReader.register(source);
            return 1;
        }
        return 0;
}
</code></pre>
<p>isComponent 是用来排除匿名类等特殊情况，一般来说都会为 true，然后进入 </p>
<pre><code class="java">this.annotatedReader.register(source);
</code></pre>
<p>到了这里就已经是 Spring 的地盘了，spring boot 的工作完成了，交给 spring 去初始化各种对象了。</p>
<h3 id="3-9-刷新-初始化-应用上下文-spring-核心"><a href="#3-9-刷新-初始化-应用上下文-spring-核心" class="headerlink" title="3.9 刷新(初始化)应用上下文 [spring 核心]"></a>3.9 刷新(初始化)应用上下文 [spring 核心]</h3><pre><code class="java">protected void refresh(ApplicationContext applicationContext) {
   Assert.isInstanceOf(AbstractApplicationContext.class, applicationContext);
   ((AbstractApplicationContext) applicationContext).refresh();
}
</code></pre>
<p>spring boot 把 context 作为 applicationContext 传入，然后转换成 AbstractApplicationContext 调用 spring 的refresh() 开启 bean 初始化的流程。</p>
<p>spring 的 refresh 实际上就是初始化 bean，为什么是 refresh()，而不是 init()，这个名字非常奇怪。实际上，spring 的 refresh 不仅仅对新的 context 有用，对旧的 context 会销毁重建，因此 refresh 这个词更适中。</p>
<pre><code class="java">@Override
public void refresh() throws BeansException, IllegalStateException {
   // 加锁，防止多次启动或者销毁操作造成混乱
   synchronized (this.startupShutdownMonitor) {
      // 3.9.1 准备刷新，记录启动时间、状态
      prepareRefresh();

      // 3.9.2 提取 bean 的配置
      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

      // 3.9.3 准备 Bean 容器
      prepareBeanFactory(beanFactory);

      try {
         // 3.9.4 后置处理 bean 工厂
         postProcessBeanFactory(beanFactory);

         // 3.9.5 调用工厂后置处理器
         invokeBeanFactoryPostProcessors(beanFactory);

         // 3.9.6 注册 bean 后置处理器
         registerBeanPostProcessors(beanFactory);

         // 3.9.7 初始化国际化消息
         initMessageSource();

         // 3.9.8 初始化事件广播器
         initApplicationEventMulticaster();

         // 3.9.9 onRefresh 钩子
         onRefresh();

         // 注册监听器
         registerListeners();

         // 3.9.10 初始化所有的 singleton beans
         finishBeanFactoryInitialization(beanFactory);

         // 广播事件，启动 web 服务器
         finishRefresh();
      }

      catch (BeansException ex) {
         if (logger.isWarnEnabled()) {
            logger.warn(&quot;Exception encountered during context initialization - &quot; +
                  &quot;cancelling refresh attempt: &quot; + ex);
         }

         // 3.9.11 销毁已经初始化的 singleton 的 Beans 
         destroyBeans();

         // 设置初始话状态
         cancelRefresh(ex);

         // 往外丢异常
         throw ex;
      }

      finally {
         // 3.9.12 清理构建过程中的对象缓存
         resetCommonCaches();
      }
   }
}
</code></pre>
<p>这部分就是 spring 容器初始化的核心逻辑了，spring 更多细节可以查看其他材料。</p>
<p>推荐材料：<a href="https://www.javadoop.com/post/spring-ioc" target="_blank" rel="noopener">https://www.javadoop.com/post/spring-ioc</a></p>
<h5 id="3-9-1-准备刷新，记录启动时间、状态"><a href="#3-9-1-准备刷新，记录启动时间、状态" class="headerlink" title="3.9.1 准备刷新，记录启动时间、状态"></a>3.9.1 准备刷新，记录启动时间、状态</h5><pre><code class="java">protected void prepareRefresh() {
   // 设置状态和时间
   this.startupDate = System.currentTimeMillis();
   this.closed.set(false);
   this.active.set(true);

   if (logger.isDebugEnabled()) {
      if (logger.isTraceEnabled()) {
         logger.trace(&quot;Refreshing &quot; + this);
      }
      else {
         logger.debug(&quot;Refreshing &quot; + getDisplayName());
      }
   }

   // 空方法，留给子类初始化配置
   initPropertySources();

   // 验证必要的属性
   getEnvironment().validateRequiredProperties();

   // 将 applicationListeners 用 earlyApplicationListeners 包裹起来
   if (this.earlyApplicationListeners == null) {
      this.earlyApplicationListeners = new LinkedHashSet&lt;&gt;(this.applicationListeners);
   }
   else {
      this.applicationListeners.clear();
      this.applicationListeners.addAll(this.earlyApplicationListeners);
   }
   this.earlyApplicationEvents = new LinkedHashSet&lt;&gt;();
</code></pre>
<h5 id="3-9-2-提取-bean-的配置"><a href="#3-9-2-提取-bean-的配置" class="headerlink" title="3.9.2 提取 bean 的配置"></a>3.9.2 提取 bean 的配置</h5><pre><code class="java">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
   // 关闭旧的 BeanFactory 重新加载 bean 信息。
   refreshBeanFactory();

   // 返回刚刚创建的 BeanFactory
   ConfigurableListableBeanFactory beanFactory = getBeanFactory();
   if (logger.isDebugEnabled()) {
      logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);
   }
   return beanFactory;
}


</code></pre>
<p>需要特别注意这句代码，refreshBeanFactory 是 ConfigurableApplicationContext 的接口，最终实现主要是两个类： GenericApplicationContext、AbstractRefreshableApplicationContext。</p>
<p>我们使用 Spring boot 走注解方式配置，使用的是 GenericApplicationContext ，而 xml 相关使用的是 AbstractRefreshableApplicationContext。他们在 refreshBeanFactory 方法实现上差异较大。</p>
<p>需要注意，我们现在通过 spring boot 分析，走的是注解这边。</p>
<p><img src="/Spring/spring/spring-boot-workflow/image-20200406094251066.png" alt="image-20200406094251066"></p>
<h5 id="3-9-3-准备-Bean-容器"><a href="#3-9-3-准备-Bean-容器" class="headerlink" title="3.9.3 准备 Bean 容器"></a>3.9.3 准备 Bean 容器</h5><p>这里为 bean 工厂准备一些必要的组件，例如加载后置处理器、类加载器、依赖处理器（spring 支持双向依赖）等。 这里的 bean 工厂一般是 DefaultListableBeanFactory，DefaultListableBeanFactory 是在前面创建应用上下文就创建好了的。基本上在 Spring 中最牛的就是 DefaultListableBeanFactory 了。</p>
<pre><code class="java">protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
        // Tell the internal bean factory to use the context&#39;s class loader etc.
    // 设置 BeanFactory 的类加载器
        beanFactory.setBeanClassLoader(getClassLoader());
    // 设置 EL 表达式处理器
        beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
    // 设置属性编辑器
        beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));

        // 设置后置处理器, ApplicationContextAwareProcessor 可以自定定义，也可以使用注解，又属于 spring 拓展点之一。我们可以通过 ApplicationContextAware 获取 ApplicationContext。
        beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(th    is));

    // 自动装配的时候忽略,这几个类比较特殊
        beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
        beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
        beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
        beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
        beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
        beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);

        // 特殊的依赖注入，因为这几个 bean 是作为 spring 关键组件，就是容器本身。用 registerResolvableDependency 这种方式注入。MessageSource 作为普通的 bean 被注入到容器中。
        // MessageSource registered (and found for autowiring) as a bean.
        beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
        beanFactory.registerResolvableDependency(ResourceLoader.class, this);
        beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
        beanFactory.registerResolvableDependency(ApplicationContext.class, this);

        // 在 bean 实例化后，如果是 ApplicationListener 的子类，会被注册到监听器中。细节有 ApplicationListenerDetector 处理。
        beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));

        // 如果存在 AOP 的bean，在运行期织入。任务由 LoadTimeWeaverAwareProcessor 完成。
        if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
            beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
            // Set a temporary ClassLoader for type matching.
            beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
        }

        // 注册默认的环境相关的 bean，的 bean 被直接注入到容器中。
    // environment 
        if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
            beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
        }
    // systemProperties
        if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
            beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
        }
    // systemEnvironment
        if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
            beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
        }
    }
</code></pre>
<h5 id="3-9-4-后置处理-bean-工厂"><a href="#3-9-4-后置处理-bean-工厂" class="headerlink" title="3.9.4 后置处理 bean 工厂"></a>3.9.4 后置处理 bean 工厂</h5><p>对我们的 bean 工厂后置处理，也就是 AnnotationConfigServletWebServerApplicationContext 中的 postProcessBeanFactory 方法。这个是前面检测应用类型决定的。</p>
<pre><code class="java">@Override
protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
   super.postProcessBeanFactory(beanFactory);
   if (this.basePackages != null &amp;&amp; this.basePackages.length &gt; 0) {
      this.scanner.scan(this.basePackages);
   }
   if (!this.annotatedClasses.isEmpty()) {
      this.reader.register(ClassUtils.toClassArray(this.annotatedClasses));
   }
}
</code></pre>
<p>如果没有包扫描，会再去进行包扫描。从批判的眼光来看，spring 有很多重复代码，前面实际上完成了 包扫描的任务的。</p>
<h5 id="3-9-5-调用工厂后置处理器-补充点"><a href="#3-9-5-调用工厂后置处理器-补充点" class="headerlink" title="3.9.5 调用工厂后置处理器 [补充点]"></a>3.9.5 调用工厂后置处理器 [补充点]</h5><p>这里是真正的调用后置处理器，也就是业务中自定义的处理器，在这里完成。注意，这里实在最终 bean 实例化完成之前调用的，另外需要注意后置处理器会按照顺序调用 。</p>
<pre><code class="java">protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
   PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());

   // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
   // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
   if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
   }
}
</code></pre>
<p>最为关键的方法是 PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors ，基本原理就是拿到所有的后置处理器，然后在这里循环执行。</p>
<p>为了不打乱主线思路，这里在 Spring IOC 的地方拆开讨论。</p>
<h5 id="3-9-6-注册-Bean-后置处理器"><a href="#3-9-6-注册-Bean-后置处理器" class="headerlink" title="3.9.6 注册 Bean 后置处理器"></a>3.9.6 注册 Bean 后置处理器</h5><p>这里有一连串的后置处理，实际上都不一样：</p>
<pre><code class="java">            // 后置处理 bean 工厂，这里是子类钩子方法
            postProcessBeanFactory(beanFactory);

            // 调用 bean 工厂后置处理器,这里是一个工厂处理器的责任链循环调用
            invokeBeanFactoryPostProcessors(beanFactory);

            // 调用 bean 自身的后置处理器,这里是一个 bean 后置处理器的责任链循环调用
            registerBeanPostProcessors(beanFactory);
</code></pre>
<pre><code class="java">protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {
   PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);
}
</code></pre>
<p>这里又到了复杂的 IOC 逻辑，这里只是注册，后面才会调用。registerBeanPostProcessors 的主要职责就是</p>
<ol>
<li>获取 bean name </li>
<li>排序</li>
<li>添加到一个数组中</li>
</ol>
<h5 id="3-9-7-初始化国际化消息"><a href="#3-9-7-初始化国际化消息" class="headerlink" title="3.9.7 初始化国际化消息"></a>3.9.7 初始化国际化消息</h5><p>​    </p>
<pre><code class="java">protected void initMessageSource() {
   ConfigurableListableBeanFactory beanFactory = getBeanFactory();
   if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) {
      this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);
      // Make MessageSource aware of parent MessageSource.
      if (this.parent != null &amp;&amp; this.messageSource instanceof HierarchicalMessageSource) {
         HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource;
         if (hms.getParentMessageSource() == null) {
            // Only set parent context as parent MessageSource if no parent MessageSource
            // registered already.
            hms.setParentMessageSource(getInternalParentMessageSource());
         }
      }
      if (logger.isTraceEnabled()) {
         logger.trace(&quot;Using MessageSource [&quot; + this.messageSource + &quot;]&quot;);
      }
   }
   else {
      // Use empty MessageSource to be able to accept getMessage calls.
      DelegatingMessageSource dms = new DelegatingMessageSource();
      dms.setParentMessageSource(getInternalParentMessageSource());
      this.messageSource = dms;
      beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);
      if (logger.isTraceEnabled()) {
         logger.trace(&quot;No &#39;&quot; + MESSAGE_SOURCE_BEAN_NAME + &quot;&#39; bean, using [&quot; + this.messageSource + &quot;]&quot;);
      }
   }
}
</code></pre>
<p>这部分逻辑比较简单，如果有注册 messageSource 就设置 messageSource ，没有就设置一个空的，防止方法调用失败，以及打出日志。</p>
<h5 id="3-9-8-onRefresh-钩子-启动-web-服务-补充点"><a href="#3-9-8-onRefresh-钩子-启动-web-服务-补充点" class="headerlink" title="3.9.8 onRefresh 钩子,启动 web 服务 [补充点]"></a>3.9.8 onRefresh 钩子,启动 web 服务 [补充点]</h5><p>这个方法对于非 web 项目无所谓，但是对于 web 项目非常重要，因为在 ServletWebServerApplicationContext 中，会在这个时候启动 web 服务器，默认是内置的 Tomecat。</p>
<pre><code class="java">@Override
protected void onRefresh() {
   // 父类会初始话一个 themeSource 
   super.onRefresh();
   try {
      createWebServer();
   }
   catch (Throwable ex) {
      throw new ApplicationContextException(&quot;Unable to start web server&quot;, ex);
   }
}
</code></pre>
<pre><code class="java">private void createWebServer() {
   WebServer webServer = this.webServer;
   // 获取 servlet 上下文
   ServletContext servletContext = getServletContext();
   if (webServer == null &amp;&amp; servletContext == null) {
      // 根据注册的 bean 获取 web server 工厂，实际上这里偷偷提前初始化了一个 bean 就是factory。因为 getWebServerFactory 是通过 beanFactory.getBean 和 名字获取的。beanFactory.getBean 实际上就是在初始化 bean。
      ServletWebServerFactory factory = getWebServerFactory();
      this.webServer = factory.getWebServer(getSelfInitializer());
   }
   else if (servletContext != null) {
      try {
         // 启动 web server，只是针对 servletContext 存在的情况，新建的 context不需要监听
         getSelfInitializer().onStartup(servletContext);
      }
      catch (ServletException ex) {
         throw new ApplicationContextException(&quot;Cannot initialize servlet context&quot;, ex);
      }
   }
   // 初始化 servletContext 中的配置信息 
   initPropertySources();
}
</code></pre>
<p>这里面涉及内置 web 服务器如果被创建出来，非常有趣，但是范围太大了，在后面展开。基本的逻辑就是根据工厂调用 Tomcat 的入口方法然后写入一些配置。</p>
<pre><code class="java">public WebServer getWebServer(ServletContextInitializer... initializers) {
   if (this.disableMBeanRegistry) {
      Registry.disableRegistry();
   }
   // 构造 Tomecat 实例
   Tomcat tomcat = new Tomcat();
   File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir(&quot;tomcat&quot;);
   tomcat.setBaseDir(baseDir.getAbsolutePath());
   Connector connector = new Connector(this.protocol);
   connector.setThrowOnFailure(true);
   tomcat.getService().addConnector(connector);
   customizeConnector(connector);
   tomcat.setConnector(connector);
   tomcat.getHost().setAutoDeploy(false);
   configureEngine(tomcat.getEngine());
   for (Connector additionalConnector : this.additionalTomcatConnectors) {
      tomcat.getService().addConnector(additionalConnector);
   }
   prepareContext(tomcat.getHost(), initializers);
   return getTomcatWebServer(tomcat);
}
</code></pre>
<p>到目前为止，web 服务已经启动成功了从日志中能看到端口、服务器等信息。</p>
<p>留一个问题，Tomcat 是怎么知道 Spring mvc 的 Servlet 入口点的呢？</p>
<h5 id="3-9-9-初始化事件广播器-补充点"><a href="#3-9-9-初始化事件广播器-补充点" class="headerlink" title="3.9.9 初始化事件广播器 [补充点]"></a>3.9.9 初始化事件广播器 [补充点]</h5><pre><code class="java">protected void registerListeners() {
   // 获取事件通道并添加监听器，这里只是注册静态监听器，不需要 bean 初始化
   for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) {
      getApplicationEventMulticaster().addApplicationListener(listener);
   }

   // 将对象监听器添加到列表中，但是不初始化，留给后面的 post-processors 处理
   String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);
   for (String listenerBeanName : listenerBeanNames) {
      getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
   }

   // 现在有事件通道了，将早期的应用事件发送出去
   Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents;
   this.earlyApplicationEvents = null;
   if (earlyEventsToProcess != null) {
      for (ApplicationEvent earlyEvent : earlyEventsToProcess) {
         getApplicationEventMulticaster().multicastEvent(earlyEvent);
      }
   }
}
</code></pre>
<p>这个方法的主要作用是讲上下文中的监听器，添加到 applicationEventMulticaster 上，applicationEventMulticaster 是一个消息通道，用于实现监听者模式的关键角色。</p>
<h5 id="3-9-10-初始化所有的-singleton-beans-核心点"><a href="#3-9-10-初始化所有的-singleton-beans-核心点" class="headerlink" title="3.9.10 初始化所有的 singleton beans [核心点]"></a>3.9.10 初始化所有的 singleton beans [核心点]</h5><p>这一步就是初始化所有的单例 bean 了，懒加载的 bean 和其他 scope 的初始化过程并不在这里。</p>
<p>到目前为止：</p>
<ul>
<li>bean 信息已经注册完成</li>
<li>postProcessBeanFactory 已经完成</li>
<li>environment、systemProperties 已经被手动初始话</li>
<li>服务器已经启动 ，同时初始化了一个 servletFactory 的bean</li>
<li>主题已经加载</li>
<li>国际化已经初始话</li>
<li>事件通道已经就绪</li>
</ul>
<p>接下来就是完成最终的 bean 初始化。</p>
<pre><code class="java">protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
   // beanFactory.getBean 就是在初始化，这里优先初始化 ConversionService 前面提到了，这个是用来做类型转换的。
   if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;
         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
      beanFactory.setConversionService(
            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
   }

   // 如果没有 EmbeddedValueResolver 就配置一个默认的 EmbeddedValueResolver，这个 resolver 的目的是处理 ${}这样的属性，通过内置的 EL 上下文处理完成。
   if (!beanFactory.hasEmbeddedValueResolver()) {
      beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));
   }

   // 初始化切面相关的 bean，LoadTimeWeaverAware  类型
   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
   for (String weaverAwareName : weaverAwareNames) {
      getBean(weaverAwareName);
   }

   // 停用 TempClassLoader，这个时候类已经全部加载完成了
   beanFactory.setTempClassLoader(null);

   // 冻结掉所有的读取配置行为，不希望在这个过程中发生变化
   beanFactory.freezeConfiguration();

   // 初始化所有的剩下的非懒加载的 bean，根据 bean 定义数组中的类名，循环调用 getBean 初始化
   beanFactory.preInstantiateSingletons();
}
</code></pre>
<p><strong>TempClassLoader 说明</strong></p>
<p>TempClassLoader 的用处是 匹配类型，默认是空，简单的使用标准的类加载器。临时类加载器只是检查是不是一个运行时切面被应用了，然后尽可能的延迟初始化。临时类加载器在启动过程完成后，会被移除。</p>
<pre><code class="java">/**
 * Specify a temporary ClassLoader to use for type matching purposes.
 * Default is none, simply using the standard bean ClassLoader.
 * &lt;p&gt;A temporary ClassLoader is usually just specified if
 * &lt;i&gt;load-time weaving&lt;/i&gt; is involved, to make sure that actual bean
 * classes are loaded as lazily as possible. The temporary loader is
 * then removed once the BeanFactory completes its bootstrap phase.
 * @since 2.5
 */
</code></pre>
<p>然后就是 spring 中最难的 preInstantiateSingletons  方法了。</p>
<pre><code class="java">//代码位于 DefaultListableBeanFactory.java 

@Override
public void preInstantiateSingletons() throws BeansException {
   if (logger.isTraceEnabled()) {
      logger.trace(&quot;Pre-instantiating singletons in &quot; + this);
   }

   // 遍历一遍 beanDefinitionNames，在这个过程中还会向 beanDefinitionNames 中添加新的内容
   List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames);

   // 触发非懒加载的 bean 创建
   for (String beanName : beanNames) {
      // 合并父 Bean 中的配置，父 bean 的配置并不像 java 的继承那样，而是给一个公共的配置参数而已，这一步相当于将公共的配置参数内联到当前的 bean 定义上。
      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
      // 只有非抽象类、单例、非懒加载才需要在这个时候初始化
      if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) {
         // factoryBean 就是通过工厂方法声明的 bean，例如我们在配置数据库连接的时候 通过 @Bean 加上方法实现。factoryBean 会带上一个 &#39;&amp;&#39; 符号标明。注意 factoryBean 和 beanFactory 完全是两回事，不要搞乱了。
         // 2.9.10.1 factorybean
         if (isFactoryBean(beanName)) {
            // 2.9.10.2 bean 初始化 getBean
            Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
            if (bean instanceof FactoryBean) {
               final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;
               boolean isEagerInit;
               // 2.9.10.3 java 安全管理器
               if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) {
                  isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)
                              ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,
                        getAccessControlContext());
               }
               else {
                  isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;
                        ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());
               }
               if (isEagerInit) {
                  getBean(beanName);
               }
            }
         }
         else {
            getBean(beanName);
         }
      }
   }

   // 2.9.10.4 smartSingleton
   for (String beanName : beanNames) {
      Object singletonInstance = getSingleton(beanName);
      if (singletonInstance instanceof SmartInitializingSingleton) {
         final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
         if (System.getSecurityManager() != null) {
            AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
               smartSingleton.afterSingletonsInstantiated();
               return null;
            }, getAccessControlContext());
         }
         else {
            smartSingleton.afterSingletonsInstantiated();
         }
      }
   }
}
</code></pre>
<h6 id="2-9-10-1-factorybean-补充点"><a href="#2-9-10-1-factorybean-补充点" class="headerlink" title="2.9.10.1 factorybean [补充点]"></a>2.9.10.1 factorybean [补充点]</h6><p>工厂就是为复杂的对象构造准备的，简单的构造通过构造函数完成，复杂的构造通过工厂完成，工厂提供一个构造方法。</p>
<p>在  Spring 中也可以提供一个构造方法，然后 spring 构造 bean 时调用方法而不是构造函数。</p>
<pre><code class="java">public interface FactoryBean&lt;T&gt; {
    T getObject() throws Exception;
    Class&lt;T&gt; getObjectType();
    boolean isSingleton();
}

@Component
public class PersonFactoryBean implements FactoryBean&lt;Person&gt;{
    private String agender; 
    private int age ;

    public Person getObject(){ 
      // 执行 bean 的构造,例如 new Person 等复
    }

    public Class&lt;Person&gt; getObjectType() { return Person.class ; } 

    public boolean isSingleton() { return false; }
}
</code></pre>
<p>这样可以提供更好地灵活性，可以获取 isSingleton、getObjectType 等额外信息。</p>
<pre><code class="java">@Configuration 
public class DBConfiguration { 

    @Bean
    public DataSource dataBea(){ 
      // 构造 DataSource
    } 
}
</code></pre>
<p>实际上这种也是 factoryBean。isFactoryBean 的逻辑比较复杂，在后面 spring 中可以单独处理。</p>
<h6 id="2-9-10-2-bean-初始化-getBean-补充点"><a href="#2-9-10-2-bean-初始化-getBean-补充点" class="headerlink" title="2.9.10.2 bean 初始化 getBean [补充点]"></a>2.9.10.2 bean 初始化 getBean [补充点]</h6><p>getBean 是 Spring 中最重要的一个方法，承担了初始化 bean 的职责。 getBean 最终调用的是 doGetBean，这个方法非常长，包含了 Spring 核心逻辑，需要一定 IOC 理论知识，这里不展开。</p>
<p>说下初始化的 bean 的过程主要有：</p>
<ol>
<li>根据别名获取 beanName transformedBeanName</li>
<li>尝试获取实例 getSingleton</li>
<li>如果存在<ol>
<li>返回存在的 bean</li>
</ol>
</li>
<li>如果不存在<ol>
<li>检查 BeanDefinition</li>
<li>获取依赖项</li>
<li>注册依赖项</li>
<li>递归调用 getBean 创建被依赖项</li>
<li>创建 bean createBean<ol>
<li>创建 bean 实例 createBeanInstance<ol>
<li>使用依赖注入构造</li>
<li>使用无参构造</li>
<li>最终使用 BeanUtils 或者 instantiateWithMethodInjection 初始化</li>
</ol>
</li>
<li>应用 PostProcessor，回调方法</li>
<li>为 bean 赋值 populateBean 给一些简单参数赋值</li>
<li>初始化创建的 bean initializeBean ，各种回调</li>
<li>处理循环依赖</li>
</ol>
</li>
<li>获取创建完成的 bean</li>
<li>如果不是单例，需要根据对应的 scope 处理</li>
<li>检查类型</li>
</ol>
</li>
</ol>
<p>这部分可以参考 <a href="https://www.javadoop.com/post/spring-ioc#toc_7" target="_blank" rel="noopener">https://www.javadoop.com/post/spring-ioc#toc_7</a></p>
<h6 id="2-9-10-3-java-安全管理器"><a href="#2-9-10-3-java-安全管理器" class="headerlink" title="2.9.10.3 java 安全管理器"></a>2.9.10.3 java 安全管理器</h6><pre><code class="java">           if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) {
              isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)
                          ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,
                    getAccessControlContext());
           }
</code></pre>
<p>安全管理器在Java语言中的作用就是检查操作是否有权限执行。<code>-Djava.security.manager</code> 开启后，可以配置一个 policy 给予应用一些权限。例如 jstatd 远程内存调试就需要配置 <em>java</em>.policy 然后开启网络访问。</p>
<p>SecurityManager 提供如下访问权限检查，包括文件的读写删除和执行、网络的连接和监听、线程的访问、以及其他包括打印机剪贴板等系统功能。</p>
<pre><code>checkAccept(String, int)
checkAccess(Thread)
checkAccess(ThreadGroup)
checkAwtEventQueueAccess()
checkConnect(String, int)
checkConnect(String, int, Object)
checkCreateClassLoader()
checkDelete(String)
checkExec(String)
checkExit(int)
checkLink(String)
checkListen(int)
checkMemberAccess(Class&lt;?&gt;, int)
checkMulticast(InetAddress)
checkMulticast(InetAddress, byte)
checkPackageAccess(String)
checkPackageDefinition(String)
checkPermission(Permission)
checkPermission(Permission, Object)
checkPrintJobAccess()
checkPropertiesAccess()
checkPropertyAccess(String)
checkRead(FileDescriptor)
checkRead(String)
checkRead(String, Object)
checkSecurityAccess(String)
checkSetFactory()
checkSystemClipboardAccess()
checkTopLevelWindow(Object)
checkWrite(FileDescriptor)
checkWrite(String)
</code></pre><p>SecurityManager 中的几个关键概念</p>
<p><strong>AccessController</strong></p>
<p>其实就是暴露给应用的一个 API  checkPermission，提供权限检查使用。</p>
<p><strong>CodeSource</strong></p>
<p>用来声明从哪里加载类，其实就是包装了 URL。</p>
<p><strong>Permission</strong></p>
<p>权限的抽象，用来表示那些资源可以被访问。</p>
<p><strong>策略Policy</strong></p>
<p>一组权限规则，在JVM中，任何情况下只能安装一个策略类的实例。可以通过  Policy.setPolicy() 动态设置，也可以使用 policy.provider=sun.security.provider.PolicyFile 指定。</p>
<p><strong>ProtectionDomain</strong></p>
<p>保护域是一个代码源的一组权限，每一个类都属于一个保护域，这个是 ClassLoader 决定了的。</p>
<p><strong>ClassLoader</strong></p>
<p>权限与类对象之间的映射，提供权限来源，类加载器根据双亲委派模型。最基础的是系统类加载器，有很多子类比如 URLClassLoader。</p>
<p>加载一个类时，以委托的形式逐层询问，父亲优先。一旦为一个域的类定义类加载器，其他类加载器不能再定义，防止冲突。另外也是类加载器来进行检查安全。</p>
<h5 id="3-9-11-销毁已经初始化的-singleton-的-Beans"><a href="#3-9-11-销毁已经初始化的-singleton-的-Beans" class="headerlink" title="3.9.11 销毁已经初始化的 singleton 的 Beans"></a>3.9.11 销毁已经初始化的 singleton 的 Beans</h5><p>如果构造过程中出错，需要把已经成功构建的 bean是销毁。</p>
<pre><code class="java">protected void destroyBeans() {
   getBeanFactory().destroySingletons();
}
</code></pre>
<pre><code class="java">// 位于 DefaultListableBeanFactory.java 

@Override
public void destroySingletons() {
   super.destroySingletons();
   updateManualSingletonNames(Set::clear, set -&gt; !set.isEmpty());
   clearByTypeCache();
}
</code></pre>
<pre><code class="java">@Override
public void destroySingletons() {
   super.destroySingletons();
   updateManualSingletonNames(Set::clear, set -&gt; !set.isEmpty());
   clearByTypeCache();
}

// 父类的销毁方法
public void destroySingletons() {
        if (logger.isTraceEnabled()) {
            logger.trace(&quot;Destroying singletons in &quot; + this);
        }
        synchronized (this.singletonObjects) {
            this.singletonsCurrentlyInDestruction = true;
        }

        String[] disposableBeanNames;
        synchronized (this.disposableBeans) {
            disposableBeanNames = StringUtils.toStringArray(this.disposableBeans.keySet());
        }
        for (int i = disposableBeanNames.length - 1; i &gt;= 0; i--) {
            destroySingleton(disposableBeanNames[i]);
        }

        this.containedBeanMap.clear();
        this.dependentBeanMap.clear();
        this.dependenciesForBeanMap.clear();

        clearSingletonCache();
    }
</code></pre>
<p>销毁掉列表中所有的记录，然后递归销毁</p>
<pre><code class="java">// 位于 DefaultSingletonBeanRegistry
    public void destroySingleton(String beanName) {
        // Remove a registered singleton of the given name, if any.
        removeSingleton(beanName);

        // Destroy the corresponding DisposableBean instance.
        DisposableBean disposableBean;
        synchronized (this.disposableBeans) {
            disposableBean = (DisposableBean) this.disposableBeans.remove(beanName);
        }
        destroyBean(beanName, disposableBean);
    }
  protected void destroyBean(String beanName, @Nullable DisposableBean bean) {
        // Trigger destruction of dependent beans first...
        Set&lt;String&gt; dependencies;
        synchronized (this.dependentBeanMap) {
            // Within full synchronization in order to guarantee a disconnected Set
            dependencies = this.dependentBeanMap.remove(beanName);
        }
        if (dependencies != null) {
            if (logger.isTraceEnabled()) {
                logger.trace(&quot;Retrieved dependent beans for bean &#39;&quot; + beanName + &quot;&#39;: &quot; + dependencies);
            }
            for (String dependentBeanName : dependencies) {
                destroySingleton(dependentBeanName);
            }
        }

        // Actually destroy the bean now...
        if (bean != null) {
            try {
                bean.destroy();
            }
            catch (Throwable ex) {
                if (logger.isWarnEnabled()) {
                    logger.warn(&quot;Destruction of bean with name &#39;&quot; + beanName + &quot;&#39; threw an exception&quot;, ex);
                }
            }
        }

        // Trigger destruction of contained beans...
        Set&lt;String&gt; containedBeans;
        synchronized (this.containedBeanMap) {
            // Within full synchronization in order to guarantee a disconnected Set
            containedBeans = this.containedBeanMap.remove(beanName);
        }
        if (containedBeans != null) {
            for (String containedBeanName : containedBeans) {
                destroySingleton(containedBeanName);
            }
        }

        // Remove destroyed bean from other beans&#39; dependencies.
        synchronized (this.dependentBeanMap) {
            for (Iterator&lt;Map.Entry&lt;String, Set&lt;String&gt;&gt;&gt; it = this.dependentBeanMap.entrySet().iterator(); it.hasNext();) {
                Map.Entry&lt;String, Set&lt;String&gt;&gt; entry = it.next();
                Set&lt;String&gt; dependenciesToClean = entry.getValue();
                dependenciesToClean.remove(beanName);
                if (dependenciesToClean.isEmpty()) {
                    it.remove();
                }
            }
        }

        // Remove destroyed bean&#39;s prepared dependency information.
        this.dependenciesForBeanMap.remove(beanName);
    }
</code></pre>
<p>因为存在循环引用，Spring 不得不手动的清理掉所有的依赖关系，否则 GC 无法释放资源。</p>
<h5 id="3-9-12-清理构建过程中的对象缓存"><a href="#3-9-12-清理构建过程中的对象缓存" class="headerlink" title="3.9.12 清理构建过程中的对象缓存"></a>3.9.12 清理构建过程中的对象缓存</h5><pre><code class="java">protected void resetCommonCaches() {
   // 反射缓存
   ReflectionUtils.clearCache();
   // 注解缓存
   AnnotationUtils.clearCache();
   // IOC 缓存
   ResolvableType.clearCache();
  // 清理类加载器
   CachedIntrospectionResults.clearClassLoader(getClassLoader());
}
</code></pre>
<h3 id="3-10-应用上下文刷新后置处理"><a href="#3-10-应用上下文刷新后置处理" class="headerlink" title="3.10 应用上下文刷新后置处理"></a>3.10 应用上下文刷新后置处理</h3><p>回调钩子函数，没有内容</p>
<h3 id="3-11-停止计时监控类"><a href="#3-11-停止计时监控类" class="headerlink" title="3.11 停止计时监控类"></a>3.11 停止计时监控类</h3><pre><code class="java">if (this.currentTaskName == null) {
   throw new IllegalStateException(&quot;Can&#39;t stop StopWatch: it&#39;s not running&quot;);
}
long lastTime = System.nanoTime() - this.startTimeNanos;
this.totalTimeNanos += lastTime;
this.lastTaskInfo = new TaskInfo(this.currentTaskName, lastTime);
if (this.keepTaskList) {
   this.taskList.add(this.lastTaskInfo);
}
++this.taskCount;
this.currentTaskName = null;

</code></pre>
<p>停止计时，计算启动花费的时间。</p>
<h3 id="3-12-输出日志记录执行主类名、时间信息"><a href="#3-12-输出日志记录执行主类名、时间信息" class="headerlink" title="3.12 输出日志记录执行主类名、时间信息"></a>3.12 输出日志记录执行主类名、时间信息</h3><pre><code class="java">if (this.logStartupInfo) {
   new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
}
</code></pre>
<h3 id="3-13-发布应用上下文启动完成事件"><a href="#3-13-发布应用上下文启动完成事件" class="headerlink" title="3.13 发布应用上下文启动完成事件"></a>3.13 发布应用上下文启动完成事件</h3><pre><code class="java">void started(ConfigurableApplicationContext context) {
   for (SpringApplicationRunListener listener : this.listeners) {
      listener.started(context);
   }
}

</code></pre>
<p>给所有的监听器，发布启动完成的事件。</p>
<h3 id="3-14-执行所有-Runner-运行器"><a href="#3-14-执行所有-Runner-运行器" class="headerlink" title="3.14 执行所有 Runner 运行器"></a>3.14 执行所有 Runner 运行器</h3><p>SpringBoot 的 ApplicationRunner 接口可以让项目在启动时候初始化一些信息 ，比如数据库连接等。</p>
<pre><code class="java">private void callRunners(ApplicationContext context, ApplicationArguments args) {
   List&lt;Object&gt; runners = new ArrayList&lt;&gt;();
   runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());
   runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());
   AnnotationAwareOrderComparator.sort(runners);
   for (Object runner : new LinkedHashSet&lt;&gt;(runners)) {
      if (runner instanceof ApplicationRunner) {
         callRunner((ApplicationRunner) runner, args);
      }
      if (runner instanceof CommandLineRunner) {
         callRunner((CommandLineRunner) runner, args);
      }
   }
}
</code></pre>
<p>Spring boot 官方例子中，定义了一个 CommandRunder，可以打出定义的所有的 bean，这个方法会在这个时机被运行。</p>
<pre><code class="java">@Bean
public CommandLineRunner commandLineRunner(ApplicationContext ctx) {
    return args -&gt; {

        System.out.println(&quot;Let&#39;s inspect the beans provided by Spring Boot:&quot;);

        String[] beanNames = ctx.getBeanDefinitionNames();
        Arrays.sort(beanNames);
        for (String beanName : beanNames) {
            System.out.println(beanName);
        }
    };
}
</code></pre>
<h3 id="3-15-发布应用上下文就绪事件"><a href="#3-15-发布应用上下文就绪事件" class="headerlink" title="3.15 发布应用上下文就绪事件"></a>3.15 发布应用上下文就绪事件</h3><pre><code>void running(ConfigurableApplicationContext context) {
   for (SpringApplicationRunListener listener : this.listeners) {
      listener.running(context);
   }
}
</code></pre><h3 id="3-16-处理运行异常"><a href="#3-16-处理运行异常" class="headerlink" title="3.16 处理运行异常"></a>3.16 处理运行异常</h3><pre><code class="java">private void handleRunFailure(ConfigurableApplicationContext context, Throwable exception,
      Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters, SpringApplicationRunListeners listeners) {
   try {
      try {
         handleExitCode(context, exception);
         if (listeners != null) {
            listeners.failed(context, exception);
         }
      }
      finally {
         reportFailure(exceptionReporters, exception);
         if (context != null) {
            context.close();
         }
      }
   }
   catch (Exception ex) {
      logger.warn(&quot;Unable to close ApplicationContext&quot;, ex);
   }
   ReflectionUtils.rethrowRuntimeException(exception);
}
</code></pre>
<p>启动过程中出现异常，会丢出异常。然后关闭上下文，context.close() 会做一些清理工作，和 bean 创建失败的操作差不太多。</p>
<h2 id="4-补充点"><a href="#4-补充点" class="headerlink" title="4 补充点"></a>4 补充点</h2><h3 id="1-自动配置的那些类是什么时候被加载的呢，包扫描的细节是什么？"><a href="#1-自动配置的那些类是什么时候被加载的呢，包扫描的细节是什么？" class="headerlink" title="1 自动配置的那些类是什么时候被加载的呢，包扫描的细节是什么？"></a>1 自动配置的那些类是什么时候被加载的呢，包扫描的细节是什么？</h3><h3 id="2-Tomcat-是怎么知道-Spring-mvc-的-Servlet-入口点的呢？"><a href="#2-Tomcat-是怎么知道-Spring-mvc-的-Servlet-入口点的呢？" class="headerlink" title="2 Tomcat 是怎么知道 Spring mvc 的 Servlet 入口点的呢？"></a>2 Tomcat 是怎么知道 Spring mvc 的 Servlet 入口点的呢？</h3><p>这个过程是异步的，也就是在另外一个线程被处理了，因此源码分析比较困难。关键点在 onRefresh 方法，这个方法中启动了一个  web server，同时注册了 Servlet。</p>
<p>我们 在 SpringApplication 中有一句 refreshContext，然后交给 Spring 的上下文去初始化应用，然后调用了 onRefresh。</p>
<p>我们回忆一下这个过程：</p>
<ol>
<li>SpringApplication.run</li>
<li>SpringApplication.refresh</li>
<li>ServletWebServerApplicationContext.onRefresh</li>
<li>ServletWebServerApplicationContext.createWebServer</li>
</ol>
<p>现在我们从 ServletWebServerApplicationContext.createWebServer 开始分析。</p>
<pre><code class="java">private void createWebServer() {
   WebServer webServer = this.webServer;
   ServletContext servletContext = getServletContext();
   if (webServer == null &amp;&amp; servletContext == null) {
      // 根据加载进来的类，决定使用哪种 web 服务器，默认是 TomcatReactiveWebServerFactory
      // 4.2.1 获取 ServletWebServerFactory
      ServletWebServerFactory factory = getWebServerFactory();
      //  TomcatReactiveWebServerFactory 帮忙获取 web 服务器实例，以及在启动时候注册 servlet
      // 4.2.2 获取获取初始化器
      // 4.2.3 获取 web server
      this.webServer = factory.getWebServer(getSelfInitializer());
   }
   else if (servletContext != null) {
      try {
         // 这一句代码非常误导，实际上 servletContext 都会为空，除非热加载，因此初始化的关键在 factory.getWebServer(getSelfInitializer());
         getSelfInitializer().onStartup(servletContext);
      }
      catch (ServletException ex) {
         throw new ApplicationContextException(&quot;Cannot initialize servlet context&quot;, ex);
      }
   }
   initPropertySources();
}
</code></pre>
<h4 id="4-2-1-获取-ServletWebServerFactory"><a href="#4-2-1-获取-ServletWebServerFactory" class="headerlink" title="4.2.1 获取 ServletWebServerFactory"></a>4.2.1 获取 ServletWebServerFactory</h4><pre><code class="java">protected ServletWebServerFactory getWebServerFactory() {
   // Use bean names so that we don&#39;t consider the hierarchy
   String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class);
   if (beanNames.length == 0) {
      throw new ApplicationContextException(&quot;Unable to start ServletWebServerApplicationContext due to missing &quot;
            + &quot;ServletWebServerFactory bean.&quot;);
   }
   if (beanNames.length &gt; 1) {
      throw new ApplicationContextException(&quot;Unable to start ServletWebServerApplicationContext due to multiple &quot;
            + &quot;ServletWebServerFactory beans : &quot; + StringUtils.arrayToCommaDelimitedString(beanNames));
   }
   return getBeanFactory().getBean(beanNames[0], ServletWebServerFactory.class);
}
</code></pre>
<p>ServletWebServerFactory 用于初始化各种服务器，bean 工厂从根据类型找到它的实现类。这里默认得到的是 TomcatServletWebServerFactory。 </p>
<pre><code class="java">String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class);
</code></pre>
<p>它的实现类有好几个</p>
<p><img src="/Spring/spring/spring-boot-workflow/image-20200406214422826.png" alt="image-20200406214422826"></p>
<p>为什么这里就能得到 TomcatServletWebServerFactory  而不是其他的呢？</p>
<p>奥秘就是自动化配置 ServletWebServerFactoryConfiguration 这类中，根据 ConditionalOnClass  进行定义了一个 Bean。</p>
<pre><code class="java">@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({ Servlet.class, Tomcat.class, UpgradeProtocol.class })
@ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)
static class EmbeddedTomcat {

   @Bean
   TomcatServletWebServerFactory tomcatServletWebServerFactory(
         ObjectProvider&lt;TomcatConnectorCustomizer&gt; connectorCustomizers,
         ObjectProvider&lt;TomcatContextCustomizer&gt; contextCustomizers,
         ObjectProvider&lt;TomcatProtocolHandlerCustomizer&lt;?&gt;&gt; protocolHandlerCustomizers) {
      TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();
      factory.getTomcatConnectorCustomizers()
            .addAll(connectorCustomizers.orderedStream().collect(Collectors.toList()));
      factory.getTomcatContextCustomizers()
            .addAll(contextCustomizers.orderedStream().collect(Collectors.toList()));
      factory.getTomcatProtocolHandlerCustomizers()
            .addAll(protocolHandlerCustomizers.orderedStream().collect(Collectors.toList()));
      return factory;
   }
}
</code></pre>
<h4 id="4-2-2-获取获取初始化器"><a href="#4-2-2-获取获取初始化器" class="headerlink" title="4.2.2 获取获取初始化器"></a>4.2.2 获取获取初始化器</h4><pre><code class="java">private org.springframework.boot.web.servlet.ServletContextInitializer getSelfInitializer() {
   return this::selfInitialize;
}

private void selfInitialize(ServletContext servletContext) throws ServletException {
   prepareWebApplicationContext(servletContext);
   registerApplicationScope(servletContext);
   WebApplicationContextUtils.registerEnvironmentBeans(getBeanFactory(), servletContext);
   for (ServletContextInitializer beans : getServletContextInitializerBeans()) {
      beans.onStartup(servletContext);
   }
}
</code></pre>
<h4 id="4-2-3-获取-web-server"><a href="#4-2-3-获取-web-server" class="headerlink" title="4.2.3 获取 web server"></a>4.2.3 获取 web server</h4><pre><code class="java">@Override
public WebServer getWebServer(ServletContextInitializer... initializers) {
   if (this.disableMBeanRegistry) {
      Registry.disableRegistry();
   }
   // Tomcat 的主类
   Tomcat tomcat = new Tomcat();
   File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir(&quot;tomcat&quot;);
   tomcat.setBaseDir(baseDir.getAbsolutePath());
   // Connector 和协议有关，HTTP、HTTPS等
   Connector connector = new Connector(this.protocol);
   connector.setThrowOnFailure(true);
   tomcat.getService().addConnector(connector);
   customizeConnector(connector);
   tomcat.setConnector(connector);
   tomcat.getHost().setAutoDeploy(false);
   configureEngine(tomcat.getEngine());
   for (Connector additionalConnector : this.additionalTomcatConnectors) {
      tomcat.getService().addConnector(additionalConnector);
   }

   // 很多自定义的逻辑都是在这个方法中，做了一些初始化，根据配置设置服务器（又利用到了自动配置中的东西）
   // 4.2.4 自定义配置服务器 
   prepareContext(tomcat.getHost(), initializers);

   // 4.2.5 创建和启动抽象的服务，并触发 initializers
   return getTomcatWebServer(tomcat);
}
</code></pre>
<h4 id="4-2-4-自定义配置服务器"><a href="#4-2-4-自定义配置服务器" class="headerlink" title="4.2.4 自定义配置服务器"></a>4.2.4 自定义配置服务器</h4><pre><code class="java">protected void prepareContext(Host host, ServletContextInitializer[] initializers) {
   File documentRoot = getValidDocumentRoot();
   // 创建服务器的上下文
   TomcatEmbeddedContext context = new TomcatEmbeddedContext();
   if (documentRoot != null) {
      context.setResources(new LoaderHidingResourceRoot(context));
   }
   context.setName(getContextPath());
   context.setDisplayName(getDisplayName());
   context.setPath(getContextPath());
   File docBase = (documentRoot != null) ? documentRoot : createTempDir(&quot;tomcat-docbase&quot;);
   context.setDocBase(docBase.getAbsolutePath());
   context.addLifecycleListener(new FixContextListener());
   context.setParentClassLoader((this.resourceLoader != null) ? this.resourceLoader.getClassLoader()
         : ClassUtils.getDefaultClassLoader());
   resetDefaultLocaleMapping(context);
   addLocaleMappings(context);
   context.setUseRelativeRedirects(false);
   try {
      context.setCreateUploadTargets(true);
   }
   catch (NoSuchMethodError ex) {
      // Tomcat is &lt; 8.5.39. Continue.
   }
   configureTldSkipPatterns(context);
   WebappLoader loader = new WebappLoader(context.getParentClassLoader());
   loader.setLoaderClass(TomcatEmbeddedWebappClassLoader.class.getName());
   loader.setDelegate(true);
   context.setLoader(loader);
   // 添加了一个默认 Servlet 实际上后面会被覆盖掉，配置到根目录的。
   if (isRegisterDefaultServlet()) {
      addDefaultServlet(context);
   }
   if (shouldRegisterJspServlet()) {
      addJspServlet(context);
      addJasperInitializer(context);
   }
   context.addLifecycleListener(new StaticResourceConfigurer(context));
   ServletContextInitializer[] initializersToUse = mergeInitializers(initializers);
   host.addChild(context);
   // 这里非常关键，根据项目配置文件配置
   configureContext(context, initializersToUse);
   // 钩子函数，这里面没什么东西
   postProcessContext(context);
}
</code></pre>
<pre><code class="java">protected void configureContext(Context context, ServletContextInitializer[] initializers) {
   // 创建了一个 starter 
   TomcatStarter starter = new TomcatStarter(initializers);
   if (context instanceof TomcatEmbeddedContext) {
      TomcatEmbeddedContext embeddedContext = (TomcatEmbeddedContext) context;
      embeddedContext.setStarter(starter);
      embeddedContext.setFailCtxIfServletStartFails(true);
   }
   context.addServletContainerInitializer(starter, NO_CLASSES);
   for (LifecycleListener lifecycleListener : this.contextLifecycleListeners) {
      context.addLifecycleListener(lifecycleListener);
   }
   for (Valve valve : this.contextValves) {
      context.getPipeline().addValve(valve);
   }
   // 配置一些默认的错误页面
   for (ErrorPage errorPage : getErrorPages()) {
      org.apache.tomcat.util.descriptor.web.ErrorPage tomcatErrorPage = new org.apache.tomcat.util.descriptor.web.ErrorPage();
      tomcatErrorPage.setLocation(errorPage.getPath());
      tomcatErrorPage.setErrorCode(errorPage.getStatusCode());
      tomcatErrorPage.setExceptionType(errorPage.getExceptionName());
      context.addErrorPage(tomcatErrorPage);
   }
   // 配置一些 MIME mapping 也就是文件头
   for (MimeMappings.Mapping mapping : getMimeMappings()) {
      context.addMimeMapping(mapping.getExtension(), mapping.getMimeType());
   }
   // 配置 session，主要是配置一个 Manager，如果引入了 spring-session 会提供额外的 Manager 例如存储到 redis
   configureSession(context);
   new DisableReferenceClearingContextCustomizer().customize(context);
   // 这个比较重要，用于配置，TomcatContextCustomizer 就是在自动配置包中的一个类，在 EmbeddedWebServerFactoryCustomizerAutoConfiguration 中被定义，根据配置文件配置服务器。
   for (TomcatContextCustomizer customizer : this.tomcatContextCustomizers) {
      customizer.customize(context);
   }
}
</code></pre>
<pre><code class="java">@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication
@EnableConfigurationProperties(ServerProperties.class)
public class EmbeddedWebServerFactoryCustomizerAutoConfiguration {

   /**
    * Nested configuration if Tomcat is being used.
    */
   @Configuration(proxyBeanMethods = false)
   @ConditionalOnClass({ Tomcat.class, UpgradeProtocol.class })
   public static class TomcatWebServerFactoryCustomizerConfiguration {

      @Bean
      public TomcatWebServerFactoryCustomizer tomcatWebServerFactoryCustomizer(Environment environment,
            ServerProperties serverProperties) {
         return new TomcatWebServerFactoryCustomizer(environment, serverProperties);
      }

   }
</code></pre>
<h4 id="4-2-5-创建和启动抽象的服务，并触发-initializers"><a href="#4-2-5-创建和启动抽象的服务，并触发-initializers" class="headerlink" title="4.2.5 创建和启动抽象的服务，并触发 initializers"></a>4.2.5 创建和启动抽象的服务，并触发 initializers</h4><pre><code class="java">protected TomcatWebServer getTomcatWebServer(Tomcat tomcat) {
   return new TomcatWebServer(tomcat, getPort() &gt;= 0);
}
</code></pre>
<p>在构造函数中初始话</p>
<pre><code class="java">// 这个类还在 Spring boot 中
public TomcatWebServer(Tomcat tomcat, boolean autoStart) {
   Assert.notNull(tomcat, &quot;Tomcat Server must not be null&quot;);
   this.tomcat = tomcat;
   this.autoStart = autoStart;
   initialize();
}
</code></pre>
<pre><code class="java">// 位于 TomecatWebServer,启停服都在这里
private void initialize() throws WebServerException {
   logger.info(&quot;Tomcat initialized with port(s): &quot; + getPortsDescription(false));
   synchronized (this.monitor) {
      try {
         // 设置容器id，这个是为多容器设计的，实际上用不到
         addInstanceIdToEngineName();
           // 找到对应上下文
         Context context = findContext();
         context.addLifecycleListener((event) -&gt; {
            if (context.equals(event.getSource()) &amp;&amp; Lifecycle.START_EVENT.equals(event.getType())) {
               // Remove service connectors so that protocol binding doesn&#39;t
               // happen when the service is started.
               removeServiceConnectors();
            }
         });

         // Start the server to trigger initialization 
         // 启动服务，终于交出控制权到 Tomcat 了
         this.tomcat.start();
         ...
   }
}
</code></pre>
<pre><code class="java">public void start() throws LifecycleException {
    getServer();
    // StandardServer ,TomCat中的概念
    server.start();
}
</code></pre>
<p>这里的启动源码看起来比较头疼，需要对 Tomcat 内部机制有一些了解主要逻辑：</p>
<ol>
<li>Spring boot 的 TomcatWebServer.start</li>
<li>Tomcat.start</li>
<li>StandardServer.start</li>
<li>NamingResources.start JEE 中的概念，命名上下文和 JNDI 上下文</li>
<li>StandardService.start 有多个 Service </li>
<li>StandardEngine.start </li>
<li>Container.start</li>
<li>StandardHost.start</li>
<li>StandardContext.start</li>
<li>StandardRoo.start </li>
<li>DirResourceSet.start</li>
<li>WebappLoader.start </li>
</ol>
<p>这里面具体的流程可以参考 Tomcat的源码分析, tomcat组成：SERVER（服务器）、service（服务）、connector（连接器）、engine（引擎）、host（主机）、context（应用服务）。</p>
<p>最终 StandardContext.start 启动完成后，会触发初始化器,实际上 spring mvc 工作在 context这层。</p>
<pre><code class="java">// Call ServletContainerInitializers
for (Map.Entry&lt;ServletContainerInitializer, Set&lt;Class&lt;?&gt;&gt;&gt; entry :
    initializers.entrySet()) {
    try {
       // onStartup 非常重要
        entry.getKey().onStartup(entry.getValue(),
                getServletContext());
    } catch (ServletException e) {
        log.error(sm.getString(&quot;standardContext.sciFail&quot;), e);
        ok = false;
        break;
    }
}
</code></pre>
<pre><code class="java">public void onStartup(Set&lt;Class&lt;?&gt;&gt; classes, ServletContext servletContext) throws ServletException {
   try {
      for (ServletContextInitializer initializer : this.initializers) {
         initializer.onStartup(servletContext);
      }
   }
</code></pre>
<p>这个数组中有三个初始化器，其中两个是 TomCat 自己的，主要看 AnnotationConfigServletWebServerApplicationContext 这个。</p>
<p>回调 AnnotationConfigServletWebServerApplicationContext.onStartup() 进入 selfInitialize方法。这里 spring boot 又自己循环了一次。</p>
<pre><code class="java">private void selfInitialize(ServletContext servletContext) throws ServletException {
   prepareWebApplicationContext(servletContext);
   registerApplicationScope(servletContext);
   WebApplicationContextUtils.registerEnvironmentBeans(getBeanFactory(), servletContext);
   // getServletContextInitializerBeans() 获取核心 Servlet 以及一些 filter
   for (ServletContextInitializer beans : getServletContextInitializerBeans()) {
      beans.onStartup(servletContext);
   }
}
</code></pre>
<pre><code>DispatcherServletRegistrationBean
FilterRegistrationBean
FilterRegistrationBean
FilterRegistrationBean
</code></pre><p>回到  Spring boot 的地盘，DispatcherServlet 这个类非常重要，就是 Spring MVC 的入口，通过它初始化 MVC 相关的映射。</p>
<p>主要看 DispatcherServletRegistrationBean 类，也是自动配置完成的。</p>
<pre><code class="java">protected final void register(String description, ServletContext servletContext) {
   // 注册 Servlet 到 servletContext，servletContext 是 Tomcat 提供的。
   D registration = addRegistration(description, servletContext);
   if (registration == null) {
      logger.info(StringUtils.capitalize(description) + &quot; was not registered (possibly already registered?)&quot;);
      return;
   }
   configure(registration);
}
</code></pre>
<pre><code class="java">@Override
protected ServletRegistration.Dynamic addRegistration(String description, ServletContext servletContext) {
   String name = getServletName();
   return servletContext.addServlet(name, this.servlet);
}
</code></pre>
<pre><code class="java">@Override
public ServletRegistration.Dynamic addServlet(String servletName,
        Servlet servlet) {
    if (SecurityUtil.isPackageProtectionEnabled()) {
        return (ServletRegistration.Dynamic) doPrivileged(&quot;addServlet&quot;,
                new Class[]{String.class, Servlet.class},
                new Object[]{servletName, servlet});
    } else {
        return context.addServlet(servletName, servlet);
    }
}
</code></pre>
<p>context 是 TomCat 提供的，然后添加 dispatcherServlet。其他几个初始化器都是给 filter 使用的，不再展开了。</p>
<h3 id="3-大量的-Filter-是怎么注册给-Tomcat-的呢？"><a href="#3-大量的-Filter-是怎么注册给-Tomcat-的呢？" class="headerlink" title="3 大量的 Filter 是怎么注册给 Tomcat 的呢？"></a>3 大量的 Filter 是怎么注册给 Tomcat 的呢？</h3><h3 id="4-API-请求的-Mapping-关系什么时候映射的呢？"><a href="#4-API-请求的-Mapping-关系什么时候映射的呢？" class="headerlink" title="4 API 请求的 Mapping 关系什么时候映射的呢？"></a>4 API 请求的 Mapping 关系什么时候映射的呢？</h3><pre><code class="java">/**
 * Initialize the strategy objects that this servlet uses.
 * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.
 */
protected void initStrategies(ApplicationContext context) {
   initMultipartResolver(context);
   initLocaleResolver(context);
   initThemeResolver(context);
   initHandlerMappings(context);
   initHandlerAdapters(context);
   initHandlerExceptionResolvers(context);
   initRequestToViewNameTranslator(context);
   initViewResolvers(context);
   initFlashMapManager(context);
}
</code></pre>
<h3 id="5-Bean-是怎么被初始化的呢？-getBean-细节"><a href="#5-Bean-是怎么被初始化的呢？-getBean-细节" class="headerlink" title="5  Bean 是怎么被初始化的呢？ getBean 细节"></a>5  Bean 是怎么被初始化的呢？ getBean 细节</h3><h3 id="6-数据库连接是在什么时候建立的呢？"><a href="#6-数据库连接是在什么时候建立的呢？" class="headerlink" title="6 数据库连接是在什么时候建立的呢？"></a>6 数据库连接是在什么时候建立的呢？</h3><h3 id="7-各种注解是在哪里被处理的？"><a href="#7-各种注解是在哪里被处理的？" class="headerlink" title="7 各种注解是在哪里被处理的？"></a>7 各种注解是在哪里被处理的？</h3><h1 id="Spring-mvc-响应请求过程"><a href="#Spring-mvc-响应请求过程" class="headerlink" title="Spring mvc 响应请求过程"></a>Spring mvc 响应请求过程</h1><h1 id="Spring-boot-打包流程"><a href="#Spring-boot-打包流程" class="headerlink" title="Spring boot 打包流程"></a>Spring boot 打包流程</h1></center></center>	  

	  <div>
  		<center>
		  <div class="pagination">
<ul class="pagination">
	
	
	
	
	
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
			
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	
	
		<li class="prev"><a href="/Spring/spring/spring-boot-annotations/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>prev</a></li>
	
	<li><a href="/"><i class="fa fa-archive"></i>Home</a></li>
	
		<li class="next"><a href="/Spring/spring/spring-rest-doc/" class="alignright next">next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

		</center>
	  </div>
	  
	</div> <!-- col-md-9/col-md-12 -->
	
  </div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
	<footer> <p>
  
  &copy; 2020 少个分号
  
  <a href="/about" target="_blank">关于本站</a> |
  <a href="https://github.com/linksgo2011/wiki" target="_blank">github |</a>
  <a href="http://www.printf.cn" target="_blank">我的博客</a>
</p> </footer>
  </div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/jquery.tableofcontents.min.js"></script>
<script src="/js/tocgenerator.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


</body>
</html>
